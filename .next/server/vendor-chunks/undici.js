"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/undici";
exports.ids = ["vendor-chunks/undici"];
exports.modules = {

/***/ "(rsc)/./node_modules/undici/index.js":
/*!**************************************!*\
  !*** ./node_modules/undici/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Client = __webpack_require__(/*! ./lib/dispatcher/client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\nconst Dispatcher = __webpack_require__(/*! ./lib/dispatcher/dispatcher */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js\")\nconst Pool = __webpack_require__(/*! ./lib/dispatcher/pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst BalancedPool = __webpack_require__(/*! ./lib/dispatcher/balanced-pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/balanced-pool.js\")\nconst Agent = __webpack_require__(/*! ./lib/dispatcher/agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/agent.js\")\nconst ProxyAgent = __webpack_require__(/*! ./lib/dispatcher/proxy-agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/proxy-agent.js\")\nconst EnvHttpProxyAgent = __webpack_require__(/*! ./lib/dispatcher/env-http-proxy-agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js\")\nconst RetryAgent = __webpack_require__(/*! ./lib/dispatcher/retry-agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/retry-agent.js\")\nconst H2CClient = __webpack_require__(/*! ./lib/dispatcher/h2c-client */ \"(rsc)/./node_modules/undici/lib/dispatcher/h2c-client.js\")\nconst errors = __webpack_require__(/*! ./lib/core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ./lib/core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { InvalidArgumentError } = errors\nconst api = __webpack_require__(/*! ./lib/api */ \"(rsc)/./node_modules/undici/lib/api/index.js\")\nconst buildConnector = __webpack_require__(/*! ./lib/core/connect */ \"(rsc)/./node_modules/undici/lib/core/connect.js\")\nconst MockClient = __webpack_require__(/*! ./lib/mock/mock-client */ \"(rsc)/./node_modules/undici/lib/mock/mock-client.js\")\nconst { MockCallHistory, MockCallHistoryLog } = __webpack_require__(/*! ./lib/mock/mock-call-history */ \"(rsc)/./node_modules/undici/lib/mock/mock-call-history.js\")\nconst MockAgent = __webpack_require__(/*! ./lib/mock/mock-agent */ \"(rsc)/./node_modules/undici/lib/mock/mock-agent.js\")\nconst MockPool = __webpack_require__(/*! ./lib/mock/mock-pool */ \"(rsc)/./node_modules/undici/lib/mock/mock-pool.js\")\nconst mockErrors = __webpack_require__(/*! ./lib/mock/mock-errors */ \"(rsc)/./node_modules/undici/lib/mock/mock-errors.js\")\nconst RetryHandler = __webpack_require__(/*! ./lib/handler/retry-handler */ \"(rsc)/./node_modules/undici/lib/handler/retry-handler.js\")\nconst { getGlobalDispatcher, setGlobalDispatcher } = __webpack_require__(/*! ./lib/global */ \"(rsc)/./node_modules/undici/lib/global.js\")\nconst DecoratorHandler = __webpack_require__(/*! ./lib/handler/decorator-handler */ \"(rsc)/./node_modules/undici/lib/handler/decorator-handler.js\")\nconst RedirectHandler = __webpack_require__(/*! ./lib/handler/redirect-handler */ \"(rsc)/./node_modules/undici/lib/handler/redirect-handler.js\")\n\nObject.assign(Dispatcher.prototype, api)\n\nmodule.exports.Dispatcher = Dispatcher\nmodule.exports.Client = Client\nmodule.exports.Pool = Pool\nmodule.exports.BalancedPool = BalancedPool\nmodule.exports.Agent = Agent\nmodule.exports.ProxyAgent = ProxyAgent\nmodule.exports.EnvHttpProxyAgent = EnvHttpProxyAgent\nmodule.exports.RetryAgent = RetryAgent\nmodule.exports.H2CClient = H2CClient\nmodule.exports.RetryHandler = RetryHandler\n\nmodule.exports.DecoratorHandler = DecoratorHandler\nmodule.exports.RedirectHandler = RedirectHandler\nmodule.exports.interceptors = {\n  redirect: __webpack_require__(/*! ./lib/interceptor/redirect */ \"(rsc)/./node_modules/undici/lib/interceptor/redirect.js\"),\n  responseError: __webpack_require__(/*! ./lib/interceptor/response-error */ \"(rsc)/./node_modules/undici/lib/interceptor/response-error.js\"),\n  retry: __webpack_require__(/*! ./lib/interceptor/retry */ \"(rsc)/./node_modules/undici/lib/interceptor/retry.js\"),\n  dump: __webpack_require__(/*! ./lib/interceptor/dump */ \"(rsc)/./node_modules/undici/lib/interceptor/dump.js\"),\n  dns: __webpack_require__(/*! ./lib/interceptor/dns */ \"(rsc)/./node_modules/undici/lib/interceptor/dns.js\"),\n  cache: __webpack_require__(/*! ./lib/interceptor/cache */ \"(rsc)/./node_modules/undici/lib/interceptor/cache.js\")\n}\n\nmodule.exports.cacheStores = {\n  MemoryCacheStore: __webpack_require__(/*! ./lib/cache/memory-cache-store */ \"(rsc)/./node_modules/undici/lib/cache/memory-cache-store.js\")\n}\n\nconst SqliteCacheStore = __webpack_require__(/*! ./lib/cache/sqlite-cache-store */ \"(rsc)/./node_modules/undici/lib/cache/sqlite-cache-store.js\")\nmodule.exports.cacheStores.SqliteCacheStore = SqliteCacheStore\n\nmodule.exports.buildConnector = buildConnector\nmodule.exports.errors = errors\nmodule.exports.util = {\n  parseHeaders: util.parseHeaders,\n  headerNameToString: util.headerNameToString\n}\n\nfunction makeDispatcher (fn) {\n  return (url, opts, handler) => {\n    if (typeof opts === 'function') {\n      handler = opts\n      opts = null\n    }\n\n    if (!url || (typeof url !== 'string' && typeof url !== 'object' && !(url instanceof URL))) {\n      throw new InvalidArgumentError('invalid url')\n    }\n\n    if (opts != null && typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (opts && opts.path != null) {\n      if (typeof opts.path !== 'string') {\n        throw new InvalidArgumentError('invalid opts.path')\n      }\n\n      let path = opts.path\n      if (!opts.path.startsWith('/')) {\n        path = `/${path}`\n      }\n\n      url = new URL(util.parseOrigin(url).origin + path)\n    } else {\n      if (!opts) {\n        opts = typeof url === 'object' ? url : {}\n      }\n\n      url = util.parseURL(url)\n    }\n\n    const { agent, dispatcher = getGlobalDispatcher() } = opts\n\n    if (agent) {\n      throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?')\n    }\n\n    return fn.call(dispatcher, {\n      ...opts,\n      origin: url.origin,\n      path: url.search ? `${url.pathname}${url.search}` : url.pathname,\n      method: opts.method || (opts.body ? 'PUT' : 'GET')\n    }, handler)\n  }\n}\n\nmodule.exports.setGlobalDispatcher = setGlobalDispatcher\nmodule.exports.getGlobalDispatcher = getGlobalDispatcher\n\nconst fetchImpl = (__webpack_require__(/*! ./lib/web/fetch */ \"(rsc)/./node_modules/undici/lib/web/fetch/index.js\").fetch)\nmodule.exports.fetch = async function fetch (init, options = undefined) {\n  try {\n    return await fetchImpl(init, options)\n  } catch (err) {\n    if (err && typeof err === 'object') {\n      Error.captureStackTrace(err)\n    }\n\n    throw err\n  }\n}\nmodule.exports.Headers = __webpack_require__(/*! ./lib/web/fetch/headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\").Headers\nmodule.exports.Response = __webpack_require__(/*! ./lib/web/fetch/response */ \"(rsc)/./node_modules/undici/lib/web/fetch/response.js\").Response\nmodule.exports.Request = __webpack_require__(/*! ./lib/web/fetch/request */ \"(rsc)/./node_modules/undici/lib/web/fetch/request.js\").Request\nmodule.exports.FormData = __webpack_require__(/*! ./lib/web/fetch/formdata */ \"(rsc)/./node_modules/undici/lib/web/fetch/formdata.js\").FormData\n\nconst { setGlobalOrigin, getGlobalOrigin } = __webpack_require__(/*! ./lib/web/fetch/global */ \"(rsc)/./node_modules/undici/lib/web/fetch/global.js\")\n\nmodule.exports.setGlobalOrigin = setGlobalOrigin\nmodule.exports.getGlobalOrigin = getGlobalOrigin\n\nconst { CacheStorage } = __webpack_require__(/*! ./lib/web/cache/cachestorage */ \"(rsc)/./node_modules/undici/lib/web/cache/cachestorage.js\")\nconst { kConstruct } = __webpack_require__(/*! ./lib/core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\n// Cache & CacheStorage are tightly coupled with fetch. Even if it may run\n// in an older version of Node, it doesn't have any use without fetch.\nmodule.exports.caches = new CacheStorage(kConstruct)\n\nconst { deleteCookie, getCookies, getSetCookies, setCookie, parseCookie } = __webpack_require__(/*! ./lib/web/cookies */ \"(rsc)/./node_modules/undici/lib/web/cookies/index.js\")\n\nmodule.exports.deleteCookie = deleteCookie\nmodule.exports.getCookies = getCookies\nmodule.exports.getSetCookies = getSetCookies\nmodule.exports.setCookie = setCookie\nmodule.exports.parseCookie = parseCookie\n\nconst { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./lib/web/fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\n\nmodule.exports.parseMIMEType = parseMIMEType\nmodule.exports.serializeAMimeType = serializeAMimeType\n\nconst { CloseEvent, ErrorEvent, MessageEvent } = __webpack_require__(/*! ./lib/web/websocket/events */ \"(rsc)/./node_modules/undici/lib/web/websocket/events.js\")\nmodule.exports.WebSocket = __webpack_require__(/*! ./lib/web/websocket/websocket */ \"(rsc)/./node_modules/undici/lib/web/websocket/websocket.js\").WebSocket\nmodule.exports.CloseEvent = CloseEvent\nmodule.exports.ErrorEvent = ErrorEvent\nmodule.exports.MessageEvent = MessageEvent\n\nmodule.exports.WebSocketStream = __webpack_require__(/*! ./lib/web/websocket/stream/websocketstream */ \"(rsc)/./node_modules/undici/lib/web/websocket/stream/websocketstream.js\").WebSocketStream\nmodule.exports.WebSocketError = __webpack_require__(/*! ./lib/web/websocket/stream/websocketerror */ \"(rsc)/./node_modules/undici/lib/web/websocket/stream/websocketerror.js\").WebSocketError\n\nmodule.exports.request = makeDispatcher(api.request)\nmodule.exports.stream = makeDispatcher(api.stream)\nmodule.exports.pipeline = makeDispatcher(api.pipeline)\nmodule.exports.connect = makeDispatcher(api.connect)\nmodule.exports.upgrade = makeDispatcher(api.upgrade)\n\nmodule.exports.MockClient = MockClient\nmodule.exports.MockCallHistory = MockCallHistory\nmodule.exports.MockCallHistoryLog = MockCallHistoryLog\nmodule.exports.MockPool = MockPool\nmodule.exports.MockAgent = MockAgent\nmodule.exports.mockErrors = mockErrors\n\nconst { EventSource } = __webpack_require__(/*! ./lib/web/eventsource/eventsource */ \"(rsc)/./node_modules/undici/lib/web/eventsource/eventsource.js\")\n\nmodule.exports.EventSource = EventSource\n\nfunction install () {\n  globalThis.fetch = module.exports.fetch\n  globalThis.Headers = module.exports.Headers\n  globalThis.Response = module.exports.Response\n  globalThis.Request = module.exports.Request\n  globalThis.FormData = module.exports.FormData\n  globalThis.WebSocket = module.exports.WebSocket\n  globalThis.CloseEvent = module.exports.CloseEvent\n  globalThis.ErrorEvent = module.exports.ErrorEvent\n  globalThis.MessageEvent = module.exports.MessageEvent\n  globalThis.EventSource = module.exports.EventSource\n}\n\nmodule.exports.install = install\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxxRkFBeUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsNkZBQTZCO0FBQ3hELGFBQWEsbUJBQU8sQ0FBQyxpRkFBdUI7QUFDNUMscUJBQXFCLG1CQUFPLENBQUMsbUdBQWdDO0FBQzdELGNBQWMsbUJBQU8sQ0FBQyxtRkFBd0I7QUFDOUMsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQThCO0FBQ3pELDBCQUEwQixtQkFBTyxDQUFDLGlIQUF1QztBQUN6RSxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBOEI7QUFDekQsa0JBQWtCLG1CQUFPLENBQUMsNkZBQTZCO0FBQ3ZELGVBQWUsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLHFFQUFpQjtBQUN0QyxRQUFRLHVCQUF1QjtBQUMvQixZQUFZLG1CQUFPLENBQUMsK0RBQVc7QUFDL0IsdUJBQXVCLG1CQUFPLENBQUMsMkVBQW9CO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLG1GQUF3QjtBQUNuRCxRQUFRLHNDQUFzQyxFQUFFLG1CQUFPLENBQUMsK0ZBQThCO0FBQ3RGLGtCQUFrQixtQkFBTyxDQUFDLGlGQUF1QjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBc0I7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsbUZBQXdCO0FBQ25ELHFCQUFxQixtQkFBTyxDQUFDLDZGQUE2QjtBQUMxRCxRQUFRLDJDQUEyQyxFQUFFLG1CQUFPLENBQUMsK0RBQWM7QUFDM0UseUJBQXlCLG1CQUFPLENBQUMscUdBQWlDO0FBQ2xFLHdCQUF3QixtQkFBTyxDQUFDLG1HQUFnQzs7QUFFaEU7O0FBRUEseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsMkJBQTJCO0FBQzNCLG9CQUFvQjtBQUNwQix5QkFBeUI7QUFDekIsZ0NBQWdDO0FBQ2hDLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsMkJBQTJCOztBQUUzQiwrQkFBK0I7QUFDL0IsOEJBQThCO0FBQzlCLDJCQUEyQjtBQUMzQixZQUFZLG1CQUFPLENBQUMsMkZBQTRCO0FBQ2hELGlCQUFpQixtQkFBTyxDQUFDLHVHQUFrQztBQUMzRCxTQUFTLG1CQUFPLENBQUMscUZBQXlCO0FBQzFDLFFBQVEsbUJBQU8sQ0FBQyxtRkFBd0I7QUFDeEMsT0FBTyxtQkFBTyxDQUFDLGlGQUF1QjtBQUN0QyxTQUFTLG1CQUFPLENBQUMscUZBQXlCO0FBQzFDOztBQUVBLDBCQUEwQjtBQUMxQixvQkFBb0IsbUJBQU8sQ0FBQyxtR0FBZ0M7QUFDNUQ7O0FBRUEseUJBQXlCLG1CQUFPLENBQUMsbUdBQWdDO0FBQ2pFLDJDQUEyQzs7QUFFM0MsNkJBQTZCO0FBQzdCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSztBQUN4Qjs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxZQUFZLDRDQUE0Qzs7QUFFeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhLEVBQUUsV0FBVztBQUN0RDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGtDQUFrQztBQUNsQyxrQ0FBa0M7O0FBRWxDLGtCQUFrQix3R0FBZ0M7QUFDbEQsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJJQUFtRTtBQUNuRSwrSUFBc0U7QUFDdEUsMklBQW1FO0FBQ25FLCtJQUFzRTs7QUFFdEUsUUFBUSxtQ0FBbUMsRUFBRSxtQkFBTyxDQUFDLG1GQUF3Qjs7QUFFN0UsOEJBQThCO0FBQzlCLDhCQUE4Qjs7QUFFOUIsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQywrRkFBOEI7QUFDL0QsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQywyRUFBb0I7O0FBRW5EO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCLFFBQVEsa0VBQWtFLEVBQUUsbUJBQU8sQ0FBQywrRUFBbUI7O0FBRXZHLDJCQUEyQjtBQUMzQix5QkFBeUI7QUFDekIsNEJBQTRCO0FBQzVCLHdCQUF3QjtBQUN4QiwwQkFBMEI7O0FBRTFCLFFBQVEsb0NBQW9DLEVBQUUsbUJBQU8sQ0FBQyx1RkFBMEI7O0FBRWhGLDRCQUE0QjtBQUM1QixpQ0FBaUM7O0FBRWpDLFFBQVEsdUNBQXVDLEVBQUUsbUJBQU8sQ0FBQywyRkFBNEI7QUFDckYsMkpBQTZFO0FBQzdFLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsMkJBQTJCOztBQUUzQixpTUFBc0c7QUFDdEcsNkxBQW1HOztBQUVuRyxzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0Qix5QkFBeUI7QUFDekIsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQyx1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLHlCQUF5Qjs7QUFFekIsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyx5R0FBbUM7O0FBRW5FLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyL2NsaWVudCcpXG5jb25zdCBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9saWIvZGlzcGF0Y2hlci9kaXNwYXRjaGVyJylcbmNvbnN0IFBvb2wgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyL3Bvb2wnKVxuY29uc3QgQmFsYW5jZWRQb29sID0gcmVxdWlyZSgnLi9saWIvZGlzcGF0Y2hlci9iYWxhbmNlZC1wb29sJylcbmNvbnN0IEFnZW50ID0gcmVxdWlyZSgnLi9saWIvZGlzcGF0Y2hlci9hZ2VudCcpXG5jb25zdCBQcm94eUFnZW50ID0gcmVxdWlyZSgnLi9saWIvZGlzcGF0Y2hlci9wcm94eS1hZ2VudCcpXG5jb25zdCBFbnZIdHRwUHJveHlBZ2VudCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvZW52LWh0dHAtcHJveHktYWdlbnQnKVxuY29uc3QgUmV0cnlBZ2VudCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvcmV0cnktYWdlbnQnKVxuY29uc3QgSDJDQ2xpZW50ID0gcmVxdWlyZSgnLi9saWIvZGlzcGF0Y2hlci9oMmMtY2xpZW50JylcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vbGliL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL2xpYi9jb3JlL3V0aWwnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gZXJyb3JzXG5jb25zdCBhcGkgPSByZXF1aXJlKCcuL2xpYi9hcGknKVxuY29uc3QgYnVpbGRDb25uZWN0b3IgPSByZXF1aXJlKCcuL2xpYi9jb3JlL2Nvbm5lY3QnKVxuY29uc3QgTW9ja0NsaWVudCA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1jbGllbnQnKVxuY29uc3QgeyBNb2NrQ2FsbEhpc3RvcnksIE1vY2tDYWxsSGlzdG9yeUxvZyB9ID0gcmVxdWlyZSgnLi9saWIvbW9jay9tb2NrLWNhbGwtaGlzdG9yeScpXG5jb25zdCBNb2NrQWdlbnQgPSByZXF1aXJlKCcuL2xpYi9tb2NrL21vY2stYWdlbnQnKVxuY29uc3QgTW9ja1Bvb2wgPSByZXF1aXJlKCcuL2xpYi9tb2NrL21vY2stcG9vbCcpXG5jb25zdCBtb2NrRXJyb3JzID0gcmVxdWlyZSgnLi9saWIvbW9jay9tb2NrLWVycm9ycycpXG5jb25zdCBSZXRyeUhhbmRsZXIgPSByZXF1aXJlKCcuL2xpYi9oYW5kbGVyL3JldHJ5LWhhbmRsZXInKVxuY29uc3QgeyBnZXRHbG9iYWxEaXNwYXRjaGVyLCBzZXRHbG9iYWxEaXNwYXRjaGVyIH0gPSByZXF1aXJlKCcuL2xpYi9nbG9iYWwnKVxuY29uc3QgRGVjb3JhdG9ySGFuZGxlciA9IHJlcXVpcmUoJy4vbGliL2hhbmRsZXIvZGVjb3JhdG9yLWhhbmRsZXInKVxuY29uc3QgUmVkaXJlY3RIYW5kbGVyID0gcmVxdWlyZSgnLi9saWIvaGFuZGxlci9yZWRpcmVjdC1oYW5kbGVyJylcblxuT2JqZWN0LmFzc2lnbihEaXNwYXRjaGVyLnByb3RvdHlwZSwgYXBpKVxuXG5tb2R1bGUuZXhwb3J0cy5EaXNwYXRjaGVyID0gRGlzcGF0Y2hlclxubW9kdWxlLmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50XG5tb2R1bGUuZXhwb3J0cy5Qb29sID0gUG9vbFxubW9kdWxlLmV4cG9ydHMuQmFsYW5jZWRQb29sID0gQmFsYW5jZWRQb29sXG5tb2R1bGUuZXhwb3J0cy5BZ2VudCA9IEFnZW50XG5tb2R1bGUuZXhwb3J0cy5Qcm94eUFnZW50ID0gUHJveHlBZ2VudFxubW9kdWxlLmV4cG9ydHMuRW52SHR0cFByb3h5QWdlbnQgPSBFbnZIdHRwUHJveHlBZ2VudFxubW9kdWxlLmV4cG9ydHMuUmV0cnlBZ2VudCA9IFJldHJ5QWdlbnRcbm1vZHVsZS5leHBvcnRzLkgyQ0NsaWVudCA9IEgyQ0NsaWVudFxubW9kdWxlLmV4cG9ydHMuUmV0cnlIYW5kbGVyID0gUmV0cnlIYW5kbGVyXG5cbm1vZHVsZS5leHBvcnRzLkRlY29yYXRvckhhbmRsZXIgPSBEZWNvcmF0b3JIYW5kbGVyXG5tb2R1bGUuZXhwb3J0cy5SZWRpcmVjdEhhbmRsZXIgPSBSZWRpcmVjdEhhbmRsZXJcbm1vZHVsZS5leHBvcnRzLmludGVyY2VwdG9ycyA9IHtcbiAgcmVkaXJlY3Q6IHJlcXVpcmUoJy4vbGliL2ludGVyY2VwdG9yL3JlZGlyZWN0JyksXG4gIHJlc3BvbnNlRXJyb3I6IHJlcXVpcmUoJy4vbGliL2ludGVyY2VwdG9yL3Jlc3BvbnNlLWVycm9yJyksXG4gIHJldHJ5OiByZXF1aXJlKCcuL2xpYi9pbnRlcmNlcHRvci9yZXRyeScpLFxuICBkdW1wOiByZXF1aXJlKCcuL2xpYi9pbnRlcmNlcHRvci9kdW1wJyksXG4gIGRuczogcmVxdWlyZSgnLi9saWIvaW50ZXJjZXB0b3IvZG5zJyksXG4gIGNhY2hlOiByZXF1aXJlKCcuL2xpYi9pbnRlcmNlcHRvci9jYWNoZScpXG59XG5cbm1vZHVsZS5leHBvcnRzLmNhY2hlU3RvcmVzID0ge1xuICBNZW1vcnlDYWNoZVN0b3JlOiByZXF1aXJlKCcuL2xpYi9jYWNoZS9tZW1vcnktY2FjaGUtc3RvcmUnKVxufVxuXG5jb25zdCBTcWxpdGVDYWNoZVN0b3JlID0gcmVxdWlyZSgnLi9saWIvY2FjaGUvc3FsaXRlLWNhY2hlLXN0b3JlJylcbm1vZHVsZS5leHBvcnRzLmNhY2hlU3RvcmVzLlNxbGl0ZUNhY2hlU3RvcmUgPSBTcWxpdGVDYWNoZVN0b3JlXG5cbm1vZHVsZS5leHBvcnRzLmJ1aWxkQ29ubmVjdG9yID0gYnVpbGRDb25uZWN0b3Jcbm1vZHVsZS5leHBvcnRzLmVycm9ycyA9IGVycm9yc1xubW9kdWxlLmV4cG9ydHMudXRpbCA9IHtcbiAgcGFyc2VIZWFkZXJzOiB1dGlsLnBhcnNlSGVhZGVycyxcbiAgaGVhZGVyTmFtZVRvU3RyaW5nOiB1dGlsLmhlYWRlck5hbWVUb1N0cmluZ1xufVxuXG5mdW5jdGlvbiBtYWtlRGlzcGF0Y2hlciAoZm4pIHtcbiAgcmV0dXJuICh1cmwsIG9wdHMsIGhhbmRsZXIpID0+IHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGhhbmRsZXIgPSBvcHRzXG4gICAgICBvcHRzID0gbnVsbFxuICAgIH1cblxuICAgIGlmICghdXJsIHx8ICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdXJsICE9PSAnb2JqZWN0JyAmJiAhKHVybCBpbnN0YW5jZW9mIFVSTCkpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgdXJsJylcbiAgICB9XG5cbiAgICBpZiAob3B0cyAhPSBudWxsICYmIHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGlmIChvcHRzICYmIG9wdHMucGF0aCAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMucGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMucGF0aCcpXG4gICAgICB9XG5cbiAgICAgIGxldCBwYXRoID0gb3B0cy5wYXRoXG4gICAgICBpZiAoIW9wdHMucGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgcGF0aCA9IGAvJHtwYXRofWBcbiAgICAgIH1cblxuICAgICAgdXJsID0gbmV3IFVSTCh1dGlsLnBhcnNlT3JpZ2luKHVybCkub3JpZ2luICsgcGF0aClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIG9wdHMgPSB0eXBlb2YgdXJsID09PSAnb2JqZWN0JyA/IHVybCA6IHt9XG4gICAgICB9XG5cbiAgICAgIHVybCA9IHV0aWwucGFyc2VVUkwodXJsKVxuICAgIH1cblxuICAgIGNvbnN0IHsgYWdlbnQsIGRpc3BhdGNoZXIgPSBnZXRHbG9iYWxEaXNwYXRjaGVyKCkgfSA9IG9wdHNcblxuICAgIGlmIChhZ2VudCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBvcHRzLmFnZW50LiBEaWQgeW91IG1lYW4gb3B0cy5jbGllbnQ/JylcbiAgICB9XG5cbiAgICByZXR1cm4gZm4uY2FsbChkaXNwYXRjaGVyLCB7XG4gICAgICAuLi5vcHRzLFxuICAgICAgb3JpZ2luOiB1cmwub3JpZ2luLFxuICAgICAgcGF0aDogdXJsLnNlYXJjaCA/IGAke3VybC5wYXRobmFtZX0ke3VybC5zZWFyY2h9YCA6IHVybC5wYXRobmFtZSxcbiAgICAgIG1ldGhvZDogb3B0cy5tZXRob2QgfHwgKG9wdHMuYm9keSA/ICdQVVQnIDogJ0dFVCcpXG4gICAgfSwgaGFuZGxlcilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5zZXRHbG9iYWxEaXNwYXRjaGVyID0gc2V0R2xvYmFsRGlzcGF0Y2hlclxubW9kdWxlLmV4cG9ydHMuZ2V0R2xvYmFsRGlzcGF0Y2hlciA9IGdldEdsb2JhbERpc3BhdGNoZXJcblxuY29uc3QgZmV0Y2hJbXBsID0gcmVxdWlyZSgnLi9saWIvd2ViL2ZldGNoJykuZmV0Y2hcbm1vZHVsZS5leHBvcnRzLmZldGNoID0gYXN5bmMgZnVuY3Rpb24gZmV0Y2ggKGluaXQsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2hJbXBsKGluaXQsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycilcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMuSGVhZGVycyA9IHJlcXVpcmUoJy4vbGliL3dlYi9mZXRjaC9oZWFkZXJzJykuSGVhZGVyc1xubW9kdWxlLmV4cG9ydHMuUmVzcG9uc2UgPSByZXF1aXJlKCcuL2xpYi93ZWIvZmV0Y2gvcmVzcG9uc2UnKS5SZXNwb25zZVxubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IHJlcXVpcmUoJy4vbGliL3dlYi9mZXRjaC9yZXF1ZXN0JykuUmVxdWVzdFxubW9kdWxlLmV4cG9ydHMuRm9ybURhdGEgPSByZXF1aXJlKCcuL2xpYi93ZWIvZmV0Y2gvZm9ybWRhdGEnKS5Gb3JtRGF0YVxuXG5jb25zdCB7IHNldEdsb2JhbE9yaWdpbiwgZ2V0R2xvYmFsT3JpZ2luIH0gPSByZXF1aXJlKCcuL2xpYi93ZWIvZmV0Y2gvZ2xvYmFsJylcblxubW9kdWxlLmV4cG9ydHMuc2V0R2xvYmFsT3JpZ2luID0gc2V0R2xvYmFsT3JpZ2luXG5tb2R1bGUuZXhwb3J0cy5nZXRHbG9iYWxPcmlnaW4gPSBnZXRHbG9iYWxPcmlnaW5cblxuY29uc3QgeyBDYWNoZVN0b3JhZ2UgfSA9IHJlcXVpcmUoJy4vbGliL3dlYi9jYWNoZS9jYWNoZXN0b3JhZ2UnKVxuY29uc3QgeyBrQ29uc3RydWN0IH0gPSByZXF1aXJlKCcuL2xpYi9jb3JlL3N5bWJvbHMnKVxuXG4vLyBDYWNoZSAmIENhY2hlU3RvcmFnZSBhcmUgdGlnaHRseSBjb3VwbGVkIHdpdGggZmV0Y2guIEV2ZW4gaWYgaXQgbWF5IHJ1blxuLy8gaW4gYW4gb2xkZXIgdmVyc2lvbiBvZiBOb2RlLCBpdCBkb2Vzbid0IGhhdmUgYW55IHVzZSB3aXRob3V0IGZldGNoLlxubW9kdWxlLmV4cG9ydHMuY2FjaGVzID0gbmV3IENhY2hlU3RvcmFnZShrQ29uc3RydWN0KVxuXG5jb25zdCB7IGRlbGV0ZUNvb2tpZSwgZ2V0Q29va2llcywgZ2V0U2V0Q29va2llcywgc2V0Q29va2llLCBwYXJzZUNvb2tpZSB9ID0gcmVxdWlyZSgnLi9saWIvd2ViL2Nvb2tpZXMnKVxuXG5tb2R1bGUuZXhwb3J0cy5kZWxldGVDb29raWUgPSBkZWxldGVDb29raWVcbm1vZHVsZS5leHBvcnRzLmdldENvb2tpZXMgPSBnZXRDb29raWVzXG5tb2R1bGUuZXhwb3J0cy5nZXRTZXRDb29raWVzID0gZ2V0U2V0Q29va2llc1xubW9kdWxlLmV4cG9ydHMuc2V0Q29va2llID0gc2V0Q29va2llXG5tb2R1bGUuZXhwb3J0cy5wYXJzZUNvb2tpZSA9IHBhcnNlQ29va2llXG5cbmNvbnN0IHsgcGFyc2VNSU1FVHlwZSwgc2VyaWFsaXplQU1pbWVUeXBlIH0gPSByZXF1aXJlKCcuL2xpYi93ZWIvZmV0Y2gvZGF0YS11cmwnKVxuXG5tb2R1bGUuZXhwb3J0cy5wYXJzZU1JTUVUeXBlID0gcGFyc2VNSU1FVHlwZVxubW9kdWxlLmV4cG9ydHMuc2VyaWFsaXplQU1pbWVUeXBlID0gc2VyaWFsaXplQU1pbWVUeXBlXG5cbmNvbnN0IHsgQ2xvc2VFdmVudCwgRXJyb3JFdmVudCwgTWVzc2FnZUV2ZW50IH0gPSByZXF1aXJlKCcuL2xpYi93ZWIvd2Vic29ja2V0L2V2ZW50cycpXG5tb2R1bGUuZXhwb3J0cy5XZWJTb2NrZXQgPSByZXF1aXJlKCcuL2xpYi93ZWIvd2Vic29ja2V0L3dlYnNvY2tldCcpLldlYlNvY2tldFxubW9kdWxlLmV4cG9ydHMuQ2xvc2VFdmVudCA9IENsb3NlRXZlbnRcbm1vZHVsZS5leHBvcnRzLkVycm9yRXZlbnQgPSBFcnJvckV2ZW50XG5tb2R1bGUuZXhwb3J0cy5NZXNzYWdlRXZlbnQgPSBNZXNzYWdlRXZlbnRcblxubW9kdWxlLmV4cG9ydHMuV2ViU29ja2V0U3RyZWFtID0gcmVxdWlyZSgnLi9saWIvd2ViL3dlYnNvY2tldC9zdHJlYW0vd2Vic29ja2V0c3RyZWFtJykuV2ViU29ja2V0U3RyZWFtXG5tb2R1bGUuZXhwb3J0cy5XZWJTb2NrZXRFcnJvciA9IHJlcXVpcmUoJy4vbGliL3dlYi93ZWJzb2NrZXQvc3RyZWFtL3dlYnNvY2tldGVycm9yJykuV2ViU29ja2V0RXJyb3JcblxubW9kdWxlLmV4cG9ydHMucmVxdWVzdCA9IG1ha2VEaXNwYXRjaGVyKGFwaS5yZXF1ZXN0KVxubW9kdWxlLmV4cG9ydHMuc3RyZWFtID0gbWFrZURpc3BhdGNoZXIoYXBpLnN0cmVhbSlcbm1vZHVsZS5leHBvcnRzLnBpcGVsaW5lID0gbWFrZURpc3BhdGNoZXIoYXBpLnBpcGVsaW5lKVxubW9kdWxlLmV4cG9ydHMuY29ubmVjdCA9IG1ha2VEaXNwYXRjaGVyKGFwaS5jb25uZWN0KVxubW9kdWxlLmV4cG9ydHMudXBncmFkZSA9IG1ha2VEaXNwYXRjaGVyKGFwaS51cGdyYWRlKVxuXG5tb2R1bGUuZXhwb3J0cy5Nb2NrQ2xpZW50ID0gTW9ja0NsaWVudFxubW9kdWxlLmV4cG9ydHMuTW9ja0NhbGxIaXN0b3J5ID0gTW9ja0NhbGxIaXN0b3J5XG5tb2R1bGUuZXhwb3J0cy5Nb2NrQ2FsbEhpc3RvcnlMb2cgPSBNb2NrQ2FsbEhpc3RvcnlMb2dcbm1vZHVsZS5leHBvcnRzLk1vY2tQb29sID0gTW9ja1Bvb2xcbm1vZHVsZS5leHBvcnRzLk1vY2tBZ2VudCA9IE1vY2tBZ2VudFxubW9kdWxlLmV4cG9ydHMubW9ja0Vycm9ycyA9IG1vY2tFcnJvcnNcblxuY29uc3QgeyBFdmVudFNvdXJjZSB9ID0gcmVxdWlyZSgnLi9saWIvd2ViL2V2ZW50c291cmNlL2V2ZW50c291cmNlJylcblxubW9kdWxlLmV4cG9ydHMuRXZlbnRTb3VyY2UgPSBFdmVudFNvdXJjZVxuXG5mdW5jdGlvbiBpbnN0YWxsICgpIHtcbiAgZ2xvYmFsVGhpcy5mZXRjaCA9IG1vZHVsZS5leHBvcnRzLmZldGNoXG4gIGdsb2JhbFRoaXMuSGVhZGVycyA9IG1vZHVsZS5leHBvcnRzLkhlYWRlcnNcbiAgZ2xvYmFsVGhpcy5SZXNwb25zZSA9IG1vZHVsZS5leHBvcnRzLlJlc3BvbnNlXG4gIGdsb2JhbFRoaXMuUmVxdWVzdCA9IG1vZHVsZS5leHBvcnRzLlJlcXVlc3RcbiAgZ2xvYmFsVGhpcy5Gb3JtRGF0YSA9IG1vZHVsZS5leHBvcnRzLkZvcm1EYXRhXG4gIGdsb2JhbFRoaXMuV2ViU29ja2V0ID0gbW9kdWxlLmV4cG9ydHMuV2ViU29ja2V0XG4gIGdsb2JhbFRoaXMuQ2xvc2VFdmVudCA9IG1vZHVsZS5leHBvcnRzLkNsb3NlRXZlbnRcbiAgZ2xvYmFsVGhpcy5FcnJvckV2ZW50ID0gbW9kdWxlLmV4cG9ydHMuRXJyb3JFdmVudFxuICBnbG9iYWxUaGlzLk1lc3NhZ2VFdmVudCA9IG1vZHVsZS5leHBvcnRzLk1lc3NhZ2VFdmVudFxuICBnbG9iYWxUaGlzLkV2ZW50U291cmNlID0gbW9kdWxlLmV4cG9ydHMuRXZlbnRTb3VyY2Vcbn1cblxubW9kdWxlLmV4cG9ydHMuaW5zdGFsbCA9IGluc3RhbGxcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/abort-signal.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/abort-signal.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { addAbortListener } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nconst kListener = Symbol('kListener')\nconst kSignal = Symbol('kSignal')\n\nfunction abort (self) {\n  if (self.abort) {\n    self.abort(self[kSignal]?.reason)\n  } else {\n    self.reason = self[kSignal]?.reason ?? new RequestAbortedError()\n  }\n  removeSignal(self)\n}\n\nfunction addSignal (self, signal) {\n  self.reason = null\n\n  self[kSignal] = null\n  self[kListener] = null\n\n  if (!signal) {\n    return\n  }\n\n  if (signal.aborted) {\n    abort(self)\n    return\n  }\n\n  self[kSignal] = signal\n  self[kListener] = () => {\n    abort(self)\n  }\n\n  addAbortListener(self[kSignal], self[kListener])\n}\n\nfunction removeSignal (self) {\n  if (!self[kSignal]) {\n    return\n  }\n\n  if ('removeEventListener' in self[kSignal]) {\n    self[kSignal].removeEventListener('abort', self[kListener])\n  } else {\n    self[kSignal].removeListener('abort', self[kListener])\n  }\n\n  self[kSignal] = null\n  self[kListener] = null\n}\n\nmodule.exports = {\n  addSignal,\n  removeSignal\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYWJvcnQtc2lnbmFsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYztBQUNuRCxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYWJvcnQtc2lnbmFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGFkZEFib3J0TGlzdGVuZXIgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IFJlcXVlc3RBYm9ydGVkRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuY29uc3Qga0xpc3RlbmVyID0gU3ltYm9sKCdrTGlzdGVuZXInKVxuY29uc3Qga1NpZ25hbCA9IFN5bWJvbCgna1NpZ25hbCcpXG5cbmZ1bmN0aW9uIGFib3J0IChzZWxmKSB7XG4gIGlmIChzZWxmLmFib3J0KSB7XG4gICAgc2VsZi5hYm9ydChzZWxmW2tTaWduYWxdPy5yZWFzb24pXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5yZWFzb24gPSBzZWxmW2tTaWduYWxdPy5yZWFzb24gPz8gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICB9XG4gIHJlbW92ZVNpZ25hbChzZWxmKVxufVxuXG5mdW5jdGlvbiBhZGRTaWduYWwgKHNlbGYsIHNpZ25hbCkge1xuICBzZWxmLnJlYXNvbiA9IG51bGxcblxuICBzZWxmW2tTaWduYWxdID0gbnVsbFxuICBzZWxmW2tMaXN0ZW5lcl0gPSBudWxsXG5cbiAgaWYgKCFzaWduYWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIGFib3J0KHNlbGYpXG4gICAgcmV0dXJuXG4gIH1cblxuICBzZWxmW2tTaWduYWxdID0gc2lnbmFsXG4gIHNlbGZba0xpc3RlbmVyXSA9ICgpID0+IHtcbiAgICBhYm9ydChzZWxmKVxuICB9XG5cbiAgYWRkQWJvcnRMaXN0ZW5lcihzZWxmW2tTaWduYWxdLCBzZWxmW2tMaXN0ZW5lcl0pXG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNpZ25hbCAoc2VsZikge1xuICBpZiAoIXNlbGZba1NpZ25hbF0pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gc2VsZltrU2lnbmFsXSkge1xuICAgIHNlbGZba1NpZ25hbF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBzZWxmW2tMaXN0ZW5lcl0pXG4gIH0gZWxzZSB7XG4gICAgc2VsZltrU2lnbmFsXS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBzZWxmW2tMaXN0ZW5lcl0pXG4gIH1cblxuICBzZWxmW2tTaWduYWxdID0gbnVsbFxuICBzZWxmW2tMaXN0ZW5lcl0gPSBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGRTaWduYWwsXG4gIHJlbW92ZVNpZ25hbFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/abort-signal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-connect.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-connect.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst { InvalidArgumentError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\")\n\nclass ConnectHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_CONNECT')\n\n    this.opaque = opaque || null\n    this.responseHeaders = responseHeaders || null\n    this.callback = callback\n    this.abort = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders () {\n    throw new SocketError('bad connect', null)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    const { callback, opaque, context } = this\n\n    removeSignal(this)\n\n    this.callback = null\n\n    let headers = rawHeaders\n    // Indicates is an HTTP2Session\n    if (headers != null) {\n      headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    }\n\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers,\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction connect (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      connect.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const connectHandler = new ConnectHandler(opts, callback)\n    const connectOptions = { ...opts, method: 'CONNECT' }\n\n    this.dispatch(connectOptions, connectHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = connect\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLWNvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDcEQsUUFBUSxvQ0FBb0MsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN0RSxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLDJFQUFnQjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrQ0FBa0M7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksNEJBQTRCOztBQUV4Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFlBQVksbUJBQW1COztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLWNvbm5lY3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnbm9kZTphc3luY19ob29rcycpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBTb2NrZXRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGFkZFNpZ25hbCwgcmVtb3ZlU2lnbmFsIH0gPSByZXF1aXJlKCcuL2Fib3J0LXNpZ25hbCcpXG5cbmNsYXNzIENvbm5lY3RIYW5kbGVyIGV4dGVuZHMgQXN5bmNSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBjYWxsYmFjaykge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBvcGFxdWUsIHJlc3BvbnNlSGVhZGVycyB9ID0gb3B0c1xuXG4gICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgIH1cblxuICAgIHN1cGVyKCdVTkRJQ0lfQ09OTkVDVCcpXG5cbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbFxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMuYWJvcnQgPSBudWxsXG5cbiAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5jYWxsYmFjaylcblxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRcbiAgfVxuXG4gIG9uSGVhZGVycyAoKSB7XG4gICAgdGhyb3cgbmV3IFNvY2tldEVycm9yKCdiYWQgY29ubmVjdCcsIG51bGwpXG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHNvY2tldCkge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSwgY29udGV4dCB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuXG4gICAgbGV0IGhlYWRlcnMgPSByYXdIZWFkZXJzXG4gICAgLy8gSW5kaWNhdGVzIGlzIGFuIEhUVFAyU2Vzc2lvblxuICAgIGlmIChoZWFkZXJzICE9IG51bGwpIHtcbiAgICAgIGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG4gICAgfVxuXG4gICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIG51bGwsIHtcbiAgICAgIHN0YXR1c0NvZGUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc29ja2V0LFxuICAgICAgb3BhcXVlLFxuICAgICAgY29udGV4dFxuICAgIH0pXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyLCB7IG9wYXF1ZSB9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29ubmVjdCAob3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29ubmVjdC5jYWxsKHRoaXMsIG9wdHMsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBjb25uZWN0SGFuZGxlciA9IG5ldyBDb25uZWN0SGFuZGxlcihvcHRzLCBjYWxsYmFjaylcbiAgICBjb25zdCBjb25uZWN0T3B0aW9ucyA9IHsgLi4ub3B0cywgbWV0aG9kOiAnQ09OTkVDVCcgfVxuXG4gICAgdGhpcy5kaXNwYXRjaChjb25uZWN0T3B0aW9ucywgY29ubmVjdEhhbmRsZXIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBjb25zdCBvcGFxdWUgPSBvcHRzPy5vcGFxdWVcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhlcnIsIHsgb3BhcXVlIH0pKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29ubmVjdFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-connect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-pipeline.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-pipeline.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  Readable,\n  Duplex,\n  PassThrough\n} = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\")\n\nfunction noop () {}\n\nconst kResume = Symbol('resume')\n\nclass PipelineRequest extends Readable {\n  constructor () {\n    super({ autoDestroy: true })\n\n    this[kResume] = null\n  }\n\n  _read () {\n    const { [kResume]: resume } = this\n\n    if (resume) {\n      this[kResume] = null\n      resume()\n    }\n  }\n\n  _destroy (err, callback) {\n    this._read()\n\n    callback(err)\n  }\n}\n\nclass PipelineResponse extends Readable {\n  constructor (resume) {\n    super({ autoDestroy: true })\n    this[kResume] = resume\n  }\n\n  _read () {\n    this[kResume]()\n  }\n\n  _destroy (err, callback) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    callback(err)\n  }\n}\n\nclass PipelineHandler extends AsyncResource {\n  constructor (opts, handler) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof handler !== 'function') {\n      throw new InvalidArgumentError('invalid handler')\n    }\n\n    const { signal, method, opaque, onInfo, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    if (method === 'CONNECT') {\n      throw new InvalidArgumentError('invalid method')\n    }\n\n    if (onInfo && typeof onInfo !== 'function') {\n      throw new InvalidArgumentError('invalid onInfo callback')\n    }\n\n    super('UNDICI_PIPELINE')\n\n    this.opaque = opaque || null\n    this.responseHeaders = responseHeaders || null\n    this.handler = handler\n    this.abort = null\n    this.context = null\n    this.onInfo = onInfo || null\n\n    this.req = new PipelineRequest().on('error', noop)\n\n    this.ret = new Duplex({\n      readableObjectMode: opts.objectMode,\n      autoDestroy: true,\n      read: () => {\n        const { body } = this\n\n        if (body?.resume) {\n          body.resume()\n        }\n      },\n      write: (chunk, encoding, callback) => {\n        const { req } = this\n\n        if (req.push(chunk, encoding) || req._readableState.destroyed) {\n          callback()\n        } else {\n          req[kResume] = callback\n        }\n      },\n      destroy: (err, callback) => {\n        const { body, req, res, ret, abort } = this\n\n        if (!err && !ret._readableState.endEmitted) {\n          err = new RequestAbortedError()\n        }\n\n        if (abort && err) {\n          abort()\n        }\n\n        util.destroy(body, err)\n        util.destroy(req, err)\n        util.destroy(res, err)\n\n        removeSignal(this)\n\n        callback(err)\n      }\n    }).on('prefinish', () => {\n      const { req } = this\n\n      // Node < 15 does not call _final in same tick.\n      req.push(null)\n    })\n\n    this.res = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    const { res } = this\n\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(!res, 'pipeline cannot be retried')\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume) {\n    const { opaque, handler, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.res = new PipelineResponse(resume)\n\n    let body\n    try {\n      this.handler = null\n      const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n      body = this.runInAsyncScope(handler, null, {\n        statusCode,\n        headers,\n        opaque,\n        body: this.res,\n        context\n      })\n    } catch (err) {\n      this.res.on('error', noop)\n      throw err\n    }\n\n    if (!body || typeof body.on !== 'function') {\n      throw new InvalidReturnValueError('expected Readable')\n    }\n\n    body\n      .on('data', (chunk) => {\n        const { ret, body } = this\n\n        if (!ret.push(chunk) && body.pause) {\n          body.pause()\n        }\n      })\n      .on('error', (err) => {\n        const { ret } = this\n\n        util.destroy(ret, err)\n      })\n      .on('end', () => {\n        const { ret } = this\n\n        ret.push(null)\n      })\n      .on('close', () => {\n        const { ret } = this\n\n        if (!ret._readableState.ended) {\n          util.destroy(ret, new RequestAbortedError())\n        }\n      })\n\n    this.body = body\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n    res.push(null)\n  }\n\n  onError (err) {\n    const { ret } = this\n    this.handler = null\n    util.destroy(ret, err)\n  }\n}\n\nfunction pipeline (opts, handler) {\n  try {\n    const pipelineHandler = new PipelineHandler(opts, handler)\n    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler)\n    return pipelineHandler.ret\n  } catch (err) {\n    return new PassThrough().destroy(err)\n  }\n}\n\nmodule.exports = pipeline\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXBpcGVsaW5lLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDekIsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDNUIsYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQywyRUFBZ0I7O0FBRTVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBLFlBQVksb0JBQW9COztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrREFBa0Q7O0FBRTlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQkFBZ0IsTUFBTTs7QUFFdEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0JBQWdCLDZCQUE2Qjs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLE1BQU07O0FBRXBCO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07O0FBRWxCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksMkJBQTJCOztBQUV2QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGdCQUFnQixNQUFNOztBQUV0QjtBQUNBLE9BQU87QUFDUDtBQUNBLGdCQUFnQixNQUFNOztBQUV0QjtBQUNBLE9BQU87QUFDUDtBQUNBLGdCQUFnQixNQUFNOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktcGlwZWxpbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgUmVhZGFibGUsXG4gIER1cGxleCxcbiAgUGFzc1Rocm91Z2hcbn0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ25vZGU6YXN5bmNfaG9va3MnKVxuY29uc3Qge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZFJldHVyblZhbHVlRXJyb3IsXG4gIFJlcXVlc3RBYm9ydGVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5jb25zdCBrUmVzdW1lID0gU3ltYm9sKCdyZXN1bWUnKVxuXG5jbGFzcyBQaXBlbGluZVJlcXVlc3QgZXh0ZW5kcyBSZWFkYWJsZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcih7IGF1dG9EZXN0cm95OiB0cnVlIH0pXG5cbiAgICB0aGlzW2tSZXN1bWVdID0gbnVsbFxuICB9XG5cbiAgX3JlYWQgKCkge1xuICAgIGNvbnN0IHsgW2tSZXN1bWVdOiByZXN1bWUgfSA9IHRoaXNcblxuICAgIGlmIChyZXN1bWUpIHtcbiAgICAgIHRoaXNba1Jlc3VtZV0gPSBudWxsXG4gICAgICByZXN1bWUoKVxuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcmVhZCgpXG5cbiAgICBjYWxsYmFjayhlcnIpXG4gIH1cbn1cblxuY2xhc3MgUGlwZWxpbmVSZXNwb25zZSBleHRlbmRzIFJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IgKHJlc3VtZSkge1xuICAgIHN1cGVyKHsgYXV0b0Rlc3Ryb3k6IHRydWUgfSlcbiAgICB0aGlzW2tSZXN1bWVdID0gcmVzdW1lXG4gIH1cblxuICBfcmVhZCAoKSB7XG4gICAgdGhpc1trUmVzdW1lXSgpXG4gIH1cblxuICBfZGVzdHJveSAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICghZXJyICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgIGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICB9XG5cbiAgICBjYWxsYmFjayhlcnIpXG4gIH1cbn1cblxuY2xhc3MgUGlwZWxpbmVIYW5kbGVyIGV4dGVuZHMgQXN5bmNSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGhhbmRsZXInKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBtZXRob2QsIG9wYXF1ZSwgb25JbmZvLCByZXNwb25zZUhlYWRlcnMgfSA9IG9wdHNcblxuICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0JylcbiAgICB9XG5cbiAgICBpZiAobWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBtZXRob2QnKVxuICAgIH1cblxuICAgIGlmIChvbkluZm8gJiYgdHlwZW9mIG9uSW5mbyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uSW5mbyBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgc3VwZXIoJ1VORElDSV9QSVBFTElORScpXG5cbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbFxuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXJcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcbiAgICB0aGlzLm9uSW5mbyA9IG9uSW5mbyB8fCBudWxsXG5cbiAgICB0aGlzLnJlcSA9IG5ldyBQaXBlbGluZVJlcXVlc3QoKS5vbignZXJyb3InLCBub29wKVxuXG4gICAgdGhpcy5yZXQgPSBuZXcgRHVwbGV4KHtcbiAgICAgIHJlYWRhYmxlT2JqZWN0TW9kZTogb3B0cy5vYmplY3RNb2RlLFxuICAgICAgYXV0b0Rlc3Ryb3k6IHRydWUsXG4gICAgICByZWFkOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYm9keSB9ID0gdGhpc1xuXG4gICAgICAgIGlmIChib2R5Py5yZXN1bWUpIHtcbiAgICAgICAgICBib2R5LnJlc3VtZSgpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB3cml0ZTogKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgY29uc3QgeyByZXEgfSA9IHRoaXNcblxuICAgICAgICBpZiAocmVxLnB1c2goY2h1bmssIGVuY29kaW5nKSB8fCByZXEuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcVtrUmVzdW1lXSA9IGNhbGxiYWNrXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiAoZXJyLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCB7IGJvZHksIHJlcSwgcmVzLCByZXQsIGFib3J0IH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKCFlcnIgJiYgIXJldC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgICAgZXJyID0gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFib3J0ICYmIGVycikge1xuICAgICAgICAgIGFib3J0KClcbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgICAgIHV0aWwuZGVzdHJveShyZXEsIGVycilcbiAgICAgICAgdXRpbC5kZXN0cm95KHJlcywgZXJyKVxuXG4gICAgICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgIH1cbiAgICB9KS5vbigncHJlZmluaXNoJywgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXEgfSA9IHRoaXNcblxuICAgICAgLy8gTm9kZSA8IDE1IGRvZXMgbm90IGNhbGwgX2ZpbmFsIGluIHNhbWUgdGljay5cbiAgICAgIHJlcS5wdXNoKG51bGwpXG4gICAgfSlcblxuICAgIHRoaXMucmVzID0gbnVsbFxuXG4gICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbClcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IHJlcyB9ID0gdGhpc1xuXG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICBhYm9ydCh0aGlzLnJlYXNvbilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydCghcmVzLCAncGlwZWxpbmUgY2Fubm90IGJlIHJldHJpZWQnKVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dFxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUpIHtcbiAgICBjb25zdCB7IG9wYXF1ZSwgaGFuZGxlciwgY29udGV4dCB9ID0gdGhpc1xuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIGlmICh0aGlzLm9uSW5mbykge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuICAgICAgICB0aGlzLm9uSW5mbyh7IHN0YXR1c0NvZGUsIGhlYWRlcnMgfSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMucmVzID0gbmV3IFBpcGVsaW5lUmVzcG9uc2UocmVzdW1lKVxuXG4gICAgbGV0IGJvZHlcbiAgICB0cnkge1xuICAgICAgdGhpcy5oYW5kbGVyID0gbnVsbFxuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICAgIGJvZHkgPSB0aGlzLnJ1bkluQXN5bmNTY29wZShoYW5kbGVyLCBudWxsLCB7XG4gICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIG9wYXF1ZSxcbiAgICAgICAgYm9keTogdGhpcy5yZXMsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLnJlcy5vbignZXJyb3InLCBub29wKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgaWYgKCFib2R5IHx8IHR5cGVvZiBib2R5Lm9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFJldHVyblZhbHVlRXJyb3IoJ2V4cGVjdGVkIFJlYWRhYmxlJylcbiAgICB9XG5cbiAgICBib2R5XG4gICAgICAub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgY29uc3QgeyByZXQsIGJvZHkgfSA9IHRoaXNcblxuICAgICAgICBpZiAoIXJldC5wdXNoKGNodW5rKSAmJiBib2R5LnBhdXNlKSB7XG4gICAgICAgICAgYm9keS5wYXVzZSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICBjb25zdCB7IHJldCB9ID0gdGhpc1xuXG4gICAgICAgIHV0aWwuZGVzdHJveShyZXQsIGVycilcbiAgICAgIH0pXG4gICAgICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXQgfSA9IHRoaXNcblxuICAgICAgICByZXQucHVzaChudWxsKVxuICAgICAgfSlcbiAgICAgIC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmV0IH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKCFyZXQuX3JlYWRhYmxlU3RhdGUuZW5kZWQpIHtcbiAgICAgICAgICB1dGlsLmRlc3Ryb3kocmV0LCBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgdGhpcy5ib2R5ID0gYm9keVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG4gICAgcmV0dXJuIHJlcy5wdXNoKGNodW5rKVxuICB9XG5cbiAgb25Db21wbGV0ZSAodHJhaWxlcnMpIHtcbiAgICBjb25zdCB7IHJlcyB9ID0gdGhpc1xuICAgIHJlcy5wdXNoKG51bGwpXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBjb25zdCB7IHJldCB9ID0gdGhpc1xuICAgIHRoaXMuaGFuZGxlciA9IG51bGxcbiAgICB1dGlsLmRlc3Ryb3kocmV0LCBlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gcGlwZWxpbmUgKG9wdHMsIGhhbmRsZXIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwaXBlbGluZUhhbmRsZXIgPSBuZXcgUGlwZWxpbmVIYW5kbGVyKG9wdHMsIGhhbmRsZXIpXG4gICAgdGhpcy5kaXNwYXRjaCh7IC4uLm9wdHMsIGJvZHk6IHBpcGVsaW5lSGFuZGxlci5yZXEgfSwgcGlwZWxpbmVIYW5kbGVyKVxuICAgIHJldHVybiBwaXBlbGluZUhhbmRsZXIucmV0XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2goKS5kZXN0cm95KGVycilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpcGVsaW5lXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-pipeline.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-request.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-request.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst { Readable } = __webpack_require__(/*! ./readable */ \"(rsc)/./node_modules/undici/lib/api/readable.js\")\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nfunction noop () {}\n\nclass RequestHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders, highWaterMark } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {\n        throw new InvalidArgumentError('invalid highWaterMark')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_REQUEST')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', noop), err)\n      }\n      throw err\n    }\n\n    this.method = method\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.body = body\n    this.trailers = {}\n    this.context = null\n    this.onInfo = onInfo || null\n    this.highWaterMark = highWaterMark\n    this.reason = null\n    this.removeAbortListener = null\n\n    if (signal?.aborted) {\n      this.reason = signal.reason ?? new RequestAbortedError()\n    } else if (signal) {\n      this.removeAbortListener = util.addAbortListener(signal, () => {\n        this.reason = signal.reason ?? new RequestAbortedError()\n        if (this.res) {\n          util.destroy(this.res.on('error', noop), this.reason)\n        } else if (this.abort) {\n          this.abort(this.reason)\n        }\n      })\n    }\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers\n    const contentType = parsedHeaders['content-type']\n    const contentLength = parsedHeaders['content-length']\n    const res = new Readable({\n      resume,\n      abort,\n      contentType,\n      contentLength: this.method !== 'HEAD' && contentLength\n        ? Number(contentLength)\n        : null,\n      highWaterMark\n    })\n\n    if (this.removeAbortListener) {\n      res.on('close', this.removeAbortListener)\n      this.removeAbortListener = null\n    }\n\n    this.callback = null\n    this.res = res\n    if (callback !== null) {\n      this.runInAsyncScope(callback, null, null, {\n        statusCode,\n        headers,\n        trailers: this.trailers,\n        opaque,\n        body: res,\n        context\n      })\n    }\n  }\n\n  onData (chunk) {\n    return this.res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    util.parseHeaders(trailers, this.trailers)\n    this.res.push(null)\n  }\n\n  onError (err) {\n    const { res, callback, body, opaque } = this\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (res) {\n      this.res = null\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res.on('error', noop), err)\n      })\n    }\n\n    if (body) {\n      this.body = null\n\n      if (util.isStream(body)) {\n        body.on('error', noop)\n        util.destroy(body, err)\n      }\n    }\n\n    if (this.removeAbortListener) {\n      this.removeAbortListener()\n      this.removeAbortListener = null\n    }\n  }\n}\n\nfunction request (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const handler = new RequestHandler(opts, callback)\n\n    this.dispatch(opts, handler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = request\nmodule.exports.RequestHandler = RequestHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXJlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDcEQsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxtRUFBWTtBQUN6QyxRQUFRLDRDQUE0QyxFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQzlFLGFBQWEsbUJBQU8sQ0FBQyxrRUFBYzs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLHVFQUF1RTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLG1FQUFtRTs7QUFFL0U7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw4QkFBOEI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QiIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXJlcXVlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnbm9kZTphc3luY19ob29rcycpXG5jb25zdCB7IFJlYWRhYmxlIH0gPSByZXF1aXJlKCcuL3JlYWRhYmxlJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFJlcXVlc3RBYm9ydGVkRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmNsYXNzIFJlcXVlc3RIYW5kbGVyIGV4dGVuZHMgQXN5bmNSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBjYWxsYmFjaykge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNpZ25hbCwgbWV0aG9kLCBvcGFxdWUsIGJvZHksIG9uSW5mbywgcmVzcG9uc2VIZWFkZXJzLCBoaWdoV2F0ZXJNYXJrIH0gPSBvcHRzXG5cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgICAgfVxuXG4gICAgICBpZiAoaGlnaFdhdGVyTWFyayAmJiAodHlwZW9mIGhpZ2hXYXRlck1hcmsgIT09ICdudW1iZXInIHx8IGhpZ2hXYXRlck1hcmsgPCAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGlnaFdhdGVyTWFyaycpXG4gICAgICB9XG5cbiAgICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgICAgfVxuXG4gICAgICBpZiAobWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG1ldGhvZCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChvbkluZm8gJiYgdHlwZW9mIG9uSW5mbyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25JbmZvIGNhbGxiYWNrJylcbiAgICAgIH1cblxuICAgICAgc3VwZXIoJ1VORElDSV9SRVFVRVNUJylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICAgIHV0aWwuZGVzdHJveShib2R5Lm9uKCdlcnJvcicsIG5vb3ApLCBlcnIpXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZFxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5yZXMgPSBudWxsXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcbiAgICB0aGlzLmJvZHkgPSBib2R5XG4gICAgdGhpcy50cmFpbGVycyA9IHt9XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICAgIHRoaXMub25JbmZvID0gb25JbmZvIHx8IG51bGxcbiAgICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBoaWdoV2F0ZXJNYXJrXG4gICAgdGhpcy5yZWFzb24gPSBudWxsXG4gICAgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyID0gbnVsbFxuXG4gICAgaWYgKHNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgdGhpcy5yZWFzb24gPSBzaWduYWwucmVhc29uID8/IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICB9IGVsc2UgaWYgKHNpZ25hbCkge1xuICAgICAgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyID0gdXRpbC5hZGRBYm9ydExpc3RlbmVyKHNpZ25hbCwgKCkgPT4ge1xuICAgICAgICB0aGlzLnJlYXNvbiA9IHNpZ25hbC5yZWFzb24gPz8gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgICAgICBpZiAodGhpcy5yZXMpIHtcbiAgICAgICAgICB1dGlsLmRlc3Ryb3kodGhpcy5yZXMub24oJ2Vycm9yJywgbm9vcCksIHRoaXMucmVhc29uKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYWJvcnQpIHtcbiAgICAgICAgICB0aGlzLmFib3J0KHRoaXMucmVhc29uKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIGFib3J0KHRoaXMucmVhc29uKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXNzZXJ0KHRoaXMuY2FsbGJhY2spXG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSwgc3RhdHVzTWVzc2FnZSkge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSwgYWJvcnQsIGNvbnRleHQsIHJlc3BvbnNlSGVhZGVycywgaGlnaFdhdGVyTWFyayB9ID0gdGhpc1xuXG4gICAgY29uc3QgaGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgaWYgKHRoaXMub25JbmZvKSB7XG4gICAgICAgIHRoaXMub25JbmZvKHsgc3RhdHVzQ29kZSwgaGVhZGVycyB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSA6IGhlYWRlcnNcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHBhcnNlZEhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IHBhcnNlZEhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ11cbiAgICBjb25zdCByZXMgPSBuZXcgUmVhZGFibGUoe1xuICAgICAgcmVzdW1lLFxuICAgICAgYWJvcnQsXG4gICAgICBjb250ZW50VHlwZSxcbiAgICAgIGNvbnRlbnRMZW5ndGg6IHRoaXMubWV0aG9kICE9PSAnSEVBRCcgJiYgY29udGVudExlbmd0aFxuICAgICAgICA/IE51bWJlcihjb250ZW50TGVuZ3RoKVxuICAgICAgICA6IG51bGwsXG4gICAgICBoaWdoV2F0ZXJNYXJrXG4gICAgfSlcblxuICAgIGlmICh0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIpIHtcbiAgICAgIHJlcy5vbignY2xvc2UnLCB0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIpXG4gICAgICB0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIgPSBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICB0aGlzLnJlcyA9IHJlc1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIG51bGwsIHtcbiAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgdHJhaWxlcnM6IHRoaXMudHJhaWxlcnMsXG4gICAgICAgIG9wYXF1ZSxcbiAgICAgICAgYm9keTogcmVzLFxuICAgICAgICBjb250ZXh0XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIG9uRGF0YSAoY2h1bmspIHtcbiAgICByZXR1cm4gdGhpcy5yZXMucHVzaChjaHVuaylcbiAgfVxuXG4gIG9uQ29tcGxldGUgKHRyYWlsZXJzKSB7XG4gICAgdXRpbC5wYXJzZUhlYWRlcnModHJhaWxlcnMsIHRoaXMudHJhaWxlcnMpXG4gICAgdGhpcy5yZXMucHVzaChudWxsKVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgY29uc3QgeyByZXMsIGNhbGxiYWNrLCBib2R5LCBvcGFxdWUgfSA9IHRoaXNcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgLy8gVE9ETzogRG9lcyB0aGlzIG5lZWQgcXVldWVNaWNyb3Rhc2s/XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyLCB7IG9wYXF1ZSB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAocmVzKSB7XG4gICAgICB0aGlzLnJlcyA9IG51bGxcbiAgICAgIC8vIEVuc3VyZSBhbGwgcXVldWVkIGhhbmRsZXJzIGFyZSBpbnZva2VkIGJlZm9yZSBkZXN0cm95aW5nIHJlcy5cbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdXRpbC5kZXN0cm95KHJlcy5vbignZXJyb3InLCBub29wKSwgZXJyKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoYm9keSkge1xuICAgICAgdGhpcy5ib2R5ID0gbnVsbFxuXG4gICAgICBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgICAgICBib2R5Lm9uKCdlcnJvcicsIG5vb3ApXG4gICAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lcikge1xuICAgICAgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyKClcbiAgICAgIHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lciA9IG51bGxcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdCAob3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVxdWVzdC5jYWxsKHRoaXMsIG9wdHMsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBoYW5kbGVyID0gbmV3IFJlcXVlc3RIYW5kbGVyKG9wdHMsIGNhbGxiYWNrKVxuXG4gICAgdGhpcy5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gICAgY29uc3Qgb3BhcXVlID0gb3B0cz8ub3BhcXVlXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2soZXJyLCB7IG9wYXF1ZSB9KSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVlc3Rcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3RIYW5kbGVyID0gUmVxdWVzdEhhbmRsZXJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-stream.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/api/api-stream.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { finished } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst { InvalidArgumentError, InvalidReturnValueError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\")\n\nfunction noop () {}\n\nclass StreamHandler extends AsyncResource {\n  constructor (opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_STREAM')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', noop), err)\n      }\n      throw err\n    }\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.factory = factory\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.context = null\n    this.trailers = null\n    this.body = body\n    this.onInfo = onInfo || null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { factory, opaque, context, responseHeaders } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.factory = null\n\n    if (factory === null) {\n      return\n    }\n\n    const res = this.runInAsyncScope(factory, null, {\n      statusCode,\n      headers,\n      opaque,\n      context\n    })\n\n    if (\n      !res ||\n      typeof res.write !== 'function' ||\n      typeof res.end !== 'function' ||\n      typeof res.on !== 'function'\n    ) {\n      throw new InvalidReturnValueError('expected Writable')\n    }\n\n    // TODO: Avoid finished. It registers an unnecessary amount of listeners.\n    finished(res, { readable: false }, (err) => {\n      const { callback, res, opaque, trailers, abort } = this\n\n      this.res = null\n      if (err || !res?.readable) {\n        util.destroy(res, err)\n      }\n\n      this.callback = null\n      this.runInAsyncScope(callback, null, err || null, { opaque, trailers })\n\n      if (err) {\n        abort()\n      }\n    })\n\n    res.on('drain', resume)\n\n    this.res = res\n\n    const needDrain = res.writableNeedDrain !== undefined\n      ? res.writableNeedDrain\n      : res._writableState?.needDrain\n\n    return needDrain !== true\n  }\n\n  onData (chunk) {\n    const { res } = this\n\n    return res ? res.write(chunk) : true\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    if (!res) {\n      return\n    }\n\n    this.trailers = util.parseHeaders(trailers)\n\n    res.end()\n  }\n\n  onError (err) {\n    const { res, callback, opaque, body } = this\n\n    removeSignal(this)\n\n    this.factory = null\n\n    if (res) {\n      this.res = null\n      util.destroy(res, err)\n    } else if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction stream (opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const handler = new StreamHandler(opts, factory, callback)\n\n    this.dispatch(opts, handler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = stream\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsMENBQWtCO0FBQ3BELFFBQVEsZ0RBQWdELEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDbEYsYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQywyRUFBZ0I7O0FBRTVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSx3REFBd0Q7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw0Q0FBNEM7O0FBRXhEOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckMsY0FBYyx5Q0FBeUM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBELGtCQUFrQjs7QUFFNUU7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTs7QUFFbEI7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTs7QUFFbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDhCQUE4Qjs7QUFFMUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktc3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IGZpbmlzaGVkIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ25vZGU6YXN5bmNfaG9va3MnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgSW52YWxpZFJldHVyblZhbHVlRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZSgnLi9hYm9ydC1zaWduYWwnKVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmNsYXNzIFN0cmVhbUhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGZhY3RvcnksIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBtZXRob2QsIG9wYXF1ZSwgYm9keSwgb25JbmZvLCByZXNwb25zZUhlYWRlcnMgfSA9IG9wdHNcblxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgZmFjdG9yeScpXG4gICAgICB9XG5cbiAgICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgICAgfVxuXG4gICAgICBpZiAobWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG1ldGhvZCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChvbkluZm8gJiYgdHlwZW9mIG9uSW5mbyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25JbmZvIGNhbGxiYWNrJylcbiAgICAgIH1cblxuICAgICAgc3VwZXIoJ1VORElDSV9TVFJFQU0nKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KGJvZHkub24oJ2Vycm9yJywgbm9vcCksIGVycilcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeVxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMucmVzID0gbnVsbFxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICAgIHRoaXMudHJhaWxlcnMgPSBudWxsXG4gICAgdGhpcy5ib2R5ID0gYm9keVxuICAgIHRoaXMub25JbmZvID0gb25JbmZvIHx8IG51bGxcblxuICAgIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICBib2R5Lm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbClcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIGFib3J0KHRoaXMucmVhc29uKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXNzZXJ0KHRoaXMuY2FsbGJhY2spXG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSwgc3RhdHVzTWVzc2FnZSkge1xuICAgIGNvbnN0IHsgZmFjdG9yeSwgb3BhcXVlLCBjb250ZXh0LCByZXNwb25zZUhlYWRlcnMgfSA9IHRoaXNcblxuICAgIGNvbnN0IGhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIGlmICh0aGlzLm9uSW5mbykge1xuICAgICAgICB0aGlzLm9uSW5mbyh7IHN0YXR1c0NvZGUsIGhlYWRlcnMgfSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuZmFjdG9yeSA9IG51bGxcblxuICAgIGlmIChmYWN0b3J5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZXMgPSB0aGlzLnJ1bkluQXN5bmNTY29wZShmYWN0b3J5LCBudWxsLCB7XG4gICAgICBzdGF0dXNDb2RlLFxuICAgICAgaGVhZGVycyxcbiAgICAgIG9wYXF1ZSxcbiAgICAgIGNvbnRleHRcbiAgICB9KVxuXG4gICAgaWYgKFxuICAgICAgIXJlcyB8fFxuICAgICAgdHlwZW9mIHJlcy53cml0ZSAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIHJlcy5lbmQgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiByZXMub24gIT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcignZXhwZWN0ZWQgV3JpdGFibGUnKVxuICAgIH1cblxuICAgIC8vIFRPRE86IEF2b2lkIGZpbmlzaGVkLiBJdCByZWdpc3RlcnMgYW4gdW5uZWNlc3NhcnkgYW1vdW50IG9mIGxpc3RlbmVycy5cbiAgICBmaW5pc2hlZChyZXMsIHsgcmVhZGFibGU6IGZhbHNlIH0sIChlcnIpID0+IHtcbiAgICAgIGNvbnN0IHsgY2FsbGJhY2ssIHJlcywgb3BhcXVlLCB0cmFpbGVycywgYWJvcnQgfSA9IHRoaXNcblxuICAgICAgdGhpcy5yZXMgPSBudWxsXG4gICAgICBpZiAoZXJyIHx8ICFyZXM/LnJlYWRhYmxlKSB7XG4gICAgICAgIHV0aWwuZGVzdHJveShyZXMsIGVycilcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIgfHwgbnVsbCwgeyBvcGFxdWUsIHRyYWlsZXJzIH0pXG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgYWJvcnQoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXMub24oJ2RyYWluJywgcmVzdW1lKVxuXG4gICAgdGhpcy5yZXMgPSByZXNcblxuICAgIGNvbnN0IG5lZWREcmFpbiA9IHJlcy53cml0YWJsZU5lZWREcmFpbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IHJlcy53cml0YWJsZU5lZWREcmFpblxuICAgICAgOiByZXMuX3dyaXRhYmxlU3RhdGU/Lm5lZWREcmFpblxuXG4gICAgcmV0dXJuIG5lZWREcmFpbiAhPT0gdHJ1ZVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG5cbiAgICByZXR1cm4gcmVzID8gcmVzLndyaXRlKGNodW5rKSA6IHRydWVcbiAgfVxuXG4gIG9uQ29tcGxldGUgKHRyYWlsZXJzKSB7XG4gICAgY29uc3QgeyByZXMgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMudHJhaWxlcnMgPSB1dGlsLnBhcnNlSGVhZGVycyh0cmFpbGVycylcblxuICAgIHJlcy5lbmQoKVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgY29uc3QgeyByZXMsIGNhbGxiYWNrLCBvcGFxdWUsIGJvZHkgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgdGhpcy5mYWN0b3J5ID0gbnVsbFxuXG4gICAgaWYgKHJlcykge1xuICAgICAgdGhpcy5yZXMgPSBudWxsXG4gICAgICB1dGlsLmRlc3Ryb3kocmVzLCBlcnIpXG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIHRoaXMuYm9keSA9IG51bGxcbiAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmVhbSAob3B0cywgZmFjdG9yeSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgc3RyZWFtLmNhbGwodGhpcywgb3B0cywgZmFjdG9yeSwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgU3RyZWFtSGFuZGxlcihvcHRzLCBmYWN0b3J5LCBjYWxsYmFjaylcblxuICAgIHRoaXMuZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHM/Lm9wYXF1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJlYW1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-upgrade.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-upgrade.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { InvalidArgumentError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\")\n\nclass UpgradeHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_UPGRADE')\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.abort = null\n    this.context = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = null\n  }\n\n  onHeaders () {\n    throw new SocketError('bad upgrade', null)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    assert(statusCode === 101)\n\n    const { callback, opaque, context } = this\n\n    removeSignal(this)\n\n    this.callback = null\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    this.runInAsyncScope(callback, null, null, {\n      headers,\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction upgrade (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      upgrade.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const upgradeHandler = new UpgradeHandler(opts, callback)\n    const upgradeOpts = {\n      ...opts,\n      method: opts.method || 'GET',\n      upgrade: opts.protocol || 'Websocket'\n    }\n\n    this.dispatch(upgradeOpts, upgradeHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = upgrade\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXVwZ3JhZGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxvQ0FBb0MsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN0RSxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsMENBQWtCO0FBQ3BELGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLDJFQUFnQjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrQ0FBa0M7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWSw0QkFBNEI7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsWUFBWSxtQkFBbUI7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVELE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktdXBncmFkZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgU29ja2V0RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnbm9kZTphc3luY19ob29rcycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcblxuY2xhc3MgVXBncmFkZUhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaWduYWwsIG9wYXF1ZSwgcmVzcG9uc2VIZWFkZXJzIH0gPSBvcHRzXG5cbiAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgfVxuXG4gICAgc3VwZXIoJ1VORElDSV9VUEdSQURFJylcblxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsXG5cbiAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5jYWxsYmFjaylcblxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcbiAgfVxuXG4gIG9uSGVhZGVycyAoKSB7XG4gICAgdGhyb3cgbmV3IFNvY2tldEVycm9yKCdiYWQgdXBncmFkZScsIG51bGwpXG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHNvY2tldCkge1xuICAgIGFzc2VydChzdGF0dXNDb2RlID09PSAxMDEpXG5cbiAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUsIGNvbnRleHQgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBudWxsLCB7XG4gICAgICBoZWFkZXJzLFxuICAgICAgc29ja2V0LFxuICAgICAgb3BhcXVlLFxuICAgICAgY29udGV4dFxuICAgIH0pXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyLCB7IG9wYXF1ZSB9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBncmFkZSAob3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdXBncmFkZS5jYWxsKHRoaXMsIG9wdHMsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB1cGdyYWRlSGFuZGxlciA9IG5ldyBVcGdyYWRlSGFuZGxlcihvcHRzLCBjYWxsYmFjaylcbiAgICBjb25zdCB1cGdyYWRlT3B0cyA9IHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBtZXRob2Q6IG9wdHMubWV0aG9kIHx8ICdHRVQnLFxuICAgICAgdXBncmFkZTogb3B0cy5wcm90b2NvbCB8fCAnV2Vic29ja2V0J1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2godXBncmFkZU9wdHMsIHVwZ3JhZGVIYW5kbGVyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gICAgY29uc3Qgb3BhcXVlID0gb3B0cz8ub3BhcXVlXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2soZXJyLCB7IG9wYXF1ZSB9KSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVwZ3JhZGVcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-upgrade.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/index.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/api/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nmodule.exports.request = __webpack_require__(/*! ./api-request */ \"(rsc)/./node_modules/undici/lib/api/api-request.js\")\nmodule.exports.stream = __webpack_require__(/*! ./api-stream */ \"(rsc)/./node_modules/undici/lib/api/api-stream.js\")\nmodule.exports.pipeline = __webpack_require__(/*! ./api-pipeline */ \"(rsc)/./node_modules/undici/lib/api/api-pipeline.js\")\nmodule.exports.upgrade = __webpack_require__(/*! ./api-upgrade */ \"(rsc)/./node_modules/undici/lib/api/api-upgrade.js\")\nmodule.exports.connect = __webpack_require__(/*! ./api-connect */ \"(rsc)/./node_modules/undici/lib/api/api-connect.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosdUhBQWlEO0FBQ2pELG9IQUErQztBQUMvQywwSEFBbUQ7QUFDbkQsdUhBQWlEO0FBQ2pELHVIQUFpRCIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzLnJlcXVlc3QgPSByZXF1aXJlKCcuL2FwaS1yZXF1ZXN0Jylcbm1vZHVsZS5leHBvcnRzLnN0cmVhbSA9IHJlcXVpcmUoJy4vYXBpLXN0cmVhbScpXG5tb2R1bGUuZXhwb3J0cy5waXBlbGluZSA9IHJlcXVpcmUoJy4vYXBpLXBpcGVsaW5lJylcbm1vZHVsZS5leHBvcnRzLnVwZ3JhZGUgPSByZXF1aXJlKCcuL2FwaS11cGdyYWRlJylcbm1vZHVsZS5leHBvcnRzLmNvbm5lY3QgPSByZXF1aXJlKCcuL2FwaS1jb25uZWN0JylcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/readable.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/api/readable.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Ported from https://github.com/nodejs/undici/pull/907\n\n\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { Readable } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { ReadableStreamFrom } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nconst kConsume = Symbol('kConsume')\nconst kReading = Symbol('kReading')\nconst kBody = Symbol('kBody')\nconst kAbort = Symbol('kAbort')\nconst kContentType = Symbol('kContentType')\nconst kContentLength = Symbol('kContentLength')\nconst kUsed = Symbol('kUsed')\nconst kBytesRead = Symbol('kBytesRead')\n\nconst noop = () => {}\n\n/**\n * @class\n * @extends {Readable}\n * @see https://fetch.spec.whatwg.org/#body\n */\nclass BodyReadable extends Readable {\n  /**\n   * @param {object} opts\n   * @param {(this: Readable, size: number) => void} opts.resume\n   * @param {() => (void | null)} opts.abort\n   * @param {string} [opts.contentType = '']\n   * @param {number} [opts.contentLength]\n   * @param {number} [opts.highWaterMark = 64 * 1024]\n   */\n  constructor ({\n    resume,\n    abort,\n    contentType = '',\n    contentLength,\n    highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n  }) {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark\n    })\n\n    this._readableState.dataEmitted = false\n\n    this[kAbort] = abort\n\n    /**\n     * @type {Consume | null}\n     */\n    this[kConsume] = null\n    this[kBytesRead] = 0\n    /**\n     * @type {ReadableStream|null}\n     */\n    this[kBody] = null\n    this[kUsed] = false\n    this[kContentType] = contentType\n    this[kContentLength] = Number.isFinite(contentLength) ? contentLength : null\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false\n  }\n\n  /**\n   * @param {Error|null} err\n   * @param {(error:(Error|null)) => void} callback\n   * @returns {void}\n   */\n  _destroy (err, callback) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    if (err) {\n      this[kAbort]()\n    }\n\n    // Workaround for Node \"bug\". If the stream is destroyed in same\n    // tick as it is created, then a user who is waiting for a\n    // promise (i.e micro tick) for installing an 'error' listener will\n    // never get a chance and will always encounter an unhandled exception.\n    if (!this[kUsed]) {\n      setImmediate(() => {\n        callback(err)\n      })\n    } else {\n      callback(err)\n    }\n  }\n\n  /**\n   * @param {string} event\n   * @param {(...args: any[]) => void} listener\n   * @returns {this}\n   */\n  on (event, listener) {\n    if (event === 'data' || event === 'readable') {\n      this[kReading] = true\n      this[kUsed] = true\n    }\n    return super.on(event, listener)\n  }\n\n  /**\n   * @param {string} event\n   * @param {(...args: any[]) => void} listener\n   * @returns {this}\n   */\n  addListener (event, listener) {\n    return this.on(event, listener)\n  }\n\n  /**\n   * @param {string|symbol} event\n   * @param {(...args: any[]) => void} listener\n   * @returns {this}\n   */\n  off (event, listener) {\n    const ret = super.off(event, listener)\n    if (event === 'data' || event === 'readable') {\n      this[kReading] = (\n        this.listenerCount('data') > 0 ||\n        this.listenerCount('readable') > 0\n      )\n    }\n    return ret\n  }\n\n  /**\n   * @param {string|symbol} event\n   * @param {(...args: any[]) => void} listener\n   * @returns {this}\n   */\n  removeListener (event, listener) {\n    return this.off(event, listener)\n  }\n\n  /**\n   * @param {Buffer|null} chunk\n   * @returns {boolean}\n   */\n  push (chunk) {\n    this[kBytesRead] += chunk ? chunk.length : 0\n\n    if (this[kConsume] && chunk !== null) {\n      consumePush(this[kConsume], chunk)\n      return this[kReading] ? super.push(chunk) : true\n    }\n    return super.push(chunk)\n  }\n\n  /**\n   * Consumes and returns the body as a string.\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-text\n   * @returns {Promise<string>}\n   */\n  text () {\n    return consume(this, 'text')\n  }\n\n  /**\n   * Consumes and returns the body as a JavaScript Object.\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-json\n   * @returns {Promise<unknown>}\n   */\n  json () {\n    return consume(this, 'json')\n  }\n\n  /**\n   * Consumes and returns the body as a Blob\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-blob\n   * @returns {Promise<Blob>}\n   */\n  blob () {\n    return consume(this, 'blob')\n  }\n\n  /**\n   * Consumes and returns the body as an Uint8Array.\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-bytes\n   * @returns {Promise<Uint8Array>}\n   */\n  bytes () {\n    return consume(this, 'bytes')\n  }\n\n  /**\n   * Consumes and returns the body as an ArrayBuffer.\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n   * @returns {Promise<ArrayBuffer>}\n   */\n  arrayBuffer () {\n    return consume(this, 'arrayBuffer')\n  }\n\n  /**\n   * Not implemented\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-formdata\n   * @throws {NotSupportedError}\n   */\n  async formData () {\n    // TODO: Implement.\n    throw new NotSupportedError()\n  }\n\n  /**\n   * Returns true if the body is not null and the body has been consumed.\n   * Otherwise, returns false.\n   *\n   * @see https://fetch.spec.whatwg.org/#dom-body-bodyused\n   * @readonly\n   * @returns {boolean}\n   */\n  get bodyUsed () {\n    return util.isDisturbed(this)\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#dom-body-body\n   * @readonly\n   * @returns {ReadableStream}\n   */\n  get body () {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this)\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader() // Ensure stream is locked.\n        assert(this[kBody].locked)\n      }\n    }\n    return this[kBody]\n  }\n\n  /**\n   * Dumps the response body by reading `limit` number of bytes.\n   * @param {object} opts\n   * @param {number} [opts.limit = 131072] Number of bytes to read.\n   * @param {AbortSignal} [opts.signal] An AbortSignal to cancel the dump.\n   * @returns {Promise<null>}\n   */\n  async dump (opts) {\n    const signal = opts?.signal\n\n    if (signal != null && (typeof signal !== 'object' || !('aborted' in signal))) {\n      throw new InvalidArgumentError('signal must be an AbortSignal')\n    }\n\n    const limit = opts?.limit && Number.isFinite(opts.limit)\n      ? opts.limit\n      : 128 * 1024\n\n    signal?.throwIfAborted()\n\n    if (this._readableState.closeEmitted) {\n      return null\n    }\n\n    return await new Promise((resolve, reject) => {\n      if (\n        (this[kContentLength] && (this[kContentLength] > limit)) ||\n        this[kBytesRead] > limit\n      ) {\n        this.destroy(new AbortError())\n      }\n\n      if (signal) {\n        const onAbort = () => {\n          this.destroy(signal.reason ?? new AbortError())\n        }\n        signal.addEventListener('abort', onAbort)\n        this\n          .on('close', function () {\n            signal.removeEventListener('abort', onAbort)\n            if (signal.aborted) {\n              reject(signal.reason ?? new AbortError())\n            } else {\n              resolve(null)\n            }\n          })\n      } else {\n        this.on('close', resolve)\n      }\n\n      this\n        .on('error', noop)\n        .on('data', () => {\n          if (this[kBytesRead] > limit) {\n            this.destroy()\n          }\n        })\n        .resume()\n    })\n  }\n\n  /**\n   * @param {BufferEncoding} encoding\n   * @returns {this}\n   */\n  setEncoding (encoding) {\n    if (Buffer.isEncoding(encoding)) {\n      this._readableState.encoding = encoding\n    }\n    return this\n  }\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestream-locked\n * @param {BodyReadable} bodyReadable\n * @returns {boolean}\n */\nfunction isLocked (bodyReadable) {\n  // Consume is an implicit lock.\n  return bodyReadable[kBody]?.locked === true || bodyReadable[kConsume] !== null\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-unusable\n * @param {BodyReadable} bodyReadable\n * @returns {boolean}\n */\nfunction isUnusable (bodyReadable) {\n  return util.isDisturbed(bodyReadable) || isLocked(bodyReadable)\n}\n\n/**\n * @typedef {object} Consume\n * @property {string} type\n * @property {BodyReadable} stream\n * @property {((value?: any) => void)} resolve\n * @property {((err: Error) => void)} reject\n * @property {number} length\n * @property {Buffer[]} body\n */\n\n/**\n * @param {BodyReadable} stream\n * @param {string} type\n * @returns {Promise<any>}\n */\nfunction consume (stream, type) {\n  assert(!stream[kConsume])\n\n  return new Promise((resolve, reject) => {\n    if (isUnusable(stream)) {\n      const rState = stream._readableState\n      if (rState.destroyed && rState.closeEmitted === false) {\n        stream\n          .on('error', err => {\n            reject(err)\n          })\n          .on('close', () => {\n            reject(new TypeError('unusable'))\n          })\n      } else {\n        reject(rState.errored ?? new TypeError('unusable'))\n      }\n    } else {\n      queueMicrotask(() => {\n        stream[kConsume] = {\n          type,\n          stream,\n          resolve,\n          reject,\n          length: 0,\n          body: []\n        }\n\n        stream\n          .on('error', function (err) {\n            consumeFinish(this[kConsume], err)\n          })\n          .on('close', function () {\n            if (this[kConsume].body !== null) {\n              consumeFinish(this[kConsume], new RequestAbortedError())\n            }\n          })\n\n        consumeStart(stream[kConsume])\n      })\n    }\n  })\n}\n\n/**\n * @param {Consume} consume\n * @returns {void}\n */\nfunction consumeStart (consume) {\n  if (consume.body === null) {\n    return\n  }\n\n  const { _readableState: state } = consume.stream\n\n  if (state.bufferIndex) {\n    const start = state.bufferIndex\n    const end = state.buffer.length\n    for (let n = start; n < end; n++) {\n      consumePush(consume, state.buffer[n])\n    }\n  } else {\n    for (const chunk of state.buffer) {\n      consumePush(consume, chunk)\n    }\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume], this._readableState.encoding)\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume], this._readableState.encoding)\n    })\n  }\n\n  consume.stream.resume()\n\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\n\n/**\n * @param {Buffer[]} chunks\n * @param {number} length\n * @param {BufferEncoding} encoding\n * @returns {string}\n */\nfunction chunksDecode (chunks, length, encoding) {\n  if (chunks.length === 0 || length === 0) {\n    return ''\n  }\n  const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length)\n  const bufferLength = buffer.length\n\n  // Skip BOM.\n  const start =\n    bufferLength > 2 &&\n    buffer[0] === 0xef &&\n    buffer[1] === 0xbb &&\n    buffer[2] === 0xbf\n      ? 3\n      : 0\n  if (!encoding || encoding === 'utf8' || encoding === 'utf-8') {\n    return buffer.utf8Slice(start, bufferLength)\n  } else {\n    return buffer.subarray(start, bufferLength).toString(encoding)\n  }\n}\n\n/**\n * @param {Buffer[]} chunks\n * @param {number} length\n * @returns {Uint8Array}\n */\nfunction chunksConcat (chunks, length) {\n  if (chunks.length === 0 || length === 0) {\n    return new Uint8Array(0)\n  }\n  if (chunks.length === 1) {\n    // fast-path\n    return new Uint8Array(chunks[0])\n  }\n  const buffer = new Uint8Array(Buffer.allocUnsafeSlow(length).buffer)\n\n  let offset = 0\n  for (let i = 0; i < chunks.length; ++i) {\n    const chunk = chunks[i]\n    buffer.set(chunk, offset)\n    offset += chunk.length\n  }\n\n  return buffer\n}\n\n/**\n * @param {Consume} consume\n * @param {BufferEncoding} encoding\n * @returns {void}\n */\nfunction consumeEnd (consume, encoding) {\n  const { type, body, resolve, stream, length } = consume\n\n  try {\n    if (type === 'text') {\n      resolve(chunksDecode(body, length, encoding))\n    } else if (type === 'json') {\n      resolve(JSON.parse(chunksDecode(body, length, encoding)))\n    } else if (type === 'arrayBuffer') {\n      resolve(chunksConcat(body, length).buffer)\n    } else if (type === 'blob') {\n      resolve(new Blob(body, { type: stream[kContentType] }))\n    } else if (type === 'bytes') {\n      resolve(chunksConcat(body, length))\n    }\n\n    consumeFinish(consume)\n  } catch (err) {\n    stream.destroy(err)\n  }\n}\n\n/**\n * @param {Consume} consume\n * @param {Buffer} chunk\n * @returns {void}\n */\nfunction consumePush (consume, chunk) {\n  consume.length += chunk.length\n  consume.body.push(chunk)\n}\n\n/**\n * @param {Consume} consume\n * @param {Error} [err]\n * @returns {void}\n */\nfunction consumeFinish (consume, err) {\n  if (consume.body === null) {\n    return\n  }\n\n  if (err) {\n    consume.reject(err)\n  } else {\n    consume.resolve()\n  }\n\n  // Reset the consume object to allow for garbage collection.\n  consume.type = null\n  consume.stream = null\n  consume.resolve = null\n  consume.reject = null\n  consume.length = 0\n  consume.body = null\n}\n\nmodule.exports = {\n  Readable: BodyReadable,\n  chunksDecode\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvcmVhZGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDMUMsUUFBUSwyRUFBMkUsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUM3RyxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLGtFQUFjOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSx3Q0FBd0M7QUFDckQsYUFBYSxxQkFBcUI7QUFDbEMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsOEJBQThCO0FBQzNDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsMEJBQTBCO0FBQ3ZDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsMEJBQTBCO0FBQ3ZDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLDBCQUEwQjtBQUN2QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLDBCQUEwQjtBQUN2QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGFBQWE7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLGFBQWE7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL3JlYWRhYmxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL3B1bGwvOTA3XG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IFJlYWRhYmxlIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7IFJlcXVlc3RBYm9ydGVkRXJyb3IsIE5vdFN1cHBvcnRlZEVycm9yLCBJbnZhbGlkQXJndW1lbnRFcnJvciwgQWJvcnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IFJlYWRhYmxlU3RyZWFtRnJvbSB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxuY29uc3Qga0NvbnN1bWUgPSBTeW1ib2woJ2tDb25zdW1lJylcbmNvbnN0IGtSZWFkaW5nID0gU3ltYm9sKCdrUmVhZGluZycpXG5jb25zdCBrQm9keSA9IFN5bWJvbCgna0JvZHknKVxuY29uc3Qga0Fib3J0ID0gU3ltYm9sKCdrQWJvcnQnKVxuY29uc3Qga0NvbnRlbnRUeXBlID0gU3ltYm9sKCdrQ29udGVudFR5cGUnKVxuY29uc3Qga0NvbnRlbnRMZW5ndGggPSBTeW1ib2woJ2tDb250ZW50TGVuZ3RoJylcbmNvbnN0IGtVc2VkID0gU3ltYm9sKCdrVXNlZCcpXG5jb25zdCBrQnl0ZXNSZWFkID0gU3ltYm9sKCdrQnl0ZXNSZWFkJylcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyB7UmVhZGFibGV9XG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5XG4gKi9cbmNsYXNzIEJvZHlSZWFkYWJsZSBleHRlbmRzIFJlYWRhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAqIEBwYXJhbSB7KHRoaXM6IFJlYWRhYmxlLCBzaXplOiBudW1iZXIpID0+IHZvaWR9IG9wdHMucmVzdW1lXG4gICAqIEBwYXJhbSB7KCkgPT4gKHZvaWQgfCBudWxsKX0gb3B0cy5hYm9ydFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udGVudFR5cGUgPSAnJ11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmNvbnRlbnRMZW5ndGhdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oaWdoV2F0ZXJNYXJrID0gNjQgKiAxMDI0XVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHtcbiAgICByZXN1bWUsXG4gICAgYWJvcnQsXG4gICAgY29udGVudFR5cGUgPSAnJyxcbiAgICBjb250ZW50TGVuZ3RoLFxuICAgIGhpZ2hXYXRlck1hcmsgPSA2NCAqIDEwMjQgLy8gU2FtZSBhcyBub2RlanMgZnMgc3RyZWFtcy5cbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGF1dG9EZXN0cm95OiB0cnVlLFxuICAgICAgcmVhZDogcmVzdW1lLFxuICAgICAgaGlnaFdhdGVyTWFya1xuICAgIH0pXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRhdGFFbWl0dGVkID0gZmFsc2VcblxuICAgIHRoaXNba0Fib3J0XSA9IGFib3J0XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q29uc3VtZSB8IG51bGx9XG4gICAgICovXG4gICAgdGhpc1trQ29uc3VtZV0gPSBudWxsXG4gICAgdGhpc1trQnl0ZXNSZWFkXSA9IDBcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UmVhZGFibGVTdHJlYW18bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzW2tCb2R5XSA9IG51bGxcbiAgICB0aGlzW2tVc2VkXSA9IGZhbHNlXG4gICAgdGhpc1trQ29udGVudFR5cGVdID0gY29udGVudFR5cGVcbiAgICB0aGlzW2tDb250ZW50TGVuZ3RoXSA9IE51bWJlci5pc0Zpbml0ZShjb250ZW50TGVuZ3RoKSA/IGNvbnRlbnRMZW5ndGggOiBudWxsXG5cbiAgICAvLyBJcyBzdHJlYW0gYmVpbmcgY29uc3VtZWQgdGhyb3VnaCBSZWFkYWJsZSBBUEk/XG4gICAgLy8gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gc28gdGhhdCB3ZSBhdm9pZCBjaGVja2luZ1xuICAgIC8vIGZvciAnZGF0YScgYW5kICdyZWFkYWJsZScgbGlzdGVuZXJzIGluIHRoZSBob3QgcGF0aFxuICAgIC8vIGluc2lkZSBwdXNoKCkuXG4gICAgdGhpc1trUmVhZGluZ10gPSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyXG4gICAqIEBwYXJhbSB7KGVycm9yOihFcnJvcnxudWxsKSkgPT4gdm9pZH0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfZGVzdHJveSAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICghZXJyICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgIGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICB9XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aGlzW2tBYm9ydF0oKVxuICAgIH1cblxuICAgIC8vIFdvcmthcm91bmQgZm9yIE5vZGUgXCJidWdcIi4gSWYgdGhlIHN0cmVhbSBpcyBkZXN0cm95ZWQgaW4gc2FtZVxuICAgIC8vIHRpY2sgYXMgaXQgaXMgY3JlYXRlZCwgdGhlbiBhIHVzZXIgd2hvIGlzIHdhaXRpbmcgZm9yIGFcbiAgICAvLyBwcm9taXNlIChpLmUgbWljcm8gdGljaykgZm9yIGluc3RhbGxpbmcgYW4gJ2Vycm9yJyBsaXN0ZW5lciB3aWxsXG4gICAgLy8gbmV2ZXIgZ2V0IGEgY2hhbmNlIGFuZCB3aWxsIGFsd2F5cyBlbmNvdW50ZXIgYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICBpZiAoIXRoaXNba1VzZWRdKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0geyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gbGlzdGVuZXJcbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuICBvbiAoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKGV2ZW50ID09PSAnZGF0YScgfHwgZXZlbnQgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgIHRoaXNba1JlYWRpbmddID0gdHJ1ZVxuICAgICAgdGhpc1trVXNlZF0gPSB0cnVlXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5vbihldmVudCwgbGlzdGVuZXIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBsaXN0ZW5lclxuICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICovXG4gIGFkZExpc3RlbmVyIChldmVudCwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudCwgbGlzdGVuZXIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8c3ltYm9sfSBldmVudFxuICAgKiBAcGFyYW0geyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gbGlzdGVuZXJcbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuICBvZmYgKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHJldCA9IHN1cGVyLm9mZihldmVudCwgbGlzdGVuZXIpXG4gICAgaWYgKGV2ZW50ID09PSAnZGF0YScgfHwgZXZlbnQgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgIHRoaXNba1JlYWRpbmddID0gKFxuICAgICAgICB0aGlzLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDAgfHxcbiAgICAgICAgdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMFxuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8c3ltYm9sfSBldmVudFxuICAgKiBAcGFyYW0geyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gbGlzdGVuZXJcbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuICByZW1vdmVMaXN0ZW5lciAoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50LCBsaXN0ZW5lcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcnxudWxsfSBjaHVua1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHB1c2ggKGNodW5rKSB7XG4gICAgdGhpc1trQnl0ZXNSZWFkXSArPSBjaHVuayA/IGNodW5rLmxlbmd0aCA6IDBcblxuICAgIGlmICh0aGlzW2tDb25zdW1lXSAmJiBjaHVuayAhPT0gbnVsbCkge1xuICAgICAgY29uc3VtZVB1c2godGhpc1trQ29uc3VtZV0sIGNodW5rKVxuICAgICAgcmV0dXJuIHRoaXNba1JlYWRpbmddID8gc3VwZXIucHVzaChjaHVuaykgOiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wdXNoKGNodW5rKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnN1bWVzIGFuZCByZXR1cm5zIHRoZSBib2R5IGFzIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS10ZXh0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59XG4gICAqL1xuICB0ZXh0ICgpIHtcbiAgICByZXR1cm4gY29uc3VtZSh0aGlzLCAndGV4dCcpXG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZXMgYW5kIHJldHVybnMgdGhlIGJvZHkgYXMgYSBKYXZhU2NyaXB0IE9iamVjdC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktanNvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duPn1cbiAgICovXG4gIGpzb24gKCkge1xuICAgIHJldHVybiBjb25zdW1lKHRoaXMsICdqc29uJylcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lcyBhbmQgcmV0dXJucyB0aGUgYm9keSBhcyBhIEJsb2JcbiAgICpcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktYmxvYlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCbG9iPn1cbiAgICovXG4gIGJsb2IgKCkge1xuICAgIHJldHVybiBjb25zdW1lKHRoaXMsICdibG9iJylcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lcyBhbmQgcmV0dXJucyB0aGUgYm9keSBhcyBhbiBVaW50OEFycmF5LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1ieXRlc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVaW50OEFycmF5Pn1cbiAgICovXG4gIGJ5dGVzICgpIHtcbiAgICByZXR1cm4gY29uc3VtZSh0aGlzLCAnYnl0ZXMnKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnN1bWVzIGFuZCByZXR1cm5zIHRoZSBib2R5IGFzIGFuIEFycmF5QnVmZmVyLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1hcnJheWJ1ZmZlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheUJ1ZmZlcj59XG4gICAqL1xuICBhcnJheUJ1ZmZlciAoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWUodGhpcywgJ2FycmF5QnVmZmVyJylcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3QgaW1wbGVtZW50ZWRcbiAgICpcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktZm9ybWRhdGFcbiAgICogQHRocm93cyB7Tm90U3VwcG9ydGVkRXJyb3J9XG4gICAqL1xuICBhc3luYyBmb3JtRGF0YSAoKSB7XG4gICAgLy8gVE9ETzogSW1wbGVtZW50LlxuICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcigpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBib2R5IGlzIG5vdCBudWxsIGFuZCB0aGUgYm9keSBoYXMgYmVlbiBjb25zdW1lZC5cbiAgICogT3RoZXJ3aXNlLCByZXR1cm5zIGZhbHNlLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1ib2R5dXNlZFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgYm9keVVzZWQgKCkge1xuICAgIHJldHVybiB1dGlsLmlzRGlzdHVyYmVkKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktYm9keVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtfVxuICAgKi9cbiAgZ2V0IGJvZHkgKCkge1xuICAgIGlmICghdGhpc1trQm9keV0pIHtcbiAgICAgIHRoaXNba0JvZHldID0gUmVhZGFibGVTdHJlYW1Gcm9tKHRoaXMpXG4gICAgICBpZiAodGhpc1trQ29uc3VtZV0pIHtcbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyB0aGUgYmVzdCB3YXkgdG8gZm9yY2UgYSBsb2NrP1xuICAgICAgICB0aGlzW2tCb2R5XS5nZXRSZWFkZXIoKSAvLyBFbnN1cmUgc3RyZWFtIGlzIGxvY2tlZC5cbiAgICAgICAgYXNzZXJ0KHRoaXNba0JvZHldLmxvY2tlZClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNba0JvZHldXG4gIH1cblxuICAvKipcbiAgICogRHVtcHMgdGhlIHJlc3BvbnNlIGJvZHkgYnkgcmVhZGluZyBgbGltaXRgIG51bWJlciBvZiBieXRlcy5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmxpbWl0ID0gMTMxMDcyXSBOdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW29wdHMuc2lnbmFsXSBBbiBBYm9ydFNpZ25hbCB0byBjYW5jZWwgdGhlIGR1bXAuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bGw+fVxuICAgKi9cbiAgYXN5bmMgZHVtcCAob3B0cykge1xuICAgIGNvbnN0IHNpZ25hbCA9IG9wdHM/LnNpZ25hbFxuXG4gICAgaWYgKHNpZ25hbCAhPSBudWxsICYmICh0eXBlb2Ygc2lnbmFsICE9PSAnb2JqZWN0JyB8fCAhKCdhYm9ydGVkJyBpbiBzaWduYWwpKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBBYm9ydFNpZ25hbCcpXG4gICAgfVxuXG4gICAgY29uc3QgbGltaXQgPSBvcHRzPy5saW1pdCAmJiBOdW1iZXIuaXNGaW5pdGUob3B0cy5saW1pdClcbiAgICAgID8gb3B0cy5saW1pdFxuICAgICAgOiAxMjggKiAxMDI0XG5cbiAgICBzaWduYWw/LnRocm93SWZBYm9ydGVkKClcblxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmNsb3NlRW1pdHRlZCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAodGhpc1trQ29udGVudExlbmd0aF0gJiYgKHRoaXNba0NvbnRlbnRMZW5ndGhdID4gbGltaXQpKSB8fFxuICAgICAgICB0aGlzW2tCeXRlc1JlYWRdID4gbGltaXRcbiAgICAgICkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kobmV3IEFib3J0RXJyb3IoKSlcbiAgICAgIH1cblxuICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICBjb25zdCBvbkFib3J0ID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZGVzdHJveShzaWduYWwucmVhc29uID8/IG5ldyBBYm9ydEVycm9yKCkpXG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25BYm9ydClcbiAgICAgICAgdGhpc1xuICAgICAgICAgIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkFib3J0KVxuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgIHJlamVjdChzaWduYWwucmVhc29uID8/IG5ldyBBYm9ydEVycm9yKCkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKG51bGwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub24oJ2Nsb3NlJywgcmVzb2x2ZSlcbiAgICAgIH1cblxuICAgICAgdGhpc1xuICAgICAgICAub24oJ2Vycm9yJywgbm9vcClcbiAgICAgICAgLm9uKCdkYXRhJywgKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzW2tCeXRlc1JlYWRdID4gbGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAucmVzdW1lKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyRW5jb2Rpbmd9IGVuY29kaW5nXG4gICAqIEByZXR1cm5zIHt0aGlzfVxuICAgKi9cbiAgc2V0RW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuY29kaW5nXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vc3RyZWFtcy5zcGVjLndoYXR3Zy5vcmcvI3JlYWRhYmxlc3RyZWFtLWxvY2tlZFxuICogQHBhcmFtIHtCb2R5UmVhZGFibGV9IGJvZHlSZWFkYWJsZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTG9ja2VkIChib2R5UmVhZGFibGUpIHtcbiAgLy8gQ29uc3VtZSBpcyBhbiBpbXBsaWNpdCBsb2NrLlxuICByZXR1cm4gYm9keVJlYWRhYmxlW2tCb2R5XT8ubG9ja2VkID09PSB0cnVlIHx8IGJvZHlSZWFkYWJsZVtrQ29uc3VtZV0gIT09IG51bGxcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5LXVudXNhYmxlXG4gKiBAcGFyYW0ge0JvZHlSZWFkYWJsZX0gYm9keVJlYWRhYmxlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNVbnVzYWJsZSAoYm9keVJlYWRhYmxlKSB7XG4gIHJldHVybiB1dGlsLmlzRGlzdHVyYmVkKGJvZHlSZWFkYWJsZSkgfHwgaXNMb2NrZWQoYm9keVJlYWRhYmxlKVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IENvbnN1bWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlXG4gKiBAcHJvcGVydHkge0JvZHlSZWFkYWJsZX0gc3RyZWFtXG4gKiBAcHJvcGVydHkgeygodmFsdWU/OiBhbnkpID0+IHZvaWQpfSByZXNvbHZlXG4gKiBAcHJvcGVydHkgeygoZXJyOiBFcnJvcikgPT4gdm9pZCl9IHJlamVjdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlbmd0aFxuICogQHByb3BlcnR5IHtCdWZmZXJbXX0gYm9keVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtCb2R5UmVhZGFibGV9IHN0cmVhbVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWUgKHN0cmVhbSwgdHlwZSkge1xuICBhc3NlcnQoIXN0cmVhbVtrQ29uc3VtZV0pXG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAoaXNVbnVzYWJsZShzdHJlYW0pKSB7XG4gICAgICBjb25zdCByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgICAgIGlmIChyU3RhdGUuZGVzdHJveWVkICYmIHJTdGF0ZS5jbG9zZUVtaXR0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHN0cmVhbVxuICAgICAgICAgIC5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcigndW51c2FibGUnKSlcbiAgICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KHJTdGF0ZS5lcnJvcmVkID8/IG5ldyBUeXBlRXJyb3IoJ3VudXNhYmxlJykpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgc3RyZWFtW2tDb25zdW1lXSA9IHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgICAgYm9keTogW11cbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmVhbVxuICAgICAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdW1lRmluaXNoKHRoaXNba0NvbnN1bWVdLCBlcnIpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXNba0NvbnN1bWVdLmJvZHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3VtZUZpbmlzaCh0aGlzW2tDb25zdW1lXSwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN1bWVTdGFydChzdHJlYW1ba0NvbnN1bWVdKVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtDb25zdW1lfSBjb25zdW1lXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gY29uc3VtZVN0YXJ0IChjb25zdW1lKSB7XG4gIGlmIChjb25zdW1lLmJvZHkgPT09IG51bGwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHsgX3JlYWRhYmxlU3RhdGU6IHN0YXRlIH0gPSBjb25zdW1lLnN0cmVhbVxuXG4gIGlmIChzdGF0ZS5idWZmZXJJbmRleCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGUuYnVmZmVySW5kZXhcbiAgICBjb25zdCBlbmQgPSBzdGF0ZS5idWZmZXIubGVuZ3RoXG4gICAgZm9yIChsZXQgbiA9IHN0YXJ0OyBuIDwgZW5kOyBuKyspIHtcbiAgICAgIGNvbnN1bWVQdXNoKGNvbnN1bWUsIHN0YXRlLmJ1ZmZlcltuXSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBjaHVuayBvZiBzdGF0ZS5idWZmZXIpIHtcbiAgICAgIGNvbnN1bWVQdXNoKGNvbnN1bWUsIGNodW5rKVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgY29uc3VtZUVuZCh0aGlzW2tDb25zdW1lXSwgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZylcbiAgfSBlbHNlIHtcbiAgICBjb25zdW1lLnN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3VtZUVuZCh0aGlzW2tDb25zdW1lXSwgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZylcbiAgICB9KVxuICB9XG5cbiAgY29uc3VtZS5zdHJlYW0ucmVzdW1lKClcblxuICB3aGlsZSAoY29uc3VtZS5zdHJlYW0ucmVhZCgpICE9IG51bGwpIHtcbiAgICAvLyBMb29wXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcltdfSBjaHVua3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEBwYXJhbSB7QnVmZmVyRW5jb2Rpbmd9IGVuY29kaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjaHVua3NEZWNvZGUgKGNodW5rcywgbGVuZ3RoLCBlbmNvZGluZykge1xuICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMCB8fCBsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuICBjb25zdCBidWZmZXIgPSBjaHVua3MubGVuZ3RoID09PSAxID8gY2h1bmtzWzBdIDogQnVmZmVyLmNvbmNhdChjaHVua3MsIGxlbmd0aClcbiAgY29uc3QgYnVmZmVyTGVuZ3RoID0gYnVmZmVyLmxlbmd0aFxuXG4gIC8vIFNraXAgQk9NLlxuICBjb25zdCBzdGFydCA9XG4gICAgYnVmZmVyTGVuZ3RoID4gMiAmJlxuICAgIGJ1ZmZlclswXSA9PT0gMHhlZiAmJlxuICAgIGJ1ZmZlclsxXSA9PT0gMHhiYiAmJlxuICAgIGJ1ZmZlclsyXSA9PT0gMHhiZlxuICAgICAgPyAzXG4gICAgICA6IDBcbiAgaWYgKCFlbmNvZGluZyB8fCBlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci51dGY4U2xpY2Uoc3RhcnQsIGJ1ZmZlckxlbmd0aClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmZmVyLnN1YmFycmF5KHN0YXJ0LCBidWZmZXJMZW5ndGgpLnRvU3RyaW5nKGVuY29kaW5nKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJbXX0gY2h1bmtzXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gY2h1bmtzQ29uY2F0IChjaHVua3MsIGxlbmd0aCkge1xuICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMCB8fCBsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMClcbiAgfVxuICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIGZhc3QtcGF0aFxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjaHVua3NbMF0pXG4gIH1cbiAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyhsZW5ndGgpLmJ1ZmZlcilcblxuICBsZXQgb2Zmc2V0ID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNodW5rID0gY2h1bmtzW2ldXG4gICAgYnVmZmVyLnNldChjaHVuaywgb2Zmc2V0KVxuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBidWZmZXJcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbnN1bWV9IGNvbnN1bWVcbiAqIEBwYXJhbSB7QnVmZmVyRW5jb2Rpbmd9IGVuY29kaW5nXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gY29uc3VtZUVuZCAoY29uc3VtZSwgZW5jb2RpbmcpIHtcbiAgY29uc3QgeyB0eXBlLCBib2R5LCByZXNvbHZlLCBzdHJlYW0sIGxlbmd0aCB9ID0gY29uc3VtZVxuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgcmVzb2x2ZShjaHVua3NEZWNvZGUoYm9keSwgbGVuZ3RoLCBlbmNvZGluZykpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnanNvbicpIHtcbiAgICAgIHJlc29sdmUoSlNPTi5wYXJzZShjaHVua3NEZWNvZGUoYm9keSwgbGVuZ3RoLCBlbmNvZGluZykpKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2FycmF5QnVmZmVyJykge1xuICAgICAgcmVzb2x2ZShjaHVua3NDb25jYXQoYm9keSwgbGVuZ3RoKS5idWZmZXIpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYmxvYicpIHtcbiAgICAgIHJlc29sdmUobmV3IEJsb2IoYm9keSwgeyB0eXBlOiBzdHJlYW1ba0NvbnRlbnRUeXBlXSB9KSlcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgIHJlc29sdmUoY2h1bmtzQ29uY2F0KGJvZHksIGxlbmd0aCkpXG4gICAgfVxuXG4gICAgY29uc3VtZUZpbmlzaChjb25zdW1lKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbnN1bWV9IGNvbnN1bWVcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVua1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVQdXNoIChjb25zdW1lLCBjaHVuaykge1xuICBjb25zdW1lLmxlbmd0aCArPSBjaHVuay5sZW5ndGhcbiAgY29uc3VtZS5ib2R5LnB1c2goY2h1bmspXG59XG5cbi8qKlxuICogQHBhcmFtIHtDb25zdW1lfSBjb25zdW1lXG4gKiBAcGFyYW0ge0Vycm9yfSBbZXJyXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVGaW5pc2ggKGNvbnN1bWUsIGVycikge1xuICBpZiAoY29uc3VtZS5ib2R5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoZXJyKSB7XG4gICAgY29uc3VtZS5yZWplY3QoZXJyKVxuICB9IGVsc2Uge1xuICAgIGNvbnN1bWUucmVzb2x2ZSgpXG4gIH1cblxuICAvLyBSZXNldCB0aGUgY29uc3VtZSBvYmplY3QgdG8gYWxsb3cgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgY29uc3VtZS50eXBlID0gbnVsbFxuICBjb25zdW1lLnN0cmVhbSA9IG51bGxcbiAgY29uc3VtZS5yZXNvbHZlID0gbnVsbFxuICBjb25zdW1lLnJlamVjdCA9IG51bGxcbiAgY29uc3VtZS5sZW5ndGggPSAwXG4gIGNvbnN1bWUuYm9keSA9IG51bGxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJlYWRhYmxlOiBCb2R5UmVhZGFibGUsXG4gIGNodW5rc0RlY29kZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/readable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/cache/memory-cache-store.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/cache/memory-cache-store.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Writable } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { EventEmitter } = __webpack_require__(/*! node:events */ \"node:events\")\nconst { assertCacheKey, assertCacheValue } = __webpack_require__(/*! ../util/cache.js */ \"(rsc)/./node_modules/undici/lib/util/cache.js\")\n\n/**\n * @typedef {import('../../types/cache-interceptor.d.ts').default.CacheKey} CacheKey\n * @typedef {import('../../types/cache-interceptor.d.ts').default.CacheValue} CacheValue\n * @typedef {import('../../types/cache-interceptor.d.ts').default.CacheStore} CacheStore\n * @typedef {import('../../types/cache-interceptor.d.ts').default.GetResult} GetResult\n */\n\n/**\n * @implements {CacheStore}\n * @extends {EventEmitter}\n */\nclass MemoryCacheStore extends EventEmitter {\n  #maxCount = 1024\n  #maxSize = 104857600 // 100MB\n  #maxEntrySize = 5242880 // 5MB\n\n  #size = 0\n  #count = 0\n  #entries = new Map()\n  #hasEmittedMaxSizeEvent = false\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.MemoryCacheStoreOpts | undefined} [opts]\n   */\n  constructor (opts) {\n    super()\n    if (opts) {\n      if (typeof opts !== 'object') {\n        throw new TypeError('MemoryCacheStore options must be an object')\n      }\n\n      if (opts.maxCount !== undefined) {\n        if (\n          typeof opts.maxCount !== 'number' ||\n          !Number.isInteger(opts.maxCount) ||\n          opts.maxCount < 0\n        ) {\n          throw new TypeError('MemoryCacheStore options.maxCount must be a non-negative integer')\n        }\n        this.#maxCount = opts.maxCount\n      }\n\n      if (opts.maxSize !== undefined) {\n        if (\n          typeof opts.maxSize !== 'number' ||\n          !Number.isInteger(opts.maxSize) ||\n          opts.maxSize < 0\n        ) {\n          throw new TypeError('MemoryCacheStore options.maxSize must be a non-negative integer')\n        }\n        this.#maxSize = opts.maxSize\n      }\n\n      if (opts.maxEntrySize !== undefined) {\n        if (\n          typeof opts.maxEntrySize !== 'number' ||\n          !Number.isInteger(opts.maxEntrySize) ||\n          opts.maxEntrySize < 0\n        ) {\n          throw new TypeError('MemoryCacheStore options.maxEntrySize must be a non-negative integer')\n        }\n        this.#maxEntrySize = opts.maxEntrySize\n      }\n    }\n  }\n\n  /**\n   * Get the current size of the cache in bytes\n   * @returns {number} The current size of the cache in bytes\n   */\n  get size () {\n    return this.#size\n  }\n\n  /**\n   * Check if the cache is full (either max size or max count reached)\n   * @returns {boolean} True if the cache is full, false otherwise\n   */\n  isFull () {\n    return this.#size >= this.#maxSize || this.#count >= this.#maxCount\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} req\n   * @returns {import('../../types/cache-interceptor.d.ts').default.GetResult | undefined}\n   */\n  get (key) {\n    assertCacheKey(key)\n\n    const topLevelKey = `${key.origin}:${key.path}`\n\n    const now = Date.now()\n    const entries = this.#entries.get(topLevelKey)\n\n    const entry = entries ? findEntry(key, entries, now) : null\n\n    return entry == null\n      ? undefined\n      : {\n          statusMessage: entry.statusMessage,\n          statusCode: entry.statusCode,\n          headers: entry.headers,\n          body: entry.body,\n          vary: entry.vary ? entry.vary : undefined,\n          etag: entry.etag,\n          cacheControlDirectives: entry.cacheControlDirectives,\n          cachedAt: entry.cachedAt,\n          staleAt: entry.staleAt,\n          deleteAt: entry.deleteAt\n        }\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue} val\n   * @returns {Writable | undefined}\n   */\n  createWriteStream (key, val) {\n    assertCacheKey(key)\n    assertCacheValue(val)\n\n    const topLevelKey = `${key.origin}:${key.path}`\n\n    const store = this\n    const entry = { ...key, ...val, body: [], size: 0 }\n\n    return new Writable({\n      write (chunk, encoding, callback) {\n        if (typeof chunk === 'string') {\n          chunk = Buffer.from(chunk, encoding)\n        }\n\n        entry.size += chunk.byteLength\n\n        if (entry.size >= store.#maxEntrySize) {\n          this.destroy()\n        } else {\n          entry.body.push(chunk)\n        }\n\n        callback(null)\n      },\n      final (callback) {\n        let entries = store.#entries.get(topLevelKey)\n        if (!entries) {\n          entries = []\n          store.#entries.set(topLevelKey, entries)\n        }\n        const previousEntry = findEntry(key, entries, Date.now())\n        if (previousEntry) {\n          const index = entries.indexOf(previousEntry)\n          entries.splice(index, 1, entry)\n          store.#size -= previousEntry.size\n        } else {\n          entries.push(entry)\n          store.#count += 1\n        }\n\n        store.#size += entry.size\n\n        // Check if cache is full and emit event if needed\n        if (store.#size > store.#maxSize || store.#count > store.#maxCount) {\n          // Emit maxSizeExceeded event if we haven't already\n          if (!store.#hasEmittedMaxSizeEvent) {\n            store.emit('maxSizeExceeded', {\n              size: store.#size,\n              maxSize: store.#maxSize,\n              count: store.#count,\n              maxCount: store.#maxCount\n            })\n            store.#hasEmittedMaxSizeEvent = true\n          }\n\n          // Perform eviction\n          for (const [key, entries] of store.#entries) {\n            for (const entry of entries.splice(0, entries.length / 2)) {\n              store.#size -= entry.size\n              store.#count -= 1\n            }\n            if (entries.length === 0) {\n              store.#entries.delete(key)\n            }\n          }\n\n          // Reset the event flag after eviction\n          if (store.#size < store.#maxSize && store.#count < store.#maxCount) {\n            store.#hasEmittedMaxSizeEvent = false\n          }\n        }\n\n        callback(null)\n      }\n    })\n  }\n\n  /**\n   * @param {CacheKey} key\n   */\n  delete (key) {\n    if (typeof key !== 'object') {\n      throw new TypeError(`expected key to be object, got ${typeof key}`)\n    }\n\n    const topLevelKey = `${key.origin}:${key.path}`\n\n    for (const entry of this.#entries.get(topLevelKey) ?? []) {\n      this.#size -= entry.size\n      this.#count -= 1\n    }\n    this.#entries.delete(topLevelKey)\n  }\n}\n\nfunction findEntry (key, entries, now) {\n  return entries.find((entry) => (\n    entry.deleteAt > now &&\n    entry.method === key.method &&\n    (entry.vary == null || Object.keys(entry.vary).every(headerName => {\n      if (entry.vary[headerName] === null) {\n        return key.headers[headerName] === undefined\n      }\n\n      return entry.vary[headerName] === key.headers[headerName]\n    }))\n  ))\n}\n\nmodule.exports = MemoryCacheStore\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS9tZW1vcnktY2FjaGUtc3RvcmUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQzlDLFFBQVEsbUNBQW1DLEVBQUUsbUJBQU8sQ0FBQyx1RUFBa0I7O0FBRXZFO0FBQ0EsYUFBYSwrREFBK0Q7QUFDNUUsYUFBYSxpRUFBaUU7QUFDOUUsYUFBYSxpRUFBaUU7QUFDOUUsYUFBYSxnRUFBZ0U7QUFDN0U7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHVGQUF1RjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSwrREFBK0Q7QUFDNUUsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsV0FBVyxHQUFHLFNBQVM7O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSwrREFBK0Q7QUFDNUUsYUFBYSxpRUFBaUU7QUFDOUUsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixXQUFXLEdBQUcsU0FBUzs7QUFFbEQ7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsV0FBVztBQUN2RTs7QUFFQSwyQkFBMkIsV0FBVyxHQUFHLFNBQVM7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS9tZW1vcnktY2FjaGUtc3RvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgV3JpdGFibGUgfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSByZXF1aXJlKCdub2RlOmV2ZW50cycpXG5jb25zdCB7IGFzc2VydENhY2hlS2V5LCBhc3NlcnRDYWNoZVZhbHVlIH0gPSByZXF1aXJlKCcuLi91dGlsL2NhY2hlLmpzJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZUtleX0gQ2FjaGVLZXlcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlVmFsdWV9IENhY2hlVmFsdWVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlU3RvcmV9IENhY2hlU3RvcmVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkdldFJlc3VsdH0gR2V0UmVzdWx0XG4gKi9cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7Q2FjaGVTdG9yZX1cbiAqIEBleHRlbmRzIHtFdmVudEVtaXR0ZXJ9XG4gKi9cbmNsYXNzIE1lbW9yeUNhY2hlU3RvcmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAjbWF4Q291bnQgPSAxMDI0XG4gICNtYXhTaXplID0gMTA0ODU3NjAwIC8vIDEwME1CXG4gICNtYXhFbnRyeVNpemUgPSA1MjQyODgwIC8vIDVNQlxuXG4gICNzaXplID0gMFxuICAjY291bnQgPSAwXG4gICNlbnRyaWVzID0gbmV3IE1hcCgpXG4gICNoYXNFbWl0dGVkTWF4U2l6ZUV2ZW50ID0gZmFsc2VcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0Lk1lbW9yeUNhY2hlU3RvcmVPcHRzIHwgdW5kZWZpbmVkfSBbb3B0c11cbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIoKVxuICAgIGlmIChvcHRzKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01lbW9yeUNhY2hlU3RvcmUgb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLm1heENvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiBvcHRzLm1heENvdW50ICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKG9wdHMubWF4Q291bnQpIHx8XG4gICAgICAgICAgb3B0cy5tYXhDb3VudCA8IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWVtb3J5Q2FjaGVTdG9yZSBvcHRpb25zLm1heENvdW50IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcicpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWF4Q291bnQgPSBvcHRzLm1heENvdW50XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLm1heFNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIG9wdHMubWF4U2l6ZSAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihvcHRzLm1heFNpemUpIHx8XG4gICAgICAgICAgb3B0cy5tYXhTaXplIDwgMFxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNZW1vcnlDYWNoZVN0b3JlIG9wdGlvbnMubWF4U2l6ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21heFNpemUgPSBvcHRzLm1heFNpemVcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMubWF4RW50cnlTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiBvcHRzLm1heEVudHJ5U2l6ZSAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihvcHRzLm1heEVudHJ5U2l6ZSkgfHxcbiAgICAgICAgICBvcHRzLm1heEVudHJ5U2l6ZSA8IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWVtb3J5Q2FjaGVTdG9yZSBvcHRpb25zLm1heEVudHJ5U2l6ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21heEVudHJ5U2l6ZSA9IG9wdHMubWF4RW50cnlTaXplXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBjYWNoZSBpbiBieXRlc1xuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY3VycmVudCBzaXplIG9mIHRoZSBjYWNoZSBpbiBieXRlc1xuICAgKi9cbiAgZ2V0IHNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLiNzaXplXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGNhY2hlIGlzIGZ1bGwgKGVpdGhlciBtYXggc2l6ZSBvciBtYXggY291bnQgcmVhY2hlZClcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNhY2hlIGlzIGZ1bGwsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgaXNGdWxsICgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2l6ZSA+PSB0aGlzLiNtYXhTaXplIHx8IHRoaXMuI2NvdW50ID49IHRoaXMuI21heENvdW50XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlS2V5fSByZXFcbiAgICogQHJldHVybnMge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuR2V0UmVzdWx0IHwgdW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0IChrZXkpIHtcbiAgICBhc3NlcnRDYWNoZUtleShrZXkpXG5cbiAgICBjb25zdCB0b3BMZXZlbEtleSA9IGAke2tleS5vcmlnaW59OiR7a2V5LnBhdGh9YFxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIGNvbnN0IGVudHJpZXMgPSB0aGlzLiNlbnRyaWVzLmdldCh0b3BMZXZlbEtleSlcblxuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllcyA/IGZpbmRFbnRyeShrZXksIGVudHJpZXMsIG5vdykgOiBudWxsXG5cbiAgICByZXR1cm4gZW50cnkgPT0gbnVsbFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDoge1xuICAgICAgICAgIHN0YXR1c01lc3NhZ2U6IGVudHJ5LnN0YXR1c01lc3NhZ2UsXG4gICAgICAgICAgc3RhdHVzQ29kZTogZW50cnkuc3RhdHVzQ29kZSxcbiAgICAgICAgICBoZWFkZXJzOiBlbnRyeS5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IGVudHJ5LmJvZHksXG4gICAgICAgICAgdmFyeTogZW50cnkudmFyeSA/IGVudHJ5LnZhcnkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgZXRhZzogZW50cnkuZXRhZyxcbiAgICAgICAgICBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzOiBlbnRyeS5jYWNoZUNvbnRyb2xEaXJlY3RpdmVzLFxuICAgICAgICAgIGNhY2hlZEF0OiBlbnRyeS5jYWNoZWRBdCxcbiAgICAgICAgICBzdGFsZUF0OiBlbnRyeS5zdGFsZUF0LFxuICAgICAgICAgIGRlbGV0ZUF0OiBlbnRyeS5kZWxldGVBdFxuICAgICAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlS2V5fSBrZXlcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlVmFsdWV9IHZhbFxuICAgKiBAcmV0dXJucyB7V3JpdGFibGUgfCB1bmRlZmluZWR9XG4gICAqL1xuICBjcmVhdGVXcml0ZVN0cmVhbSAoa2V5LCB2YWwpIHtcbiAgICBhc3NlcnRDYWNoZUtleShrZXkpXG4gICAgYXNzZXJ0Q2FjaGVWYWx1ZSh2YWwpXG5cbiAgICBjb25zdCB0b3BMZXZlbEtleSA9IGAke2tleS5vcmlnaW59OiR7a2V5LnBhdGh9YFxuXG4gICAgY29uc3Qgc3RvcmUgPSB0aGlzXG4gICAgY29uc3QgZW50cnkgPSB7IC4uLmtleSwgLi4udmFsLCBib2R5OiBbXSwgc2l6ZTogMCB9XG5cbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKHtcbiAgICAgIHdyaXRlIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpXG4gICAgICAgIH1cblxuICAgICAgICBlbnRyeS5zaXplICs9IGNodW5rLmJ5dGVMZW5ndGhcblxuICAgICAgICBpZiAoZW50cnkuc2l6ZSA+PSBzdG9yZS4jbWF4RW50cnlTaXplKSB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnRyeS5ib2R5LnB1c2goY2h1bmspXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsKVxuICAgICAgfSxcbiAgICAgIGZpbmFsIChjYWxsYmFjaykge1xuICAgICAgICBsZXQgZW50cmllcyA9IHN0b3JlLiNlbnRyaWVzLmdldCh0b3BMZXZlbEtleSlcbiAgICAgICAgaWYgKCFlbnRyaWVzKSB7XG4gICAgICAgICAgZW50cmllcyA9IFtdXG4gICAgICAgICAgc3RvcmUuI2VudHJpZXMuc2V0KHRvcExldmVsS2V5LCBlbnRyaWVzKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRW50cnkgPSBmaW5kRW50cnkoa2V5LCBlbnRyaWVzLCBEYXRlLm5vdygpKVxuICAgICAgICBpZiAocHJldmlvdXNFbnRyeSkge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gZW50cmllcy5pbmRleE9mKHByZXZpb3VzRW50cnkpXG4gICAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEsIGVudHJ5KVxuICAgICAgICAgIHN0b3JlLiNzaXplIC09IHByZXZpb3VzRW50cnkuc2l6ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudHJpZXMucHVzaChlbnRyeSlcbiAgICAgICAgICBzdG9yZS4jY291bnQgKz0gMVxuICAgICAgICB9XG5cbiAgICAgICAgc3RvcmUuI3NpemUgKz0gZW50cnkuc2l6ZVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGNhY2hlIGlzIGZ1bGwgYW5kIGVtaXQgZXZlbnQgaWYgbmVlZGVkXG4gICAgICAgIGlmIChzdG9yZS4jc2l6ZSA+IHN0b3JlLiNtYXhTaXplIHx8IHN0b3JlLiNjb3VudCA+IHN0b3JlLiNtYXhDb3VudCkge1xuICAgICAgICAgIC8vIEVtaXQgbWF4U2l6ZUV4Y2VlZGVkIGV2ZW50IGlmIHdlIGhhdmVuJ3QgYWxyZWFkeVxuICAgICAgICAgIGlmICghc3RvcmUuI2hhc0VtaXR0ZWRNYXhTaXplRXZlbnQpIHtcbiAgICAgICAgICAgIHN0b3JlLmVtaXQoJ21heFNpemVFeGNlZWRlZCcsIHtcbiAgICAgICAgICAgICAgc2l6ZTogc3RvcmUuI3NpemUsXG4gICAgICAgICAgICAgIG1heFNpemU6IHN0b3JlLiNtYXhTaXplLFxuICAgICAgICAgICAgICBjb3VudDogc3RvcmUuI2NvdW50LFxuICAgICAgICAgICAgICBtYXhDb3VudDogc3RvcmUuI21heENvdW50XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgc3RvcmUuI2hhc0VtaXR0ZWRNYXhTaXplRXZlbnQgPSB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUGVyZm9ybSBldmljdGlvblxuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgZW50cmllc10gb2Ygc3RvcmUuI2VudHJpZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcy5zcGxpY2UoMCwgZW50cmllcy5sZW5ndGggLyAyKSkge1xuICAgICAgICAgICAgICBzdG9yZS4jc2l6ZSAtPSBlbnRyeS5zaXplXG4gICAgICAgICAgICAgIHN0b3JlLiNjb3VudCAtPSAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgc3RvcmUuI2VudHJpZXMuZGVsZXRlKGtleSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZXNldCB0aGUgZXZlbnQgZmxhZyBhZnRlciBldmljdGlvblxuICAgICAgICAgIGlmIChzdG9yZS4jc2l6ZSA8IHN0b3JlLiNtYXhTaXplICYmIHN0b3JlLiNjb3VudCA8IHN0b3JlLiNtYXhDb3VudCkge1xuICAgICAgICAgICAgc3RvcmUuI2hhc0VtaXR0ZWRNYXhTaXplRXZlbnQgPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhY2hlS2V5fSBrZXlcbiAgICovXG4gIGRlbGV0ZSAoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBrZXkgdG8gYmUgb2JqZWN0LCBnb3QgJHt0eXBlb2Yga2V5fWApXG4gICAgfVxuXG4gICAgY29uc3QgdG9wTGV2ZWxLZXkgPSBgJHtrZXkub3JpZ2lufToke2tleS5wYXRofWBcblxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy4jZW50cmllcy5nZXQodG9wTGV2ZWxLZXkpID8/IFtdKSB7XG4gICAgICB0aGlzLiNzaXplIC09IGVudHJ5LnNpemVcbiAgICAgIHRoaXMuI2NvdW50IC09IDFcbiAgICB9XG4gICAgdGhpcy4jZW50cmllcy5kZWxldGUodG9wTGV2ZWxLZXkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEVudHJ5IChrZXksIGVudHJpZXMsIG5vdykge1xuICByZXR1cm4gZW50cmllcy5maW5kKChlbnRyeSkgPT4gKFxuICAgIGVudHJ5LmRlbGV0ZUF0ID4gbm93ICYmXG4gICAgZW50cnkubWV0aG9kID09PSBrZXkubWV0aG9kICYmXG4gICAgKGVudHJ5LnZhcnkgPT0gbnVsbCB8fCBPYmplY3Qua2V5cyhlbnRyeS52YXJ5KS5ldmVyeShoZWFkZXJOYW1lID0+IHtcbiAgICAgIGlmIChlbnRyeS52YXJ5W2hlYWRlck5hbWVdID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrZXkuaGVhZGVyc1toZWFkZXJOYW1lXSA9PT0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnRyeS52YXJ5W2hlYWRlck5hbWVdID09PSBrZXkuaGVhZGVyc1toZWFkZXJOYW1lXVxuICAgIH0pKVxuICApKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lbW9yeUNhY2hlU3RvcmVcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/cache/memory-cache-store.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/cache/sqlite-cache-store.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/cache/sqlite-cache-store.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Writable } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { assertCacheKey, assertCacheValue } = __webpack_require__(/*! ../util/cache.js */ \"(rsc)/./node_modules/undici/lib/util/cache.js\")\n\nlet DatabaseSync\n\nconst VERSION = 3\n\n// 2gb\nconst MAX_ENTRY_SIZE = 2 * 1000 * 1000 * 1000\n\n/**\n * @typedef {import('../../types/cache-interceptor.d.ts').default.CacheStore} CacheStore\n * @implements {CacheStore}\n *\n * @typedef {{\n *  id: Readonly<number>,\n *  body?: Uint8Array\n *  statusCode: number\n *  statusMessage: string\n *  headers?: string\n *  vary?: string\n *  etag?: string\n *  cacheControlDirectives?: string\n *  cachedAt: number\n *  staleAt: number\n *  deleteAt: number\n * }} SqliteStoreValue\n */\nmodule.exports = class SqliteCacheStore {\n  #maxEntrySize = MAX_ENTRY_SIZE\n  #maxCount = Infinity\n\n  /**\n   * @type {import('node:sqlite').DatabaseSync}\n   */\n  #db\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #getValuesQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #updateValueQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #insertValueQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #deleteExpiredValuesQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #deleteByUrlQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync}\n   */\n  #countEntriesQuery\n\n  /**\n   * @type {import('node:sqlite').StatementSync | null}\n   */\n  #deleteOldValuesQuery\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.SqliteCacheStoreOpts | undefined} opts\n   */\n  constructor (opts) {\n    if (opts) {\n      if (typeof opts !== 'object') {\n        throw new TypeError('SqliteCacheStore options must be an object')\n      }\n\n      if (opts.maxEntrySize !== undefined) {\n        if (\n          typeof opts.maxEntrySize !== 'number' ||\n          !Number.isInteger(opts.maxEntrySize) ||\n          opts.maxEntrySize < 0\n        ) {\n          throw new TypeError('SqliteCacheStore options.maxEntrySize must be a non-negative integer')\n        }\n\n        if (opts.maxEntrySize > MAX_ENTRY_SIZE) {\n          throw new TypeError('SqliteCacheStore options.maxEntrySize must be less than 2gb')\n        }\n\n        this.#maxEntrySize = opts.maxEntrySize\n      }\n\n      if (opts.maxCount !== undefined) {\n        if (\n          typeof opts.maxCount !== 'number' ||\n          !Number.isInteger(opts.maxCount) ||\n          opts.maxCount < 0\n        ) {\n          throw new TypeError('SqliteCacheStore options.maxCount must be a non-negative integer')\n        }\n        this.#maxCount = opts.maxCount\n      }\n    }\n\n    if (!DatabaseSync) {\n      DatabaseSync = (__webpack_require__(/*! node:sqlite */ \"node:sqlite\").DatabaseSync)\n    }\n    this.#db = new DatabaseSync(opts?.location ?? ':memory:')\n\n    this.#db.exec(`\n      PRAGMA journal_mode = WAL;\n      PRAGMA synchronous = NORMAL;\n      PRAGMA temp_store = memory;\n      PRAGMA optimize;\n\n      CREATE TABLE IF NOT EXISTS cacheInterceptorV${VERSION} (\n        -- Data specific to us\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        url TEXT NOT NULL,\n        method TEXT NOT NULL,\n\n        -- Data returned to the interceptor\n        body BUF NULL,\n        deleteAt INTEGER NOT NULL,\n        statusCode INTEGER NOT NULL,\n        statusMessage TEXT NOT NULL,\n        headers TEXT NULL,\n        cacheControlDirectives TEXT NULL,\n        etag TEXT NULL,\n        vary TEXT NULL,\n        cachedAt INTEGER NOT NULL,\n        staleAt INTEGER NOT NULL\n      );\n\n      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION}_getValuesQuery ON cacheInterceptorV${VERSION}(url, method, deleteAt);\n      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION}_deleteByUrlQuery ON cacheInterceptorV${VERSION}(deleteAt);\n    `)\n\n    this.#getValuesQuery = this.#db.prepare(`\n      SELECT\n        id,\n        body,\n        deleteAt,\n        statusCode,\n        statusMessage,\n        headers,\n        etag,\n        cacheControlDirectives,\n        vary,\n        cachedAt,\n        staleAt\n      FROM cacheInterceptorV${VERSION}\n      WHERE\n        url = ?\n        AND method = ?\n      ORDER BY\n        deleteAt ASC\n    `)\n\n    this.#updateValueQuery = this.#db.prepare(`\n      UPDATE cacheInterceptorV${VERSION} SET\n        body = ?,\n        deleteAt = ?,\n        statusCode = ?,\n        statusMessage = ?,\n        headers = ?,\n        etag = ?,\n        cacheControlDirectives = ?,\n        cachedAt = ?,\n        staleAt = ?\n      WHERE\n        id = ?\n    `)\n\n    this.#insertValueQuery = this.#db.prepare(`\n      INSERT INTO cacheInterceptorV${VERSION} (\n        url,\n        method,\n        body,\n        deleteAt,\n        statusCode,\n        statusMessage,\n        headers,\n        etag,\n        cacheControlDirectives,\n        vary,\n        cachedAt,\n        staleAt\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `)\n\n    this.#deleteByUrlQuery = this.#db.prepare(\n      `DELETE FROM cacheInterceptorV${VERSION} WHERE url = ?`\n    )\n\n    this.#countEntriesQuery = this.#db.prepare(\n      `SELECT COUNT(*) AS total FROM cacheInterceptorV${VERSION}`\n    )\n\n    this.#deleteExpiredValuesQuery = this.#db.prepare(\n      `DELETE FROM cacheInterceptorV${VERSION} WHERE deleteAt <= ?`\n    )\n\n    this.#deleteOldValuesQuery = this.#maxCount === Infinity\n      ? null\n      : this.#db.prepare(`\n        DELETE FROM cacheInterceptorV${VERSION}\n        WHERE id IN (\n          SELECT\n            id\n          FROM cacheInterceptorV${VERSION}\n          ORDER BY cachedAt DESC\n          LIMIT ?\n        )\n      `)\n  }\n\n  close () {\n    this.#db.close()\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @returns {(import('../../types/cache-interceptor.d.ts').default.GetResult & { body?: Buffer }) | undefined}\n   */\n  get (key) {\n    assertCacheKey(key)\n\n    const value = this.#findValue(key)\n    return value\n      ? {\n          body: value.body ? Buffer.from(value.body.buffer, value.body.byteOffset, value.body.byteLength) : undefined,\n          statusCode: value.statusCode,\n          statusMessage: value.statusMessage,\n          headers: value.headers ? JSON.parse(value.headers) : undefined,\n          etag: value.etag ? value.etag : undefined,\n          vary: value.vary ? JSON.parse(value.vary) : undefined,\n          cacheControlDirectives: value.cacheControlDirectives\n            ? JSON.parse(value.cacheControlDirectives)\n            : undefined,\n          cachedAt: value.cachedAt,\n          staleAt: value.staleAt,\n          deleteAt: value.deleteAt\n        }\n      : undefined\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue & { body: null | Buffer | Array<Buffer>}} value\n   */\n  set (key, value) {\n    assertCacheKey(key)\n\n    const url = this.#makeValueUrl(key)\n    const body = Array.isArray(value.body) ? Buffer.concat(value.body) : value.body\n    const size = body?.byteLength\n\n    if (size && size > this.#maxEntrySize) {\n      return\n    }\n\n    const existingValue = this.#findValue(key, true)\n    if (existingValue) {\n      // Updating an existing response, let's overwrite it\n      this.#updateValueQuery.run(\n        body,\n        value.deleteAt,\n        value.statusCode,\n        value.statusMessage,\n        value.headers ? JSON.stringify(value.headers) : null,\n        value.etag ? value.etag : null,\n        value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null,\n        value.cachedAt,\n        value.staleAt,\n        existingValue.id\n      )\n    } else {\n      this.#prune()\n      // New response, let's insert it\n      this.#insertValueQuery.run(\n        url,\n        key.method,\n        body,\n        value.deleteAt,\n        value.statusCode,\n        value.statusMessage,\n        value.headers ? JSON.stringify(value.headers) : null,\n        value.etag ? value.etag : null,\n        value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null,\n        value.vary ? JSON.stringify(value.vary) : null,\n        value.cachedAt,\n        value.staleAt\n      )\n    }\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue} value\n   * @returns {Writable | undefined}\n   */\n  createWriteStream (key, value) {\n    assertCacheKey(key)\n    assertCacheValue(value)\n\n    let size = 0\n    /**\n     * @type {Buffer[] | null}\n     */\n    const body = []\n    const store = this\n\n    return new Writable({\n      decodeStrings: true,\n      write (chunk, encoding, callback) {\n        size += chunk.byteLength\n\n        if (size < store.#maxEntrySize) {\n          body.push(chunk)\n        } else {\n          this.destroy()\n        }\n\n        callback()\n      },\n      final (callback) {\n        store.set(key, { ...value, body })\n        callback()\n      }\n    })\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   */\n  delete (key) {\n    if (typeof key !== 'object') {\n      throw new TypeError(`expected key to be object, got ${typeof key}`)\n    }\n\n    this.#deleteByUrlQuery.run(this.#makeValueUrl(key))\n  }\n\n  #prune () {\n    if (Number.isFinite(this.#maxCount) && this.size <= this.#maxCount) {\n      return 0\n    }\n\n    {\n      const removed = this.#deleteExpiredValuesQuery.run(Date.now()).changes\n      if (removed) {\n        return removed\n      }\n    }\n\n    {\n      const removed = this.#deleteOldValuesQuery?.run(Math.max(Math.floor(this.#maxCount * 0.1), 1)).changes\n      if (removed) {\n        return removed\n      }\n    }\n\n    return 0\n  }\n\n  /**\n   * Counts the number of rows in the cache\n   * @returns {Number}\n   */\n  get size () {\n    const { total } = this.#countEntriesQuery.get()\n    return total\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @returns {string}\n   */\n  #makeValueUrl (key) {\n    return `${key.origin}/${key.path}`\n  }\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key\n   * @param {boolean} [canBeExpired=false]\n   * @returns {SqliteStoreValue | undefined}\n   */\n  #findValue (key, canBeExpired = false) {\n    const url = this.#makeValueUrl(key)\n    const { headers, method } = key\n\n    /**\n     * @type {SqliteStoreValue[]}\n     */\n    const values = this.#getValuesQuery.all(url, method)\n\n    if (values.length === 0) {\n      return undefined\n    }\n\n    const now = Date.now()\n    for (const value of values) {\n      if (now >= value.deleteAt && !canBeExpired) {\n        return undefined\n      }\n\n      let matches = true\n\n      if (value.vary) {\n        const vary = JSON.parse(value.vary)\n\n        for (const header in vary) {\n          if (!headerValueEquals(headers[header], vary[header])) {\n            matches = false\n            break\n          }\n        }\n      }\n\n      if (matches) {\n        return value\n      }\n    }\n\n    return undefined\n  }\n}\n\n/**\n * @param {string|string[]|null|undefined} lhs\n * @param {string|string[]|null|undefined} rhs\n * @returns {boolean}\n */\nfunction headerValueEquals (lhs, rhs) {\n  if (lhs == null && rhs == null) {\n    return true\n  }\n\n  if ((lhs == null && rhs != null) ||\n      (lhs != null && rhs == null)) {\n    return false\n  }\n\n  if (Array.isArray(lhs) && Array.isArray(rhs)) {\n    if (lhs.length !== rhs.length) {\n      return false\n    }\n\n    return lhs.every((x, i) => x === rhs[i])\n  }\n\n  return lhs === rhs\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jYWNoZS9zcWxpdGUtY2FjaGUtc3RvcmUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxRQUFRLG1DQUFtQyxFQUFFLG1CQUFPLENBQUMsdUVBQWtCOztBQUV2RTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxpRUFBaUU7QUFDOUUsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQWEsdUZBQXVGO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsb0VBQW1DO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdELFFBQVEs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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NhY2hlL3NxbGl0ZS1jYWNoZS1zdG9yZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgeyBhc3NlcnRDYWNoZUtleSwgYXNzZXJ0Q2FjaGVWYWx1ZSB9ID0gcmVxdWlyZSgnLi4vdXRpbC9jYWNoZS5qcycpXG5cbmxldCBEYXRhYmFzZVN5bmNcblxuY29uc3QgVkVSU0lPTiA9IDNcblxuLy8gMmdiXG5jb25zdCBNQVhfRU5UUllfU0laRSA9IDIgKiAxMDAwICogMTAwMCAqIDEwMDBcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZVN0b3JlfSBDYWNoZVN0b3JlXG4gKiBAaW1wbGVtZW50cyB7Q2FjaGVTdG9yZX1cbiAqXG4gKiBAdHlwZWRlZiB7e1xuICogIGlkOiBSZWFkb25seTxudW1iZXI+LFxuICogIGJvZHk/OiBVaW50OEFycmF5XG4gKiAgc3RhdHVzQ29kZTogbnVtYmVyXG4gKiAgc3RhdHVzTWVzc2FnZTogc3RyaW5nXG4gKiAgaGVhZGVycz86IHN0cmluZ1xuICogIHZhcnk/OiBzdHJpbmdcbiAqICBldGFnPzogc3RyaW5nXG4gKiAgY2FjaGVDb250cm9sRGlyZWN0aXZlcz86IHN0cmluZ1xuICogIGNhY2hlZEF0OiBudW1iZXJcbiAqICBzdGFsZUF0OiBudW1iZXJcbiAqICBkZWxldGVBdDogbnVtYmVyXG4gKiB9fSBTcWxpdGVTdG9yZVZhbHVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU3FsaXRlQ2FjaGVTdG9yZSB7XG4gICNtYXhFbnRyeVNpemUgPSBNQVhfRU5UUllfU0laRVxuICAjbWF4Q291bnQgPSBJbmZpbml0eVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7aW1wb3J0KCdub2RlOnNxbGl0ZScpLkRhdGFiYXNlU3luY31cbiAgICovXG4gICNkYlxuXG4gIC8qKlxuICAgKiBAdHlwZSB7aW1wb3J0KCdub2RlOnNxbGl0ZScpLlN0YXRlbWVudFN5bmN9XG4gICAqL1xuICAjZ2V0VmFsdWVzUXVlcnlcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnbm9kZTpzcWxpdGUnKS5TdGF0ZW1lbnRTeW5jfVxuICAgKi9cbiAgI3VwZGF0ZVZhbHVlUXVlcnlcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnbm9kZTpzcWxpdGUnKS5TdGF0ZW1lbnRTeW5jfVxuICAgKi9cbiAgI2luc2VydFZhbHVlUXVlcnlcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnbm9kZTpzcWxpdGUnKS5TdGF0ZW1lbnRTeW5jfVxuICAgKi9cbiAgI2RlbGV0ZUV4cGlyZWRWYWx1ZXNRdWVyeVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7aW1wb3J0KCdub2RlOnNxbGl0ZScpLlN0YXRlbWVudFN5bmN9XG4gICAqL1xuICAjZGVsZXRlQnlVcmxRdWVyeVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7aW1wb3J0KCdub2RlOnNxbGl0ZScpLlN0YXRlbWVudFN5bmN9XG4gICAqL1xuICAjY291bnRFbnRyaWVzUXVlcnlcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnbm9kZTpzcWxpdGUnKS5TdGF0ZW1lbnRTeW5jIHwgbnVsbH1cbiAgICovXG4gICNkZWxldGVPbGRWYWx1ZXNRdWVyeVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuU3FsaXRlQ2FjaGVTdG9yZU9wdHMgfCB1bmRlZmluZWR9IG9wdHNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3FsaXRlQ2FjaGVTdG9yZSBvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMubWF4RW50cnlTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiBvcHRzLm1heEVudHJ5U2l6ZSAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihvcHRzLm1heEVudHJ5U2l6ZSkgfHxcbiAgICAgICAgICBvcHRzLm1heEVudHJ5U2l6ZSA8IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3FsaXRlQ2FjaGVTdG9yZSBvcHRpb25zLm1heEVudHJ5U2l6ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMubWF4RW50cnlTaXplID4gTUFYX0VOVFJZX1NJWkUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTcWxpdGVDYWNoZVN0b3JlIG9wdGlvbnMubWF4RW50cnlTaXplIG11c3QgYmUgbGVzcyB0aGFuIDJnYicpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNtYXhFbnRyeVNpemUgPSBvcHRzLm1heEVudHJ5U2l6ZVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5tYXhDb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0eXBlb2Ygb3B0cy5tYXhDb3VudCAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihvcHRzLm1heENvdW50KSB8fFxuICAgICAgICAgIG9wdHMubWF4Q291bnQgPCAwXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NxbGl0ZUNhY2hlU3RvcmUgb3B0aW9ucy5tYXhDb3VudCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21heENvdW50ID0gb3B0cy5tYXhDb3VudFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghRGF0YWJhc2VTeW5jKSB7XG4gICAgICBEYXRhYmFzZVN5bmMgPSByZXF1aXJlKCdub2RlOnNxbGl0ZScpLkRhdGFiYXNlU3luY1xuICAgIH1cbiAgICB0aGlzLiNkYiA9IG5ldyBEYXRhYmFzZVN5bmMob3B0cz8ubG9jYXRpb24gPz8gJzptZW1vcnk6JylcblxuICAgIHRoaXMuI2RiLmV4ZWMoYFxuICAgICAgUFJBR01BIGpvdXJuYWxfbW9kZSA9IFdBTDtcbiAgICAgIFBSQUdNQSBzeW5jaHJvbm91cyA9IE5PUk1BTDtcbiAgICAgIFBSQUdNQSB0ZW1wX3N0b3JlID0gbWVtb3J5O1xuICAgICAgUFJBR01BIG9wdGltaXplO1xuXG4gICAgICBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyBjYWNoZUludGVyY2VwdG9yViR7VkVSU0lPTn0gKFxuICAgICAgICAtLSBEYXRhIHNwZWNpZmljIHRvIHVzXG4gICAgICAgIGlkIElOVEVHRVIgUFJJTUFSWSBLRVkgQVVUT0lOQ1JFTUVOVCxcbiAgICAgICAgdXJsIFRFWFQgTk9UIE5VTEwsXG4gICAgICAgIG1ldGhvZCBURVhUIE5PVCBOVUxMLFxuXG4gICAgICAgIC0tIERhdGEgcmV0dXJuZWQgdG8gdGhlIGludGVyY2VwdG9yXG4gICAgICAgIGJvZHkgQlVGIE5VTEwsXG4gICAgICAgIGRlbGV0ZUF0IElOVEVHRVIgTk9UIE5VTEwsXG4gICAgICAgIHN0YXR1c0NvZGUgSU5URUdFUiBOT1QgTlVMTCxcbiAgICAgICAgc3RhdHVzTWVzc2FnZSBURVhUIE5PVCBOVUxMLFxuICAgICAgICBoZWFkZXJzIFRFWFQgTlVMTCxcbiAgICAgICAgY2FjaGVDb250cm9sRGlyZWN0aXZlcyBURVhUIE5VTEwsXG4gICAgICAgIGV0YWcgVEVYVCBOVUxMLFxuICAgICAgICB2YXJ5IFRFWFQgTlVMTCxcbiAgICAgICAgY2FjaGVkQXQgSU5URUdFUiBOT1QgTlVMTCxcbiAgICAgICAgc3RhbGVBdCBJTlRFR0VSIE5PVCBOVUxMXG4gICAgICApO1xuXG4gICAgICBDUkVBVEUgSU5ERVggSUYgTk9UIEVYSVNUUyBpZHhfY2FjaGVJbnRlcmNlcHRvclYke1ZFUlNJT059X2dldFZhbHVlc1F1ZXJ5IE9OIGNhY2hlSW50ZXJjZXB0b3JWJHtWRVJTSU9OfSh1cmwsIG1ldGhvZCwgZGVsZXRlQXQpO1xuICAgICAgQ1JFQVRFIElOREVYIElGIE5PVCBFWElTVFMgaWR4X2NhY2hlSW50ZXJjZXB0b3JWJHtWRVJTSU9OfV9kZWxldGVCeVVybFF1ZXJ5IE9OIGNhY2hlSW50ZXJjZXB0b3JWJHtWRVJTSU9OfShkZWxldGVBdCk7XG4gICAgYClcblxuICAgIHRoaXMuI2dldFZhbHVlc1F1ZXJ5ID0gdGhpcy4jZGIucHJlcGFyZShgXG4gICAgICBTRUxFQ1RcbiAgICAgICAgaWQsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGRlbGV0ZUF0LFxuICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICBzdGF0dXNNZXNzYWdlLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBldGFnLFxuICAgICAgICBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzLFxuICAgICAgICB2YXJ5LFxuICAgICAgICBjYWNoZWRBdCxcbiAgICAgICAgc3RhbGVBdFxuICAgICAgRlJPTSBjYWNoZUludGVyY2VwdG9yViR7VkVSU0lPTn1cbiAgICAgIFdIRVJFXG4gICAgICAgIHVybCA9ID9cbiAgICAgICAgQU5EIG1ldGhvZCA9ID9cbiAgICAgIE9SREVSIEJZXG4gICAgICAgIGRlbGV0ZUF0IEFTQ1xuICAgIGApXG5cbiAgICB0aGlzLiN1cGRhdGVWYWx1ZVF1ZXJ5ID0gdGhpcy4jZGIucHJlcGFyZShgXG4gICAgICBVUERBVEUgY2FjaGVJbnRlcmNlcHRvclYke1ZFUlNJT059IFNFVFxuICAgICAgICBib2R5ID0gPyxcbiAgICAgICAgZGVsZXRlQXQgPSA/LFxuICAgICAgICBzdGF0dXNDb2RlID0gPyxcbiAgICAgICAgc3RhdHVzTWVzc2FnZSA9ID8sXG4gICAgICAgIGhlYWRlcnMgPSA/LFxuICAgICAgICBldGFnID0gPyxcbiAgICAgICAgY2FjaGVDb250cm9sRGlyZWN0aXZlcyA9ID8sXG4gICAgICAgIGNhY2hlZEF0ID0gPyxcbiAgICAgICAgc3RhbGVBdCA9ID9cbiAgICAgIFdIRVJFXG4gICAgICAgIGlkID0gP1xuICAgIGApXG5cbiAgICB0aGlzLiNpbnNlcnRWYWx1ZVF1ZXJ5ID0gdGhpcy4jZGIucHJlcGFyZShgXG4gICAgICBJTlNFUlQgSU5UTyBjYWNoZUludGVyY2VwdG9yViR7VkVSU0lPTn0gKFxuICAgICAgICB1cmwsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgYm9keSxcbiAgICAgICAgZGVsZXRlQXQsXG4gICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgIHN0YXR1c01lc3NhZ2UsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGV0YWcsXG4gICAgICAgIGNhY2hlQ29udHJvbERpcmVjdGl2ZXMsXG4gICAgICAgIHZhcnksXG4gICAgICAgIGNhY2hlZEF0LFxuICAgICAgICBzdGFsZUF0XG4gICAgICApIFZBTFVFUyAoPywgPywgPywgPywgPywgPywgPywgPywgPywgPywgPywgPylcbiAgICBgKVxuXG4gICAgdGhpcy4jZGVsZXRlQnlVcmxRdWVyeSA9IHRoaXMuI2RiLnByZXBhcmUoXG4gICAgICBgREVMRVRFIEZST00gY2FjaGVJbnRlcmNlcHRvclYke1ZFUlNJT059IFdIRVJFIHVybCA9ID9gXG4gICAgKVxuXG4gICAgdGhpcy4jY291bnRFbnRyaWVzUXVlcnkgPSB0aGlzLiNkYi5wcmVwYXJlKFxuICAgICAgYFNFTEVDVCBDT1VOVCgqKSBBUyB0b3RhbCBGUk9NIGNhY2hlSW50ZXJjZXB0b3JWJHtWRVJTSU9OfWBcbiAgICApXG5cbiAgICB0aGlzLiNkZWxldGVFeHBpcmVkVmFsdWVzUXVlcnkgPSB0aGlzLiNkYi5wcmVwYXJlKFxuICAgICAgYERFTEVURSBGUk9NIGNhY2hlSW50ZXJjZXB0b3JWJHtWRVJTSU9OfSBXSEVSRSBkZWxldGVBdCA8PSA/YFxuICAgIClcblxuICAgIHRoaXMuI2RlbGV0ZU9sZFZhbHVlc1F1ZXJ5ID0gdGhpcy4jbWF4Q291bnQgPT09IEluZmluaXR5XG4gICAgICA/IG51bGxcbiAgICAgIDogdGhpcy4jZGIucHJlcGFyZShgXG4gICAgICAgIERFTEVURSBGUk9NIGNhY2hlSW50ZXJjZXB0b3JWJHtWRVJTSU9OfVxuICAgICAgICBXSEVSRSBpZCBJTiAoXG4gICAgICAgICAgU0VMRUNUXG4gICAgICAgICAgICBpZFxuICAgICAgICAgIEZST00gY2FjaGVJbnRlcmNlcHRvclYke1ZFUlNJT059XG4gICAgICAgICAgT1JERVIgQlkgY2FjaGVkQXQgREVTQ1xuICAgICAgICAgIExJTUlUID9cbiAgICAgICAgKVxuICAgICAgYClcbiAgfVxuXG4gIGNsb3NlICgpIHtcbiAgICB0aGlzLiNkYi5jbG9zZSgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlS2V5fSBrZXlcbiAgICogQHJldHVybnMgeyhpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkdldFJlc3VsdCAmIHsgYm9keT86IEJ1ZmZlciB9KSB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGdldCAoa2V5KSB7XG4gICAgYXNzZXJ0Q2FjaGVLZXkoa2V5KVxuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNmaW5kVmFsdWUoa2V5KVxuICAgIHJldHVybiB2YWx1ZVxuICAgICAgPyB7XG4gICAgICAgICAgYm9keTogdmFsdWUuYm9keSA/IEJ1ZmZlci5mcm9tKHZhbHVlLmJvZHkuYnVmZmVyLCB2YWx1ZS5ib2R5LmJ5dGVPZmZzZXQsIHZhbHVlLmJvZHkuYnl0ZUxlbmd0aCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgc3RhdHVzQ29kZTogdmFsdWUuc3RhdHVzQ29kZSxcbiAgICAgICAgICBzdGF0dXNNZXNzYWdlOiB2YWx1ZS5zdGF0dXNNZXNzYWdlLFxuICAgICAgICAgIGhlYWRlcnM6IHZhbHVlLmhlYWRlcnMgPyBKU09OLnBhcnNlKHZhbHVlLmhlYWRlcnMpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGV0YWc6IHZhbHVlLmV0YWcgPyB2YWx1ZS5ldGFnIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHZhcnk6IHZhbHVlLnZhcnkgPyBKU09OLnBhcnNlKHZhbHVlLnZhcnkpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGNhY2hlQ29udHJvbERpcmVjdGl2ZXM6IHZhbHVlLmNhY2hlQ29udHJvbERpcmVjdGl2ZXNcbiAgICAgICAgICAgID8gSlNPTi5wYXJzZSh2YWx1ZS5jYWNoZUNvbnRyb2xEaXJlY3RpdmVzKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgY2FjaGVkQXQ6IHZhbHVlLmNhY2hlZEF0LFxuICAgICAgICAgIHN0YWxlQXQ6IHZhbHVlLnN0YWxlQXQsXG4gICAgICAgICAgZGVsZXRlQXQ6IHZhbHVlLmRlbGV0ZUF0XG4gICAgICAgIH1cbiAgICAgIDogdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlS2V5fSBrZXlcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlVmFsdWUgJiB7IGJvZHk6IG51bGwgfCBCdWZmZXIgfCBBcnJheTxCdWZmZXI+fX0gdmFsdWVcbiAgICovXG4gIHNldCAoa2V5LCB2YWx1ZSkge1xuICAgIGFzc2VydENhY2hlS2V5KGtleSlcblxuICAgIGNvbnN0IHVybCA9IHRoaXMuI21ha2VWYWx1ZVVybChrZXkpXG4gICAgY29uc3QgYm9keSA9IEFycmF5LmlzQXJyYXkodmFsdWUuYm9keSkgPyBCdWZmZXIuY29uY2F0KHZhbHVlLmJvZHkpIDogdmFsdWUuYm9keVxuICAgIGNvbnN0IHNpemUgPSBib2R5Py5ieXRlTGVuZ3RoXG5cbiAgICBpZiAoc2l6ZSAmJiBzaXplID4gdGhpcy4jbWF4RW50cnlTaXplKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBleGlzdGluZ1ZhbHVlID0gdGhpcy4jZmluZFZhbHVlKGtleSwgdHJ1ZSlcbiAgICBpZiAoZXhpc3RpbmdWYWx1ZSkge1xuICAgICAgLy8gVXBkYXRpbmcgYW4gZXhpc3RpbmcgcmVzcG9uc2UsIGxldCdzIG92ZXJ3cml0ZSBpdFxuICAgICAgdGhpcy4jdXBkYXRlVmFsdWVRdWVyeS5ydW4oXG4gICAgICAgIGJvZHksXG4gICAgICAgIHZhbHVlLmRlbGV0ZUF0LFxuICAgICAgICB2YWx1ZS5zdGF0dXNDb2RlLFxuICAgICAgICB2YWx1ZS5zdGF0dXNNZXNzYWdlLFxuICAgICAgICB2YWx1ZS5oZWFkZXJzID8gSlNPTi5zdHJpbmdpZnkodmFsdWUuaGVhZGVycykgOiBudWxsLFxuICAgICAgICB2YWx1ZS5ldGFnID8gdmFsdWUuZXRhZyA6IG51bGwsXG4gICAgICAgIHZhbHVlLmNhY2hlQ29udHJvbERpcmVjdGl2ZXMgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZS5jYWNoZUNvbnRyb2xEaXJlY3RpdmVzKSA6IG51bGwsXG4gICAgICAgIHZhbHVlLmNhY2hlZEF0LFxuICAgICAgICB2YWx1ZS5zdGFsZUF0LFxuICAgICAgICBleGlzdGluZ1ZhbHVlLmlkXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3BydW5lKClcbiAgICAgIC8vIE5ldyByZXNwb25zZSwgbGV0J3MgaW5zZXJ0IGl0XG4gICAgICB0aGlzLiNpbnNlcnRWYWx1ZVF1ZXJ5LnJ1bihcbiAgICAgICAgdXJsLFxuICAgICAgICBrZXkubWV0aG9kLFxuICAgICAgICBib2R5LFxuICAgICAgICB2YWx1ZS5kZWxldGVBdCxcbiAgICAgICAgdmFsdWUuc3RhdHVzQ29kZSxcbiAgICAgICAgdmFsdWUuc3RhdHVzTWVzc2FnZSxcbiAgICAgICAgdmFsdWUuaGVhZGVycyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlLmhlYWRlcnMpIDogbnVsbCxcbiAgICAgICAgdmFsdWUuZXRhZyA/IHZhbHVlLmV0YWcgOiBudWxsLFxuICAgICAgICB2YWx1ZS5jYWNoZUNvbnRyb2xEaXJlY3RpdmVzID8gSlNPTi5zdHJpbmdpZnkodmFsdWUuY2FjaGVDb250cm9sRGlyZWN0aXZlcykgOiBudWxsLFxuICAgICAgICB2YWx1ZS52YXJ5ID8gSlNPTi5zdHJpbmdpZnkodmFsdWUudmFyeSkgOiBudWxsLFxuICAgICAgICB2YWx1ZS5jYWNoZWRBdCxcbiAgICAgICAgdmFsdWUuc3RhbGVBdFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVLZXl9IGtleVxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVWYWx1ZX0gdmFsdWVcbiAgICogQHJldHVybnMge1dyaXRhYmxlIHwgdW5kZWZpbmVkfVxuICAgKi9cbiAgY3JlYXRlV3JpdGVTdHJlYW0gKGtleSwgdmFsdWUpIHtcbiAgICBhc3NlcnRDYWNoZUtleShrZXkpXG4gICAgYXNzZXJ0Q2FjaGVWYWx1ZSh2YWx1ZSlcblxuICAgIGxldCBzaXplID0gMFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCdWZmZXJbXSB8IG51bGx9XG4gICAgICovXG4gICAgY29uc3QgYm9keSA9IFtdXG4gICAgY29uc3Qgc3RvcmUgPSB0aGlzXG5cbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKHtcbiAgICAgIGRlY29kZVN0cmluZ3M6IHRydWUsXG4gICAgICB3cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBzaXplICs9IGNodW5rLmJ5dGVMZW5ndGhcblxuICAgICAgICBpZiAoc2l6ZSA8IHN0b3JlLiNtYXhFbnRyeVNpemUpIHtcbiAgICAgICAgICBib2R5LnB1c2goY2h1bmspXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KClcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgIH0sXG4gICAgICBmaW5hbCAoY2FsbGJhY2spIHtcbiAgICAgICAgc3RvcmUuc2V0KGtleSwgeyAuLi52YWx1ZSwgYm9keSB9KVxuICAgICAgICBjYWxsYmFjaygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVLZXl9IGtleVxuICAgKi9cbiAgZGVsZXRlIChrZXkpIHtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIGtleSB0byBiZSBvYmplY3QsIGdvdCAke3R5cGVvZiBrZXl9YClcbiAgICB9XG5cbiAgICB0aGlzLiNkZWxldGVCeVVybFF1ZXJ5LnJ1bih0aGlzLiNtYWtlVmFsdWVVcmwoa2V5KSlcbiAgfVxuXG4gICNwcnVuZSAoKSB7XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZSh0aGlzLiNtYXhDb3VudCkgJiYgdGhpcy5zaXplIDw9IHRoaXMuI21heENvdW50KSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSB0aGlzLiNkZWxldGVFeHBpcmVkVmFsdWVzUXVlcnkucnVuKERhdGUubm93KCkpLmNoYW5nZXNcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVkXG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IHRoaXMuI2RlbGV0ZU9sZFZhbHVlc1F1ZXJ5Py5ydW4oTWF0aC5tYXgoTWF0aC5mbG9vcih0aGlzLiNtYXhDb3VudCAqIDAuMSksIDEpKS5jaGFuZ2VzXG4gICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlZFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwXG4gIH1cblxuICAvKipcbiAgICogQ291bnRzIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgY2FjaGVcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIGdldCBzaXplICgpIHtcbiAgICBjb25zdCB7IHRvdGFsIH0gPSB0aGlzLiNjb3VudEVudHJpZXNRdWVyeS5nZXQoKVxuICAgIHJldHVybiB0b3RhbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZUtleX0ga2V5XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICAjbWFrZVZhbHVlVXJsIChrZXkpIHtcbiAgICByZXR1cm4gYCR7a2V5Lm9yaWdpbn0vJHtrZXkucGF0aH1gXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlS2V5fSBrZXlcbiAgICogQHBhcmFtIHtib29sZWFufSBbY2FuQmVFeHBpcmVkPWZhbHNlXVxuICAgKiBAcmV0dXJucyB7U3FsaXRlU3RvcmVWYWx1ZSB8IHVuZGVmaW5lZH1cbiAgICovXG4gICNmaW5kVmFsdWUgKGtleSwgY2FuQmVFeHBpcmVkID0gZmFsc2UpIHtcbiAgICBjb25zdCB1cmwgPSB0aGlzLiNtYWtlVmFsdWVVcmwoa2V5KVxuICAgIGNvbnN0IHsgaGVhZGVycywgbWV0aG9kIH0gPSBrZXlcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTcWxpdGVTdG9yZVZhbHVlW119XG4gICAgICovXG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy4jZ2V0VmFsdWVzUXVlcnkuYWxsKHVybCwgbWV0aG9kKVxuXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmIChub3cgPj0gdmFsdWUuZGVsZXRlQXQgJiYgIWNhbkJlRXhwaXJlZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGxldCBtYXRjaGVzID0gdHJ1ZVxuXG4gICAgICBpZiAodmFsdWUudmFyeSkge1xuICAgICAgICBjb25zdCB2YXJ5ID0gSlNPTi5wYXJzZSh2YWx1ZS52YXJ5KVxuXG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIGluIHZhcnkpIHtcbiAgICAgICAgICBpZiAoIWhlYWRlclZhbHVlRXF1YWxzKGhlYWRlcnNbaGVhZGVyXSwgdmFyeVtoZWFkZXJdKSkge1xuICAgICAgICAgICAgbWF0Y2hlcyA9IGZhbHNlXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXXxudWxsfHVuZGVmaW5lZH0gbGhzXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXXxudWxsfHVuZGVmaW5lZH0gcmhzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGVhZGVyVmFsdWVFcXVhbHMgKGxocywgcmhzKSB7XG4gIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoKGxocyA9PSBudWxsICYmIHJocyAhPSBudWxsKSB8fFxuICAgICAgKGxocyAhPSBudWxsICYmIHJocyA9PSBudWxsKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobGhzKSAmJiBBcnJheS5pc0FycmF5KHJocykpIHtcbiAgICBpZiAobGhzLmxlbmd0aCAhPT0gcmhzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIGxocy5ldmVyeSgoeCwgaSkgPT4geCA9PT0gcmhzW2ldKVxuICB9XG5cbiAgcmV0dXJuIGxocyA9PT0gcmhzXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/cache/sqlite-cache-store.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/connect.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/connect.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst net = __webpack_require__(/*! node:net */ \"node:net\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nlet tls // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nconst SessionCache = class WeakSessionCache {\n  constructor (maxCachedSessions) {\n    this._maxCachedSessions = maxCachedSessions\n    this._sessionCache = new Map()\n    this._sessionRegistry = new FinalizationRegistry((key) => {\n      if (this._sessionCache.size < this._maxCachedSessions) {\n        return\n      }\n\n      const ref = this._sessionCache.get(key)\n      if (ref !== undefined && ref.deref() === undefined) {\n        this._sessionCache.delete(key)\n      }\n    })\n  }\n\n  get (sessionKey) {\n    const ref = this._sessionCache.get(sessionKey)\n    return ref ? ref.deref() : null\n  }\n\n  set (sessionKey, session) {\n    if (this._maxCachedSessions === 0) {\n      return\n    }\n\n    this._sessionCache.set(sessionKey, new WeakRef(session))\n    this._sessionRegistry.register(session, sessionKey)\n  }\n}\n\nfunction buildConnector ({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions)\n  timeout = timeout == null ? 10e3 : timeout\n  allowH2 = allowH2 != null ? allowH2 : false\n  return function connect ({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = __webpack_require__(/*! node:tls */ \"node:tls\")\n      }\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      assert(sessionKey)\n\n      const session = customSession || sessionCache.get(sessionKey) || null\n\n      port = port || 443\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        localAddress,\n        ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],\n        socket: httpSocket, // upgrade socket connection\n        port,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // TODO (fix): Can a session become invalid once established? Don't think so?\n          sessionCache.set(sessionKey, session)\n        })\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update')\n\n      port = port || 80\n\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        localAddress,\n        port,\n        host: hostname\n      })\n    }\n\n    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n    if (options.keepAlive == null || options.keepAlive) {\n      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay\n      socket.setKeepAlive(true, keepAliveInitialDelay)\n    }\n\n    const clearConnectTimeout = util.setupConnectTimeout(new WeakRef(socket), { timeout, hostname, port })\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        queueMicrotask(clearConnectTimeout)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        queueMicrotask(clearConnectTimeout)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\nmodule.exports = buildConnector\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Nvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosWUFBWSxtQkFBTyxDQUFDLDBCQUFVO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsNERBQVE7QUFDN0IsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLGdFQUFVOztBQUVuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixrRkFBa0Y7QUFDN0c7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0VBQXNFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQywwQkFBVTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnRkFBZ0YseUJBQXlCOztBQUV6RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvY29ubmVjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgbmV0ID0gcmVxdWlyZSgnbm9kZTpuZXQnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuL2Vycm9ycycpXG5cbmxldCB0bHMgLy8gaW5jbHVkZSB0bHMgY29uZGl0aW9uYWxseSBzaW5jZSBpdCBpcyBub3QgYWx3YXlzIGF2YWlsYWJsZVxuXG4vLyBUT0RPOiBzZXNzaW9uIHJlLXVzZSBkb2VzIG5vdCB3YWl0IGZvciB0aGUgZmlyc3Rcbi8vIGNvbm5lY3Rpb24gdG8gcmVzb2x2ZSB0aGUgc2Vzc2lvbiBhbmQgbWlnaHQgdGhlcmVmb3JlXG4vLyByZXNvbHZlIHRoZSBzYW1lIHNlcnZlcm5hbWUgbXVsdGlwbGUgdGltZXMgZXZlbiB3aGVuXG4vLyByZS11c2UgaXMgZW5hYmxlZC5cblxuY29uc3QgU2Vzc2lvbkNhY2hlID0gY2xhc3MgV2Vha1Nlc3Npb25DYWNoZSB7XG4gIGNvbnN0cnVjdG9yIChtYXhDYWNoZWRTZXNzaW9ucykge1xuICAgIHRoaXMuX21heENhY2hlZFNlc3Npb25zID0gbWF4Q2FjaGVkU2Vzc2lvbnNcbiAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSBuZXcgTWFwKClcbiAgICB0aGlzLl9zZXNzaW9uUmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKGtleSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3Nlc3Npb25DYWNoZS5zaXplIDwgdGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlZiA9IHRoaXMuX3Nlc3Npb25DYWNoZS5nZXQoa2V5KVxuICAgICAgaWYgKHJlZiAhPT0gdW5kZWZpbmVkICYmIHJlZi5kZXJlZigpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlLmRlbGV0ZShrZXkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGdldCAoc2Vzc2lvbktleSkge1xuICAgIGNvbnN0IHJlZiA9IHRoaXMuX3Nlc3Npb25DYWNoZS5nZXQoc2Vzc2lvbktleSlcbiAgICByZXR1cm4gcmVmID8gcmVmLmRlcmVmKCkgOiBudWxsXG4gIH1cblxuICBzZXQgKHNlc3Npb25LZXksIHNlc3Npb24pIHtcbiAgICBpZiAodGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMgPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3Nlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgbmV3IFdlYWtSZWYoc2Vzc2lvbikpXG4gICAgdGhpcy5fc2Vzc2lvblJlZ2lzdHJ5LnJlZ2lzdGVyKHNlc3Npb24sIHNlc3Npb25LZXkpXG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRDb25uZWN0b3IgKHsgYWxsb3dIMiwgbWF4Q2FjaGVkU2Vzc2lvbnMsIHNvY2tldFBhdGgsIHRpbWVvdXQsIHNlc3Npb246IGN1c3RvbVNlc3Npb24sIC4uLm9wdHMgfSkge1xuICBpZiAobWF4Q2FjaGVkU2Vzc2lvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4Q2FjaGVkU2Vzc2lvbnMpIHx8IG1heENhY2hlZFNlc3Npb25zIDwgMCkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heENhY2hlZFNlc3Npb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHplcm8nKVxuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHsgcGF0aDogc29ja2V0UGF0aCwgLi4ub3B0cyB9XG4gIGNvbnN0IHNlc3Npb25DYWNoZSA9IG5ldyBTZXNzaW9uQ2FjaGUobWF4Q2FjaGVkU2Vzc2lvbnMgPT0gbnVsbCA/IDEwMCA6IG1heENhY2hlZFNlc3Npb25zKVxuICB0aW1lb3V0ID0gdGltZW91dCA9PSBudWxsID8gMTBlMyA6IHRpbWVvdXRcbiAgYWxsb3dIMiA9IGFsbG93SDIgIT0gbnVsbCA/IGFsbG93SDIgOiBmYWxzZVxuICByZXR1cm4gZnVuY3Rpb24gY29ubmVjdCAoeyBob3N0bmFtZSwgaG9zdCwgcHJvdG9jb2wsIHBvcnQsIHNlcnZlcm5hbWUsIGxvY2FsQWRkcmVzcywgaHR0cFNvY2tldCB9LCBjYWxsYmFjaykge1xuICAgIGxldCBzb2NrZXRcbiAgICBpZiAocHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICBpZiAoIXRscykge1xuICAgICAgICB0bHMgPSByZXF1aXJlKCdub2RlOnRscycpXG4gICAgICB9XG4gICAgICBzZXJ2ZXJuYW1lID0gc2VydmVybmFtZSB8fCBvcHRpb25zLnNlcnZlcm5hbWUgfHwgdXRpbC5nZXRTZXJ2ZXJOYW1lKGhvc3QpIHx8IG51bGxcblxuICAgICAgY29uc3Qgc2Vzc2lvbktleSA9IHNlcnZlcm5hbWUgfHwgaG9zdG5hbWVcbiAgICAgIGFzc2VydChzZXNzaW9uS2V5KVxuXG4gICAgICBjb25zdCBzZXNzaW9uID0gY3VzdG9tU2Vzc2lvbiB8fCBzZXNzaW9uQ2FjaGUuZ2V0KHNlc3Npb25LZXkpIHx8IG51bGxcblxuICAgICAgcG9ydCA9IHBvcnQgfHwgNDQzXG5cbiAgICAgIHNvY2tldCA9IHRscy5jb25uZWN0KHtcbiAgICAgICAgaGlnaFdhdGVyTWFyazogMTYzODQsIC8vIFRMUyBpbiBub2RlIGNhbid0IGhhdmUgYmlnZ2VyIEhXTSBhbnl3YXkuLi5cbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgc2VydmVybmFtZSxcbiAgICAgICAgc2Vzc2lvbixcbiAgICAgICAgbG9jYWxBZGRyZXNzLFxuICAgICAgICBBTFBOUHJvdG9jb2xzOiBhbGxvd0gyID8gWydodHRwLzEuMScsICdoMiddIDogWydodHRwLzEuMSddLFxuICAgICAgICBzb2NrZXQ6IGh0dHBTb2NrZXQsIC8vIHVwZ3JhZGUgc29ja2V0IGNvbm5lY3Rpb25cbiAgICAgICAgcG9ydCxcbiAgICAgICAgaG9zdDogaG9zdG5hbWVcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldFxuICAgICAgICAub24oJ3Nlc3Npb24nLCBmdW5jdGlvbiAoc2Vzc2lvbikge1xuICAgICAgICAgIC8vIFRPRE8gKGZpeCk6IENhbiBhIHNlc3Npb24gYmVjb21lIGludmFsaWQgb25jZSBlc3RhYmxpc2hlZD8gRG9uJ3QgdGhpbmsgc28/XG4gICAgICAgICAgc2Vzc2lvbkNhY2hlLnNldChzZXNzaW9uS2V5LCBzZXNzaW9uKVxuICAgICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoIWh0dHBTb2NrZXQsICdodHRwU29ja2V0IGNhbiBvbmx5IGJlIHNlbnQgb24gVExTIHVwZGF0ZScpXG5cbiAgICAgIHBvcnQgPSBwb3J0IHx8IDgwXG5cbiAgICAgIHNvY2tldCA9IG5ldC5jb25uZWN0KHtcbiAgICAgICAgaGlnaFdhdGVyTWFyazogNjQgKiAxMDI0LCAvLyBTYW1lIGFzIG5vZGVqcyBmcyBzdHJlYW1zLlxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBsb2NhbEFkZHJlc3MsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIGhvc3Q6IGhvc3RuYW1lXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIFNldCBUQ1Aga2VlcCBhbGl2ZSBvcHRpb25zIG9uIHRoZSBzb2NrZXQgaGVyZSBpbnN0ZWFkIG9mIGluIGNvbm5lY3QoKSBmb3IgdGhlIGNhc2Ugb2YgYXNzaWduaW5nIHRoZSBzb2NrZXRcbiAgICBpZiAob3B0aW9ucy5rZWVwQWxpdmUgPT0gbnVsbCB8fCBvcHRpb25zLmtlZXBBbGl2ZSkge1xuICAgICAgY29uc3Qga2VlcEFsaXZlSW5pdGlhbERlbGF5ID0gb3B0aW9ucy5rZWVwQWxpdmVJbml0aWFsRGVsYXkgPT09IHVuZGVmaW5lZCA/IDYwZTMgOiBvcHRpb25zLmtlZXBBbGl2ZUluaXRpYWxEZWxheVxuICAgICAgc29ja2V0LnNldEtlZXBBbGl2ZSh0cnVlLCBrZWVwQWxpdmVJbml0aWFsRGVsYXkpXG4gICAgfVxuXG4gICAgY29uc3QgY2xlYXJDb25uZWN0VGltZW91dCA9IHV0aWwuc2V0dXBDb25uZWN0VGltZW91dChuZXcgV2Vha1JlZihzb2NrZXQpLCB7IHRpbWVvdXQsIGhvc3RuYW1lLCBwb3J0IH0pXG5cbiAgICBzb2NrZXRcbiAgICAgIC5zZXROb0RlbGF5KHRydWUpXG4gICAgICAub25jZShwcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnc2VjdXJlQ29ubmVjdCcgOiAnY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soY2xlYXJDb25uZWN0VGltZW91dClcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2sgPSBudWxsXG4gICAgICAgICAgY2IobnVsbCwgdGhpcylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKGNsZWFyQ29ubmVjdFRpbWVvdXQpXG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY29uc3QgY2IgPSBjYWxsYmFja1xuICAgICAgICAgIGNhbGxiYWNrID0gbnVsbFxuICAgICAgICAgIGNiKGVycilcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIHJldHVybiBzb2NrZXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkQ29ubmVjdG9yXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/connect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/core/constants.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\n\n/**\n * @see https://developer.mozilla.org/docs/Web/HTTP/Headers\n */\nconst wellknownHeaderNames = /** @type {const} */ ([\n  'Accept',\n  'Accept-Encoding',\n  'Accept-Language',\n  'Accept-Ranges',\n  'Access-Control-Allow-Credentials',\n  'Access-Control-Allow-Headers',\n  'Access-Control-Allow-Methods',\n  'Access-Control-Allow-Origin',\n  'Access-Control-Expose-Headers',\n  'Access-Control-Max-Age',\n  'Access-Control-Request-Headers',\n  'Access-Control-Request-Method',\n  'Age',\n  'Allow',\n  'Alt-Svc',\n  'Alt-Used',\n  'Authorization',\n  'Cache-Control',\n  'Clear-Site-Data',\n  'Connection',\n  'Content-Disposition',\n  'Content-Encoding',\n  'Content-Language',\n  'Content-Length',\n  'Content-Location',\n  'Content-Range',\n  'Content-Security-Policy',\n  'Content-Security-Policy-Report-Only',\n  'Content-Type',\n  'Cookie',\n  'Cross-Origin-Embedder-Policy',\n  'Cross-Origin-Opener-Policy',\n  'Cross-Origin-Resource-Policy',\n  'Date',\n  'Device-Memory',\n  'Downlink',\n  'ECT',\n  'ETag',\n  'Expect',\n  'Expect-CT',\n  'Expires',\n  'Forwarded',\n  'From',\n  'Host',\n  'If-Match',\n  'If-Modified-Since',\n  'If-None-Match',\n  'If-Range',\n  'If-Unmodified-Since',\n  'Keep-Alive',\n  'Last-Modified',\n  'Link',\n  'Location',\n  'Max-Forwards',\n  'Origin',\n  'Permissions-Policy',\n  'Pragma',\n  'Proxy-Authenticate',\n  'Proxy-Authorization',\n  'RTT',\n  'Range',\n  'Referer',\n  'Referrer-Policy',\n  'Refresh',\n  'Retry-After',\n  'Sec-WebSocket-Accept',\n  'Sec-WebSocket-Extensions',\n  'Sec-WebSocket-Key',\n  'Sec-WebSocket-Protocol',\n  'Sec-WebSocket-Version',\n  'Server',\n  'Server-Timing',\n  'Service-Worker-Allowed',\n  'Service-Worker-Navigation-Preload',\n  'Set-Cookie',\n  'SourceMap',\n  'Strict-Transport-Security',\n  'Supports-Loading-Mode',\n  'TE',\n  'Timing-Allow-Origin',\n  'Trailer',\n  'Transfer-Encoding',\n  'Upgrade',\n  'Upgrade-Insecure-Requests',\n  'User-Agent',\n  'Vary',\n  'Via',\n  'WWW-Authenticate',\n  'X-Content-Type-Options',\n  'X-DNS-Prefetch-Control',\n  'X-Frame-Options',\n  'X-Permitted-Cross-Domain-Policies',\n  'X-Powered-By',\n  'X-Requested-With',\n  'X-XSS-Protection'\n])\n\n/** @type {Record<typeof wellknownHeaderNames[number]|Lowercase<typeof wellknownHeaderNames[number]>, string>} */\nconst headerNameLowerCasedRecord = {}\n\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(headerNameLowerCasedRecord, null)\n\n/**\n * @type {Record<Lowercase<typeof wellknownHeaderNames[number]>, Buffer>}\n */\nconst wellknownHeaderNameBuffers = {}\n\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(wellknownHeaderNameBuffers, null)\n\n/**\n * @param {string} header Lowercased header\n * @returns {Buffer}\n */\nfunction getHeaderNameAsBuffer (header) {\n  let buffer = wellknownHeaderNameBuffers[header]\n\n  if (buffer === undefined) {\n    buffer = Buffer.from(header)\n  }\n\n  return buffer\n}\n\nfor (let i = 0; i < wellknownHeaderNames.length; ++i) {\n  const key = wellknownHeaderNames[i]\n  const lowerCasedKey = key.toLowerCase()\n  headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] =\n    lowerCasedKey\n}\n\nmodule.exports = {\n  wellknownHeaderNames,\n  headerNameLowerCasedRecord,\n  getHeaderNameAsBuffer\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxvR0FBb0c7QUFDL0c7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUVFAvSGVhZGVyc1xuICovXG5jb25zdCB3ZWxsa25vd25IZWFkZXJOYW1lcyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG4gICdBY2NlcHQnLFxuICAnQWNjZXB0LUVuY29kaW5nJyxcbiAgJ0FjY2VwdC1MYW5ndWFnZScsXG4gICdBY2NlcHQtUmFuZ2VzJyxcbiAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzJyxcbiAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnMnLFxuICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctTWV0aG9kcycsXG4gICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nLFxuICAnQWNjZXNzLUNvbnRyb2wtRXhwb3NlLUhlYWRlcnMnLFxuICAnQWNjZXNzLUNvbnRyb2wtTWF4LUFnZScsXG4gICdBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LUhlYWRlcnMnLFxuICAnQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1NZXRob2QnLFxuICAnQWdlJyxcbiAgJ0FsbG93JyxcbiAgJ0FsdC1TdmMnLFxuICAnQWx0LVVzZWQnLFxuICAnQXV0aG9yaXphdGlvbicsXG4gICdDYWNoZS1Db250cm9sJyxcbiAgJ0NsZWFyLVNpdGUtRGF0YScsXG4gICdDb25uZWN0aW9uJyxcbiAgJ0NvbnRlbnQtRGlzcG9zaXRpb24nLFxuICAnQ29udGVudC1FbmNvZGluZycsXG4gICdDb250ZW50LUxhbmd1YWdlJyxcbiAgJ0NvbnRlbnQtTGVuZ3RoJyxcbiAgJ0NvbnRlbnQtTG9jYXRpb24nLFxuICAnQ29udGVudC1SYW5nZScsXG4gICdDb250ZW50LVNlY3VyaXR5LVBvbGljeScsXG4gICdDb250ZW50LVNlY3VyaXR5LVBvbGljeS1SZXBvcnQtT25seScsXG4gICdDb250ZW50LVR5cGUnLFxuICAnQ29va2llJyxcbiAgJ0Nyb3NzLU9yaWdpbi1FbWJlZGRlci1Qb2xpY3knLFxuICAnQ3Jvc3MtT3JpZ2luLU9wZW5lci1Qb2xpY3knLFxuICAnQ3Jvc3MtT3JpZ2luLVJlc291cmNlLVBvbGljeScsXG4gICdEYXRlJyxcbiAgJ0RldmljZS1NZW1vcnknLFxuICAnRG93bmxpbmsnLFxuICAnRUNUJyxcbiAgJ0VUYWcnLFxuICAnRXhwZWN0JyxcbiAgJ0V4cGVjdC1DVCcsXG4gICdFeHBpcmVzJyxcbiAgJ0ZvcndhcmRlZCcsXG4gICdGcm9tJyxcbiAgJ0hvc3QnLFxuICAnSWYtTWF0Y2gnLFxuICAnSWYtTW9kaWZpZWQtU2luY2UnLFxuICAnSWYtTm9uZS1NYXRjaCcsXG4gICdJZi1SYW5nZScsXG4gICdJZi1Vbm1vZGlmaWVkLVNpbmNlJyxcbiAgJ0tlZXAtQWxpdmUnLFxuICAnTGFzdC1Nb2RpZmllZCcsXG4gICdMaW5rJyxcbiAgJ0xvY2F0aW9uJyxcbiAgJ01heC1Gb3J3YXJkcycsXG4gICdPcmlnaW4nLFxuICAnUGVybWlzc2lvbnMtUG9saWN5JyxcbiAgJ1ByYWdtYScsXG4gICdQcm94eS1BdXRoZW50aWNhdGUnLFxuICAnUHJveHktQXV0aG9yaXphdGlvbicsXG4gICdSVFQnLFxuICAnUmFuZ2UnLFxuICAnUmVmZXJlcicsXG4gICdSZWZlcnJlci1Qb2xpY3knLFxuICAnUmVmcmVzaCcsXG4gICdSZXRyeS1BZnRlcicsXG4gICdTZWMtV2ViU29ja2V0LUFjY2VwdCcsXG4gICdTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnLFxuICAnU2VjLVdlYlNvY2tldC1LZXknLFxuICAnU2VjLVdlYlNvY2tldC1Qcm90b2NvbCcsXG4gICdTZWMtV2ViU29ja2V0LVZlcnNpb24nLFxuICAnU2VydmVyJyxcbiAgJ1NlcnZlci1UaW1pbmcnLFxuICAnU2VydmljZS1Xb3JrZXItQWxsb3dlZCcsXG4gICdTZXJ2aWNlLVdvcmtlci1OYXZpZ2F0aW9uLVByZWxvYWQnLFxuICAnU2V0LUNvb2tpZScsXG4gICdTb3VyY2VNYXAnLFxuICAnU3RyaWN0LVRyYW5zcG9ydC1TZWN1cml0eScsXG4gICdTdXBwb3J0cy1Mb2FkaW5nLU1vZGUnLFxuICAnVEUnLFxuICAnVGltaW5nLUFsbG93LU9yaWdpbicsXG4gICdUcmFpbGVyJyxcbiAgJ1RyYW5zZmVyLUVuY29kaW5nJyxcbiAgJ1VwZ3JhZGUnLFxuICAnVXBncmFkZS1JbnNlY3VyZS1SZXF1ZXN0cycsXG4gICdVc2VyLUFnZW50JyxcbiAgJ1ZhcnknLFxuICAnVmlhJyxcbiAgJ1dXVy1BdXRoZW50aWNhdGUnLFxuICAnWC1Db250ZW50LVR5cGUtT3B0aW9ucycsXG4gICdYLUROUy1QcmVmZXRjaC1Db250cm9sJyxcbiAgJ1gtRnJhbWUtT3B0aW9ucycsXG4gICdYLVBlcm1pdHRlZC1Dcm9zcy1Eb21haW4tUG9saWNpZXMnLFxuICAnWC1Qb3dlcmVkLUJ5JyxcbiAgJ1gtUmVxdWVzdGVkLVdpdGgnLFxuICAnWC1YU1MtUHJvdGVjdGlvbidcbl0pXG5cbi8qKiBAdHlwZSB7UmVjb3JkPHR5cGVvZiB3ZWxsa25vd25IZWFkZXJOYW1lc1tudW1iZXJdfExvd2VyY2FzZTx0eXBlb2Ygd2VsbGtub3duSGVhZGVyTmFtZXNbbnVtYmVyXT4sIHN0cmluZz59ICovXG5jb25zdCBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCA9IHt9XG5cbi8vIE5vdGU6IG9iamVjdCBwcm90b3R5cGVzIHNob3VsZCBub3QgYmUgYWJsZSB0byBiZSByZWZlcmVuY2VkLiBlLmcuIGBPYmplY3QjaGFzT3duUHJvcGVydHlgLlxuT2JqZWN0LnNldFByb3RvdHlwZU9mKGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkLCBudWxsKVxuXG4vKipcbiAqIEB0eXBlIHtSZWNvcmQ8TG93ZXJjYXNlPHR5cGVvZiB3ZWxsa25vd25IZWFkZXJOYW1lc1tudW1iZXJdPiwgQnVmZmVyPn1cbiAqL1xuY29uc3Qgd2VsbGtub3duSGVhZGVyTmFtZUJ1ZmZlcnMgPSB7fVxuXG4vLyBOb3RlOiBvYmplY3QgcHJvdG90eXBlcyBzaG91bGQgbm90IGJlIGFibGUgdG8gYmUgcmVmZXJlbmNlZC4gZS5nLiBgT2JqZWN0I2hhc093blByb3BlcnR5YC5cbk9iamVjdC5zZXRQcm90b3R5cGVPZih3ZWxsa25vd25IZWFkZXJOYW1lQnVmZmVycywgbnVsbClcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyIExvd2VyY2FzZWQgaGVhZGVyXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBnZXRIZWFkZXJOYW1lQXNCdWZmZXIgKGhlYWRlcikge1xuICBsZXQgYnVmZmVyID0gd2VsbGtub3duSGVhZGVyTmFtZUJ1ZmZlcnNbaGVhZGVyXVxuXG4gIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGhlYWRlcilcbiAgfVxuXG4gIHJldHVybiBidWZmZXJcbn1cblxuZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWxsa25vd25IZWFkZXJOYW1lcy5sZW5ndGg7ICsraSkge1xuICBjb25zdCBrZXkgPSB3ZWxsa25vd25IZWFkZXJOYW1lc1tpXVxuICBjb25zdCBsb3dlckNhc2VkS2V5ID0ga2V5LnRvTG93ZXJDYXNlKClcbiAgaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmRba2V5XSA9IGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkW2xvd2VyQ2FzZWRLZXldID1cbiAgICBsb3dlckNhc2VkS2V5XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3ZWxsa25vd25IZWFkZXJOYW1lcyxcbiAgaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQsXG4gIGdldEhlYWRlck5hbWVBc0J1ZmZlclxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/diagnostics.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/core/diagnostics.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst diagnosticsChannel = __webpack_require__(/*! node:diagnostics_channel */ \"node:diagnostics_channel\")\nconst util = __webpack_require__(/*! node:util */ \"node:util\")\n\nconst undiciDebugLog = util.debuglog('undici')\nconst fetchDebuglog = util.debuglog('fetch')\nconst websocketDebuglog = util.debuglog('websocket')\n\nconst channels = {\n  // Client\n  beforeConnect: diagnosticsChannel.channel('undici:client:beforeConnect'),\n  connected: diagnosticsChannel.channel('undici:client:connected'),\n  connectError: diagnosticsChannel.channel('undici:client:connectError'),\n  sendHeaders: diagnosticsChannel.channel('undici:client:sendHeaders'),\n  // Request\n  create: diagnosticsChannel.channel('undici:request:create'),\n  bodySent: diagnosticsChannel.channel('undici:request:bodySent'),\n  bodyChunkSent: diagnosticsChannel.channel('undici:request:bodyChunkSent'),\n  bodyChunkReceived: diagnosticsChannel.channel('undici:request:bodyChunkReceived'),\n  headers: diagnosticsChannel.channel('undici:request:headers'),\n  trailers: diagnosticsChannel.channel('undici:request:trailers'),\n  error: diagnosticsChannel.channel('undici:request:error'),\n  // WebSocket\n  open: diagnosticsChannel.channel('undici:websocket:open'),\n  close: diagnosticsChannel.channel('undici:websocket:close'),\n  socketError: diagnosticsChannel.channel('undici:websocket:socket_error'),\n  ping: diagnosticsChannel.channel('undici:websocket:ping'),\n  pong: diagnosticsChannel.channel('undici:websocket:pong')\n}\n\nlet isTrackingClientEvents = false\n\nfunction trackClientEvents (debugLog = undiciDebugLog) {\n  if (isTrackingClientEvents) {\n    return\n  }\n\n  isTrackingClientEvents = true\n\n  diagnosticsChannel.subscribe('undici:client:beforeConnect',\n    evt => {\n      const {\n        connectParams: { version, protocol, port, host }\n      } = evt\n      debugLog(\n        'connecting to %s%s using %s%s',\n        host,\n        port ? `:${port}` : '',\n        protocol,\n        version\n      )\n    })\n\n  diagnosticsChannel.subscribe('undici:client:connected',\n    evt => {\n      const {\n        connectParams: { version, protocol, port, host }\n      } = evt\n      debugLog(\n        'connected to %s%s using %s%s',\n        host,\n        port ? `:${port}` : '',\n        protocol,\n        version\n      )\n    })\n\n  diagnosticsChannel.subscribe('undici:client:connectError',\n    evt => {\n      const {\n        connectParams: { version, protocol, port, host },\n        error\n      } = evt\n      debugLog(\n        'connection to %s%s using %s%s errored - %s',\n        host,\n        port ? `:${port}` : '',\n        protocol,\n        version,\n        error.message\n      )\n    })\n\n  diagnosticsChannel.subscribe('undici:client:sendHeaders',\n    evt => {\n      const {\n        request: { method, path, origin }\n      } = evt\n      debugLog('sending request to %s %s%s', method, origin, path)\n    })\n}\n\nlet isTrackingRequestEvents = false\n\nfunction trackRequestEvents (debugLog = undiciDebugLog) {\n  if (isTrackingRequestEvents) {\n    return\n  }\n\n  isTrackingRequestEvents = true\n\n  diagnosticsChannel.subscribe('undici:request:headers',\n    evt => {\n      const {\n        request: { method, path, origin },\n        response: { statusCode }\n      } = evt\n      debugLog(\n        'received response to %s %s%s - HTTP %d',\n        method,\n        origin,\n        path,\n        statusCode\n      )\n    })\n\n  diagnosticsChannel.subscribe('undici:request:trailers',\n    evt => {\n      const {\n        request: { method, path, origin }\n      } = evt\n      debugLog('trailers received from %s %s%s', method, origin, path)\n    })\n\n  diagnosticsChannel.subscribe('undici:request:error',\n    evt => {\n      const {\n        request: { method, path, origin },\n        error\n      } = evt\n      debugLog(\n        'request to %s %s%s errored - %s',\n        method,\n        origin,\n        path,\n        error.message\n      )\n    })\n}\n\nlet isTrackingWebSocketEvents = false\n\nfunction trackWebSocketEvents (debugLog = websocketDebuglog) {\n  if (isTrackingWebSocketEvents) {\n    return\n  }\n\n  isTrackingWebSocketEvents = true\n\n  diagnosticsChannel.subscribe('undici:websocket:open',\n    evt => {\n      const {\n        address: { address, port }\n      } = evt\n      debugLog('connection opened %s%s', address, port ? `:${port}` : '')\n    })\n\n  diagnosticsChannel.subscribe('undici:websocket:close',\n    evt => {\n      const { websocket, code, reason } = evt\n      debugLog(\n        'closed connection to %s - %s %s',\n        websocket.url,\n        code,\n        reason\n      )\n    })\n\n  diagnosticsChannel.subscribe('undici:websocket:socket_error',\n    err => {\n      debugLog('connection errored - %s', err.message)\n    })\n\n  diagnosticsChannel.subscribe('undici:websocket:ping',\n    evt => {\n      debugLog('ping received')\n    })\n\n  diagnosticsChannel.subscribe('undici:websocket:pong',\n    evt => {\n      debugLog('pong received')\n    })\n}\n\nif (undiciDebugLog.enabled || fetchDebuglog.enabled) {\n  trackClientEvents(fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog)\n  trackRequestEvents(fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog)\n}\n\nif (websocketDebuglog.enabled) {\n  trackClientEvents(undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog)\n  trackWebSocketEvents(websocketDebuglog)\n}\n\nmodule.exports = {\n  channels\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2RpYWdub3N0aWNzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLDJCQUEyQixtQkFBTyxDQUFDLDBEQUEwQjtBQUM3RCxhQUFhLG1CQUFPLENBQUMsNEJBQVc7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsK0JBQStCO0FBQ3hEO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixLQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMsb0JBQW9CO0FBQ3BCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFFBQVE7QUFDUjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsUUFBUTtBQUNSLDZEQUE2RCxLQUFLO0FBQ2xFLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9kaWFnbm9zdGljcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZGlhZ25vc3RpY3NDaGFubmVsID0gcmVxdWlyZSgnbm9kZTpkaWFnbm9zdGljc19jaGFubmVsJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuXG5jb25zdCB1bmRpY2lEZWJ1Z0xvZyA9IHV0aWwuZGVidWdsb2coJ3VuZGljaScpXG5jb25zdCBmZXRjaERlYnVnbG9nID0gdXRpbC5kZWJ1Z2xvZygnZmV0Y2gnKVxuY29uc3Qgd2Vic29ja2V0RGVidWdsb2cgPSB1dGlsLmRlYnVnbG9nKCd3ZWJzb2NrZXQnKVxuXG5jb25zdCBjaGFubmVscyA9IHtcbiAgLy8gQ2xpZW50XG4gIGJlZm9yZUNvbm5lY3Q6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OmJlZm9yZUNvbm5lY3QnKSxcbiAgY29ubmVjdGVkOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpjb25uZWN0ZWQnKSxcbiAgY29ubmVjdEVycm9yOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpjb25uZWN0RXJyb3InKSxcbiAgc2VuZEhlYWRlcnM6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OnNlbmRIZWFkZXJzJyksXG4gIC8vIFJlcXVlc3RcbiAgY3JlYXRlOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6Y3JlYXRlJyksXG4gIGJvZHlTZW50OiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6Ym9keVNlbnQnKSxcbiAgYm9keUNodW5rU2VudDogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmJvZHlDaHVua1NlbnQnKSxcbiAgYm9keUNodW5rUmVjZWl2ZWQ6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDpib2R5Q2h1bmtSZWNlaXZlZCcpLFxuICBoZWFkZXJzOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6aGVhZGVycycpLFxuICB0cmFpbGVyczogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OnRyYWlsZXJzJyksXG4gIGVycm9yOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6ZXJyb3InKSxcbiAgLy8gV2ViU29ja2V0XG4gIG9wZW46IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0Om9wZW4nKSxcbiAgY2xvc2U6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OmNsb3NlJyksXG4gIHNvY2tldEVycm9yOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpzb2NrZXRfZXJyb3InKSxcbiAgcGluZzogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6cGluZycpLFxuICBwb25nOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpwb25nJylcbn1cblxubGV0IGlzVHJhY2tpbmdDbGllbnRFdmVudHMgPSBmYWxzZVxuXG5mdW5jdGlvbiB0cmFja0NsaWVudEV2ZW50cyAoZGVidWdMb2cgPSB1bmRpY2lEZWJ1Z0xvZykge1xuICBpZiAoaXNUcmFja2luZ0NsaWVudEV2ZW50cykge1xuICAgIHJldHVyblxuICB9XG5cbiAgaXNUcmFja2luZ0NsaWVudEV2ZW50cyA9IHRydWVcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuc3Vic2NyaWJlKCd1bmRpY2k6Y2xpZW50OmJlZm9yZUNvbm5lY3QnLFxuICAgIGV2dCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbm5lY3RQYXJhbXM6IHsgdmVyc2lvbiwgcHJvdG9jb2wsIHBvcnQsIGhvc3QgfVxuICAgICAgfSA9IGV2dFxuICAgICAgZGVidWdMb2coXG4gICAgICAgICdjb25uZWN0aW5nIHRvICVzJXMgdXNpbmcgJXMlcycsXG4gICAgICAgIGhvc3QsXG4gICAgICAgIHBvcnQgPyBgOiR7cG9ydH1gIDogJycsXG4gICAgICAgIHByb3RvY29sLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICApXG4gICAgfSlcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuc3Vic2NyaWJlKCd1bmRpY2k6Y2xpZW50OmNvbm5lY3RlZCcsXG4gICAgZXZ0ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29ubmVjdFBhcmFtczogeyB2ZXJzaW9uLCBwcm90b2NvbCwgcG9ydCwgaG9zdCB9XG4gICAgICB9ID0gZXZ0XG4gICAgICBkZWJ1Z0xvZyhcbiAgICAgICAgJ2Nvbm5lY3RlZCB0byAlcyVzIHVzaW5nICVzJXMnLFxuICAgICAgICBob3N0LFxuICAgICAgICBwb3J0ID8gYDoke3BvcnR9YCA6ICcnLFxuICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgdmVyc2lvblxuICAgICAgKVxuICAgIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLnN1YnNjcmliZSgndW5kaWNpOmNsaWVudDpjb25uZWN0RXJyb3InLFxuICAgIGV2dCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbm5lY3RQYXJhbXM6IHsgdmVyc2lvbiwgcHJvdG9jb2wsIHBvcnQsIGhvc3QgfSxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0gPSBldnRcbiAgICAgIGRlYnVnTG9nKFxuICAgICAgICAnY29ubmVjdGlvbiB0byAlcyVzIHVzaW5nICVzJXMgZXJyb3JlZCAtICVzJyxcbiAgICAgICAgaG9zdCxcbiAgICAgICAgcG9ydCA/IGA6JHtwb3J0fWAgOiAnJyxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIGVycm9yLm1lc3NhZ2VcbiAgICAgIClcbiAgICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5zdWJzY3JpYmUoJ3VuZGljaTpjbGllbnQ6c2VuZEhlYWRlcnMnLFxuICAgIGV2dCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kLCBwYXRoLCBvcmlnaW4gfVxuICAgICAgfSA9IGV2dFxuICAgICAgZGVidWdMb2coJ3NlbmRpbmcgcmVxdWVzdCB0byAlcyAlcyVzJywgbWV0aG9kLCBvcmlnaW4sIHBhdGgpXG4gICAgfSlcbn1cblxubGV0IGlzVHJhY2tpbmdSZXF1ZXN0RXZlbnRzID0gZmFsc2VcblxuZnVuY3Rpb24gdHJhY2tSZXF1ZXN0RXZlbnRzIChkZWJ1Z0xvZyA9IHVuZGljaURlYnVnTG9nKSB7XG4gIGlmIChpc1RyYWNraW5nUmVxdWVzdEV2ZW50cykge1xuICAgIHJldHVyblxuICB9XG5cbiAgaXNUcmFja2luZ1JlcXVlc3RFdmVudHMgPSB0cnVlXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLnN1YnNjcmliZSgndW5kaWNpOnJlcXVlc3Q6aGVhZGVycycsXG4gICAgZXZ0ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVxdWVzdDogeyBtZXRob2QsIHBhdGgsIG9yaWdpbiB9LFxuICAgICAgICByZXNwb25zZTogeyBzdGF0dXNDb2RlIH1cbiAgICAgIH0gPSBldnRcbiAgICAgIGRlYnVnTG9nKFxuICAgICAgICAncmVjZWl2ZWQgcmVzcG9uc2UgdG8gJXMgJXMlcyAtIEhUVFAgJWQnLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgcGF0aCxcbiAgICAgICAgc3RhdHVzQ29kZVxuICAgICAgKVxuICAgIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLnN1YnNjcmliZSgndW5kaWNpOnJlcXVlc3Q6dHJhaWxlcnMnLFxuICAgIGV2dCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kLCBwYXRoLCBvcmlnaW4gfVxuICAgICAgfSA9IGV2dFxuICAgICAgZGVidWdMb2coJ3RyYWlsZXJzIHJlY2VpdmVkIGZyb20gJXMgJXMlcycsIG1ldGhvZCwgb3JpZ2luLCBwYXRoKVxuICAgIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLnN1YnNjcmliZSgndW5kaWNpOnJlcXVlc3Q6ZXJyb3InLFxuICAgIGV2dCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kLCBwYXRoLCBvcmlnaW4gfSxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0gPSBldnRcbiAgICAgIGRlYnVnTG9nKFxuICAgICAgICAncmVxdWVzdCB0byAlcyAlcyVzIGVycm9yZWQgLSAlcycsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICBwYXRoLFxuICAgICAgICBlcnJvci5tZXNzYWdlXG4gICAgICApXG4gICAgfSlcbn1cblxubGV0IGlzVHJhY2tpbmdXZWJTb2NrZXRFdmVudHMgPSBmYWxzZVxuXG5mdW5jdGlvbiB0cmFja1dlYlNvY2tldEV2ZW50cyAoZGVidWdMb2cgPSB3ZWJzb2NrZXREZWJ1Z2xvZykge1xuICBpZiAoaXNUcmFja2luZ1dlYlNvY2tldEV2ZW50cykge1xuICAgIHJldHVyblxuICB9XG5cbiAgaXNUcmFja2luZ1dlYlNvY2tldEV2ZW50cyA9IHRydWVcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuc3Vic2NyaWJlKCd1bmRpY2k6d2Vic29ja2V0Om9wZW4nLFxuICAgIGV2dCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFkZHJlc3M6IHsgYWRkcmVzcywgcG9ydCB9XG4gICAgICB9ID0gZXZ0XG4gICAgICBkZWJ1Z0xvZygnY29ubmVjdGlvbiBvcGVuZWQgJXMlcycsIGFkZHJlc3MsIHBvcnQgPyBgOiR7cG9ydH1gIDogJycpXG4gICAgfSlcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuc3Vic2NyaWJlKCd1bmRpY2k6d2Vic29ja2V0OmNsb3NlJyxcbiAgICBldnQgPT4ge1xuICAgICAgY29uc3QgeyB3ZWJzb2NrZXQsIGNvZGUsIHJlYXNvbiB9ID0gZXZ0XG4gICAgICBkZWJ1Z0xvZyhcbiAgICAgICAgJ2Nsb3NlZCBjb25uZWN0aW9uIHRvICVzIC0gJXMgJXMnLFxuICAgICAgICB3ZWJzb2NrZXQudXJsLFxuICAgICAgICBjb2RlLFxuICAgICAgICByZWFzb25cbiAgICAgIClcbiAgICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5zdWJzY3JpYmUoJ3VuZGljaTp3ZWJzb2NrZXQ6c29ja2V0X2Vycm9yJyxcbiAgICBlcnIgPT4ge1xuICAgICAgZGVidWdMb2coJ2Nvbm5lY3Rpb24gZXJyb3JlZCAtICVzJywgZXJyLm1lc3NhZ2UpXG4gICAgfSlcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuc3Vic2NyaWJlKCd1bmRpY2k6d2Vic29ja2V0OnBpbmcnLFxuICAgIGV2dCA9PiB7XG4gICAgICBkZWJ1Z0xvZygncGluZyByZWNlaXZlZCcpXG4gICAgfSlcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuc3Vic2NyaWJlKCd1bmRpY2k6d2Vic29ja2V0OnBvbmcnLFxuICAgIGV2dCA9PiB7XG4gICAgICBkZWJ1Z0xvZygncG9uZyByZWNlaXZlZCcpXG4gICAgfSlcbn1cblxuaWYgKHVuZGljaURlYnVnTG9nLmVuYWJsZWQgfHwgZmV0Y2hEZWJ1Z2xvZy5lbmFibGVkKSB7XG4gIHRyYWNrQ2xpZW50RXZlbnRzKGZldGNoRGVidWdsb2cuZW5hYmxlZCA/IGZldGNoRGVidWdsb2cgOiB1bmRpY2lEZWJ1Z0xvZylcbiAgdHJhY2tSZXF1ZXN0RXZlbnRzKGZldGNoRGVidWdsb2cuZW5hYmxlZCA/IGZldGNoRGVidWdsb2cgOiB1bmRpY2lEZWJ1Z0xvZylcbn1cblxuaWYgKHdlYnNvY2tldERlYnVnbG9nLmVuYWJsZWQpIHtcbiAgdHJhY2tDbGllbnRFdmVudHModW5kaWNpRGVidWdMb2cuZW5hYmxlZCA/IHVuZGljaURlYnVnTG9nIDogd2Vic29ja2V0RGVidWdsb2cpXG4gIHRyYWNrV2ViU29ja2V0RXZlbnRzKHdlYnNvY2tldERlYnVnbG9nKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2hhbm5lbHNcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/diagnostics.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/errors.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/core/errors.js ***!
  \************************************************/
/***/ ((module) => {

eval("\n\nclass UndiciError extends Error {\n  constructor (message, options) {\n    super(message, options)\n    this.name = 'UndiciError'\n    this.code = 'UND_ERR'\n  }\n}\n\nclass ConnectTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ConnectTimeoutError'\n    this.message = message || 'Connect Timeout Error'\n    this.code = 'UND_ERR_CONNECT_TIMEOUT'\n  }\n}\n\nclass HeadersTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'HeadersTimeoutError'\n    this.message = message || 'Headers Timeout Error'\n    this.code = 'UND_ERR_HEADERS_TIMEOUT'\n  }\n}\n\nclass HeadersOverflowError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'HeadersOverflowError'\n    this.message = message || 'Headers Overflow Error'\n    this.code = 'UND_ERR_HEADERS_OVERFLOW'\n  }\n}\n\nclass BodyTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'BodyTimeoutError'\n    this.message = message || 'Body Timeout Error'\n    this.code = 'UND_ERR_BODY_TIMEOUT'\n  }\n}\n\nclass ResponseStatusCodeError extends UndiciError {\n  constructor (message, statusCode, headers, body) {\n    super(message)\n    this.name = 'ResponseStatusCodeError'\n    this.message = message || 'Response Status Code Error'\n    this.code = 'UND_ERR_RESPONSE_STATUS_CODE'\n    this.body = body\n    this.status = statusCode\n    this.statusCode = statusCode\n    this.headers = headers\n  }\n}\n\nclass InvalidArgumentError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'InvalidArgumentError'\n    this.message = message || 'Invalid Argument Error'\n    this.code = 'UND_ERR_INVALID_ARG'\n  }\n}\n\nclass InvalidReturnValueError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'InvalidReturnValueError'\n    this.message = message || 'Invalid Return Value Error'\n    this.code = 'UND_ERR_INVALID_RETURN_VALUE'\n  }\n}\n\nclass AbortError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'AbortError'\n    this.message = message || 'The operation was aborted'\n  }\n}\n\nclass RequestAbortedError extends AbortError {\n  constructor (message) {\n    super(message)\n    this.name = 'AbortError'\n    this.message = message || 'Request aborted'\n    this.code = 'UND_ERR_ABORTED'\n  }\n}\n\nclass InformationalError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'InformationalError'\n    this.message = message || 'Request information'\n    this.code = 'UND_ERR_INFO'\n  }\n}\n\nclass RequestContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'RequestContentLengthMismatchError'\n    this.message = message || 'Request body length does not match content-length header'\n    this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH'\n  }\n}\n\nclass ResponseContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ResponseContentLengthMismatchError'\n    this.message = message || 'Response body length does not match content-length header'\n    this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH'\n  }\n}\n\nclass ClientDestroyedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ClientDestroyedError'\n    this.message = message || 'The client is destroyed'\n    this.code = 'UND_ERR_DESTROYED'\n  }\n}\n\nclass ClientClosedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ClientClosedError'\n    this.message = message || 'The client is closed'\n    this.code = 'UND_ERR_CLOSED'\n  }\n}\n\nclass SocketError extends UndiciError {\n  constructor (message, socket) {\n    super(message)\n    this.name = 'SocketError'\n    this.message = message || 'Socket error'\n    this.code = 'UND_ERR_SOCKET'\n    this.socket = socket\n  }\n}\n\nclass NotSupportedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'NotSupportedError'\n    this.message = message || 'Not supported error'\n    this.code = 'UND_ERR_NOT_SUPPORTED'\n  }\n}\n\nclass BalancedPoolMissingUpstreamError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'MissingUpstreamError'\n    this.message = message || 'No upstream has been added to the BalancedPool'\n    this.code = 'UND_ERR_BPL_MISSING_UPSTREAM'\n  }\n}\n\nclass HTTPParserError extends Error {\n  constructor (message, code, data) {\n    super(message)\n    this.name = 'HTTPParserError'\n    this.code = code ? `HPE_${code}` : undefined\n    this.data = data ? data.toString() : undefined\n  }\n}\n\nclass ResponseExceededMaxSizeError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ResponseExceededMaxSizeError'\n    this.message = message || 'Response content exceeded max size'\n    this.code = 'UND_ERR_RES_EXCEEDED_MAX_SIZE'\n  }\n}\n\nclass RequestRetryError extends UndiciError {\n  constructor (message, code, { headers, data }) {\n    super(message)\n    this.name = 'RequestRetryError'\n    this.message = message || 'Request retry error'\n    this.code = 'UND_ERR_REQ_RETRY'\n    this.statusCode = code\n    this.data = data\n    this.headers = headers\n  }\n}\n\nclass ResponseError extends UndiciError {\n  constructor (message, code, { headers, body }) {\n    super(message)\n    this.name = 'ResponseError'\n    this.message = message || 'Response error'\n    this.code = 'UND_ERR_RESPONSE'\n    this.statusCode = code\n    this.body = body\n    this.headers = headers\n  }\n}\n\nclass SecureProxyConnectionError extends UndiciError {\n  constructor (cause, message, options = {}) {\n    super(message, { cause, ...options })\n    this.name = 'SecureProxyConnectionError'\n    this.message = message || 'Secure Proxy Connection failed'\n    this.code = 'UND_ERR_PRX_TLS'\n    this.cause = cause\n  }\n}\n\nmodule.exports = {\n  AbortError,\n  HTTPParserError,\n  UndiciError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  BodyTimeoutError,\n  RequestContentLengthMismatchError,\n  ConnectTimeoutError,\n  ResponseStatusCodeError,\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError,\n  ClientDestroyedError,\n  ClientClosedError,\n  InformationalError,\n  SocketError,\n  NotSupportedError,\n  ResponseContentLengthMismatchError,\n  BalancedPoolMissingUpstreamError,\n  ResponseExceededMaxSizeError,\n  RequestRetryError,\n  ResponseError,\n  SecureProxyConnectionError\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jbGFzcyBVbmRpY2lFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKVxuICAgIHRoaXMubmFtZSA9ICdVbmRpY2lFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUidcbiAgfVxufVxuXG5jbGFzcyBDb25uZWN0VGltZW91dEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0Nvbm5lY3RUaW1lb3V0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnQ29ubmVjdCBUaW1lb3V0IEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0NPTk5FQ1RfVElNRU9VVCdcbiAgfVxufVxuXG5jbGFzcyBIZWFkZXJzVGltZW91dEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0hlYWRlcnNUaW1lb3V0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnSGVhZGVycyBUaW1lb3V0IEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0hFQURFUlNfVElNRU9VVCdcbiAgfVxufVxuXG5jbGFzcyBIZWFkZXJzT3ZlcmZsb3dFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdIZWFkZXJzT3ZlcmZsb3dFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdIZWFkZXJzIE92ZXJmbG93IEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0hFQURFUlNfT1ZFUkZMT1cnXG4gIH1cbn1cblxuY2xhc3MgQm9keVRpbWVvdXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdCb2R5VGltZW91dEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0JvZHkgVGltZW91dCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9CT0RZX1RJTUVPVVQnXG4gIH1cbn1cblxuY2xhc3MgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBib2R5KSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVzcG9uc2UgU3RhdHVzIENvZGUgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfUkVTUE9OU0VfU1RBVFVTX0NPREUnXG4gICAgdGhpcy5ib2R5ID0gYm9keVxuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzQ29kZVxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGVcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gIH1cbn1cblxuY2xhc3MgSW52YWxpZEFyZ3VtZW50RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSW52YWxpZEFyZ3VtZW50RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnSW52YWxpZCBBcmd1bWVudCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9JTlZBTElEX0FSRydcbiAgfVxufVxuXG5jbGFzcyBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdJbnZhbGlkIFJldHVybiBWYWx1ZSBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSdcbiAgfVxufVxuXG5jbGFzcyBBYm9ydEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0Fib3J0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZCdcbiAgfVxufVxuXG5jbGFzcyBSZXF1ZXN0QWJvcnRlZEVycm9yIGV4dGVuZHMgQWJvcnRFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQWJvcnRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXF1ZXN0IGFib3J0ZWQnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfQUJPUlRFRCdcbiAgfVxufVxuXG5jbGFzcyBJbmZvcm1hdGlvbmFsRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSW5mb3JtYXRpb25hbEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1JlcXVlc3QgaW5mb3JtYXRpb24nXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSU5GTydcbiAgfVxufVxuXG5jbGFzcyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1JlcXVlc3QgYm9keSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggY29udGVudC1sZW5ndGggaGVhZGVyJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFUV9DT05URU5UX0xFTkdUSF9NSVNNQVRDSCdcbiAgfVxufVxuXG5jbGFzcyBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1Jlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVzcG9uc2UgYm9keSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggY29udGVudC1sZW5ndGggaGVhZGVyJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFU19DT05URU5UX0xFTkdUSF9NSVNNQVRDSCdcbiAgfVxufVxuXG5jbGFzcyBDbGllbnREZXN0cm95ZWRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdDbGllbnREZXN0cm95ZWRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdUaGUgY2xpZW50IGlzIGRlc3Ryb3llZCdcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9ERVNUUk9ZRUQnXG4gIH1cbn1cblxuY2xhc3MgQ2xpZW50Q2xvc2VkRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQ2xpZW50Q2xvc2VkRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVGhlIGNsaWVudCBpcyBjbG9zZWQnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfQ0xPU0VEJ1xuICB9XG59XG5cbmNsYXNzIFNvY2tldEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgc29ja2V0KSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnU29ja2V0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnU29ja2V0IGVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1NPQ0tFVCdcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICB9XG59XG5cbmNsYXNzIE5vdFN1cHBvcnRlZEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ05vdFN1cHBvcnRlZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ05vdCBzdXBwb3J0ZWQgZXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfTk9UX1NVUFBPUlRFRCdcbiAgfVxufVxuXG5jbGFzcyBCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdNaXNzaW5nVXBzdHJlYW1FcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdObyB1cHN0cmVhbSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgQmFsYW5jZWRQb29sJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0JQTF9NSVNTSU5HX1VQU1RSRUFNJ1xuICB9XG59XG5cbmNsYXNzIEhUVFBQYXJzZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGNvZGUsIGRhdGEpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdIVFRQUGFyc2VyRXJyb3InXG4gICAgdGhpcy5jb2RlID0gY29kZSA/IGBIUEVfJHtjb2RlfWAgOiB1bmRlZmluZWRcbiAgICB0aGlzLmRhdGEgPSBkYXRhID8gZGF0YS50b1N0cmluZygpIDogdW5kZWZpbmVkXG4gIH1cbn1cblxuY2xhc3MgUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Jlc3BvbnNlIGNvbnRlbnQgZXhjZWVkZWQgbWF4IHNpemUnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfUkVTX0VYQ0VFREVEX01BWF9TSVpFJ1xuICB9XG59XG5cbmNsYXNzIFJlcXVlc3RSZXRyeUVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgY29kZSwgeyBoZWFkZXJzLCBkYXRhIH0pIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdSZXF1ZXN0UmV0cnlFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXF1ZXN0IHJldHJ5IGVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFUV9SRVRSWSdcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBjb2RlXG4gICAgdGhpcy5kYXRhID0gZGF0YVxuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnNcbiAgfVxufVxuXG5jbGFzcyBSZXNwb25zZUVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgY29kZSwgeyBoZWFkZXJzLCBib2R5IH0pIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdSZXNwb25zZUVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Jlc3BvbnNlIGVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFU1BPTlNFJ1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IGNvZGVcbiAgICB0aGlzLmJvZHkgPSBib2R5XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVyc1xuICB9XG59XG5cbmNsYXNzIFNlY3VyZVByb3h5Q29ubmVjdGlvbkVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAoY2F1c2UsIG1lc3NhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHsgY2F1c2UsIC4uLm9wdGlvbnMgfSlcbiAgICB0aGlzLm5hbWUgPSAnU2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnU2VjdXJlIFByb3h5IENvbm5lY3Rpb24gZmFpbGVkJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1BSWF9UTFMnXG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFib3J0RXJyb3IsXG4gIEhUVFBQYXJzZXJFcnJvcixcbiAgVW5kaWNpRXJyb3IsXG4gIEhlYWRlcnNUaW1lb3V0RXJyb3IsXG4gIEhlYWRlcnNPdmVyZmxvd0Vycm9yLFxuICBCb2R5VGltZW91dEVycm9yLFxuICBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IsXG4gIENvbm5lY3RUaW1lb3V0RXJyb3IsXG4gIFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZFJldHVyblZhbHVlRXJyb3IsXG4gIFJlcXVlc3RBYm9ydGVkRXJyb3IsXG4gIENsaWVudERlc3Ryb3llZEVycm9yLFxuICBDbGllbnRDbG9zZWRFcnJvcixcbiAgSW5mb3JtYXRpb25hbEVycm9yLFxuICBTb2NrZXRFcnJvcixcbiAgTm90U3VwcG9ydGVkRXJyb3IsXG4gIFJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IsXG4gIEJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yLFxuICBSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yLFxuICBSZXF1ZXN0UmV0cnlFcnJvcixcbiAgUmVzcG9uc2VFcnJvcixcbiAgU2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3Jcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/request.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/request.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  InvalidArgumentError,\n  NotSupportedError\n} = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst {\n  isValidHTTPToken,\n  isValidHeaderValue,\n  isStream,\n  destroy,\n  isBuffer,\n  isFormDataLike,\n  isIterable,\n  isBlobLike,\n  serializePathWithQuery,\n  assertRequestHandler,\n  getServerName,\n  normalizedMethodRecords\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { channels } = __webpack_require__(/*! ./diagnostics.js */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\nconst { headerNameLowerCasedRecord } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/core/constants.js\")\n\n// Verifies that a given path is valid does not contain control chars \\x00 to \\x20\nconst invalidPathRegex = /[^\\u0021-\\u00ff]/\n\nconst kHandler = Symbol('handler')\n\nclass Request {\n  constructor (origin, {\n    path,\n    method,\n    body,\n    headers,\n    query,\n    idempotent,\n    blocking,\n    upgrade,\n    headersTimeout,\n    bodyTimeout,\n    reset,\n    expectContinue,\n    servername,\n    throwOnError\n  }, handler) {\n    if (typeof path !== 'string') {\n      throw new InvalidArgumentError('path must be a string')\n    } else if (\n      path[0] !== '/' &&\n      !(path.startsWith('http://') || path.startsWith('https://')) &&\n      method !== 'CONNECT'\n    ) {\n      throw new InvalidArgumentError('path must be an absolute URL or start with a slash')\n    } else if (invalidPathRegex.test(path)) {\n      throw new InvalidArgumentError('invalid request path')\n    }\n\n    if (typeof method !== 'string') {\n      throw new InvalidArgumentError('method must be a string')\n    } else if (normalizedMethodRecords[method] === undefined && !isValidHTTPToken(method)) {\n      throw new InvalidArgumentError('invalid request method')\n    }\n\n    if (upgrade && typeof upgrade !== 'string') {\n      throw new InvalidArgumentError('upgrade must be a string')\n    }\n\n    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('invalid headersTimeout')\n    }\n\n    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('invalid bodyTimeout')\n    }\n\n    if (reset != null && typeof reset !== 'boolean') {\n      throw new InvalidArgumentError('invalid reset')\n    }\n\n    if (expectContinue != null && typeof expectContinue !== 'boolean') {\n      throw new InvalidArgumentError('invalid expectContinue')\n    }\n\n    if (throwOnError != null) {\n      throw new InvalidArgumentError('invalid throwOnError')\n    }\n\n    this.headersTimeout = headersTimeout\n\n    this.bodyTimeout = bodyTimeout\n\n    this.method = method\n\n    this.abort = null\n\n    if (body == null) {\n      this.body = null\n    } else if (isStream(body)) {\n      this.body = body\n\n      const rState = this.body._readableState\n      if (!rState || !rState.autoDestroy) {\n        this.endHandler = function autoDestroy () {\n          destroy(this)\n        }\n        this.body.on('end', this.endHandler)\n      }\n\n      this.errorHandler = err => {\n        if (this.abort) {\n          this.abort(err)\n        } else {\n          this.error = err\n        }\n      }\n      this.body.on('error', this.errorHandler)\n    } else if (isBuffer(body)) {\n      this.body = body.byteLength ? body : null\n    } else if (ArrayBuffer.isView(body)) {\n      this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null\n    } else if (body instanceof ArrayBuffer) {\n      this.body = body.byteLength ? Buffer.from(body) : null\n    } else if (typeof body === 'string') {\n      this.body = body.length ? Buffer.from(body) : null\n    } else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) {\n      this.body = body\n    } else {\n      throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable')\n    }\n\n    this.completed = false\n    this.aborted = false\n\n    this.upgrade = upgrade || null\n\n    this.path = query ? serializePathWithQuery(path, query) : path\n\n    this.origin = origin\n\n    this.idempotent = idempotent == null\n      ? method === 'HEAD' || method === 'GET'\n      : idempotent\n\n    this.blocking = blocking ?? this.method !== 'HEAD'\n\n    this.reset = reset == null ? null : reset\n\n    this.host = null\n\n    this.contentLength = null\n\n    this.contentType = null\n\n    this.headers = []\n\n    // Only for H2\n    this.expectContinue = expectContinue != null ? expectContinue : false\n\n    if (Array.isArray(headers)) {\n      if (headers.length % 2 !== 0) {\n        throw new InvalidArgumentError('headers array must be even')\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        processHeader(this, headers[i], headers[i + 1])\n      }\n    } else if (headers && typeof headers === 'object') {\n      if (headers[Symbol.iterator]) {\n        for (const header of headers) {\n          if (!Array.isArray(header) || header.length !== 2) {\n            throw new InvalidArgumentError('headers must be in key-value pair format')\n          }\n          processHeader(this, header[0], header[1])\n        }\n      } else {\n        const keys = Object.keys(headers)\n        for (let i = 0; i < keys.length; ++i) {\n          processHeader(this, keys[i], headers[keys[i]])\n        }\n      }\n    } else if (headers != null) {\n      throw new InvalidArgumentError('headers must be an object or an array')\n    }\n\n    assertRequestHandler(handler, method, upgrade)\n\n    this.servername = servername || getServerName(this.host) || null\n\n    this[kHandler] = handler\n\n    if (channels.create.hasSubscribers) {\n      channels.create.publish({ request: this })\n    }\n  }\n\n  onBodySent (chunk) {\n    if (channels.bodyChunkSent.hasSubscribers) {\n      channels.bodyChunkSent.publish({ request: this, chunk })\n    }\n    if (this[kHandler].onBodySent) {\n      try {\n        return this[kHandler].onBodySent(chunk)\n      } catch (err) {\n        this.abort(err)\n      }\n    }\n  }\n\n  onRequestSent () {\n    if (channels.bodySent.hasSubscribers) {\n      channels.bodySent.publish({ request: this })\n    }\n\n    if (this[kHandler].onRequestSent) {\n      try {\n        return this[kHandler].onRequestSent()\n      } catch (err) {\n        this.abort(err)\n      }\n    }\n  }\n\n  onConnect (abort) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (this.error) {\n      abort(this.error)\n    } else {\n      this.abort = abort\n      return this[kHandler].onConnect(abort)\n    }\n  }\n\n  onResponseStarted () {\n    return this[kHandler].onResponseStarted?.()\n  }\n\n  onHeaders (statusCode, headers, resume, statusText) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (channels.headers.hasSubscribers) {\n      channels.headers.publish({ request: this, response: { statusCode, headers, statusText } })\n    }\n\n    try {\n      return this[kHandler].onHeaders(statusCode, headers, resume, statusText)\n    } catch (err) {\n      this.abort(err)\n    }\n  }\n\n  onData (chunk) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (channels.bodyChunkReceived.hasSubscribers) {\n      channels.bodyChunkReceived.publish({ request: this, chunk })\n    }\n    try {\n      return this[kHandler].onData(chunk)\n    } catch (err) {\n      this.abort(err)\n      return false\n    }\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    return this[kHandler].onUpgrade(statusCode, headers, socket)\n  }\n\n  onComplete (trailers) {\n    this.onFinally()\n\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    this.completed = true\n    if (channels.trailers.hasSubscribers) {\n      channels.trailers.publish({ request: this, trailers })\n    }\n\n    try {\n      return this[kHandler].onComplete(trailers)\n    } catch (err) {\n      // TODO (fix): This might be a bad idea?\n      this.onError(err)\n    }\n  }\n\n  onError (error) {\n    this.onFinally()\n\n    if (channels.error.hasSubscribers) {\n      channels.error.publish({ request: this, error })\n    }\n\n    if (this.aborted) {\n      return\n    }\n    this.aborted = true\n\n    return this[kHandler].onError(error)\n  }\n\n  onFinally () {\n    if (this.errorHandler) {\n      this.body.off('error', this.errorHandler)\n      this.errorHandler = null\n    }\n\n    if (this.endHandler) {\n      this.body.off('end', this.endHandler)\n      this.endHandler = null\n    }\n  }\n\n  addHeader (key, value) {\n    processHeader(this, key, value)\n    return this\n  }\n}\n\nfunction processHeader (request, key, val) {\n  if (val && (typeof val === 'object' && !Array.isArray(val))) {\n    throw new InvalidArgumentError(`invalid ${key} header`)\n  } else if (val === undefined) {\n    return\n  }\n\n  let headerName = headerNameLowerCasedRecord[key]\n\n  if (headerName === undefined) {\n    headerName = key.toLowerCase()\n    if (headerNameLowerCasedRecord[headerName] === undefined && !isValidHTTPToken(headerName)) {\n      throw new InvalidArgumentError('invalid header key')\n    }\n  }\n\n  if (Array.isArray(val)) {\n    const arr = []\n    for (let i = 0; i < val.length; i++) {\n      if (typeof val[i] === 'string') {\n        if (!isValidHeaderValue(val[i])) {\n          throw new InvalidArgumentError(`invalid ${key} header`)\n        }\n        arr.push(val[i])\n      } else if (val[i] === null) {\n        arr.push('')\n      } else if (typeof val[i] === 'object') {\n        throw new InvalidArgumentError(`invalid ${key} header`)\n      } else {\n        arr.push(`${val[i]}`)\n      }\n    }\n    val = arr\n  } else if (typeof val === 'string') {\n    if (!isValidHeaderValue(val)) {\n      throw new InvalidArgumentError(`invalid ${key} header`)\n    }\n  } else if (val === null) {\n    val = ''\n  } else {\n    val = `${val}`\n  }\n\n  if (request.host === null && headerName === 'host') {\n    if (typeof val !== 'string') {\n      throw new InvalidArgumentError('invalid host header')\n    }\n    // Consumed by Client\n    request.host = val\n  } else if (request.contentLength === null && headerName === 'content-length') {\n    request.contentLength = parseInt(val, 10)\n    if (!Number.isFinite(request.contentLength)) {\n      throw new InvalidArgumentError('invalid content-length header')\n    }\n  } else if (request.contentType === null && headerName === 'content-type') {\n    request.contentType = val\n    request.headers.push(key, val)\n  } else if (headerName === 'transfer-encoding' || headerName === 'keep-alive' || headerName === 'upgrade') {\n    throw new InvalidArgumentError(`invalid ${headerName} header`)\n  } else if (headerName === 'connection') {\n    const value = typeof val === 'string' ? val.toLowerCase() : null\n    if (value !== 'close' && value !== 'keep-alive') {\n      throw new InvalidArgumentError('invalid connection header')\n    }\n\n    if (value === 'close') {\n      request.reset = true\n    }\n  } else if (headerName === 'expect') {\n    throw new NotSupportedError('expect header not supported')\n  } else {\n    request.headers.push(key, val)\n  }\n}\n\nmodule.exports = Request\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3JlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsZ0VBQVU7QUFDdEIsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNERBQVE7QUFDcEIsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyw2RUFBa0I7QUFDL0MsUUFBUSw2QkFBNkIsRUFBRSxtQkFBTyxDQUFDLHNFQUFhOztBQUU1RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWU7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsMkJBQTJCLG1DQUFtQztBQUMvRjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsc0JBQXNCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBLG9EQUFvRCxLQUFLO0FBQ3pEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1Isa0RBQWtELEtBQUs7QUFDdkQsUUFBUTtBQUNSLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGdEQUFnRCxLQUFLO0FBQ3JEO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLGFBQWEsSUFBSTtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSiw4Q0FBOEMsWUFBWTtBQUMxRCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3JlcXVlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIE5vdFN1cHBvcnRlZEVycm9yXG59ID0gcmVxdWlyZSgnLi9lcnJvcnMnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3Qge1xuICBpc1ZhbGlkSFRUUFRva2VuLFxuICBpc1ZhbGlkSGVhZGVyVmFsdWUsXG4gIGlzU3RyZWFtLFxuICBkZXN0cm95LFxuICBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YUxpa2UsXG4gIGlzSXRlcmFibGUsXG4gIGlzQmxvYkxpa2UsXG4gIHNlcmlhbGl6ZVBhdGhXaXRoUXVlcnksXG4gIGFzc2VydFJlcXVlc3RIYW5kbGVyLFxuICBnZXRTZXJ2ZXJOYW1lLFxuICBub3JtYWxpemVkTWV0aG9kUmVjb3Jkc1xufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuL2RpYWdub3N0aWNzLmpzJylcbmNvbnN0IHsgaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuLy8gVmVyaWZpZXMgdGhhdCBhIGdpdmVuIHBhdGggaXMgdmFsaWQgZG9lcyBub3QgY29udGFpbiBjb250cm9sIGNoYXJzIFxceDAwIHRvIFxceDIwXG5jb25zdCBpbnZhbGlkUGF0aFJlZ2V4ID0gL1teXFx1MDAyMS1cXHUwMGZmXS9cblxuY29uc3Qga0hhbmRsZXIgPSBTeW1ib2woJ2hhbmRsZXInKVxuXG5jbGFzcyBSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IgKG9yaWdpbiwge1xuICAgIHBhdGgsXG4gICAgbWV0aG9kLFxuICAgIGJvZHksXG4gICAgaGVhZGVycyxcbiAgICBxdWVyeSxcbiAgICBpZGVtcG90ZW50LFxuICAgIGJsb2NraW5nLFxuICAgIHVwZ3JhZGUsXG4gICAgaGVhZGVyc1RpbWVvdXQsXG4gICAgYm9keVRpbWVvdXQsXG4gICAgcmVzZXQsXG4gICAgZXhwZWN0Q29udGludWUsXG4gICAgc2VydmVybmFtZSxcbiAgICB0aHJvd09uRXJyb3JcbiAgfSwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncGF0aCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgcGF0aFswXSAhPT0gJy8nICYmXG4gICAgICAhKHBhdGguc3RhcnRzV2l0aCgnaHR0cDovLycpIHx8IHBhdGguc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkgJiZcbiAgICAgIG1ldGhvZCAhPT0gJ0NPTk5FQ1QnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3BhdGggbXVzdCBiZSBhbiBhYnNvbHV0ZSBVUkwgb3Igc3RhcnQgd2l0aCBhIHNsYXNoJylcbiAgICB9IGVsc2UgaWYgKGludmFsaWRQYXRoUmVnZXgudGVzdChwYXRoKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlcXVlc3QgcGF0aCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21ldGhvZCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzW21ldGhvZF0gPT09IHVuZGVmaW5lZCAmJiAhaXNWYWxpZEhUVFBUb2tlbihtZXRob2QpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgcmVxdWVzdCBtZXRob2QnKVxuICAgIH1cblxuICAgIGlmICh1cGdyYWRlICYmIHR5cGVvZiB1cGdyYWRlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1cGdyYWRlIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cblxuICAgIGlmIChoZWFkZXJzVGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGhlYWRlcnNUaW1lb3V0KSB8fCBoZWFkZXJzVGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGVhZGVyc1RpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChib2R5VGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGJvZHlUaW1lb3V0KSB8fCBib2R5VGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgYm9keVRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChyZXNldCAhPSBudWxsICYmIHR5cGVvZiByZXNldCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgcmVzZXQnKVxuICAgIH1cblxuICAgIGlmIChleHBlY3RDb250aW51ZSAhPSBudWxsICYmIHR5cGVvZiBleHBlY3RDb250aW51ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgZXhwZWN0Q29udGludWUnKVxuICAgIH1cblxuICAgIGlmICh0aHJvd09uRXJyb3IgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHRocm93T25FcnJvcicpXG4gICAgfVxuXG4gICAgdGhpcy5oZWFkZXJzVGltZW91dCA9IGhlYWRlcnNUaW1lb3V0XG5cbiAgICB0aGlzLmJvZHlUaW1lb3V0ID0gYm9keVRpbWVvdXRcblxuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kXG5cbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuXG4gICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgdGhpcy5ib2R5ID0gbnVsbFxuICAgIH0gZWxzZSBpZiAoaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHlcblxuICAgICAgY29uc3QgclN0YXRlID0gdGhpcy5ib2R5Ll9yZWFkYWJsZVN0YXRlXG4gICAgICBpZiAoIXJTdGF0ZSB8fCAhclN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAgIHRoaXMuZW5kSGFuZGxlciA9IGZ1bmN0aW9uIGF1dG9EZXN0cm95ICgpIHtcbiAgICAgICAgICBkZXN0cm95KHRoaXMpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5Lm9uKCdlbmQnLCB0aGlzLmVuZEhhbmRsZXIpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gZXJyID0+IHtcbiAgICAgICAgaWYgKHRoaXMuYWJvcnQpIHtcbiAgICAgICAgICB0aGlzLmFib3J0KGVycilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVycm9yID0gZXJyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keS5vbignZXJyb3InLCB0aGlzLmVycm9ySGFuZGxlcilcbiAgICB9IGVsc2UgaWYgKGlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5LmJ5dGVMZW5ndGggPyBib2R5IDogbnVsbFxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5LmJ1ZmZlci5ieXRlTGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keS5idWZmZXIsIGJvZHkuYnl0ZU9mZnNldCwgYm9keS5ieXRlTGVuZ3RoKSA6IG51bGxcbiAgICB9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keS5ieXRlTGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keSkgOiBudWxsXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHkubGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keSkgOiBudWxsXG4gICAgfSBlbHNlIGlmIChpc0Zvcm1EYXRhTGlrZShib2R5KSB8fCBpc0l0ZXJhYmxlKGJvZHkpIHx8IGlzQmxvYkxpa2UoYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdib2R5IG11c3QgYmUgYSBzdHJpbmcsIGEgQnVmZmVyLCBhIFJlYWRhYmxlIHN0cmVhbSwgYW4gaXRlcmFibGUsIG9yIGFuIGFzeW5jIGl0ZXJhYmxlJylcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlXG4gICAgdGhpcy5hYm9ydGVkID0gZmFsc2VcblxuICAgIHRoaXMudXBncmFkZSA9IHVwZ3JhZGUgfHwgbnVsbFxuXG4gICAgdGhpcy5wYXRoID0gcXVlcnkgPyBzZXJpYWxpemVQYXRoV2l0aFF1ZXJ5KHBhdGgsIHF1ZXJ5KSA6IHBhdGhcblxuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luXG5cbiAgICB0aGlzLmlkZW1wb3RlbnQgPSBpZGVtcG90ZW50ID09IG51bGxcbiAgICAgID8gbWV0aG9kID09PSAnSEVBRCcgfHwgbWV0aG9kID09PSAnR0VUJ1xuICAgICAgOiBpZGVtcG90ZW50XG5cbiAgICB0aGlzLmJsb2NraW5nID0gYmxvY2tpbmcgPz8gdGhpcy5tZXRob2QgIT09ICdIRUFEJ1xuXG4gICAgdGhpcy5yZXNldCA9IHJlc2V0ID09IG51bGwgPyBudWxsIDogcmVzZXRcblxuICAgIHRoaXMuaG9zdCA9IG51bGxcblxuICAgIHRoaXMuY29udGVudExlbmd0aCA9IG51bGxcblxuICAgIHRoaXMuY29udGVudFR5cGUgPSBudWxsXG5cbiAgICB0aGlzLmhlYWRlcnMgPSBbXVxuXG4gICAgLy8gT25seSBmb3IgSDJcbiAgICB0aGlzLmV4cGVjdENvbnRpbnVlID0gZXhwZWN0Q29udGludWUgIT0gbnVsbCA/IGV4cGVjdENvbnRpbnVlIDogZmFsc2VcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBpZiAoaGVhZGVycy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVycyBhcnJheSBtdXN0IGJlIGV2ZW4nKVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHByb2Nlc3NIZWFkZXIodGhpcywgaGVhZGVyc1tpXSwgaGVhZGVyc1tpICsgMV0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzICYmIHR5cGVvZiBoZWFkZXJzID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGhlYWRlcnNbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBoZWFkZXJzKSB7XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGhlYWRlcikgfHwgaGVhZGVyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzIG11c3QgYmUgaW4ga2V5LXZhbHVlIHBhaXIgZm9ybWF0JylcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzc0hlYWRlcih0aGlzLCBoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHByb2Nlc3NIZWFkZXIodGhpcywga2V5c1tpXSwgaGVhZGVyc1trZXlzW2ldXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGVhZGVycyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnMgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXknKVxuICAgIH1cblxuICAgIGFzc2VydFJlcXVlc3RIYW5kbGVyKGhhbmRsZXIsIG1ldGhvZCwgdXBncmFkZSlcblxuICAgIHRoaXMuc2VydmVybmFtZSA9IHNlcnZlcm5hbWUgfHwgZ2V0U2VydmVyTmFtZSh0aGlzLmhvc3QpIHx8IG51bGxcblxuICAgIHRoaXNba0hhbmRsZXJdID0gaGFuZGxlclxuXG4gICAgaWYgKGNoYW5uZWxzLmNyZWF0ZS5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuY3JlYXRlLnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzIH0pXG4gICAgfVxuICB9XG5cbiAgb25Cb2R5U2VudCAoY2h1bmspIHtcbiAgICBpZiAoY2hhbm5lbHMuYm9keUNodW5rU2VudC5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuYm9keUNodW5rU2VudC5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgY2h1bmsgfSlcbiAgICB9XG4gICAgaWYgKHRoaXNba0hhbmRsZXJdLm9uQm9keVNlbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkJvZHlTZW50KGNodW5rKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuYWJvcnQoZXJyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uUmVxdWVzdFNlbnQgKCkge1xuICAgIGlmIChjaGFubmVscy5ib2R5U2VudC5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuYm9keVNlbnQucHVibGlzaCh7IHJlcXVlc3Q6IHRoaXMgfSlcbiAgICB9XG5cbiAgICBpZiAodGhpc1trSGFuZGxlcl0ub25SZXF1ZXN0U2VudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uUmVxdWVzdFNlbnQoKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuYWJvcnQoZXJyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQpIHtcbiAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZClcbiAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKVxuXG4gICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgIGFib3J0KHRoaXMuZXJyb3IpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uQ29ubmVjdChhYm9ydClcbiAgICB9XG4gIH1cblxuICBvblJlc3BvbnNlU3RhcnRlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uUmVzcG9uc2VTdGFydGVkPy4oKVxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXN1bWUsIHN0YXR1c1RleHQpIHtcbiAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZClcbiAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKVxuXG4gICAgaWYgKGNoYW5uZWxzLmhlYWRlcnMuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmhlYWRlcnMucHVibGlzaCh7IHJlcXVlc3Q6IHRoaXMsIHJlc3BvbnNlOiB7IHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c1RleHQgfSB9KVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25IZWFkZXJzKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3VtZSwgc3RhdHVzVGV4dClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuYWJvcnQoZXJyKVxuICAgIH1cbiAgfVxuXG4gIG9uRGF0YSAoY2h1bmspIHtcbiAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZClcbiAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKVxuXG4gICAgaWYgKGNoYW5uZWxzLmJvZHlDaHVua1JlY2VpdmVkLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5ib2R5Q2h1bmtSZWNlaXZlZC5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgY2h1bmsgfSlcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkRhdGEoY2h1bmspXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmFib3J0KGVycilcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIG9uVXBncmFkZSAoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KSB7XG4gICAgYXNzZXJ0KCF0aGlzLmFib3J0ZWQpXG4gICAgYXNzZXJ0KCF0aGlzLmNvbXBsZXRlZClcblxuICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vblVwZ3JhZGUoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KVxuICB9XG5cbiAgb25Db21wbGV0ZSAodHJhaWxlcnMpIHtcbiAgICB0aGlzLm9uRmluYWxseSgpXG5cbiAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZClcbiAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKVxuXG4gICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlXG4gICAgaWYgKGNoYW5uZWxzLnRyYWlsZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy50cmFpbGVycy5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgdHJhaWxlcnMgfSlcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uQ29tcGxldGUodHJhaWxlcnMpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBUT0RPIChmaXgpOiBUaGlzIG1pZ2h0IGJlIGEgYmFkIGlkZWE/XG4gICAgICB0aGlzLm9uRXJyb3IoZXJyKVxuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IgKGVycm9yKSB7XG4gICAgdGhpcy5vbkZpbmFsbHkoKVxuXG4gICAgaWYgKGNoYW5uZWxzLmVycm9yLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5lcnJvci5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgZXJyb3IgfSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5hYm9ydGVkID0gdHJ1ZVxuXG4gICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uRXJyb3IoZXJyb3IpXG4gIH1cblxuICBvbkZpbmFsbHkgKCkge1xuICAgIGlmICh0aGlzLmVycm9ySGFuZGxlcikge1xuICAgICAgdGhpcy5ib2R5Lm9mZignZXJyb3InLCB0aGlzLmVycm9ySGFuZGxlcilcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gbnVsbFxuICAgIH1cblxuICAgIGlmICh0aGlzLmVuZEhhbmRsZXIpIHtcbiAgICAgIHRoaXMuYm9keS5vZmYoJ2VuZCcsIHRoaXMuZW5kSGFuZGxlcilcbiAgICAgIHRoaXMuZW5kSGFuZGxlciA9IG51bGxcbiAgICB9XG4gIH1cblxuICBhZGRIZWFkZXIgKGtleSwgdmFsdWUpIHtcbiAgICBwcm9jZXNzSGVhZGVyKHRoaXMsIGtleSwgdmFsdWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSGVhZGVyIChyZXF1ZXN0LCBrZXksIHZhbCkge1xuICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWwpKSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgaW52YWxpZCAke2tleX0gaGVhZGVyYClcbiAgfSBlbHNlIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IGhlYWRlck5hbWUgPSBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFtrZXldXG5cbiAgaWYgKGhlYWRlck5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGhlYWRlck5hbWUgPSBrZXkudG9Mb3dlckNhc2UoKVxuICAgIGlmIChoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFtoZWFkZXJOYW1lXSA9PT0gdW5kZWZpbmVkICYmICFpc1ZhbGlkSFRUUFRva2VuKGhlYWRlck5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGVhZGVyIGtleScpXG4gICAgfVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGNvbnN0IGFyciA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWxbaV0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7a2V5fSBoZWFkZXJgKVxuICAgICAgICB9XG4gICAgICAgIGFyci5wdXNoKHZhbFtpXSlcbiAgICAgIH0gZWxzZSBpZiAodmFsW2ldID09PSBudWxsKSB7XG4gICAgICAgIGFyci5wdXNoKCcnKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtrZXl9IGhlYWRlcmApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnIucHVzaChgJHt2YWxbaV19YClcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsID0gYXJyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWwpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtrZXl9IGhlYWRlcmApXG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHZhbCA9ICcnXG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYCR7dmFsfWBcbiAgfVxuXG4gIGlmIChyZXF1ZXN0Lmhvc3QgPT09IG51bGwgJiYgaGVhZGVyTmFtZSA9PT0gJ2hvc3QnKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaG9zdCBoZWFkZXInKVxuICAgIH1cbiAgICAvLyBDb25zdW1lZCBieSBDbGllbnRcbiAgICByZXF1ZXN0Lmhvc3QgPSB2YWxcbiAgfSBlbHNlIGlmIChyZXF1ZXN0LmNvbnRlbnRMZW5ndGggPT09IG51bGwgJiYgaGVhZGVyTmFtZSA9PT0gJ2NvbnRlbnQtbGVuZ3RoJykge1xuICAgIHJlcXVlc3QuY29udGVudExlbmd0aCA9IHBhcnNlSW50KHZhbCwgMTApXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocmVxdWVzdC5jb250ZW50TGVuZ3RoKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcicpXG4gICAgfVxuICB9IGVsc2UgaWYgKHJlcXVlc3QuY29udGVudFR5cGUgPT09IG51bGwgJiYgaGVhZGVyTmFtZSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICByZXF1ZXN0LmNvbnRlbnRUeXBlID0gdmFsXG4gICAgcmVxdWVzdC5oZWFkZXJzLnB1c2goa2V5LCB2YWwpXG4gIH0gZWxzZSBpZiAoaGVhZGVyTmFtZSA9PT0gJ3RyYW5zZmVyLWVuY29kaW5nJyB8fCBoZWFkZXJOYW1lID09PSAna2VlcC1hbGl2ZScgfHwgaGVhZGVyTmFtZSA9PT0gJ3VwZ3JhZGUnKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7aGVhZGVyTmFtZX0gaGVhZGVyYClcbiAgfSBlbHNlIGlmIChoZWFkZXJOYW1lID09PSAnY29ubmVjdGlvbicpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gdmFsLnRvTG93ZXJDYXNlKCkgOiBudWxsXG4gICAgaWYgKHZhbHVlICE9PSAnY2xvc2UnICYmIHZhbHVlICE9PSAna2VlcC1hbGl2ZScpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjb25uZWN0aW9uIGhlYWRlcicpXG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnY2xvc2UnKSB7XG4gICAgICByZXF1ZXN0LnJlc2V0ID0gdHJ1ZVxuICAgIH1cbiAgfSBlbHNlIGlmIChoZWFkZXJOYW1lID09PSAnZXhwZWN0Jykge1xuICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcignZXhwZWN0IGhlYWRlciBub3Qgc3VwcG9ydGVkJylcbiAgfSBlbHNlIHtcbiAgICByZXF1ZXN0LmhlYWRlcnMucHVzaChrZXksIHZhbClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/symbols.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/symbols.js ***!
  \*************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = {\n  kClose: Symbol('close'),\n  kDestroy: Symbol('destroy'),\n  kDispatch: Symbol('dispatch'),\n  kUrl: Symbol('url'),\n  kWriting: Symbol('writing'),\n  kResuming: Symbol('resuming'),\n  kQueue: Symbol('queue'),\n  kConnect: Symbol('connect'),\n  kConnecting: Symbol('connecting'),\n  kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),\n  kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),\n  kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),\n  kKeepAliveTimeoutValue: Symbol('keep alive timeout'),\n  kKeepAlive: Symbol('keep alive'),\n  kHeadersTimeout: Symbol('headers timeout'),\n  kBodyTimeout: Symbol('body timeout'),\n  kServerName: Symbol('server name'),\n  kLocalAddress: Symbol('local address'),\n  kHost: Symbol('host'),\n  kNoRef: Symbol('no ref'),\n  kBodyUsed: Symbol('used'),\n  kBody: Symbol('abstracted request body'),\n  kRunning: Symbol('running'),\n  kBlocking: Symbol('blocking'),\n  kPending: Symbol('pending'),\n  kSize: Symbol('size'),\n  kBusy: Symbol('busy'),\n  kQueued: Symbol('queued'),\n  kFree: Symbol('free'),\n  kConnected: Symbol('connected'),\n  kClosed: Symbol('closed'),\n  kNeedDrain: Symbol('need drain'),\n  kReset: Symbol('reset'),\n  kDestroyed: Symbol.for('nodejs.stream.destroyed'),\n  kResume: Symbol('resume'),\n  kOnError: Symbol('on error'),\n  kMaxHeadersSize: Symbol('max headers size'),\n  kRunningIdx: Symbol('running index'),\n  kPendingIdx: Symbol('pending index'),\n  kError: Symbol('error'),\n  kClients: Symbol('clients'),\n  kClient: Symbol('client'),\n  kParser: Symbol('parser'),\n  kOnDestroyed: Symbol('destroy callbacks'),\n  kPipelining: Symbol('pipelining'),\n  kSocket: Symbol('socket'),\n  kHostHeader: Symbol('host header'),\n  kConnector: Symbol('connector'),\n  kStrictContentLength: Symbol('strict content length'),\n  kMaxRedirections: Symbol('maxRedirections'),\n  kMaxRequests: Symbol('maxRequestsPerClient'),\n  kProxy: Symbol('proxy agent options'),\n  kCounter: Symbol('socket request counter'),\n  kMaxResponseSize: Symbol('max response size'),\n  kHTTP2Session: Symbol('http2Session'),\n  kHTTP2SessionState: Symbol('http2Session state'),\n  kRetryHandlerDefaultRetry: Symbol('retry agent default retry'),\n  kConstruct: Symbol('constructable'),\n  kListeners: Symbol('listeners'),\n  kHTTPContext: Symbol('http context'),\n  kMaxConcurrentStreams: Symbol('max concurrent streams'),\n  kNoProxyAgent: Symbol('no proxy agent'),\n  kHttpProxyAgent: Symbol('http proxy agent'),\n  kHttpsProxyAgent: Symbol('https proxy agent')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvc3ltYm9scy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtDbG9zZTogU3ltYm9sKCdjbG9zZScpLFxuICBrRGVzdHJveTogU3ltYm9sKCdkZXN0cm95JyksXG4gIGtEaXNwYXRjaDogU3ltYm9sKCdkaXNwYXRjaCcpLFxuICBrVXJsOiBTeW1ib2woJ3VybCcpLFxuICBrV3JpdGluZzogU3ltYm9sKCd3cml0aW5nJyksXG4gIGtSZXN1bWluZzogU3ltYm9sKCdyZXN1bWluZycpLFxuICBrUXVldWU6IFN5bWJvbCgncXVldWUnKSxcbiAga0Nvbm5lY3Q6IFN5bWJvbCgnY29ubmVjdCcpLFxuICBrQ29ubmVjdGluZzogU3ltYm9sKCdjb25uZWN0aW5nJyksXG4gIGtLZWVwQWxpdmVEZWZhdWx0VGltZW91dDogU3ltYm9sKCdkZWZhdWx0IGtlZXAgYWxpdmUgdGltZW91dCcpLFxuICBrS2VlcEFsaXZlTWF4VGltZW91dDogU3ltYm9sKCdtYXgga2VlcCBhbGl2ZSB0aW1lb3V0JyksXG4gIGtLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkOiBTeW1ib2woJ2tlZXAgYWxpdmUgdGltZW91dCB0aHJlc2hvbGQnKSxcbiAga0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZTogU3ltYm9sKCdrZWVwIGFsaXZlIHRpbWVvdXQnKSxcbiAga0tlZXBBbGl2ZTogU3ltYm9sKCdrZWVwIGFsaXZlJyksXG4gIGtIZWFkZXJzVGltZW91dDogU3ltYm9sKCdoZWFkZXJzIHRpbWVvdXQnKSxcbiAga0JvZHlUaW1lb3V0OiBTeW1ib2woJ2JvZHkgdGltZW91dCcpLFxuICBrU2VydmVyTmFtZTogU3ltYm9sKCdzZXJ2ZXIgbmFtZScpLFxuICBrTG9jYWxBZGRyZXNzOiBTeW1ib2woJ2xvY2FsIGFkZHJlc3MnKSxcbiAga0hvc3Q6IFN5bWJvbCgnaG9zdCcpLFxuICBrTm9SZWY6IFN5bWJvbCgnbm8gcmVmJyksXG4gIGtCb2R5VXNlZDogU3ltYm9sKCd1c2VkJyksXG4gIGtCb2R5OiBTeW1ib2woJ2Fic3RyYWN0ZWQgcmVxdWVzdCBib2R5JyksXG4gIGtSdW5uaW5nOiBTeW1ib2woJ3J1bm5pbmcnKSxcbiAga0Jsb2NraW5nOiBTeW1ib2woJ2Jsb2NraW5nJyksXG4gIGtQZW5kaW5nOiBTeW1ib2woJ3BlbmRpbmcnKSxcbiAga1NpemU6IFN5bWJvbCgnc2l6ZScpLFxuICBrQnVzeTogU3ltYm9sKCdidXN5JyksXG4gIGtRdWV1ZWQ6IFN5bWJvbCgncXVldWVkJyksXG4gIGtGcmVlOiBTeW1ib2woJ2ZyZWUnKSxcbiAga0Nvbm5lY3RlZDogU3ltYm9sKCdjb25uZWN0ZWQnKSxcbiAga0Nsb3NlZDogU3ltYm9sKCdjbG9zZWQnKSxcbiAga05lZWREcmFpbjogU3ltYm9sKCduZWVkIGRyYWluJyksXG4gIGtSZXNldDogU3ltYm9sKCdyZXNldCcpLFxuICBrRGVzdHJveWVkOiBTeW1ib2wuZm9yKCdub2RlanMuc3RyZWFtLmRlc3Ryb3llZCcpLFxuICBrUmVzdW1lOiBTeW1ib2woJ3Jlc3VtZScpLFxuICBrT25FcnJvcjogU3ltYm9sKCdvbiBlcnJvcicpLFxuICBrTWF4SGVhZGVyc1NpemU6IFN5bWJvbCgnbWF4IGhlYWRlcnMgc2l6ZScpLFxuICBrUnVubmluZ0lkeDogU3ltYm9sKCdydW5uaW5nIGluZGV4JyksXG4gIGtQZW5kaW5nSWR4OiBTeW1ib2woJ3BlbmRpbmcgaW5kZXgnKSxcbiAga0Vycm9yOiBTeW1ib2woJ2Vycm9yJyksXG4gIGtDbGllbnRzOiBTeW1ib2woJ2NsaWVudHMnKSxcbiAga0NsaWVudDogU3ltYm9sKCdjbGllbnQnKSxcbiAga1BhcnNlcjogU3ltYm9sKCdwYXJzZXInKSxcbiAga09uRGVzdHJveWVkOiBTeW1ib2woJ2Rlc3Ryb3kgY2FsbGJhY2tzJyksXG4gIGtQaXBlbGluaW5nOiBTeW1ib2woJ3BpcGVsaW5pbmcnKSxcbiAga1NvY2tldDogU3ltYm9sKCdzb2NrZXQnKSxcbiAga0hvc3RIZWFkZXI6IFN5bWJvbCgnaG9zdCBoZWFkZXInKSxcbiAga0Nvbm5lY3RvcjogU3ltYm9sKCdjb25uZWN0b3InKSxcbiAga1N0cmljdENvbnRlbnRMZW5ndGg6IFN5bWJvbCgnc3RyaWN0IGNvbnRlbnQgbGVuZ3RoJyksXG4gIGtNYXhSZWRpcmVjdGlvbnM6IFN5bWJvbCgnbWF4UmVkaXJlY3Rpb25zJyksXG4gIGtNYXhSZXF1ZXN0czogU3ltYm9sKCdtYXhSZXF1ZXN0c1BlckNsaWVudCcpLFxuICBrUHJveHk6IFN5bWJvbCgncHJveHkgYWdlbnQgb3B0aW9ucycpLFxuICBrQ291bnRlcjogU3ltYm9sKCdzb2NrZXQgcmVxdWVzdCBjb3VudGVyJyksXG4gIGtNYXhSZXNwb25zZVNpemU6IFN5bWJvbCgnbWF4IHJlc3BvbnNlIHNpemUnKSxcbiAga0hUVFAyU2Vzc2lvbjogU3ltYm9sKCdodHRwMlNlc3Npb24nKSxcbiAga0hUVFAyU2Vzc2lvblN0YXRlOiBTeW1ib2woJ2h0dHAyU2Vzc2lvbiBzdGF0ZScpLFxuICBrUmV0cnlIYW5kbGVyRGVmYXVsdFJldHJ5OiBTeW1ib2woJ3JldHJ5IGFnZW50IGRlZmF1bHQgcmV0cnknKSxcbiAga0NvbnN0cnVjdDogU3ltYm9sKCdjb25zdHJ1Y3RhYmxlJyksXG4gIGtMaXN0ZW5lcnM6IFN5bWJvbCgnbGlzdGVuZXJzJyksXG4gIGtIVFRQQ29udGV4dDogU3ltYm9sKCdodHRwIGNvbnRleHQnKSxcbiAga01heENvbmN1cnJlbnRTdHJlYW1zOiBTeW1ib2woJ21heCBjb25jdXJyZW50IHN0cmVhbXMnKSxcbiAga05vUHJveHlBZ2VudDogU3ltYm9sKCdubyBwcm94eSBhZ2VudCcpLFxuICBrSHR0cFByb3h5QWdlbnQ6IFN5bWJvbCgnaHR0cCBwcm94eSBhZ2VudCcpLFxuICBrSHR0cHNQcm94eUFnZW50OiBTeW1ib2woJ2h0dHBzIHByb3h5IGFnZW50Jylcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/tree.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/core/tree.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  wellknownHeaderNames,\n  headerNameLowerCasedRecord\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/core/constants.js\")\n\nclass TstNode {\n  /** @type {any} */\n  value = null\n  /** @type {null | TstNode} */\n  left = null\n  /** @type {null | TstNode} */\n  middle = null\n  /** @type {null | TstNode} */\n  right = null\n  /** @type {number} */\n  code\n  /**\n   * @param {string} key\n   * @param {any} value\n   * @param {number} index\n   */\n  constructor (key, value, index) {\n    if (index === undefined || index >= key.length) {\n      throw new TypeError('Unreachable')\n    }\n    const code = this.code = key.charCodeAt(index)\n    // check code is ascii string\n    if (code > 0x7F) {\n      throw new TypeError('key must be ascii string')\n    }\n    if (key.length !== ++index) {\n      this.middle = new TstNode(key, value, index)\n    } else {\n      this.value = value\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} value\n   * @returns {void}\n   */\n  add (key, value) {\n    const length = key.length\n    if (length === 0) {\n      throw new TypeError('Unreachable')\n    }\n    let index = 0\n    /**\n     * @type {TstNode}\n     */\n    let node = this\n    while (true) {\n      const code = key.charCodeAt(index)\n      // check code is ascii string\n      if (code > 0x7F) {\n        throw new TypeError('key must be ascii string')\n      }\n      if (node.code === code) {\n        if (length === ++index) {\n          node.value = value\n          break\n        } else if (node.middle !== null) {\n          node = node.middle\n        } else {\n          node.middle = new TstNode(key, value, index)\n          break\n        }\n      } else if (node.code < code) {\n        if (node.left !== null) {\n          node = node.left\n        } else {\n          node.left = new TstNode(key, value, index)\n          break\n        }\n      } else if (node.right !== null) {\n        node = node.right\n      } else {\n        node.right = new TstNode(key, value, index)\n        break\n      }\n    }\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @return {TstNode | null}\n   */\n  search (key) {\n    const keylength = key.length\n    let index = 0\n    /**\n     * @type {TstNode|null}\n     */\n    let node = this\n    while (node !== null && index < keylength) {\n      let code = key[index]\n      // A-Z\n      // First check if it is bigger than 0x5a.\n      // Lowercase letters have higher char codes than uppercase ones.\n      // Also we assume that headers will mostly contain lowercase characters.\n      if (code <= 0x5a && code >= 0x41) {\n        // Lowercase for uppercase.\n        code |= 32\n      }\n      while (node !== null) {\n        if (code === node.code) {\n          if (keylength === ++index) {\n            // Returns Node since it is the last key.\n            return node\n          }\n          node = node.middle\n          break\n        }\n        node = node.code < code ? node.left : node.right\n      }\n    }\n    return null\n  }\n}\n\nclass TernarySearchTree {\n  /** @type {TstNode | null} */\n  node = null\n\n  /**\n   * @param {string} key\n   * @param {any} value\n   * @returns {void}\n   * */\n  insert (key, value) {\n    if (this.node === null) {\n      this.node = new TstNode(key, value, 0)\n    } else {\n      this.node.add(key, value)\n    }\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @returns {any}\n   */\n  lookup (key) {\n    return this.node?.search(key)?.value ?? null\n  }\n}\n\nconst tree = new TernarySearchTree()\n\nfor (let i = 0; i < wellknownHeaderNames.length; ++i) {\n  const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]]\n  tree.insert(key, key)\n}\n\nmodule.exports = {\n  TernarySearchTree,\n  tree\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3RyZWUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsc0VBQWE7O0FBRXpCO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsS0FBSztBQUNsQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS90cmVlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIHdlbGxrbm93bkhlYWRlck5hbWVzLFxuICBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuY2xhc3MgVHN0Tm9kZSB7XG4gIC8qKiBAdHlwZSB7YW55fSAqL1xuICB2YWx1ZSA9IG51bGxcbiAgLyoqIEB0eXBlIHtudWxsIHwgVHN0Tm9kZX0gKi9cbiAgbGVmdCA9IG51bGxcbiAgLyoqIEB0eXBlIHtudWxsIHwgVHN0Tm9kZX0gKi9cbiAgbWlkZGxlID0gbnVsbFxuICAvKiogQHR5cGUge251bGwgfCBUc3ROb2RlfSAqL1xuICByaWdodCA9IG51bGxcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIGNvZGVcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPj0ga2V5Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWFjaGFibGUnKVxuICAgIH1cbiAgICBjb25zdCBjb2RlID0gdGhpcy5jb2RlID0ga2V5LmNoYXJDb2RlQXQoaW5kZXgpXG4gICAgLy8gY2hlY2sgY29kZSBpcyBhc2NpaSBzdHJpbmdcbiAgICBpZiAoY29kZSA+IDB4N0YpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2tleSBtdXN0IGJlIGFzY2lpIHN0cmluZycpXG4gICAgfVxuICAgIGlmIChrZXkubGVuZ3RoICE9PSArK2luZGV4KSB7XG4gICAgICB0aGlzLm1pZGRsZSA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIGluZGV4KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBhZGQgKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBsZW5ndGggPSBrZXkubGVuZ3RoXG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWFjaGFibGUnKVxuICAgIH1cbiAgICBsZXQgaW5kZXggPSAwXG4gICAgLyoqXG4gICAgICogQHR5cGUge1RzdE5vZGV9XG4gICAgICovXG4gICAgbGV0IG5vZGUgPSB0aGlzXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBrZXkuY2hhckNvZGVBdChpbmRleClcbiAgICAgIC8vIGNoZWNrIGNvZGUgaXMgYXNjaWkgc3RyaW5nXG4gICAgICBpZiAoY29kZSA+IDB4N0YpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigna2V5IG11c3QgYmUgYXNjaWkgc3RyaW5nJylcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNvZGUgPT09IGNvZGUpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gKytpbmRleCkge1xuICAgICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5taWRkbGUgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5taWRkbGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLm1pZGRsZSA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIGluZGV4KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jb2RlIDwgY29kZSkge1xuICAgICAgICBpZiAobm9kZS5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUubGVmdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUubGVmdCA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIGluZGV4KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gbm9kZS5yaWdodFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yaWdodCA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIGluZGV4KVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGtleVxuICAgKiBAcmV0dXJuIHtUc3ROb2RlIHwgbnVsbH1cbiAgICovXG4gIHNlYXJjaCAoa2V5KSB7XG4gICAgY29uc3Qga2V5bGVuZ3RoID0ga2V5Lmxlbmd0aFxuICAgIGxldCBpbmRleCA9IDBcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VHN0Tm9kZXxudWxsfVxuICAgICAqL1xuICAgIGxldCBub2RlID0gdGhpc1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIGluZGV4IDwga2V5bGVuZ3RoKSB7XG4gICAgICBsZXQgY29kZSA9IGtleVtpbmRleF1cbiAgICAgIC8vIEEtWlxuICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgaXQgaXMgYmlnZ2VyIHRoYW4gMHg1YS5cbiAgICAgIC8vIExvd2VyY2FzZSBsZXR0ZXJzIGhhdmUgaGlnaGVyIGNoYXIgY29kZXMgdGhhbiB1cHBlcmNhc2Ugb25lcy5cbiAgICAgIC8vIEFsc28gd2UgYXNzdW1lIHRoYXQgaGVhZGVycyB3aWxsIG1vc3RseSBjb250YWluIGxvd2VyY2FzZSBjaGFyYWN0ZXJzLlxuICAgICAgaWYgKGNvZGUgPD0gMHg1YSAmJiBjb2RlID49IDB4NDEpIHtcbiAgICAgICAgLy8gTG93ZXJjYXNlIGZvciB1cHBlcmNhc2UuXG4gICAgICAgIGNvZGUgfD0gMzJcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChjb2RlID09PSBub2RlLmNvZGUpIHtcbiAgICAgICAgICBpZiAoa2V5bGVuZ3RoID09PSArK2luZGV4KSB7XG4gICAgICAgICAgICAvLyBSZXR1cm5zIE5vZGUgc2luY2UgaXQgaXMgdGhlIGxhc3Qga2V5LlxuICAgICAgICAgICAgcmV0dXJuIG5vZGVcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZSA9IG5vZGUubWlkZGxlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5jb2RlIDwgY29kZSA/IG5vZGUubGVmdCA6IG5vZGUucmlnaHRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5jbGFzcyBUZXJuYXJ5U2VhcmNoVHJlZSB7XG4gIC8qKiBAdHlwZSB7VHN0Tm9kZSB8IG51bGx9ICovXG4gIG5vZGUgPSBudWxsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKiAqL1xuICBpbnNlcnQgKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5ub2RlID09PSBudWxsKSB7XG4gICAgICB0aGlzLm5vZGUgPSBuZXcgVHN0Tm9kZShrZXksIHZhbHVlLCAwKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vZGUuYWRkKGtleSwgdmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0ga2V5XG4gICAqIEByZXR1cm5zIHthbnl9XG4gICAqL1xuICBsb29rdXAgKGtleSkge1xuICAgIHJldHVybiB0aGlzLm5vZGU/LnNlYXJjaChrZXkpPy52YWx1ZSA/PyBudWxsXG4gIH1cbn1cblxuY29uc3QgdHJlZSA9IG5ldyBUZXJuYXJ5U2VhcmNoVHJlZSgpXG5cbmZvciAobGV0IGkgPSAwOyBpIDwgd2VsbGtub3duSGVhZGVyTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgY29uc3Qga2V5ID0gaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmRbd2VsbGtub3duSGVhZGVyTmFtZXNbaV1dXG4gIHRyZWUuaW5zZXJ0KGtleSwga2V5KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVGVybmFyeVNlYXJjaFRyZWUsXG4gIHRyZWVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/tree.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/util.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/core/util.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { kDestroyed, kBodyUsed, kListeners, kBody } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { IncomingMessage } = __webpack_require__(/*! node:http */ \"node:http\")\nconst stream = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst net = __webpack_require__(/*! node:net */ \"node:net\")\nconst { Blob } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\nconst { stringify } = __webpack_require__(/*! node:querystring */ \"node:querystring\")\nconst { EventEmitter: EE } = __webpack_require__(/*! node:events */ \"node:events\")\nconst timers = __webpack_require__(/*! ../util/timers */ \"(rsc)/./node_modules/undici/lib/util/timers.js\")\nconst { InvalidArgumentError, ConnectTimeoutError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { headerNameLowerCasedRecord } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/core/constants.js\")\nconst { tree } = __webpack_require__(/*! ./tree */ \"(rsc)/./node_modules/undici/lib/core/tree.js\")\n\nconst [nodeMajor, nodeMinor] = process.versions.node.split('.', 2).map(v => Number(v))\n\nclass BodyAsyncIterable {\n  constructor (body) {\n    this[kBody] = body\n    this[kBodyUsed] = false\n  }\n\n  async * [Symbol.asyncIterator] () {\n    assert(!this[kBodyUsed], 'disturbed')\n    this[kBodyUsed] = true\n    yield * this[kBody]\n  }\n}\n\nfunction noop () {}\n\n/**\n * @param {*} body\n * @returns {*}\n */\nfunction wrapRequestBody (body) {\n  if (isStream(body)) {\n    // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n    // so that it can be dispatched again?\n    // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n    if (bodyLength(body) === 0) {\n      body\n        .on('data', function () {\n          assert(false)\n        })\n    }\n\n    if (typeof body.readableDidRead !== 'boolean') {\n      body[kBodyUsed] = false\n      EE.prototype.on.call(body, 'data', function () {\n        this[kBodyUsed] = true\n      })\n    }\n\n    return body\n  } else if (body && typeof body.pipeTo === 'function') {\n    // TODO (fix): We can't access ReadableStream internal state\n    // to determine whether or not it has been disturbed. This is just\n    // a workaround.\n    return new BodyAsyncIterable(body)\n  } else if (\n    body &&\n    typeof body !== 'string' &&\n    !ArrayBuffer.isView(body) &&\n    isIterable(body)\n  ) {\n    // TODO: Should we allow re-using iterable if !this.opts.idempotent\n    // or through some other flag?\n    return new BodyAsyncIterable(body)\n  } else {\n    return body\n  }\n}\n\n/**\n * @param {*} obj\n * @returns {obj is import('node:stream').Stream}\n */\nfunction isStream (obj) {\n  return obj && typeof obj === 'object' && typeof obj.pipe === 'function' && typeof obj.on === 'function'\n}\n\n/**\n * @param {*} object\n * @returns {object is Blob}\n * based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)\n */\nfunction isBlobLike (object) {\n  if (object === null) {\n    return false\n  } else if (object instanceof Blob) {\n    return true\n  } else if (typeof object !== 'object') {\n    return false\n  } else {\n    const sTag = object[Symbol.toStringTag]\n\n    return (sTag === 'Blob' || sTag === 'File') && (\n      ('stream' in object && typeof object.stream === 'function') ||\n      ('arrayBuffer' in object && typeof object.arrayBuffer === 'function')\n    )\n  }\n}\n\n/**\n * @param {string} url The URL to add the query params to\n * @param {import('node:querystring').ParsedUrlQueryInput} queryParams The object to serialize into a URL query string\n * @returns {string} The URL with the query params added\n */\nfunction serializePathWithQuery (url, queryParams) {\n  if (url.includes('?') || url.includes('#')) {\n    throw new Error('Query params cannot be passed when url already contains \"?\" or \"#\".')\n  }\n\n  const stringified = stringify(queryParams)\n\n  if (stringified) {\n    url += '?' + stringified\n  }\n\n  return url\n}\n\n/**\n * @param {number|string|undefined} port\n * @returns {boolean}\n */\nfunction isValidPort (port) {\n  const value = parseInt(port, 10)\n  return (\n    value === Number(port) &&\n    value >= 0 &&\n    value <= 65535\n  )\n}\n\n/**\n * Check if the value is a valid http or https prefixed string.\n *\n * @param {string} value\n * @returns {boolean}\n */\nfunction isHttpOrHttpsPrefixed (value) {\n  return (\n    value != null &&\n    value[0] === 'h' &&\n    value[1] === 't' &&\n    value[2] === 't' &&\n    value[3] === 'p' &&\n    (\n      value[4] === ':' ||\n      (\n        value[4] === 's' &&\n        value[5] === ':'\n      )\n    )\n  )\n}\n\n/**\n * @param {string|URL|Record<string,string>} url\n * @returns {URL}\n */\nfunction parseURL (url) {\n  if (typeof url === 'string') {\n    /**\n     * @type {URL}\n     */\n    url = new URL(url)\n\n    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n      throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n    }\n\n    return url\n  }\n\n  if (!url || typeof url !== 'object') {\n    throw new InvalidArgumentError('Invalid URL: The URL argument must be a non-null object.')\n  }\n\n  if (!(url instanceof URL)) {\n    if (url.port != null && url.port !== '' && isValidPort(url.port) === false) {\n      throw new InvalidArgumentError('Invalid URL: port must be a valid integer or a string representation of an integer.')\n    }\n\n    if (url.path != null && typeof url.path !== 'string') {\n      throw new InvalidArgumentError('Invalid URL path: the path must be a string or null/undefined.')\n    }\n\n    if (url.pathname != null && typeof url.pathname !== 'string') {\n      throw new InvalidArgumentError('Invalid URL pathname: the pathname must be a string or null/undefined.')\n    }\n\n    if (url.hostname != null && typeof url.hostname !== 'string') {\n      throw new InvalidArgumentError('Invalid URL hostname: the hostname must be a string or null/undefined.')\n    }\n\n    if (url.origin != null && typeof url.origin !== 'string') {\n      throw new InvalidArgumentError('Invalid URL origin: the origin must be a string or null/undefined.')\n    }\n\n    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n      throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n    }\n\n    const port = url.port != null\n      ? url.port\n      : (url.protocol === 'https:' ? 443 : 80)\n    let origin = url.origin != null\n      ? url.origin\n      : `${url.protocol || ''}//${url.hostname || ''}:${port}`\n    let path = url.path != null\n      ? url.path\n      : `${url.pathname || ''}${url.search || ''}`\n\n    if (origin[origin.length - 1] === '/') {\n      origin = origin.slice(0, origin.length - 1)\n    }\n\n    if (path && path[0] !== '/') {\n      path = `/${path}`\n    }\n    // new URL(path, origin) is unsafe when `path` contains an absolute URL\n    // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:\n    // If first parameter is a relative URL, second param is required, and will be used as the base URL.\n    // If first parameter is an absolute URL, a given second param will be ignored.\n    return new URL(`${origin}${path}`)\n  }\n\n  if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n    throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n  }\n\n  return url\n}\n\n/**\n * @param {string|URL|Record<string, string>} url\n * @returns {URL}\n */\nfunction parseOrigin (url) {\n  url = parseURL(url)\n\n  if (url.pathname !== '/' || url.search || url.hash) {\n    throw new InvalidArgumentError('invalid url')\n  }\n\n  return url\n}\n\n/**\n * @param {string} host\n * @returns {string}\n */\nfunction getHostname (host) {\n  if (host[0] === '[') {\n    const idx = host.indexOf(']')\n\n    assert(idx !== -1)\n    return host.substring(1, idx)\n  }\n\n  const idx = host.indexOf(':')\n  if (idx === -1) return host\n\n  return host.substring(0, idx)\n}\n\n/**\n * IP addresses are not valid server names per RFC6066\n * Currently, the only server names supported are DNS hostnames\n * @param {string|null} host\n * @returns {string|null}\n */\nfunction getServerName (host) {\n  if (!host) {\n    return null\n  }\n\n  assert(typeof host === 'string')\n\n  const servername = getHostname(host)\n  if (net.isIP(servername)) {\n    return ''\n  }\n\n  return servername\n}\n\n/**\n * @function\n * @template T\n * @param {T} obj\n * @returns {T}\n */\nfunction deepClone (obj) {\n  return JSON.parse(JSON.stringify(obj))\n}\n\n/**\n * @param {*} obj\n * @returns {obj is AsyncIterable}\n */\nfunction isAsyncIterable (obj) {\n  return !!(obj != null && typeof obj[Symbol.asyncIterator] === 'function')\n}\n\n/**\n * @param {*} obj\n * @returns {obj is Iterable}\n */\nfunction isIterable (obj) {\n  return !!(obj != null && (typeof obj[Symbol.iterator] === 'function' || typeof obj[Symbol.asyncIterator] === 'function'))\n}\n\n/**\n * @param {Blob|Buffer|import ('stream').Stream} body\n * @returns {number|null}\n */\nfunction bodyLength (body) {\n  if (body == null) {\n    return 0\n  } else if (isStream(body)) {\n    const state = body._readableState\n    return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length)\n      ? state.length\n      : null\n  } else if (isBlobLike(body)) {\n    return body.size != null ? body.size : null\n  } else if (isBuffer(body)) {\n    return body.byteLength\n  }\n\n  return null\n}\n\n/**\n * @param {import ('stream').Stream} body\n * @returns {boolean}\n */\nfunction isDestroyed (body) {\n  return body && !!(body.destroyed || body[kDestroyed] || (stream.isDestroyed?.(body)))\n}\n\n/**\n * @param {import ('stream').Stream} stream\n * @param {Error} [err]\n * @returns {void}\n */\nfunction destroy (stream, err) {\n  if (stream == null || !isStream(stream) || isDestroyed(stream)) {\n    return\n  }\n\n  if (typeof stream.destroy === 'function') {\n    if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {\n      // See: https://github.com/nodejs/node/pull/38505/files\n      stream.socket = null\n    }\n\n    stream.destroy(err)\n  } else if (err) {\n    queueMicrotask(() => {\n      stream.emit('error', err)\n    })\n  }\n\n  if (stream.destroyed !== true) {\n    stream[kDestroyed] = true\n  }\n}\n\nconst KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)/\n/**\n * @param {string} val\n * @returns {number | null}\n */\nfunction parseKeepAliveTimeout (val) {\n  const m = val.match(KEEPALIVE_TIMEOUT_EXPR)\n  return m ? parseInt(m[1], 10) * 1000 : null\n}\n\n/**\n * Retrieves a header name and returns its lowercase value.\n * @param {string | Buffer} value Header name\n * @returns {string}\n */\nfunction headerNameToString (value) {\n  return typeof value === 'string'\n    ? headerNameLowerCasedRecord[value] ?? value.toLowerCase()\n    : tree.lookup(value) ?? value.toString('latin1').toLowerCase()\n}\n\n/**\n * Receive the buffer as a string and return its lowercase value.\n * @param {Buffer} value Header name\n * @returns {string}\n */\nfunction bufferToLowerCasedHeaderName (value) {\n  return tree.lookup(value) ?? value.toString('latin1').toLowerCase()\n}\n\n/**\n * @param {(Buffer | string)[]} headers\n * @param {Record<string, string | string[]>} [obj]\n * @returns {Record<string, string | string[]>}\n */\nfunction parseHeaders (headers, obj) {\n  if (obj === undefined) obj = {}\n\n  for (let i = 0; i < headers.length; i += 2) {\n    const key = headerNameToString(headers[i])\n    let val = obj[key]\n\n    if (val) {\n      if (typeof val === 'string') {\n        val = [val]\n        obj[key] = val\n      }\n      val.push(headers[i + 1].toString('utf8'))\n    } else {\n      const headersValue = headers[i + 1]\n      if (typeof headersValue === 'string') {\n        obj[key] = headersValue\n      } else {\n        obj[key] = Array.isArray(headersValue) ? headersValue.map(x => x.toString('utf8')) : headersValue.toString('utf8')\n      }\n    }\n  }\n\n  // See https://github.com/nodejs/node/pull/46528\n  if ('content-length' in obj && 'content-disposition' in obj) {\n    obj['content-disposition'] = Buffer.from(obj['content-disposition']).toString('latin1')\n  }\n\n  return obj\n}\n\n/**\n * @param {Buffer[]} headers\n * @returns {string[]}\n */\nfunction parseRawHeaders (headers) {\n  const headersLength = headers.length\n  /**\n   * @type {string[]}\n   */\n  const ret = new Array(headersLength)\n\n  let hasContentLength = false\n  let contentDispositionIdx = -1\n  let key\n  let val\n  let kLen = 0\n\n  for (let n = 0; n < headersLength; n += 2) {\n    key = headers[n]\n    val = headers[n + 1]\n\n    typeof key !== 'string' && (key = key.toString())\n    typeof val !== 'string' && (val = val.toString('utf8'))\n\n    kLen = key.length\n    if (kLen === 14 && key[7] === '-' && (key === 'content-length' || key.toLowerCase() === 'content-length')) {\n      hasContentLength = true\n    } else if (kLen === 19 && key[7] === '-' && (key === 'content-disposition' || key.toLowerCase() === 'content-disposition')) {\n      contentDispositionIdx = n + 1\n    }\n    ret[n] = key\n    ret[n + 1] = val\n  }\n\n  // See https://github.com/nodejs/node/pull/46528\n  if (hasContentLength && contentDispositionIdx !== -1) {\n    ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString('latin1')\n  }\n\n  return ret\n}\n\n/**\n * @param {string[]} headers\n * @param {Buffer[]} headers\n */\nfunction encodeRawHeaders (headers) {\n  if (!Array.isArray(headers)) {\n    throw new TypeError('expected headers to be an array')\n  }\n  return headers.map(x => Buffer.from(x))\n}\n\n/**\n * @param {*} buffer\n * @returns {buffer is Buffer}\n */\nfunction isBuffer (buffer) {\n  // See, https://github.com/mcollina/undici/pull/319\n  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer)\n}\n\n/**\n * Asserts that the handler object is a request handler.\n *\n * @param {object} handler\n * @param {string} method\n * @param {string} [upgrade]\n * @returns {asserts handler is import('../api/api-request').RequestHandler}\n */\nfunction assertRequestHandler (handler, method, upgrade) {\n  if (!handler || typeof handler !== 'object') {\n    throw new InvalidArgumentError('handler must be an object')\n  }\n\n  if (typeof handler.onRequestStart === 'function') {\n    // TODO (fix): More checks...\n    return\n  }\n\n  if (typeof handler.onConnect !== 'function') {\n    throw new InvalidArgumentError('invalid onConnect method')\n  }\n\n  if (typeof handler.onError !== 'function') {\n    throw new InvalidArgumentError('invalid onError method')\n  }\n\n  if (typeof handler.onBodySent !== 'function' && handler.onBodySent !== undefined) {\n    throw new InvalidArgumentError('invalid onBodySent method')\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    if (typeof handler.onUpgrade !== 'function') {\n      throw new InvalidArgumentError('invalid onUpgrade method')\n    }\n  } else {\n    if (typeof handler.onHeaders !== 'function') {\n      throw new InvalidArgumentError('invalid onHeaders method')\n    }\n\n    if (typeof handler.onData !== 'function') {\n      throw new InvalidArgumentError('invalid onData method')\n    }\n\n    if (typeof handler.onComplete !== 'function') {\n      throw new InvalidArgumentError('invalid onComplete method')\n    }\n  }\n}\n\n/**\n * A body is disturbed if it has been read from and it cannot be re-used without\n * losing state or data.\n * @param {import('node:stream').Readable} body\n * @returns {boolean}\n */\nfunction isDisturbed (body) {\n  // TODO (fix): Why is body[kBodyUsed] needed?\n  return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]))\n}\n\n/**\n * @typedef {object} SocketInfo\n * @property {string} [localAddress]\n * @property {number} [localPort]\n * @property {string} [remoteAddress]\n * @property {number} [remotePort]\n * @property {string} [remoteFamily]\n * @property {number} [timeout]\n * @property {number} bytesWritten\n * @property {number} bytesRead\n */\n\n/**\n * @param {import('net').Socket} socket\n * @returns {SocketInfo}\n */\nfunction getSocketInfo (socket) {\n  return {\n    localAddress: socket.localAddress,\n    localPort: socket.localPort,\n    remoteAddress: socket.remoteAddress,\n    remotePort: socket.remotePort,\n    remoteFamily: socket.remoteFamily,\n    timeout: socket.timeout,\n    bytesWritten: socket.bytesWritten,\n    bytesRead: socket.bytesRead\n  }\n}\n\n/**\n * @param {Iterable} iterable\n * @returns {ReadableStream}\n */\nfunction ReadableStreamFrom (iterable) {\n  // We cannot use ReadableStream.from here because it does not return a byte stream.\n\n  let iterator\n  return new ReadableStream(\n    {\n      async start () {\n        iterator = iterable[Symbol.asyncIterator]()\n      },\n      pull (controller) {\n        async function pull () {\n          const { done, value } = await iterator.next()\n          if (done) {\n            queueMicrotask(() => {\n              controller.close()\n              controller.byobRequest?.respond(0)\n            })\n          } else {\n            const buf = Buffer.isBuffer(value) ? value : Buffer.from(value)\n            if (buf.byteLength) {\n              controller.enqueue(new Uint8Array(buf))\n            } else {\n              return await pull()\n            }\n          }\n        }\n\n        return pull()\n      },\n      async cancel () {\n        await iterator.return()\n      },\n      type: 'bytes'\n    }\n  )\n}\n\n/**\n * The object should be a FormData instance and contains all the required\n * methods.\n * @param {*} object\n * @returns {object is FormData}\n */\nfunction isFormDataLike (object) {\n  return (\n    object &&\n    typeof object === 'object' &&\n    typeof object.append === 'function' &&\n    typeof object.delete === 'function' &&\n    typeof object.get === 'function' &&\n    typeof object.getAll === 'function' &&\n    typeof object.has === 'function' &&\n    typeof object.set === 'function' &&\n    object[Symbol.toStringTag] === 'FormData'\n  )\n}\n\nfunction addAbortListener (signal, listener) {\n  if ('addEventListener' in signal) {\n    signal.addEventListener('abort', listener, { once: true })\n    return () => signal.removeEventListener('abort', listener)\n  }\n  signal.once('abort', listener)\n  return () => signal.removeListener('abort', listener)\n}\n\n/**\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n * @param {number} c\n * @returns {boolean}\n */\nfunction isTokenCharCode (c) {\n  switch (c) {\n    case 0x22:\n    case 0x28:\n    case 0x29:\n    case 0x2c:\n    case 0x2f:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3d:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x5b:\n    case 0x5c:\n    case 0x5d:\n    case 0x7b:\n    case 0x7d:\n      // DQUOTE and \"(),/:;<=>?@[\\]{}\"\n      return false\n    default:\n      // VCHAR %x21-7E\n      return c >= 0x21 && c <= 0x7e\n  }\n}\n\n/**\n * @param {string} characters\n * @returns {boolean}\n */\nfunction isValidHTTPToken (characters) {\n  if (characters.length === 0) {\n    return false\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    if (!isTokenCharCode(characters.charCodeAt(i))) {\n      return false\n    }\n  }\n  return true\n}\n\n// headerCharRegex have been lifted from\n// https://github.com/nodejs/node/blob/main/lib/_http_common.js\n\n/**\n * Matches if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n */\nconst headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/\n\n/**\n * @param {string} characters\n * @returns {boolean}\n */\nfunction isValidHeaderValue (characters) {\n  return !headerCharRegex.test(characters)\n}\n\nconst rangeHeaderRegex = /^bytes (\\d+)-(\\d+)\\/(\\d+)?$/\n\n/**\n * @typedef {object} RangeHeader\n * @property {number} start\n * @property {number | null} end\n * @property {number | null} size\n */\n\n/**\n * Parse accordingly to RFC 9110\n * @see https://www.rfc-editor.org/rfc/rfc9110#field.content-range\n * @param {string} [range]\n * @returns {RangeHeader|null}\n */\nfunction parseRangeHeader (range) {\n  if (range == null || range === '') return { start: 0, end: null, size: null }\n\n  const m = range ? range.match(rangeHeaderRegex) : null\n  return m\n    ? {\n        start: parseInt(m[1]),\n        end: m[2] ? parseInt(m[2]) : null,\n        size: m[3] ? parseInt(m[3]) : null\n      }\n    : null\n}\n\n/**\n * @template {import(\"events\").EventEmitter} T\n * @param {T} obj\n * @param {string} name\n * @param {(...args: any[]) => void} listener\n * @returns {T}\n */\nfunction addListener (obj, name, listener) {\n  const listeners = (obj[kListeners] ??= [])\n  listeners.push([name, listener])\n  obj.on(name, listener)\n  return obj\n}\n\n/**\n * @template {import(\"events\").EventEmitter} T\n * @param {T} obj\n * @returns {T}\n */\nfunction removeAllListeners (obj) {\n  if (obj[kListeners] != null) {\n    for (const [name, listener] of obj[kListeners]) {\n      obj.removeListener(name, listener)\n    }\n    obj[kListeners] = null\n  }\n  return obj\n}\n\n/**\n * @param {import ('../dispatcher/client')} client\n * @param {import ('../core/request')} request\n * @param {Error} err\n */\nfunction errorRequest (client, request, err) {\n  try {\n    request.onError(err)\n    assert(request.aborted)\n  } catch (err) {\n    client.emit('error', err)\n  }\n}\n\n/**\n * @param {WeakRef<net.Socket>} socketWeakRef\n * @param {object} opts\n * @param {number} opts.timeout\n * @param {string} opts.hostname\n * @param {number} opts.port\n * @returns {() => void}\n */\nconst setupConnectTimeout = process.platform === 'win32'\n  ? (socketWeakRef, opts) => {\n      if (!opts.timeout) {\n        return noop\n      }\n\n      let s1 = null\n      let s2 = null\n      const fastTimer = timers.setFastTimeout(() => {\n      // setImmediate is added to make sure that we prioritize socket error events over timeouts\n        s1 = setImmediate(() => {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n          s2 = setImmediate(() => onConnectTimeout(socketWeakRef.deref(), opts))\n        })\n      }, opts.timeout)\n      return () => {\n        timers.clearFastTimeout(fastTimer)\n        clearImmediate(s1)\n        clearImmediate(s2)\n      }\n    }\n  : (socketWeakRef, opts) => {\n      if (!opts.timeout) {\n        return noop\n      }\n\n      let s1 = null\n      const fastTimer = timers.setFastTimeout(() => {\n      // setImmediate is added to make sure that we prioritize socket error events over timeouts\n        s1 = setImmediate(() => {\n          onConnectTimeout(socketWeakRef.deref(), opts)\n        })\n      }, opts.timeout)\n      return () => {\n        timers.clearFastTimeout(fastTimer)\n        clearImmediate(s1)\n      }\n    }\n\n/**\n * @param {net.Socket} socket\n * @param {object} opts\n * @param {number} opts.timeout\n * @param {string} opts.hostname\n * @param {number} opts.port\n */\nfunction onConnectTimeout (socket, opts) {\n  // The socket could be already garbage collected\n  if (socket == null) {\n    return\n  }\n\n  let message = 'Connect Timeout Error'\n  if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {\n    message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(', ')},`\n  } else {\n    message += ` (attempted address: ${opts.hostname}:${opts.port},`\n  }\n\n  message += ` timeout: ${opts.timeout}ms)`\n\n  destroy(socket, new ConnectTimeoutError(message))\n}\n\nconst kEnumerableProperty = Object.create(null)\nkEnumerableProperty.enumerable = true\n\nconst normalizedMethodRecordsBase = {\n  delete: 'DELETE',\n  DELETE: 'DELETE',\n  get: 'GET',\n  GET: 'GET',\n  head: 'HEAD',\n  HEAD: 'HEAD',\n  options: 'OPTIONS',\n  OPTIONS: 'OPTIONS',\n  post: 'POST',\n  POST: 'POST',\n  put: 'PUT',\n  PUT: 'PUT'\n}\n\nconst normalizedMethodRecords = {\n  ...normalizedMethodRecordsBase,\n  patch: 'patch',\n  PATCH: 'PATCH'\n}\n\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(normalizedMethodRecordsBase, null)\nObject.setPrototypeOf(normalizedMethodRecords, null)\n\nmodule.exports = {\n  kEnumerableProperty,\n  isDisturbed,\n  isBlobLike,\n  parseOrigin,\n  parseURL,\n  getServerName,\n  isStream,\n  isIterable,\n  isAsyncIterable,\n  isDestroyed,\n  headerNameToString,\n  bufferToLowerCasedHeaderName,\n  addListener,\n  removeAllListeners,\n  errorRequest,\n  parseRawHeaders,\n  encodeRawHeaders,\n  parseHeaders,\n  parseKeepAliveTimeout,\n  destroy,\n  bodyLength,\n  deepClone,\n  ReadableStreamFrom,\n  isBuffer,\n  assertRequestHandler,\n  getSocketInfo,\n  isFormDataLike,\n  serializePathWithQuery,\n  addAbortListener,\n  isValidHTTPToken,\n  isValidHeaderValue,\n  isTokenCharCode,\n  parseRangeHeader,\n  normalizedMethodRecordsBase,\n  normalizedMethodRecords,\n  isValidPort,\n  isHttpOrHttpsPrefixed,\n  nodeMajor,\n  nodeMinor,\n  safeHTTPMethods: Object.freeze(['GET', 'HEAD', 'OPTIONS', 'TRACE']),\n  wrapRequestBody,\n  setupConnectTimeout\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsMkNBQTJDLEVBQUUsbUJBQU8sQ0FBQyxrRUFBVztBQUN4RSxRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFlBQVksbUJBQU8sQ0FBQywwQkFBVTtBQUM5QixRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3RDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsMENBQWtCO0FBQ2hELFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNsRCxlQUFlLG1CQUFPLENBQUMsc0VBQWdCO0FBQ3ZDLFFBQVEsNENBQTRDLEVBQUUsbUJBQU8sQ0FBQyxnRUFBVTtBQUN4RSxRQUFRLDZCQUE2QixFQUFFLG1CQUFPLENBQUMsc0VBQWE7QUFDNUQsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyw0REFBUTs7QUFFakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEdBQUc7QUFD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TztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLHFEQUFxRDtBQUM5RixJQUFJO0FBQ0osdUNBQXVDLGNBQWMsR0FBRyxVQUFVO0FBQ2xFOztBQUVBLDBCQUEwQixhQUFhOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBrRGVzdHJveWVkLCBrQm9keVVzZWQsIGtMaXN0ZW5lcnMsIGtCb2R5IH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBJbmNvbWluZ01lc3NhZ2UgfSA9IHJlcXVpcmUoJ25vZGU6aHR0cCcpXG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCBuZXQgPSByZXF1aXJlKCdub2RlOm5ldCcpXG5jb25zdCB7IEJsb2IgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcbmNvbnN0IHsgc3RyaW5naWZ5IH0gPSByZXF1aXJlKCdub2RlOnF1ZXJ5c3RyaW5nJylcbmNvbnN0IHsgRXZlbnRFbWl0dGVyOiBFRSB9ID0gcmVxdWlyZSgnbm9kZTpldmVudHMnKVxuY29uc3QgdGltZXJzID0gcmVxdWlyZSgnLi4vdXRpbC90aW1lcnMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgQ29ubmVjdFRpbWVvdXRFcnJvciB9ID0gcmVxdWlyZSgnLi9lcnJvcnMnKVxuY29uc3QgeyBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyB0cmVlIH0gPSByZXF1aXJlKCcuL3RyZWUnKVxuXG5jb25zdCBbbm9kZU1ham9yLCBub2RlTWlub3JdID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KCcuJywgMikubWFwKHYgPT4gTnVtYmVyKHYpKVxuXG5jbGFzcyBCb2R5QXN5bmNJdGVyYWJsZSB7XG4gIGNvbnN0cnVjdG9yIChib2R5KSB7XG4gICAgdGhpc1trQm9keV0gPSBib2R5XG4gICAgdGhpc1trQm9keVVzZWRdID0gZmFsc2VcbiAgfVxuXG4gIGFzeW5jICogW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSAoKSB7XG4gICAgYXNzZXJ0KCF0aGlzW2tCb2R5VXNlZF0sICdkaXN0dXJiZWQnKVxuICAgIHRoaXNba0JvZHlVc2VkXSA9IHRydWVcbiAgICB5aWVsZCAqIHRoaXNba0JvZHldXG4gIH1cbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gYm9keVxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIHdyYXBSZXF1ZXN0Qm9keSAoYm9keSkge1xuICBpZiAoaXNTdHJlYW0oYm9keSkpIHtcbiAgICAvLyBUT0RPIChmaXgpOiBQcm92aWRlIHNvbWUgd2F5IGZvciB0aGUgdXNlciB0byBjYWNoZSB0aGUgZmlsZSB0byBlLmcuIC90bXBcbiAgICAvLyBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGFnYWluP1xuICAgIC8vIFRPRE8gKGZpeCk6IERvIHdlIG5lZWQgMTAwLWV4cGVjdCBzdXBwb3J0IHRvIHByb3ZpZGUgYSB3YXkgdG8gZG8gdGhpcyBwcm9wZXJseT9cbiAgICBpZiAoYm9keUxlbmd0aChib2R5KSA9PT0gMCkge1xuICAgICAgYm9keVxuICAgICAgICAub24oJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYXNzZXJ0KGZhbHNlKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYm9keS5yZWFkYWJsZURpZFJlYWQgIT09ICdib29sZWFuJykge1xuICAgICAgYm9keVtrQm9keVVzZWRdID0gZmFsc2VcbiAgICAgIEVFLnByb3RvdHlwZS5vbi5jYWxsKGJvZHksICdkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzW2tCb2R5VXNlZF0gPSB0cnVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBib2R5XG4gIH0gZWxzZSBpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5waXBlVG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUT0RPIChmaXgpOiBXZSBjYW4ndCBhY2Nlc3MgUmVhZGFibGVTdHJlYW0gaW50ZXJuYWwgc3RhdGVcbiAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgaXQgaGFzIGJlZW4gZGlzdHVyYmVkLiBUaGlzIGlzIGp1c3RcbiAgICAvLyBhIHdvcmthcm91bmQuXG4gICAgcmV0dXJuIG5ldyBCb2R5QXN5bmNJdGVyYWJsZShib2R5KVxuICB9IGVsc2UgaWYgKFxuICAgIGJvZHkgJiZcbiAgICB0eXBlb2YgYm9keSAhPT0gJ3N0cmluZycgJiZcbiAgICAhQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpICYmXG4gICAgaXNJdGVyYWJsZShib2R5KVxuICApIHtcbiAgICAvLyBUT0RPOiBTaG91bGQgd2UgYWxsb3cgcmUtdXNpbmcgaXRlcmFibGUgaWYgIXRoaXMub3B0cy5pZGVtcG90ZW50XG4gICAgLy8gb3IgdGhyb3VnaCBzb21lIG90aGVyIGZsYWc/XG4gICAgcmV0dXJuIG5ldyBCb2R5QXN5bmNJdGVyYWJsZShib2R5KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBib2R5XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybnMge29iaiBpcyBpbXBvcnQoJ25vZGU6c3RyZWFtJykuU3RyZWFtfVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai5waXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmoub24gPT09ICdmdW5jdGlvbidcbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybnMge29iamVjdCBpcyBCbG9ifVxuICogYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvZmV0Y2gtYmxvYi9ibG9iLzhhYjU4N2QzNDA4MGRlOTQxNDBiNTRmMDcxNjg0NTFlN2QwYjY1NWUvaW5kZXguanMjTDIyOS1MMjQxIChNSVQgTGljZW5zZSlcbiAqL1xuZnVuY3Rpb24gaXNCbG9iTGlrZSAob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNUYWcgPSBvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXVxuXG4gICAgcmV0dXJuIChzVGFnID09PSAnQmxvYicgfHwgc1RhZyA9PT0gJ0ZpbGUnKSAmJiAoXG4gICAgICAoJ3N0cmVhbScgaW4gb2JqZWN0ICYmIHR5cGVvZiBvYmplY3Quc3RyZWFtID09PSAnZnVuY3Rpb24nKSB8fFxuICAgICAgKCdhcnJheUJ1ZmZlcicgaW4gb2JqZWN0ICYmIHR5cGVvZiBvYmplY3QuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicpXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIGFkZCB0aGUgcXVlcnkgcGFyYW1zIHRvXG4gKiBAcGFyYW0ge2ltcG9ydCgnbm9kZTpxdWVyeXN0cmluZycpLlBhcnNlZFVybFF1ZXJ5SW5wdXR9IHF1ZXJ5UGFyYW1zIFRoZSBvYmplY3QgdG8gc2VyaWFsaXplIGludG8gYSBVUkwgcXVlcnkgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgVVJMIHdpdGggdGhlIHF1ZXJ5IHBhcmFtcyBhZGRlZFxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVQYXRoV2l0aFF1ZXJ5ICh1cmwsIHF1ZXJ5UGFyYW1zKSB7XG4gIGlmICh1cmwuaW5jbHVkZXMoJz8nKSB8fCB1cmwuaW5jbHVkZXMoJyMnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkgcGFyYW1zIGNhbm5vdCBiZSBwYXNzZWQgd2hlbiB1cmwgYWxyZWFkeSBjb250YWlucyBcIj9cIiBvciBcIiNcIi4nKVxuICB9XG5cbiAgY29uc3Qgc3RyaW5naWZpZWQgPSBzdHJpbmdpZnkocXVlcnlQYXJhbXMpXG5cbiAgaWYgKHN0cmluZ2lmaWVkKSB7XG4gICAgdXJsICs9ICc/JyArIHN0cmluZ2lmaWVkXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZH0gcG9ydFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRQb3J0IChwb3J0KSB7XG4gIGNvbnN0IHZhbHVlID0gcGFyc2VJbnQocG9ydCwgMTApXG4gIHJldHVybiAoXG4gICAgdmFsdWUgPT09IE51bWJlcihwb3J0KSAmJlxuICAgIHZhbHVlID49IDAgJiZcbiAgICB2YWx1ZSA8PSA2NTUzNVxuICApXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaHR0cCBvciBodHRwcyBwcmVmaXhlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNIdHRwT3JIdHRwc1ByZWZpeGVkICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICB2YWx1ZVswXSA9PT0gJ2gnICYmXG4gICAgdmFsdWVbMV0gPT09ICd0JyAmJlxuICAgIHZhbHVlWzJdID09PSAndCcgJiZcbiAgICB2YWx1ZVszXSA9PT0gJ3AnICYmXG4gICAgKFxuICAgICAgdmFsdWVbNF0gPT09ICc6JyB8fFxuICAgICAgKFxuICAgICAgICB2YWx1ZVs0XSA9PT0gJ3MnICYmXG4gICAgICAgIHZhbHVlWzVdID09PSAnOidcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx8UmVjb3JkPHN0cmluZyxzdHJpbmc+fSB1cmxcbiAqIEByZXR1cm5zIHtVUkx9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVVJMICh1cmwpIHtcbiAgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1VSTH1cbiAgICAgKi9cbiAgICB1cmwgPSBuZXcgVVJMKHVybClcblxuICAgIGlmICghaXNIdHRwT3JIdHRwc1ByZWZpeGVkKHVybC5vcmlnaW4gfHwgdXJsLnByb3RvY29sKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwcm90b2NvbDogdGhlIFVSTCBtdXN0IHN0YXJ0IHdpdGggYGh0dHA6YCBvciBgaHR0cHM6YC4nKVxuICAgIH1cblxuICAgIHJldHVybiB1cmxcbiAgfVxuXG4gIGlmICghdXJsIHx8IHR5cGVvZiB1cmwgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTDogVGhlIFVSTCBhcmd1bWVudCBtdXN0IGJlIGEgbm9uLW51bGwgb2JqZWN0LicpXG4gIH1cblxuICBpZiAoISh1cmwgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgaWYgKHVybC5wb3J0ICE9IG51bGwgJiYgdXJsLnBvcnQgIT09ICcnICYmIGlzVmFsaWRQb3J0KHVybC5wb3J0KSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkw6IHBvcnQgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgb3IgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlci4nKVxuICAgIH1cblxuICAgIGlmICh1cmwucGF0aCAhPSBudWxsICYmIHR5cGVvZiB1cmwucGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgcGF0aDogdGhlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBudWxsL3VuZGVmaW5lZC4nKVxuICAgIH1cblxuICAgIGlmICh1cmwucGF0aG5hbWUgIT0gbnVsbCAmJiB0eXBlb2YgdXJsLnBhdGhuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwYXRobmFtZTogdGhlIHBhdGhuYW1lIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuJylcbiAgICB9XG5cbiAgICBpZiAodXJsLmhvc3RuYW1lICE9IG51bGwgJiYgdHlwZW9mIHVybC5ob3N0bmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgaG9zdG5hbWU6IHRoZSBob3N0bmFtZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGwvdW5kZWZpbmVkLicpXG4gICAgfVxuXG4gICAgaWYgKHVybC5vcmlnaW4gIT0gbnVsbCAmJiB0eXBlb2YgdXJsLm9yaWdpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgb3JpZ2luOiB0aGUgb3JpZ2luIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuJylcbiAgICB9XG5cbiAgICBpZiAoIWlzSHR0cE9ySHR0cHNQcmVmaXhlZCh1cmwub3JpZ2luIHx8IHVybC5wcm90b2NvbCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgcHJvdG9jb2w6IHRoZSBVUkwgbXVzdCBzdGFydCB3aXRoIGBodHRwOmAgb3IgYGh0dHBzOmAuJylcbiAgICB9XG5cbiAgICBjb25zdCBwb3J0ID0gdXJsLnBvcnQgIT0gbnVsbFxuICAgICAgPyB1cmwucG9ydFxuICAgICAgOiAodXJsLnByb3RvY29sID09PSAnaHR0cHM6JyA/IDQ0MyA6IDgwKVxuICAgIGxldCBvcmlnaW4gPSB1cmwub3JpZ2luICE9IG51bGxcbiAgICAgID8gdXJsLm9yaWdpblxuICAgICAgOiBgJHt1cmwucHJvdG9jb2wgfHwgJyd9Ly8ke3VybC5ob3N0bmFtZSB8fCAnJ306JHtwb3J0fWBcbiAgICBsZXQgcGF0aCA9IHVybC5wYXRoICE9IG51bGxcbiAgICAgID8gdXJsLnBhdGhcbiAgICAgIDogYCR7dXJsLnBhdGhuYW1lIHx8ICcnfSR7dXJsLnNlYXJjaCB8fCAnJ31gXG5cbiAgICBpZiAob3JpZ2luW29yaWdpbi5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICBvcmlnaW4gPSBvcmlnaW4uc2xpY2UoMCwgb3JpZ2luLmxlbmd0aCAtIDEpXG4gICAgfVxuXG4gICAgaWYgKHBhdGggJiYgcGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICBwYXRoID0gYC8ke3BhdGh9YFxuICAgIH1cbiAgICAvLyBuZXcgVVJMKHBhdGgsIG9yaWdpbikgaXMgdW5zYWZlIHdoZW4gYHBhdGhgIGNvbnRhaW5zIGFuIGFic29sdXRlIFVSTFxuICAgIC8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9VUkw6XG4gICAgLy8gSWYgZmlyc3QgcGFyYW1ldGVyIGlzIGEgcmVsYXRpdmUgVVJMLCBzZWNvbmQgcGFyYW0gaXMgcmVxdWlyZWQsIGFuZCB3aWxsIGJlIHVzZWQgYXMgdGhlIGJhc2UgVVJMLlxuICAgIC8vIElmIGZpcnN0IHBhcmFtZXRlciBpcyBhbiBhYnNvbHV0ZSBVUkwsIGEgZ2l2ZW4gc2Vjb25kIHBhcmFtIHdpbGwgYmUgaWdub3JlZC5cbiAgICByZXR1cm4gbmV3IFVSTChgJHtvcmlnaW59JHtwYXRofWApXG4gIH1cblxuICBpZiAoIWlzSHR0cE9ySHR0cHNQcmVmaXhlZCh1cmwub3JpZ2luIHx8IHVybC5wcm90b2NvbCkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgVVJMIHByb3RvY29sOiB0aGUgVVJMIG11c3Qgc3RhcnQgd2l0aCBgaHR0cDpgIG9yIGBodHRwczpgLicpXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfFJlY29yZDxzdHJpbmcsIHN0cmluZz59IHVybFxuICogQHJldHVybnMge1VSTH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VPcmlnaW4gKHVybCkge1xuICB1cmwgPSBwYXJzZVVSTCh1cmwpXG5cbiAgaWYgKHVybC5wYXRobmFtZSAhPT0gJy8nIHx8IHVybC5zZWFyY2ggfHwgdXJsLmhhc2gpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgdXJsJylcbiAgfVxuXG4gIHJldHVybiB1cmxcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaG9zdFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0SG9zdG5hbWUgKGhvc3QpIHtcbiAgaWYgKGhvc3RbMF0gPT09ICdbJykge1xuICAgIGNvbnN0IGlkeCA9IGhvc3QuaW5kZXhPZignXScpXG5cbiAgICBhc3NlcnQoaWR4ICE9PSAtMSlcbiAgICByZXR1cm4gaG9zdC5zdWJzdHJpbmcoMSwgaWR4KVxuICB9XG5cbiAgY29uc3QgaWR4ID0gaG9zdC5pbmRleE9mKCc6JylcbiAgaWYgKGlkeCA9PT0gLTEpIHJldHVybiBob3N0XG5cbiAgcmV0dXJuIGhvc3Quc3Vic3RyaW5nKDAsIGlkeClcbn1cblxuLyoqXG4gKiBJUCBhZGRyZXNzZXMgYXJlIG5vdCB2YWxpZCBzZXJ2ZXIgbmFtZXMgcGVyIFJGQzYwNjZcbiAqIEN1cnJlbnRseSwgdGhlIG9ubHkgc2VydmVyIG5hbWVzIHN1cHBvcnRlZCBhcmUgRE5TIGhvc3RuYW1lc1xuICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gaG9zdFxuICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuICovXG5mdW5jdGlvbiBnZXRTZXJ2ZXJOYW1lIChob3N0KSB7XG4gIGlmICghaG9zdCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBhc3NlcnQodHlwZW9mIGhvc3QgPT09ICdzdHJpbmcnKVxuXG4gIGNvbnN0IHNlcnZlcm5hbWUgPSBnZXRIb3N0bmFtZShob3N0KVxuICBpZiAobmV0LmlzSVAoc2VydmVybmFtZSkpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIHJldHVybiBzZXJ2ZXJuYW1lXG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBvYmpcbiAqIEByZXR1cm5zIHtUfVxuICovXG5mdW5jdGlvbiBkZWVwQ2xvbmUgKG9iaikge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJucyB7b2JqIGlzIEFzeW5jSXRlcmFibGV9XG4gKi9cbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZSAob2JqKSB7XG4gIHJldHVybiAhIShvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJylcbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybnMge29iaiBpcyBJdGVyYWJsZX1cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYWJsZSAob2JqKSB7XG4gIHJldHVybiAhIShvYmogIT0gbnVsbCAmJiAodHlwZW9mIG9ialtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Jsb2J8QnVmZmVyfGltcG9ydCAoJ3N0cmVhbScpLlN0cmVhbX0gYm9keVxuICogQHJldHVybnMge251bWJlcnxudWxsfVxuICovXG5mdW5jdGlvbiBib2R5TGVuZ3RoIChib2R5KSB7XG4gIGlmIChib2R5ID09IG51bGwpIHtcbiAgICByZXR1cm4gMFxuICB9IGVsc2UgaWYgKGlzU3RyZWFtKGJvZHkpKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBib2R5Ll9yZWFkYWJsZVN0YXRlXG4gICAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLm9iamVjdE1vZGUgPT09IGZhbHNlICYmIHN0YXRlLmVuZGVkID09PSB0cnVlICYmIE51bWJlci5pc0Zpbml0ZShzdGF0ZS5sZW5ndGgpXG4gICAgICA/IHN0YXRlLmxlbmd0aFxuICAgICAgOiBudWxsXG4gIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShib2R5KSkge1xuICAgIHJldHVybiBib2R5LnNpemUgIT0gbnVsbCA/IGJvZHkuc2l6ZSA6IG51bGxcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihib2R5KSkge1xuICAgIHJldHVybiBib2R5LmJ5dGVMZW5ndGhcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQgKCdzdHJlYW0nKS5TdHJlYW19IGJvZHlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Rlc3Ryb3llZCAoYm9keSkge1xuICByZXR1cm4gYm9keSAmJiAhIShib2R5LmRlc3Ryb3llZCB8fCBib2R5W2tEZXN0cm95ZWRdIHx8IChzdHJlYW0uaXNEZXN0cm95ZWQ/Lihib2R5KSkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQgKCdzdHJlYW0nKS5TdHJlYW19IHN0cmVhbVxuICogQHBhcmFtIHtFcnJvcn0gW2Vycl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkZXN0cm95IChzdHJlYW0sIGVycikge1xuICBpZiAoc3RyZWFtID09IG51bGwgfHwgIWlzU3RyZWFtKHN0cmVhbSkgfHwgaXNEZXN0cm95ZWQoc3RyZWFtKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHR5cGVvZiBzdHJlYW0uZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3RyZWFtKS5jb25zdHJ1Y3RvciA9PT0gSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzM4NTA1L2ZpbGVzXG4gICAgICBzdHJlYW0uc29ja2V0ID0gbnVsbFxuICAgIH1cblxuICAgIHN0cmVhbS5kZXN0cm95KGVycilcbiAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChzdHJlYW0uZGVzdHJveWVkICE9PSB0cnVlKSB7XG4gICAgc3RyZWFtW2tEZXN0cm95ZWRdID0gdHJ1ZVxuICB9XG59XG5cbmNvbnN0IEtFRVBBTElWRV9USU1FT1VUX0VYUFIgPSAvdGltZW91dD0oXFxkKykvXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcbiAqIEByZXR1cm5zIHtudW1iZXIgfCBudWxsfVxuICovXG5mdW5jdGlvbiBwYXJzZUtlZXBBbGl2ZVRpbWVvdXQgKHZhbCkge1xuICBjb25zdCBtID0gdmFsLm1hdGNoKEtFRVBBTElWRV9USU1FT1VUX0VYUFIpXG4gIHJldHVybiBtID8gcGFyc2VJbnQobVsxXSwgMTApICogMTAwMCA6IG51bGxcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBoZWFkZXIgbmFtZSBhbmQgcmV0dXJucyBpdHMgbG93ZXJjYXNlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmcgfCBCdWZmZXJ9IHZhbHVlIEhlYWRlciBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoZWFkZXJOYW1lVG9TdHJpbmcgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG4gICAgPyBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFt2YWx1ZV0gPz8gdmFsdWUudG9Mb3dlckNhc2UoKVxuICAgIDogdHJlZS5sb29rdXAodmFsdWUpID8/IHZhbHVlLnRvU3RyaW5nKCdsYXRpbjEnKS50b0xvd2VyQ2FzZSgpXG59XG5cbi8qKlxuICogUmVjZWl2ZSB0aGUgYnVmZmVyIGFzIGEgc3RyaW5nIGFuZCByZXR1cm4gaXRzIGxvd2VyY2FzZSB2YWx1ZS5cbiAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZSBIZWFkZXIgbmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZSAodmFsdWUpIHtcbiAgcmV0dXJuIHRyZWUubG9va3VwKHZhbHVlKSA/PyB2YWx1ZS50b1N0cmluZygnbGF0aW4xJykudG9Mb3dlckNhc2UoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7KEJ1ZmZlciB8IHN0cmluZylbXX0gaGVhZGVyc1xuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXT59IFtvYmpdXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+fVxuICovXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMgKGhlYWRlcnMsIG9iaikge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIG9iaiA9IHt9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3Qga2V5ID0gaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcnNbaV0pXG4gICAgbGV0IHZhbCA9IG9ialtrZXldXG5cbiAgICBpZiAodmFsKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsID0gW3ZhbF1cbiAgICAgICAgb2JqW2tleV0gPSB2YWxcbiAgICAgIH1cbiAgICAgIHZhbC5wdXNoKGhlYWRlcnNbaSArIDFdLnRvU3RyaW5nKCd1dGY4JykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlYWRlcnNWYWx1ZSA9IGhlYWRlcnNbaSArIDFdXG4gICAgICBpZiAodHlwZW9mIGhlYWRlcnNWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2JqW2tleV0gPSBoZWFkZXJzVmFsdWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gQXJyYXkuaXNBcnJheShoZWFkZXJzVmFsdWUpID8gaGVhZGVyc1ZhbHVlLm1hcCh4ID0+IHgudG9TdHJpbmcoJ3V0ZjgnKSkgOiBoZWFkZXJzVmFsdWUudG9TdHJpbmcoJ3V0ZjgnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC80NjUyOFxuICBpZiAoJ2NvbnRlbnQtbGVuZ3RoJyBpbiBvYmogJiYgJ2NvbnRlbnQtZGlzcG9zaXRpb24nIGluIG9iaikge1xuICAgIG9ialsnY29udGVudC1kaXNwb3NpdGlvbiddID0gQnVmZmVyLmZyb20ob2JqWydjb250ZW50LWRpc3Bvc2l0aW9uJ10pLnRvU3RyaW5nKCdsYXRpbjEnKVxuICB9XG5cbiAgcmV0dXJuIG9ialxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyW119IGhlYWRlcnNcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqL1xuZnVuY3Rpb24gcGFyc2VSYXdIZWFkZXJzIChoZWFkZXJzKSB7XG4gIGNvbnN0IGhlYWRlcnNMZW5ndGggPSBoZWFkZXJzLmxlbmd0aFxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgKi9cbiAgY29uc3QgcmV0ID0gbmV3IEFycmF5KGhlYWRlcnNMZW5ndGgpXG5cbiAgbGV0IGhhc0NvbnRlbnRMZW5ndGggPSBmYWxzZVxuICBsZXQgY29udGVudERpc3Bvc2l0aW9uSWR4ID0gLTFcbiAgbGV0IGtleVxuICBsZXQgdmFsXG4gIGxldCBrTGVuID0gMFxuXG4gIGZvciAobGV0IG4gPSAwOyBuIDwgaGVhZGVyc0xlbmd0aDsgbiArPSAyKSB7XG4gICAga2V5ID0gaGVhZGVyc1tuXVxuICAgIHZhbCA9IGhlYWRlcnNbbiArIDFdXG5cbiAgICB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyAmJiAoa2V5ID0ga2V5LnRvU3RyaW5nKCkpXG4gICAgdHlwZW9mIHZhbCAhPT0gJ3N0cmluZycgJiYgKHZhbCA9IHZhbC50b1N0cmluZygndXRmOCcpKVxuXG4gICAga0xlbiA9IGtleS5sZW5ndGhcbiAgICBpZiAoa0xlbiA9PT0gMTQgJiYga2V5WzddID09PSAnLScgJiYgKGtleSA9PT0gJ2NvbnRlbnQtbGVuZ3RoJyB8fCBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtbGVuZ3RoJykpIHtcbiAgICAgIGhhc0NvbnRlbnRMZW5ndGggPSB0cnVlXG4gICAgfSBlbHNlIGlmIChrTGVuID09PSAxOSAmJiBrZXlbN10gPT09ICctJyAmJiAoa2V5ID09PSAnY29udGVudC1kaXNwb3NpdGlvbicgfHwga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LWRpc3Bvc2l0aW9uJykpIHtcbiAgICAgIGNvbnRlbnREaXNwb3NpdGlvbklkeCA9IG4gKyAxXG4gICAgfVxuICAgIHJldFtuXSA9IGtleVxuICAgIHJldFtuICsgMV0gPSB2YWxcbiAgfVxuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC80NjUyOFxuICBpZiAoaGFzQ29udGVudExlbmd0aCAmJiBjb250ZW50RGlzcG9zaXRpb25JZHggIT09IC0xKSB7XG4gICAgcmV0W2NvbnRlbnREaXNwb3NpdGlvbklkeF0gPSBCdWZmZXIuZnJvbShyZXRbY29udGVudERpc3Bvc2l0aW9uSWR4XSkudG9TdHJpbmcoJ2xhdGluMScpXG4gIH1cblxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gaGVhZGVyc1xuICogQHBhcmFtIHtCdWZmZXJbXX0gaGVhZGVyc1xuICovXG5mdW5jdGlvbiBlbmNvZGVSYXdIZWFkZXJzIChoZWFkZXJzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGhlYWRlcnMgdG8gYmUgYW4gYXJyYXknKVxuICB9XG4gIHJldHVybiBoZWFkZXJzLm1hcCh4ID0+IEJ1ZmZlci5mcm9tKHgpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gYnVmZmVyXG4gKiBAcmV0dXJucyB7YnVmZmVyIGlzIEJ1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIgKGJ1ZmZlcikge1xuICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS9tY29sbGluYS91bmRpY2kvcHVsbC8zMTlcbiAgcmV0dXJuIGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcilcbn1cblxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGhhbmRsZXIgb2JqZWN0IGlzIGEgcmVxdWVzdCBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VwZ3JhZGVdXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyBoYW5kbGVyIGlzIGltcG9ydCgnLi4vYXBpL2FwaS1yZXF1ZXN0JykuUmVxdWVzdEhhbmRsZXJ9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydFJlcXVlc3RIYW5kbGVyIChoYW5kbGVyLCBtZXRob2QsIHVwZ3JhZGUpIHtcbiAgaWYgKCFoYW5kbGVyIHx8IHR5cGVvZiBoYW5kbGVyICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGFuZGxlciBtdXN0IGJlIGFuIG9iamVjdCcpXG4gIH1cblxuICBpZiAodHlwZW9mIGhhbmRsZXIub25SZXF1ZXN0U3RhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUT0RPIChmaXgpOiBNb3JlIGNoZWNrcy4uLlxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uQ29ubmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkNvbm5lY3QgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGFuZGxlci5vbkVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRXJyb3IgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGFuZGxlci5vbkJvZHlTZW50ICE9PSAnZnVuY3Rpb24nICYmIGhhbmRsZXIub25Cb2R5U2VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uQm9keVNlbnQgbWV0aG9kJylcbiAgfVxuXG4gIGlmICh1cGdyYWRlIHx8IG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uVXBncmFkZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uVXBncmFkZSBtZXRob2QnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIub25IZWFkZXJzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25IZWFkZXJzIG1ldGhvZCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uRGF0YSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRGF0YSBtZXRob2QnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkNvbXBsZXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25Db21wbGV0ZSBtZXRob2QnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEEgYm9keSBpcyBkaXN0dXJiZWQgaWYgaXQgaGFzIGJlZW4gcmVhZCBmcm9tIGFuZCBpdCBjYW5ub3QgYmUgcmUtdXNlZCB3aXRob3V0XG4gKiBsb3Npbmcgc3RhdGUgb3IgZGF0YS5cbiAqIEBwYXJhbSB7aW1wb3J0KCdub2RlOnN0cmVhbScpLlJlYWRhYmxlfSBib2R5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEaXN0dXJiZWQgKGJvZHkpIHtcbiAgLy8gVE9ETyAoZml4KTogV2h5IGlzIGJvZHlba0JvZHlVc2VkXSBuZWVkZWQ/XG4gIHJldHVybiAhIShib2R5ICYmIChzdHJlYW0uaXNEaXN0dXJiZWQoYm9keSkgfHwgYm9keVtrQm9keVVzZWRdKSlcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTb2NrZXRJbmZvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xvY2FsQWRkcmVzc11cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbG9jYWxQb3J0XVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtyZW1vdGVBZGRyZXNzXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZW1vdGVQb3J0XVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtyZW1vdGVGYW1pbHldXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbWVvdXRdXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnl0ZXNXcml0dGVuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnl0ZXNSZWFkXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnbmV0JykuU29ja2V0fSBzb2NrZXRcbiAqIEByZXR1cm5zIHtTb2NrZXRJbmZvfVxuICovXG5mdW5jdGlvbiBnZXRTb2NrZXRJbmZvIChzb2NrZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBsb2NhbEFkZHJlc3M6IHNvY2tldC5sb2NhbEFkZHJlc3MsXG4gICAgbG9jYWxQb3J0OiBzb2NrZXQubG9jYWxQb3J0LFxuICAgIHJlbW90ZUFkZHJlc3M6IHNvY2tldC5yZW1vdGVBZGRyZXNzLFxuICAgIHJlbW90ZVBvcnQ6IHNvY2tldC5yZW1vdGVQb3J0LFxuICAgIHJlbW90ZUZhbWlseTogc29ja2V0LnJlbW90ZUZhbWlseSxcbiAgICB0aW1lb3V0OiBzb2NrZXQudGltZW91dCxcbiAgICBieXRlc1dyaXR0ZW46IHNvY2tldC5ieXRlc1dyaXR0ZW4sXG4gICAgYnl0ZXNSZWFkOiBzb2NrZXQuYnl0ZXNSZWFkXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBpdGVyYWJsZVxuICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtfVxuICovXG5mdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZyb20gKGl0ZXJhYmxlKSB7XG4gIC8vIFdlIGNhbm5vdCB1c2UgUmVhZGFibGVTdHJlYW0uZnJvbSBoZXJlIGJlY2F1c2UgaXQgZG9lcyBub3QgcmV0dXJuIGEgYnl0ZSBzdHJlYW0uXG5cbiAgbGV0IGl0ZXJhdG9yXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAge1xuICAgICAgYXN5bmMgc3RhcnQgKCkge1xuICAgICAgICBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpXG4gICAgICB9LFxuICAgICAgcHVsbCAoY29udHJvbGxlcikge1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBwdWxsICgpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KClcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKClcbiAgICAgICAgICAgICAgY29udHJvbGxlci5ieW9iUmVxdWVzdD8ucmVzcG9uZCgwKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSA/IHZhbHVlIDogQnVmZmVyLmZyb20odmFsdWUpXG4gICAgICAgICAgICBpZiAoYnVmLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHVsbCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHB1bGwoKVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGNhbmNlbCAoKSB7XG4gICAgICAgIGF3YWl0IGl0ZXJhdG9yLnJldHVybigpXG4gICAgICB9LFxuICAgICAgdHlwZTogJ2J5dGVzJ1xuICAgIH1cbiAgKVxufVxuXG4vKipcbiAqIFRoZSBvYmplY3Qgc2hvdWxkIGJlIGEgRm9ybURhdGEgaW5zdGFuY2UgYW5kIGNvbnRhaW5zIGFsbCB0aGUgcmVxdWlyZWRcbiAqIG1ldGhvZHMuXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybnMge29iamVjdCBpcyBGb3JtRGF0YX1cbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YUxpa2UgKG9iamVjdCkge1xuICByZXR1cm4gKFxuICAgIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5hcHBlbmQgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmRlbGV0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3QuZ2V0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iamVjdC5nZXRBbGwgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmhhcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3Quc2V0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgb2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGb3JtRGF0YSdcbiAgKVxufVxuXG5mdW5jdGlvbiBhZGRBYm9ydExpc3RlbmVyIChzaWduYWwsIGxpc3RlbmVyKSB7XG4gIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gc2lnbmFsKSB7XG4gICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KVxuICAgIHJldHVybiAoKSA9PiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBsaXN0ZW5lcilcbiAgfVxuICBzaWduYWwub25jZSgnYWJvcnQnLCBsaXN0ZW5lcilcbiAgcmV0dXJuICgpID0+IHNpZ25hbC5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBsaXN0ZW5lcilcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yLjZcbiAqIEBwYXJhbSB7bnVtYmVyfSBjXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNUb2tlbkNoYXJDb2RlIChjKSB7XG4gIHN3aXRjaCAoYykge1xuICAgIGNhc2UgMHgyMjpcbiAgICBjYXNlIDB4Mjg6XG4gICAgY2FzZSAweDI5OlxuICAgIGNhc2UgMHgyYzpcbiAgICBjYXNlIDB4MmY6XG4gICAgY2FzZSAweDNhOlxuICAgIGNhc2UgMHgzYjpcbiAgICBjYXNlIDB4M2M6XG4gICAgY2FzZSAweDNkOlxuICAgIGNhc2UgMHgzZTpcbiAgICBjYXNlIDB4M2Y6XG4gICAgY2FzZSAweDQwOlxuICAgIGNhc2UgMHg1YjpcbiAgICBjYXNlIDB4NWM6XG4gICAgY2FzZSAweDVkOlxuICAgIGNhc2UgMHg3YjpcbiAgICBjYXNlIDB4N2Q6XG4gICAgICAvLyBEUVVPVEUgYW5kIFwiKCksLzo7PD0+P0BbXFxde31cIlxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFZDSEFSICV4MjEtN0VcbiAgICAgIHJldHVybiBjID49IDB4MjEgJiYgYyA8PSAweDdlXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhcmFjdGVyc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRIVFRQVG9rZW4gKGNoYXJhY3RlcnMpIHtcbiAgaWYgKGNoYXJhY3RlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyYWN0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFpc1Rva2VuQ2hhckNvZGUoY2hhcmFjdGVycy5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIGhlYWRlckNoYXJSZWdleCBoYXZlIGJlZW4gbGlmdGVkIGZyb21cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21haW4vbGliL19odHRwX2NvbW1vbi5qc1xuXG4vKipcbiAqIE1hdGNoZXMgaWYgdmFsIGNvbnRhaW5zIGFuIGludmFsaWQgZmllbGQtdmNoYXJcbiAqICBmaWVsZC12YWx1ZSAgICA9ICooIGZpZWxkLWNvbnRlbnQgLyBvYnMtZm9sZCApXG4gKiAgZmllbGQtY29udGVudCAgPSBmaWVsZC12Y2hhciBbIDEqKCBTUCAvIEhUQUIgKSBmaWVsZC12Y2hhciBdXG4gKiAgZmllbGQtdmNoYXIgICAgPSBWQ0hBUiAvIG9icy10ZXh0XG4gKi9cbmNvbnN0IGhlYWRlckNoYXJSZWdleCA9IC9bXlxcdFxceDIwLVxceDdlXFx4ODAtXFx4ZmZdL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyYWN0ZXJzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEhlYWRlclZhbHVlIChjaGFyYWN0ZXJzKSB7XG4gIHJldHVybiAhaGVhZGVyQ2hhclJlZ2V4LnRlc3QoY2hhcmFjdGVycylcbn1cblxuY29uc3QgcmFuZ2VIZWFkZXJSZWdleCA9IC9eYnl0ZXMgKFxcZCspLShcXGQrKVxcLyhcXGQrKT8kL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFJhbmdlSGVhZGVyXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhcnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyIHwgbnVsbH0gZW5kXG4gKiBAcHJvcGVydHkge251bWJlciB8IG51bGx9IHNpemVcbiAqL1xuXG4vKipcbiAqIFBhcnNlIGFjY29yZGluZ2x5IHRvIFJGQyA5MTEwXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MTEwI2ZpZWxkLmNvbnRlbnQtcmFuZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcmFuZ2VdXG4gKiBAcmV0dXJucyB7UmFuZ2VIZWFkZXJ8bnVsbH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VSYW5nZUhlYWRlciAocmFuZ2UpIHtcbiAgaWYgKHJhbmdlID09IG51bGwgfHwgcmFuZ2UgPT09ICcnKSByZXR1cm4geyBzdGFydDogMCwgZW5kOiBudWxsLCBzaXplOiBudWxsIH1cblxuICBjb25zdCBtID0gcmFuZ2UgPyByYW5nZS5tYXRjaChyYW5nZUhlYWRlclJlZ2V4KSA6IG51bGxcbiAgcmV0dXJuIG1cbiAgICA/IHtcbiAgICAgICAgc3RhcnQ6IHBhcnNlSW50KG1bMV0pLFxuICAgICAgICBlbmQ6IG1bMl0gPyBwYXJzZUludChtWzJdKSA6IG51bGwsXG4gICAgICAgIHNpemU6IG1bM10gPyBwYXJzZUludChtWzNdKSA6IG51bGxcbiAgICAgIH1cbiAgICA6IG51bGxcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcImV2ZW50c1wiKS5FdmVudEVtaXR0ZXJ9IFRcbiAqIEBwYXJhbSB7VH0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsoLi4uYXJnczogYW55W10pID0+IHZvaWR9IGxpc3RlbmVyXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIgKG9iaiwgbmFtZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgbGlzdGVuZXJzID0gKG9ialtrTGlzdGVuZXJzXSA/Pz0gW10pXG4gIGxpc3RlbmVycy5wdXNoKFtuYW1lLCBsaXN0ZW5lcl0pXG4gIG9iai5vbihuYW1lLCBsaXN0ZW5lcilcbiAgcmV0dXJuIG9ialxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiZXZlbnRzXCIpLkV2ZW50RW1pdHRlcn0gVFxuICogQHBhcmFtIHtUfSBvYmpcbiAqIEByZXR1cm5zIHtUfVxuICovXG5mdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMgKG9iaikge1xuICBpZiAob2JqW2tMaXN0ZW5lcnNdICE9IG51bGwpIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBsaXN0ZW5lcl0gb2Ygb2JqW2tMaXN0ZW5lcnNdKSB7XG4gICAgICBvYmoucmVtb3ZlTGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpXG4gICAgfVxuICAgIG9ialtrTGlzdGVuZXJzXSA9IG51bGxcbiAgfVxuICByZXR1cm4gb2JqXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQgKCcuLi9kaXNwYXRjaGVyL2NsaWVudCcpfSBjbGllbnRcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi4vY29yZS9yZXF1ZXN0Jyl9IHJlcXVlc3RcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICovXG5mdW5jdGlvbiBlcnJvclJlcXVlc3QgKGNsaWVudCwgcmVxdWVzdCwgZXJyKSB7XG4gIHRyeSB7XG4gICAgcmVxdWVzdC5vbkVycm9yKGVycilcbiAgICBhc3NlcnQocmVxdWVzdC5hYm9ydGVkKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjbGllbnQuZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1dlYWtSZWY8bmV0LlNvY2tldD59IHNvY2tldFdlYWtSZWZcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy50aW1lb3V0XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5ob3N0bmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMucG9ydFxuICogQHJldHVybnMgeygpID0+IHZvaWR9XG4gKi9cbmNvbnN0IHNldHVwQ29ubmVjdFRpbWVvdXQgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXG4gID8gKHNvY2tldFdlYWtSZWYsIG9wdHMpID0+IHtcbiAgICAgIGlmICghb3B0cy50aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiBub29wXG4gICAgICB9XG5cbiAgICAgIGxldCBzMSA9IG51bGxcbiAgICAgIGxldCBzMiA9IG51bGxcbiAgICAgIGNvbnN0IGZhc3RUaW1lciA9IHRpbWVycy5zZXRGYXN0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyBzZXRJbW1lZGlhdGUgaXMgYWRkZWQgdG8gbWFrZSBzdXJlIHRoYXQgd2UgcHJpb3JpdGl6ZSBzb2NrZXQgZXJyb3IgZXZlbnRzIG92ZXIgdGltZW91dHNcbiAgICAgICAgczEgPSBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAvLyBXaW5kb3dzIG5lZWRzIGFuIGV4dHJhIHNldEltbWVkaWF0ZSBwcm9iYWJseSBkdWUgdG8gaW1wbGVtZW50YXRpb24gZGlmZmVyZW5jZXMgaW4gdGhlIHNvY2tldCBsb2dpY1xuICAgICAgICAgIHMyID0gc2V0SW1tZWRpYXRlKCgpID0+IG9uQ29ubmVjdFRpbWVvdXQoc29ja2V0V2Vha1JlZi5kZXJlZigpLCBvcHRzKSlcbiAgICAgICAgfSlcbiAgICAgIH0sIG9wdHMudGltZW91dClcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHRpbWVycy5jbGVhckZhc3RUaW1lb3V0KGZhc3RUaW1lcilcbiAgICAgICAgY2xlYXJJbW1lZGlhdGUoczEpXG4gICAgICAgIGNsZWFySW1tZWRpYXRlKHMyKVxuICAgICAgfVxuICAgIH1cbiAgOiAoc29ja2V0V2Vha1JlZiwgb3B0cykgPT4ge1xuICAgICAgaWYgKCFvcHRzLnRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIG5vb3BcbiAgICAgIH1cblxuICAgICAgbGV0IHMxID0gbnVsbFxuICAgICAgY29uc3QgZmFzdFRpbWVyID0gdGltZXJzLnNldEZhc3RUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIHNldEltbWVkaWF0ZSBpcyBhZGRlZCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBwcmlvcml0aXplIHNvY2tldCBlcnJvciBldmVudHMgb3ZlciB0aW1lb3V0c1xuICAgICAgICBzMSA9IHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgb25Db25uZWN0VGltZW91dChzb2NrZXRXZWFrUmVmLmRlcmVmKCksIG9wdHMpXG4gICAgICAgIH0pXG4gICAgICB9LCBvcHRzLnRpbWVvdXQpXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB0aW1lcnMuY2xlYXJGYXN0VGltZW91dChmYXN0VGltZXIpXG4gICAgICAgIGNsZWFySW1tZWRpYXRlKHMxKVxuICAgICAgfVxuICAgIH1cblxuLyoqXG4gKiBAcGFyYW0ge25ldC5Tb2NrZXR9IHNvY2tldFxuICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnRpbWVvdXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmhvc3RuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy5wb3J0XG4gKi9cbmZ1bmN0aW9uIG9uQ29ubmVjdFRpbWVvdXQgKHNvY2tldCwgb3B0cykge1xuICAvLyBUaGUgc29ja2V0IGNvdWxkIGJlIGFscmVhZHkgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgaWYgKHNvY2tldCA9PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgbWVzc2FnZSA9ICdDb25uZWN0IFRpbWVvdXQgRXJyb3InXG4gIGlmIChBcnJheS5pc0FycmF5KHNvY2tldC5hdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdGVkQWRkcmVzc2VzKSkge1xuICAgIG1lc3NhZ2UgKz0gYCAoYXR0ZW1wdGVkIGFkZHJlc3NlczogJHtzb2NrZXQuYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRlZEFkZHJlc3Nlcy5qb2luKCcsICcpfSxgXG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZSArPSBgIChhdHRlbXB0ZWQgYWRkcmVzczogJHtvcHRzLmhvc3RuYW1lfToke29wdHMucG9ydH0sYFxuICB9XG5cbiAgbWVzc2FnZSArPSBgIHRpbWVvdXQ6ICR7b3B0cy50aW1lb3V0fW1zKWBcblxuICBkZXN0cm95KHNvY2tldCwgbmV3IENvbm5lY3RUaW1lb3V0RXJyb3IobWVzc2FnZSkpXG59XG5cbmNvbnN0IGtFbnVtZXJhYmxlUHJvcGVydHkgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5rRW51bWVyYWJsZVByb3BlcnR5LmVudW1lcmFibGUgPSB0cnVlXG5cbmNvbnN0IG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSA9IHtcbiAgZGVsZXRlOiAnREVMRVRFJyxcbiAgREVMRVRFOiAnREVMRVRFJyxcbiAgZ2V0OiAnR0VUJyxcbiAgR0VUOiAnR0VUJyxcbiAgaGVhZDogJ0hFQUQnLFxuICBIRUFEOiAnSEVBRCcsXG4gIG9wdGlvbnM6ICdPUFRJT05TJyxcbiAgT1BUSU9OUzogJ09QVElPTlMnLFxuICBwb3N0OiAnUE9TVCcsXG4gIFBPU1Q6ICdQT1NUJyxcbiAgcHV0OiAnUFVUJyxcbiAgUFVUOiAnUFVUJ1xufVxuXG5jb25zdCBub3JtYWxpemVkTWV0aG9kUmVjb3JkcyA9IHtcbiAgLi4ubm9ybWFsaXplZE1ldGhvZFJlY29yZHNCYXNlLFxuICBwYXRjaDogJ3BhdGNoJyxcbiAgUEFUQ0g6ICdQQVRDSCdcbn1cblxuLy8gTm90ZTogb2JqZWN0IHByb3RvdHlwZXMgc2hvdWxkIG5vdCBiZSBhYmxlIHRvIGJlIHJlZmVyZW5jZWQuIGUuZy4gYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAuXG5PYmplY3Quc2V0UHJvdG90eXBlT2Yobm9ybWFsaXplZE1ldGhvZFJlY29yZHNCYXNlLCBudWxsKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzLCBudWxsKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaXNEaXN0dXJiZWQsXG4gIGlzQmxvYkxpa2UsXG4gIHBhcnNlT3JpZ2luLFxuICBwYXJzZVVSTCxcbiAgZ2V0U2VydmVyTmFtZSxcbiAgaXNTdHJlYW0sXG4gIGlzSXRlcmFibGUsXG4gIGlzQXN5bmNJdGVyYWJsZSxcbiAgaXNEZXN0cm95ZWQsXG4gIGhlYWRlck5hbWVUb1N0cmluZyxcbiAgYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZSxcbiAgYWRkTGlzdGVuZXIsXG4gIHJlbW92ZUFsbExpc3RlbmVycyxcbiAgZXJyb3JSZXF1ZXN0LFxuICBwYXJzZVJhd0hlYWRlcnMsXG4gIGVuY29kZVJhd0hlYWRlcnMsXG4gIHBhcnNlSGVhZGVycyxcbiAgcGFyc2VLZWVwQWxpdmVUaW1lb3V0LFxuICBkZXN0cm95LFxuICBib2R5TGVuZ3RoLFxuICBkZWVwQ2xvbmUsXG4gIFJlYWRhYmxlU3RyZWFtRnJvbSxcbiAgaXNCdWZmZXIsXG4gIGFzc2VydFJlcXVlc3RIYW5kbGVyLFxuICBnZXRTb2NrZXRJbmZvLFxuICBpc0Zvcm1EYXRhTGlrZSxcbiAgc2VyaWFsaXplUGF0aFdpdGhRdWVyeSxcbiAgYWRkQWJvcnRMaXN0ZW5lcixcbiAgaXNWYWxpZEhUVFBUb2tlbixcbiAgaXNWYWxpZEhlYWRlclZhbHVlLFxuICBpc1Rva2VuQ2hhckNvZGUsXG4gIHBhcnNlUmFuZ2VIZWFkZXIsXG4gIG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSxcbiAgbm9ybWFsaXplZE1ldGhvZFJlY29yZHMsXG4gIGlzVmFsaWRQb3J0LFxuICBpc0h0dHBPckh0dHBzUHJlZml4ZWQsXG4gIG5vZGVNYWpvcixcbiAgbm9kZU1pbm9yLFxuICBzYWZlSFRUUE1ldGhvZHM6IE9iamVjdC5mcmVlemUoWydHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1RSQUNFJ10pLFxuICB3cmFwUmVxdWVzdEJvZHksXG4gIHNldHVwQ29ubmVjdFRpbWVvdXRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/agent.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { kClients, kRunning, kClose, kDestroy, kDispatch, kUrl } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst Client = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kOnDrain = Symbol('onDrain')\nconst kFactory = Symbol('factory')\nconst kOptions = Symbol('options')\n\nfunction defaultFactory (origin, opts) {\n  return opts && opts.connections === 1\n    ? new Client(origin, opts)\n    : new Pool(origin, opts)\n}\n\nclass Agent extends DispatcherBase {\n  constructor ({ factory = defaultFactory, connect, ...options } = {}) {\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    super()\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect }\n    }\n\n    this[kOptions] = { ...util.deepClone(options), connect }\n    this[kFactory] = factory\n    this[kClients] = new Map()\n\n    this[kOnDrain] = (origin, targets) => {\n      this.emit('drain', origin, [this, ...targets])\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      const result = this[kClients].get(origin)\n      if (result) {\n        result.count += 1\n      }\n      this.emit('connect', origin, [this, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      const result = this[kClients].get(origin)\n      if (result) {\n        result.count -= 1\n        if (result.count <= 0) {\n          this[kClients].delete(origin)\n          result.dispatcher.destroy()\n        }\n      }\n      this.emit('disconnect', origin, [this, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      // TODO: should this decrement result.count here?\n      this.emit('connectionError', origin, [this, ...targets], err)\n    }\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const { dispatcher } of this[kClients].values()) {\n      ret += dispatcher[kRunning]\n    }\n    return ret\n  }\n\n  [kDispatch] (opts, handler) {\n    let key\n    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n      key = String(opts.origin)\n    } else {\n      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')\n    }\n\n    const result = this[kClients].get(key)\n    let dispatcher = result && result.dispatcher\n    if (!dispatcher) {\n      dispatcher = this[kFactory](opts.origin, this[kOptions])\n        .on('drain', this[kOnDrain])\n        .on('connect', this[kOnConnect])\n        .on('disconnect', this[kOnDisconnect])\n        .on('connectionError', this[kOnConnectionError])\n\n      this[kClients].set(key, { count: 0, dispatcher })\n    }\n\n    return dispatcher.dispatch(opts, handler)\n  }\n\n  async [kClose] () {\n    const closePromises = []\n    for (const { dispatcher } of this[kClients].values()) {\n      closePromises.push(dispatcher.close())\n    }\n    this[kClients].clear()\n\n    await Promise.all(closePromises)\n  }\n\n  async [kDestroy] (err) {\n    const destroyPromises = []\n    for (const { dispatcher } of this[kClients].values()) {\n      destroyPromises.push(dispatcher.destroy(err))\n    }\n    this[kClients].clear()\n\n    await Promise.all(destroyPromises)\n  }\n\n  get stats () {\n    const allClientStats = {}\n    for (const { dispatcher } of this[kClients].values()) {\n      if (dispatcher.stats) {\n        allClientStats[dispatcher[kUrl].origin] = dispatcher.stats\n      }\n    }\n    return allClientStats\n  }\n}\n\nmodule.exports = Agent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2FnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDekQsUUFBUSx3REFBd0QsRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjtBQUMzRix1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDbEQsYUFBYSxtQkFBTyxDQUFDLGtFQUFRO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyxzRUFBVTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsa0VBQWM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdEQUFnRCxJQUFJO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2FnZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7IGtDbGllbnRzLCBrUnVubmluZywga0Nsb3NlLCBrRGVzdHJveSwga0Rpc3BhdGNoLCBrVXJsIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi9wb29sJylcbmNvbnN0IENsaWVudCA9IHJlcXVpcmUoJy4vY2xpZW50JylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuXG5jb25zdCBrT25Db25uZWN0ID0gU3ltYm9sKCdvbkNvbm5lY3QnKVxuY29uc3Qga09uRGlzY29ubmVjdCA9IFN5bWJvbCgnb25EaXNjb25uZWN0JylcbmNvbnN0IGtPbkNvbm5lY3Rpb25FcnJvciA9IFN5bWJvbCgnb25Db25uZWN0aW9uRXJyb3InKVxuY29uc3Qga09uRHJhaW4gPSBTeW1ib2woJ29uRHJhaW4nKVxuY29uc3Qga0ZhY3RvcnkgPSBTeW1ib2woJ2ZhY3RvcnknKVxuY29uc3Qga09wdGlvbnMgPSBTeW1ib2woJ29wdGlvbnMnKVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIG9wdHMuY29ubmVjdGlvbnMgPT09IDFcbiAgICA/IG5ldyBDbGllbnQob3JpZ2luLCBvcHRzKVxuICAgIDogbmV3IFBvb2wob3JpZ2luLCBvcHRzKVxufVxuXG5jbGFzcyBBZ2VudCBleHRlbmRzIERpc3BhdGNoZXJCYXNlIHtcbiAgY29uc3RydWN0b3IgKHsgZmFjdG9yeSA9IGRlZmF1bHRGYWN0b3J5LCBjb25uZWN0LCAuLi5vcHRpb25zIH0gPSB7fSkge1xuICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdmYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0ICE9IG51bGwgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2Nvbm5lY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgc3VwZXIoKVxuXG4gICAgaWYgKGNvbm5lY3QgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbm5lY3QgPSB7IC4uLmNvbm5lY3QgfVxuICAgIH1cblxuICAgIHRoaXNba09wdGlvbnNdID0geyAuLi51dGlsLmRlZXBDbG9uZShvcHRpb25zKSwgY29ubmVjdCB9XG4gICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5XG4gICAgdGhpc1trQ2xpZW50c10gPSBuZXcgTWFwKClcblxuICAgIHRoaXNba09uRHJhaW5dID0gKG9yaWdpbiwgdGFyZ2V0cykgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdkcmFpbicsIG9yaWdpbiwgW3RoaXMsIC4uLnRhcmdldHNdKVxuICAgIH1cblxuICAgIHRoaXNba09uQ29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzW2tDbGllbnRzXS5nZXQob3JpZ2luKVxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXN1bHQuY291bnQgKz0gMVxuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCdjb25uZWN0Jywgb3JpZ2luLCBbdGhpcywgLi4udGFyZ2V0c10pXG4gICAgfVxuXG4gICAgdGhpc1trT25EaXNjb25uZWN0XSA9IChvcmlnaW4sIHRhcmdldHMsIGVycikgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpc1trQ2xpZW50c10uZ2V0KG9yaWdpbilcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LmNvdW50IC09IDFcbiAgICAgICAgaWYgKHJlc3VsdC5jb3VudCA8PSAwKSB7XG4gICAgICAgICAgdGhpc1trQ2xpZW50c10uZGVsZXRlKG9yaWdpbilcbiAgICAgICAgICByZXN1bHQuZGlzcGF0Y2hlci5kZXN0cm95KClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCdkaXNjb25uZWN0Jywgb3JpZ2luLCBbdGhpcywgLi4udGFyZ2V0c10sIGVycilcbiAgICB9XG5cbiAgICB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0gPSAob3JpZ2luLCB0YXJnZXRzLCBlcnIpID0+IHtcbiAgICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIGRlY3JlbWVudCByZXN1bHQuY291bnQgaGVyZT9cbiAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbkVycm9yJywgb3JpZ2luLCBbdGhpcywgLi4udGFyZ2V0c10sIGVycilcbiAgICB9XG4gIH1cblxuICBnZXQgW2tSdW5uaW5nXSAoKSB7XG4gICAgbGV0IHJldCA9IDBcbiAgICBmb3IgKGNvbnN0IHsgZGlzcGF0Y2hlciB9IG9mIHRoaXNba0NsaWVudHNdLnZhbHVlcygpKSB7XG4gICAgICByZXQgKz0gZGlzcGF0Y2hlcltrUnVubmluZ11cbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgW2tEaXNwYXRjaF0gKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBsZXQga2V5XG4gICAgaWYgKG9wdHMub3JpZ2luICYmICh0eXBlb2Ygb3B0cy5vcmlnaW4gPT09ICdzdHJpbmcnIHx8IG9wdHMub3JpZ2luIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAga2V5ID0gU3RyaW5nKG9wdHMub3JpZ2luKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdHMub3JpZ2luIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIG9yIFVSTC4nKVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXNba0NsaWVudHNdLmdldChrZXkpXG4gICAgbGV0IGRpc3BhdGNoZXIgPSByZXN1bHQgJiYgcmVzdWx0LmRpc3BhdGNoZXJcbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShvcHRzLm9yaWdpbiwgdGhpc1trT3B0aW9uc10pXG4gICAgICAgIC5vbignZHJhaW4nLCB0aGlzW2tPbkRyYWluXSlcbiAgICAgICAgLm9uKCdjb25uZWN0JywgdGhpc1trT25Db25uZWN0XSlcbiAgICAgICAgLm9uKCdkaXNjb25uZWN0JywgdGhpc1trT25EaXNjb25uZWN0XSlcbiAgICAgICAgLm9uKCdjb25uZWN0aW9uRXJyb3InLCB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0pXG5cbiAgICAgIHRoaXNba0NsaWVudHNdLnNldChrZXksIHsgY291bnQ6IDAsIGRpc3BhdGNoZXIgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gZGlzcGF0Y2hlci5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGNvbnN0IGNsb3NlUHJvbWlzZXMgPSBbXVxuICAgIGZvciAoY29uc3QgeyBkaXNwYXRjaGVyIH0gb2YgdGhpc1trQ2xpZW50c10udmFsdWVzKCkpIHtcbiAgICAgIGNsb3NlUHJvbWlzZXMucHVzaChkaXNwYXRjaGVyLmNsb3NlKCkpXG4gICAgfVxuICAgIHRoaXNba0NsaWVudHNdLmNsZWFyKClcblxuICAgIGF3YWl0IFByb21pc2UuYWxsKGNsb3NlUHJvbWlzZXMpXG4gIH1cblxuICBhc3luYyBba0Rlc3Ryb3ldIChlcnIpIHtcbiAgICBjb25zdCBkZXN0cm95UHJvbWlzZXMgPSBbXVxuICAgIGZvciAoY29uc3QgeyBkaXNwYXRjaGVyIH0gb2YgdGhpc1trQ2xpZW50c10udmFsdWVzKCkpIHtcbiAgICAgIGRlc3Ryb3lQcm9taXNlcy5wdXNoKGRpc3BhdGNoZXIuZGVzdHJveShlcnIpKVxuICAgIH1cbiAgICB0aGlzW2tDbGllbnRzXS5jbGVhcigpXG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChkZXN0cm95UHJvbWlzZXMpXG4gIH1cblxuICBnZXQgc3RhdHMgKCkge1xuICAgIGNvbnN0IGFsbENsaWVudFN0YXRzID0ge31cbiAgICBmb3IgKGNvbnN0IHsgZGlzcGF0Y2hlciB9IG9mIHRoaXNba0NsaWVudHNdLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZGlzcGF0Y2hlci5zdGF0cykge1xuICAgICAgICBhbGxDbGllbnRTdGF0c1tkaXNwYXRjaGVyW2tVcmxdLm9yaWdpbl0gPSBkaXNwYXRjaGVyLnN0YXRzXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbGxDbGllbnRTdGF0c1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWdlbnRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/balanced-pool.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/balanced-pool.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  BalancedPoolMissingUpstreamError,\n  InvalidArgumentError\n} = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = __webpack_require__(/*! ./pool-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool-base.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst { kUrl } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { parseOrigin } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst kFactory = Symbol('factory')\n\nconst kOptions = Symbol('options')\nconst kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor')\nconst kCurrentWeight = Symbol('kCurrentWeight')\nconst kIndex = Symbol('kIndex')\nconst kWeight = Symbol('kWeight')\nconst kMaxWeightPerServer = Symbol('kMaxWeightPerServer')\nconst kErrorPenalty = Symbol('kErrorPenalty')\n\n/**\n * Calculate the greatest common divisor of two numbers by\n * using the Euclidean algorithm.\n *\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction getGreatestCommonDivisor (a, b) {\n  if (a === 0) return b\n\n  while (b !== 0) {\n    const t = b\n    b = a % b\n    a = t\n  }\n  return a\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nclass BalancedPool extends PoolBase {\n  constructor (upstreams = [], { factory = defaultFactory, ...opts } = {}) {\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    super()\n\n    this[kOptions] = opts\n    this[kIndex] = -1\n    this[kCurrentWeight] = 0\n\n    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100\n    this[kErrorPenalty] = this[kOptions].errorPenalty || 15\n\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams]\n    }\n\n    this[kFactory] = factory\n\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream)\n    }\n    this._updateBalancedPoolStats()\n  }\n\n  addUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    if (this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))) {\n      return this\n    }\n    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]))\n\n    this[kAddClient](pool)\n    pool.on('connect', () => {\n      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty])\n    })\n\n    pool.on('connectionError', () => {\n      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n      this._updateBalancedPoolStats()\n    })\n\n    pool.on('disconnect', (...args) => {\n      const err = args[2]\n      if (err && err.code === 'UND_ERR_SOCKET') {\n        // decrease the weight of the pool.\n        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n        this._updateBalancedPoolStats()\n      }\n    })\n\n    for (const client of this[kClients]) {\n      client[kWeight] = this[kMaxWeightPerServer]\n    }\n\n    this._updateBalancedPoolStats()\n\n    return this\n  }\n\n  _updateBalancedPoolStats () {\n    let result = 0\n    for (let i = 0; i < this[kClients].length; i++) {\n      result = getGreatestCommonDivisor(this[kClients][i][kWeight], result)\n    }\n\n    this[kGreatestCommonDivisor] = result\n  }\n\n  removeUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    const pool = this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))\n\n    if (pool) {\n      this[kRemoveClient](pool)\n    }\n\n    return this\n  }\n\n  get upstreams () {\n    return this[kClients]\n      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)\n      .map((p) => p[kUrl].origin)\n  }\n\n  [kGetDispatcher] () {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError()\n    }\n\n    const dispatcher = this[kClients].find(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n\n    if (!dispatcher) {\n      return\n    }\n\n    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true)\n\n    if (allClientsBusy) {\n      return\n    }\n\n    let counter = 0\n\n    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain])\n\n    while (counter++ < this[kClients].length) {\n      this[kIndex] = (this[kIndex] + 1) % this[kClients].length\n      const pool = this[kClients][this[kIndex]]\n\n      // find pool index with the largest weight\n      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n        maxWeightIndex = this[kIndex]\n      }\n\n      // decrease the current weight every `this[kClients].length`.\n      if (this[kIndex] === 0) {\n        // Set the current weight to the next lower weight.\n        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor]\n\n        if (this[kCurrentWeight] <= 0) {\n          this[kCurrentWeight] = this[kMaxWeightPerServer]\n        }\n      }\n      if (pool[kWeight] >= this[kCurrentWeight] && (!pool[kNeedDrain])) {\n        return pool\n      }\n    }\n\n    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight]\n    this[kIndex] = maxWeightIndex\n    return this[kClients][maxWeightIndex]\n  }\n}\n\nmodule.exports = BalancedPool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2JhbGFuY2VkLXBvb2wuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEVBQWE7QUFDekIsYUFBYSxtQkFBTyxDQUFDLGtFQUFRO0FBQzdCLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsd0VBQWlCO0FBQzFDLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsa0VBQWM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLG9DQUFvQyxJQUFJO0FBQ3pFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2JhbGFuY2VkLXBvb2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3Qge1xuICBQb29sQmFzZSxcbiAga0NsaWVudHMsXG4gIGtOZWVkRHJhaW4sXG4gIGtBZGRDbGllbnQsXG4gIGtSZW1vdmVDbGllbnQsXG4gIGtHZXREaXNwYXRjaGVyXG59ID0gcmVxdWlyZSgnLi9wb29sLWJhc2UnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vcG9vbCcpXG5jb25zdCB7IGtVcmwgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IHBhcnNlT3JpZ2luIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3Qga0ZhY3RvcnkgPSBTeW1ib2woJ2ZhY3RvcnknKVxuXG5jb25zdCBrT3B0aW9ucyA9IFN5bWJvbCgnb3B0aW9ucycpXG5jb25zdCBrR3JlYXRlc3RDb21tb25EaXZpc29yID0gU3ltYm9sKCdrR3JlYXRlc3RDb21tb25EaXZpc29yJylcbmNvbnN0IGtDdXJyZW50V2VpZ2h0ID0gU3ltYm9sKCdrQ3VycmVudFdlaWdodCcpXG5jb25zdCBrSW5kZXggPSBTeW1ib2woJ2tJbmRleCcpXG5jb25zdCBrV2VpZ2h0ID0gU3ltYm9sKCdrV2VpZ2h0JylcbmNvbnN0IGtNYXhXZWlnaHRQZXJTZXJ2ZXIgPSBTeW1ib2woJ2tNYXhXZWlnaHRQZXJTZXJ2ZXInKVxuY29uc3Qga0Vycm9yUGVuYWx0eSA9IFN5bWJvbCgna0Vycm9yUGVuYWx0eScpXG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBncmVhdGVzdCBjb21tb24gZGl2aXNvciBvZiB0d28gbnVtYmVycyBieVxuICogdXNpbmcgdGhlIEV1Y2xpZGVhbiBhbGdvcml0aG0uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IgKGEsIGIpIHtcbiAgaWYgKGEgPT09IDApIHJldHVybiBiXG5cbiAgd2hpbGUgKGIgIT09IDApIHtcbiAgICBjb25zdCB0ID0gYlxuICAgIGIgPSBhICUgYlxuICAgIGEgPSB0XG4gIH1cbiAgcmV0dXJuIGFcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEZhY3RvcnkgKG9yaWdpbiwgb3B0cykge1xuICByZXR1cm4gbmV3IFBvb2wob3JpZ2luLCBvcHRzKVxufVxuXG5jbGFzcyBCYWxhbmNlZFBvb2wgZXh0ZW5kcyBQb29sQmFzZSB7XG4gIGNvbnN0cnVjdG9yICh1cHN0cmVhbXMgPSBbXSwgeyBmYWN0b3J5ID0gZGVmYXVsdEZhY3RvcnksIC4uLm9wdHMgfSA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpXG4gICAgfVxuXG4gICAgc3VwZXIoKVxuXG4gICAgdGhpc1trT3B0aW9uc10gPSBvcHRzXG4gICAgdGhpc1trSW5kZXhdID0gLTFcbiAgICB0aGlzW2tDdXJyZW50V2VpZ2h0XSA9IDBcblxuICAgIHRoaXNba01heFdlaWdodFBlclNlcnZlcl0gPSB0aGlzW2tPcHRpb25zXS5tYXhXZWlnaHRQZXJTZXJ2ZXIgfHwgMTAwXG4gICAgdGhpc1trRXJyb3JQZW5hbHR5XSA9IHRoaXNba09wdGlvbnNdLmVycm9yUGVuYWx0eSB8fCAxNVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHVwc3RyZWFtcykpIHtcbiAgICAgIHVwc3RyZWFtcyA9IFt1cHN0cmVhbXNdXG4gICAgfVxuXG4gICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5XG5cbiAgICBmb3IgKGNvbnN0IHVwc3RyZWFtIG9mIHVwc3RyZWFtcykge1xuICAgICAgdGhpcy5hZGRVcHN0cmVhbSh1cHN0cmVhbSlcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuICB9XG5cbiAgYWRkVXBzdHJlYW0gKHVwc3RyZWFtKSB7XG4gICAgY29uc3QgdXBzdHJlYW1PcmlnaW4gPSBwYXJzZU9yaWdpbih1cHN0cmVhbSkub3JpZ2luXG5cbiAgICBpZiAodGhpc1trQ2xpZW50c10uZmluZCgocG9vbCkgPT4gKFxuICAgICAgcG9vbFtrVXJsXS5vcmlnaW4gPT09IHVwc3RyZWFtT3JpZ2luICYmXG4gICAgICBwb29sLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgcG9vbC5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgY29uc3QgcG9vbCA9IHRoaXNba0ZhY3RvcnldKHVwc3RyZWFtT3JpZ2luLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzW2tPcHRpb25zXSkpXG5cbiAgICB0aGlzW2tBZGRDbGllbnRdKHBvb2wpXG4gICAgcG9vbC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgIHBvb2xba1dlaWdodF0gPSBNYXRoLm1pbih0aGlzW2tNYXhXZWlnaHRQZXJTZXJ2ZXJdLCBwb29sW2tXZWlnaHRdICsgdGhpc1trRXJyb3JQZW5hbHR5XSlcbiAgICB9KVxuXG4gICAgcG9vbC5vbignY29ubmVjdGlvbkVycm9yJywgKCkgPT4ge1xuICAgICAgcG9vbFtrV2VpZ2h0XSA9IE1hdGgubWF4KDEsIHBvb2xba1dlaWdodF0gLSB0aGlzW2tFcnJvclBlbmFsdHldKVxuICAgICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuICAgIH0pXG5cbiAgICBwb29sLm9uKCdkaXNjb25uZWN0JywgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IGFyZ3NbMl1cbiAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdVTkRfRVJSX1NPQ0tFVCcpIHtcbiAgICAgICAgLy8gZGVjcmVhc2UgdGhlIHdlaWdodCBvZiB0aGUgcG9vbC5cbiAgICAgICAgcG9vbFtrV2VpZ2h0XSA9IE1hdGgubWF4KDEsIHBvb2xba1dlaWdodF0gLSB0aGlzW2tFcnJvclBlbmFsdHldKVxuICAgICAgICB0aGlzLl91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cygpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGZvciAoY29uc3QgY2xpZW50IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICBjbGllbnRba1dlaWdodF0gPSB0aGlzW2tNYXhXZWlnaHRQZXJTZXJ2ZXJdXG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIF91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cyAoKSB7XG4gICAgbGV0IHJlc3VsdCA9IDBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXNba0NsaWVudHNdLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQgPSBnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IodGhpc1trQ2xpZW50c11baV1ba1dlaWdodF0sIHJlc3VsdClcbiAgICB9XG5cbiAgICB0aGlzW2tHcmVhdGVzdENvbW1vbkRpdmlzb3JdID0gcmVzdWx0XG4gIH1cblxuICByZW1vdmVVcHN0cmVhbSAodXBzdHJlYW0pIHtcbiAgICBjb25zdCB1cHN0cmVhbU9yaWdpbiA9IHBhcnNlT3JpZ2luKHVwc3RyZWFtKS5vcmlnaW5cblxuICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tDbGllbnRzXS5maW5kKChwb29sKSA9PiAoXG4gICAgICBwb29sW2tVcmxdLm9yaWdpbiA9PT0gdXBzdHJlYW1PcmlnaW4gJiZcbiAgICAgIHBvb2wuY2xvc2VkICE9PSB0cnVlICYmXG4gICAgICBwb29sLmRlc3Ryb3llZCAhPT0gdHJ1ZVxuICAgICkpXG5cbiAgICBpZiAocG9vbCkge1xuICAgICAgdGhpc1trUmVtb3ZlQ2xpZW50XShwb29sKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgdXBzdHJlYW1zICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ2xpZW50c11cbiAgICAgIC5maWx0ZXIoZGlzcGF0Y2hlciA9PiBkaXNwYXRjaGVyLmNsb3NlZCAhPT0gdHJ1ZSAmJiBkaXNwYXRjaGVyLmRlc3Ryb3llZCAhPT0gdHJ1ZSlcbiAgICAgIC5tYXAoKHApID0+IHBba1VybF0ub3JpZ2luKVxuICB9XG5cbiAgW2tHZXREaXNwYXRjaGVyXSAoKSB7XG4gICAgLy8gV2UgdmFsaWRhdGUgdGhhdCBwb29scyBpcyBncmVhdGVyIHRoYW4gMCxcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd291bGQgaGF2ZSB0byB3YWl0IHVudGlsIGFuIHVwc3RyZWFtXG4gICAgLy8gaXMgYWRkZWQsIHdoaWNoIG1pZ2h0IG5ldmVyIGhhcHBlbi5cbiAgICBpZiAodGhpc1trQ2xpZW50c10ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IoKVxuICAgIH1cblxuICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tDbGllbnRzXS5maW5kKGRpc3BhdGNoZXIgPT4gKFxuICAgICAgIWRpc3BhdGNoZXJba05lZWREcmFpbl0gJiZcbiAgICAgIGRpc3BhdGNoZXIuY2xvc2VkICE9PSB0cnVlICYmXG4gICAgICBkaXNwYXRjaGVyLmRlc3Ryb3llZCAhPT0gdHJ1ZVxuICAgICkpXG5cbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGFsbENsaWVudHNCdXN5ID0gdGhpc1trQ2xpZW50c10ubWFwKHBvb2wgPT4gcG9vbFtrTmVlZERyYWluXSkucmVkdWNlKChhLCBiKSA9PiBhICYmIGIsIHRydWUpXG5cbiAgICBpZiAoYWxsQ2xpZW50c0J1c3kpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBjb3VudGVyID0gMFxuXG4gICAgbGV0IG1heFdlaWdodEluZGV4ID0gdGhpc1trQ2xpZW50c10uZmluZEluZGV4KHBvb2wgPT4gIXBvb2xba05lZWREcmFpbl0pXG5cbiAgICB3aGlsZSAoY291bnRlcisrIDwgdGhpc1trQ2xpZW50c10ubGVuZ3RoKSB7XG4gICAgICB0aGlzW2tJbmRleF0gPSAodGhpc1trSW5kZXhdICsgMSkgJSB0aGlzW2tDbGllbnRzXS5sZW5ndGhcbiAgICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tDbGllbnRzXVt0aGlzW2tJbmRleF1dXG5cbiAgICAgIC8vIGZpbmQgcG9vbCBpbmRleCB3aXRoIHRoZSBsYXJnZXN0IHdlaWdodFxuICAgICAgaWYgKHBvb2xba1dlaWdodF0gPiB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1ba1dlaWdodF0gJiYgIXBvb2xba05lZWREcmFpbl0pIHtcbiAgICAgICAgbWF4V2VpZ2h0SW5kZXggPSB0aGlzW2tJbmRleF1cbiAgICAgIH1cblxuICAgICAgLy8gZGVjcmVhc2UgdGhlIGN1cnJlbnQgd2VpZ2h0IGV2ZXJ5IGB0aGlzW2tDbGllbnRzXS5sZW5ndGhgLlxuICAgICAgaWYgKHRoaXNba0luZGV4XSA9PT0gMCkge1xuICAgICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgd2VpZ2h0IHRvIHRoZSBuZXh0IGxvd2VyIHdlaWdodC5cbiAgICAgICAgdGhpc1trQ3VycmVudFdlaWdodF0gPSB0aGlzW2tDdXJyZW50V2VpZ2h0XSAtIHRoaXNba0dyZWF0ZXN0Q29tbW9uRGl2aXNvcl1cblxuICAgICAgICBpZiAodGhpc1trQ3VycmVudFdlaWdodF0gPD0gMCkge1xuICAgICAgICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gdGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9vbFtrV2VpZ2h0XSA+PSB0aGlzW2tDdXJyZW50V2VpZ2h0XSAmJiAoIXBvb2xba05lZWREcmFpbl0pKSB7XG4gICAgICAgIHJldHVybiBwb29sXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpc1trQ3VycmVudFdlaWdodF0gPSB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1ba1dlaWdodF1cbiAgICB0aGlzW2tJbmRleF0gPSBtYXhXZWlnaHRJbmRleFxuICAgIHJldHVybiB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhbGFuY2VkUG9vbFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/balanced-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/client-h1.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client-h1.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* global WebAssembly */\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst util = __webpack_require__(/*! ../core/util.js */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { channels } = __webpack_require__(/*! ../core/diagnostics.js */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\nconst timers = __webpack_require__(/*! ../util/timers.js */ \"(rsc)/./node_modules/undici/lib/util/timers.js\")\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError\n} = __webpack_require__(/*! ../core/errors.js */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst {\n  kUrl,\n  kReset,\n  kClient,\n  kParser,\n  kBlocking,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kMaxRequests,\n  kCounter,\n  kMaxResponseSize,\n  kOnError,\n  kResume,\n  kHTTPContext,\n  kClosed\n} = __webpack_require__(/*! ../core/symbols.js */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\nconst constants = __webpack_require__(/*! ../llhttp/constants.js */ \"(rsc)/./node_modules/undici/lib/llhttp/constants.js\")\nconst EMPTY_BUF = Buffer.alloc(0)\nconst FastBuffer = Buffer[Symbol.species]\nconst removeAllListeners = util.removeAllListeners\n\nlet extractBody\n\nasync function lazyllhttp () {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? __webpack_require__(/*! ../llhttp/llhttp-wasm.js */ \"(rsc)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\") : undefined\n\n  let mod\n  try {\n    mod = await WebAssembly.compile(__webpack_require__(/*! ../llhttp/llhttp_simd-wasm.js */ \"(rsc)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\"))\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(llhttpWasmData || __webpack_require__(/*! ../llhttp/llhttp-wasm.js */ \"(rsc)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\"))\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /**\n       * @param {number} p\n       * @param {number} at\n       * @param {number} len\n       * @returns {number}\n       */\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      /**\n       * @param {number} p\n       * @param {number} at\n       * @param {number} len\n       * @returns {number}\n       */\n      wasm_on_status: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len))\n      },\n      /**\n       * @param {number} p\n       * @returns {number}\n       */\n      wasm_on_message_begin: (p) => {\n        assert(currentParser.ptr === p)\n        return currentParser.onMessageBegin()\n      },\n      /**\n       * @param {number} p\n       * @param {number} at\n       * @param {number} len\n       * @returns {number}\n       */\n      wasm_on_header_field: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len))\n      },\n      /**\n       * @param {number} p\n       * @param {number} at\n       * @param {number} len\n       * @returns {number}\n       */\n      wasm_on_header_value: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len))\n      },\n      /**\n       * @param {number} p\n       * @param {number} statusCode\n       * @param {0|1} upgrade\n       * @param {0|1} shouldKeepAlive\n       * @returns {number}\n       */\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert(currentParser.ptr === p)\n        return currentParser.onHeadersComplete(statusCode, upgrade === 1, shouldKeepAlive === 1)\n      },\n      /**\n       * @param {number} p\n       * @param {number} at\n       * @param {number} len\n       * @returns {number}\n       */\n      wasm_on_body: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len))\n      },\n      /**\n       * @param {number} p\n       * @returns {number}\n       */\n      wasm_on_message_complete: (p) => {\n        assert(currentParser.ptr === p)\n        return currentParser.onMessageComplete()\n      }\n\n    }\n  })\n}\n\nlet llhttpInstance = null\n/**\n * @type {Promise<WebAssembly.Instance>|null}\n */\nlet llhttpPromise = lazyllhttp()\nllhttpPromise.catch()\n\n/**\n * @type {Parser|null}\n */\nlet currentParser = null\nlet currentBufferRef = null\n/**\n * @type {number}\n */\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst USE_NATIVE_TIMER = 0\nconst USE_FAST_TIMER = 1\n\n// Use fast timers for headers and body to take eventual event loop\n// latency into account.\nconst TIMEOUT_HEADERS = 2 | USE_FAST_TIMER\nconst TIMEOUT_BODY = 4 | USE_FAST_TIMER\n\n// Use native timers to ignore event loop latency for keep-alive\n// handling.\nconst TIMEOUT_KEEP_ALIVE = 8 | USE_NATIVE_TIMER\n\nclass Parser {\n  /**\n     * @param {import('./client.js')} client\n     * @param {import('net').Socket} socket\n     * @param {*} llhttp\n     */\n  constructor (client, socket, { exports }) {\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    /**\n     * @type {import('net').Socket}\n     */\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = 0\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.keepAlive = ''\n    this.contentLength = ''\n    this.connection = ''\n    this.maxResponseSize = client[kMaxResponseSize]\n  }\n\n  setTimeout (delay, type) {\n    // If the existing timer and the new timer are of different timer type\n    // (fast or native) or have different delay, we need to clear the existing\n    // timer and set a new one.\n    if (\n      delay !== this.timeoutValue ||\n      (type & USE_FAST_TIMER) ^ (this.timeoutType & USE_FAST_TIMER)\n    ) {\n      // If a timeout is already set, clear it with clearTimeout of the fast\n      // timer implementation, as it can clear fast and native timers.\n      if (this.timeout) {\n        timers.clearTimeout(this.timeout)\n        this.timeout = null\n      }\n\n      if (delay) {\n        if (type & USE_FAST_TIMER) {\n          this.timeout = timers.setFastTimeout(onParserTimeout, delay, new WeakRef(this))\n        } else {\n          this.timeout = setTimeout(onParserTimeout, delay, new WeakRef(this))\n          this.timeout?.unref()\n        }\n      }\n\n      this.timeoutValue = delay\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.timeoutType = type\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser === null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   */\n  execute (chunk) {\n    assert(currentParser === null)\n    assert(this.ptr != null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    // Allocate a new buffer if the current buffer is too small.\n    if (chunk.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      // Allocate a buffer that is a multiple of 4096 bytes.\n      currentBufferSize = Math.ceil(chunk.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(chunk)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = chunk\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, chunk.length)\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      if (ret !== constants.ERROR.OK) {\n        const data = chunk.subarray(llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr)\n\n        if (ret === constants.ERROR.PAUSED_UPGRADE) {\n          this.onUpgrade(data)\n        } else if (ret === constants.ERROR.PAUSED) {\n          this.paused = true\n          socket.unshift(data)\n        } else {\n          const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n          let message = ''\n          /* istanbul ignore else: difficult to make a test case for */\n          if (ptr) {\n            const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n            message =\n              'Response does not match the HTTP/1.1 protocol (' +\n              Buffer.from(llhttp.memory.buffer, ptr, len).toString() +\n              ')'\n          }\n          throw new HTTPParserError(message, constants.ERROR[ret], data)\n        }\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  destroy () {\n    assert(currentParser === null)\n    assert(this.ptr != null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    this.timeout && timers.clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  /**\n   * @param {Buffer} buf\n   * @returns {0}\n   */\n  onStatus (buf) {\n    this.statusText = buf.toString()\n    return 0\n  }\n\n  /**\n   * @returns {0|-1}\n   */\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n    request.onResponseStarted()\n\n    return 0\n  }\n\n  /**\n   * @param {Buffer} buf\n   * @returns {number}\n   */\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n\n    return 0\n  }\n\n  /**\n   * @param {Buffer} buf\n   * @returns {number}\n   */\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10) {\n      const headerName = util.bufferToLowerCasedHeaderName(key)\n      if (headerName === 'keep-alive') {\n        this.keepAlive += buf.toString()\n      } else if (headerName === 'connection') {\n        this.connection += buf.toString()\n      }\n    } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n\n    return 0\n  }\n\n  /**\n   * @param {number} len\n   */\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  /**\n   * @param {Buffer} head\n   */\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n    assert(client[kSocket] === socket)\n    assert(!socket.destroyed)\n    assert(!this.paused)\n    assert((headers.length & 1) === 0)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = 0\n    this.statusText = ''\n    this.shouldKeepAlive = false\n\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n\n    removeAllListeners(socket)\n\n    client[kSocket] = null\n    client[kHTTPContext] = null // TODO (fix): This is hacky...\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    client[kResume]()\n  }\n\n  /**\n   * @param {number} statusCode\n   * @param {boolean} upgrade\n   * @param {boolean} shouldKeepAlive\n   * @returns {number}\n   */\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert(this.timeoutType === TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = (\n      shouldKeepAlive ||\n      // Override llhttp value which does not allow keepAlive for HEAD.\n      (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive')\n    )\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert((this.headers.length & 1) === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (this.shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n\n    if (request.aborted) {\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      client[kResume]()\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  /**\n   * @param {Buffer} buf\n   * @returns {number}\n   */\n  onBody (buf) {\n    const { client, socket, statusCode, maxResponseSize } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError())\n      return -1\n    }\n\n    this.bytesRead += buf.length\n\n    if (request.onData(buf) === false) {\n      return constants.ERROR.PAUSED\n    }\n\n    return 0\n  }\n\n  /**\n   * @returns {number}\n   */\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return 0\n    }\n\n    assert(statusCode >= 100)\n    assert((this.headers.length & 1) === 0)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    this.statusCode = 0\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.keepAlive = ''\n    this.connection = ''\n\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return 0\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    request.onComplete(headers)\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert(client[kRunning] === 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (client[kPipelining] == null || client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(() => client[kResume]())\n    } else {\n      client[kResume]()\n    }\n\n    return 0\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client, paused } = parser.deref()\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_KEEP_ALIVE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\n/**\n * @param {import ('./client.js')} client\n * @param {import('net').Socket} socket\n * @returns\n */\nasync function connectH1 (client, socket) {\n  client[kSocket] = socket\n\n  if (!llhttpInstance) {\n    const noop = () => {}\n    socket.on('error', noop)\n    llhttpInstance = await llhttpPromise\n    llhttpPromise = null\n    socket.off('error', noop)\n  }\n\n  if (socket.errored) {\n    throw socket.errored\n  }\n\n  if (socket.destroyed) {\n    throw new SocketError('destroyed')\n  }\n\n  socket[kNoRef] = false\n  socket[kWriting] = false\n  socket[kReset] = false\n  socket[kBlocking] = false\n  socket[kParser] = new Parser(client, socket, llhttpInstance)\n\n  util.addListener(socket, 'error', onHttpSocketError)\n  util.addListener(socket, 'readable', onHttpSocketReadable)\n  util.addListener(socket, 'end', onHttpSocketEnd)\n  util.addListener(socket, 'close', onHttpSocketClose)\n\n  socket[kClosed] = false\n  socket.on('close', onSocketClose)\n\n  return {\n    version: 'h1',\n    defaultPipelining: 1,\n    write (request) {\n      return writeH1(client, request)\n    },\n    resume () {\n      resumeH1(client)\n    },\n    /**\n     * @param {Error|undefined} err\n     * @param {() => void} callback\n     */\n    destroy (err, callback) {\n      if (socket[kClosed]) {\n        queueMicrotask(callback)\n      } else {\n        socket.on('close', callback)\n        socket.destroy(err)\n      }\n    },\n    /**\n     * @returns {boolean}\n     */\n    get destroyed () {\n      return socket.destroyed\n    },\n    /**\n     * @param {import('../core/request.js')} request\n     * @returns {boolean}\n     */\n    busy (request) {\n      if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n        return true\n      }\n\n      if (request) {\n        if (client[kRunning] > 0 && !request.idempotent) {\n          // Non-idempotent request cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          return true\n        }\n\n        if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n          // Don't dispatch an upgrade until all preceding requests have completed.\n          // A misbehaving server might upgrade the connection before all pipelined\n          // request has completed.\n          return true\n        }\n\n        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 &&\n          (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {\n          // Request with stream or iterator body can error while other requests\n          // are inflight and indirectly error those as well.\n          // Ensure this doesn't happen by waiting for inflight\n          // to complete before dispatching.\n\n          // Request with stream or iterator body cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          return true\n        }\n      }\n\n      return false\n    }\n  }\n}\n\nfunction onHttpSocketError (err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  const parser = this[kParser]\n\n  // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.onMessageComplete()\n    return\n  }\n\n  this[kError] = err\n\n  this[kClient][kOnError](err)\n}\n\nfunction onHttpSocketReadable () {\n  this[kParser]?.readMore()\n}\n\nfunction onHttpSocketEnd () {\n  const parser = this[kParser]\n\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.onMessageComplete()\n    return\n  }\n\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onHttpSocketClose () {\n  const parser = this[kParser]\n\n  if (parser) {\n    if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so far as a valid response.\n      parser.onMessageComplete()\n    }\n\n    this[kParser].destroy()\n    this[kParser] = null\n  }\n\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  const client = this[kClient]\n\n  client[kSocket] = null\n  client[kHTTPContext] = null // TODO (fix): This is hacky...\n\n  if (client.destroyed) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      util.errorRequest(client, request, err)\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    util.errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  client[kResume]()\n}\n\nfunction onSocketClose () {\n  this[kClosed] = true\n}\n\n/**\n * @param {import('./client.js')} client\n */\nfunction resumeH1 (client) {\n  const socket = client[kSocket]\n\n  if (socket && !socket.destroyed) {\n    if (client[kSize] === 0) {\n      if (!socket[kNoRef] && socket.unref) {\n        socket.unref()\n        socket[kNoRef] = true\n      }\n    } else if (socket[kNoRef] && socket.ref) {\n      socket.ref()\n      socket[kNoRef] = false\n    }\n\n    if (client[kSize] === 0) {\n      if (socket[kParser].timeoutType !== TIMEOUT_KEEP_ALIVE) {\n        socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_KEEP_ALIVE)\n      }\n    } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n      if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n        const request = client[kQueue][client[kRunningIdx]]\n        const headersTimeout = request.headersTimeout != null\n          ? request.headersTimeout\n          : client[kHeadersTimeout]\n        socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n      }\n    }\n  }\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength (method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'\n}\n\n/**\n * @param {import('./client.js')} client\n * @param {import('../core/request.js')} request\n * @returns\n */\nfunction writeH1 (client, request) {\n  const { method, path, host, upgrade, blocking, reset } = request\n\n  let { body, headers, contentLength } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH' ||\n    method === 'QUERY' ||\n    method === 'PROPFIND' ||\n    method === 'PROPPATCH'\n  )\n\n  if (util.isFormDataLike(body)) {\n    if (!extractBody) {\n      extractBody = (__webpack_require__(/*! ../web/fetch/body.js */ \"(rsc)/./node_modules/undici/lib/web/fetch/body.js\").extractBody)\n    }\n\n    const [bodyStream, contentType] = extractBody(body)\n    if (request.contentType == null) {\n      headers.push('content-type', contentType)\n    }\n    body = bodyStream.stream\n    contentLength = bodyStream.length\n  } else if (util.isBlobLike(body) && request.contentType == null && body.type) {\n    headers.push('content-type', body.type)\n  }\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  const bodyLength = util.bodyLength(body)\n\n  contentLength = bodyLength ?? contentLength\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      util.errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  /**\n   * @param {Error} [err]\n   * @returns {void}\n   */\n  const abort = (err) => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    util.errorRequest(client, request, err || new RequestAbortedError())\n\n    util.destroy(body)\n    util.destroy(socket, new InformationalError('aborted'))\n  }\n\n  try {\n    request.onConnect(abort)\n  } catch (err) {\n    util.errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (reset != null) {\n    socket[kReset] = reset\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (Array.isArray(headers)) {\n    for (let n = 0; n < headers.length; n += 2) {\n      const key = headers[n + 0]\n      const val = headers[n + 1]\n\n      if (Array.isArray(val)) {\n        for (let i = 0; i < val.length; i++) {\n          header += `${key}: ${val[i]}\\r\\n`\n        }\n      } else {\n        header += `${key}: ${val}\\r\\n`\n      }\n    }\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body || bodyLength === 0) {\n    writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isBuffer(body)) {\n    writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload)\n    } else {\n      writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload)\n    }\n  } else if (util.isStream(body)) {\n    writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isIterable(body)) {\n    writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\n/**\n * @param {AbortCallback} abort\n * @param {import('stream').Stream} body\n * @param {import('./client.js')} client\n * @param {import('../core/request.js')} request\n * @param {import('net').Socket} socket\n * @param {number} contentLength\n * @param {string} header\n * @param {boolean} expectsPayload\n */\nfunction writeStream (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  let finished = false\n\n  const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header })\n\n  /**\n   * @param {Buffer} chunk\n   * @returns {void}\n   */\n  const onData = function (chunk) {\n    if (finished) {\n      return\n    }\n\n    try {\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  const onDrain = function () {\n    if (finished) {\n      return\n    }\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  const onClose = function () {\n    // 'close' might be emitted *before* 'error' for\n    // broken streams. Wait a tick to avoid this case.\n    queueMicrotask(() => {\n      // It's only safe to remove 'error' listener after\n      // 'close'.\n      body.removeListener('error', onFinished)\n    })\n\n    if (!finished) {\n      const err = new RequestAbortedError()\n      queueMicrotask(() => onFinished(err))\n    }\n  }\n\n  /**\n   * @param {Error} [err]\n   * @returns\n   */\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('close', onClose)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onClose)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n\n  if (body.errorEmitted ?? body.errored) {\n    setImmediate(() => onFinished(body.errored))\n  } else if (body.endEmitted ?? body.readableEnded) {\n    setImmediate(() => onFinished(null))\n  }\n\n  if (body.closeEmitted ?? body.closed) {\n    setImmediate(onClose)\n  }\n}\n\n/**\n * @typedef AbortCallback\n * @type {Function}\n * @param {Error} [err]\n * @returns {void}\n */\n\n/**\n * @param {AbortCallback} abort\n * @param {Uint8Array|null} body\n * @param {import('./client.js')} client\n * @param {import('../core/request.js')} request\n * @param {import('net').Socket} socket\n * @param {number} contentLength\n * @param {string} header\n * @param {boolean} expectsPayload\n * @returns {void}\n */\nfunction writeBuffer (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  try {\n    if (!body) {\n      if (contentLength === 0) {\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        assert(contentLength === null, 'no body must not have content length')\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n      socket.cork()\n      socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      socket.write(body)\n      socket.uncork()\n      request.onBodySent(body)\n\n      if (!expectsPayload && request.reset !== false) {\n        socket[kReset] = true\n      }\n    }\n    request.onRequestSent()\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\n/**\n * @param {AbortCallback} abort\n * @param {Blob} body\n * @param {import('./client.js')} client\n * @param {import('../core/request.js')} request\n * @param {import('net').Socket} socket\n * @param {number} contentLength\n * @param {string} header\n * @param {boolean} expectsPayload\n * @returns {Promise<void>}\n */\nasync function writeBlob (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n    socket.write(buffer)\n    socket.uncork()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload && request.reset !== false) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\n/**\n * @param {AbortCallback} abort\n * @param {Iterable} body\n * @param {import('./client.js')} client\n * @param {import('../core/request.js')} request\n * @param {import('net').Socket} socket\n * @param {number} contentLength\n * @param {string} header\n * @param {boolean} expectsPayload\n * @returns {Promise<void>}\n */\nasync function writeIterable (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  /**\n   *\n   * @param {object} arg\n   * @param {AbortCallback} arg.abort\n   * @param {import('net').Socket} arg.socket\n   * @param {import('../core/request.js')} arg.request\n   * @param {number} arg.contentLength\n   * @param {import('./client.js')} arg.client\n   * @param {boolean} arg.expectsPayload\n   * @param {string} arg.header\n   */\n  constructor ({ abort, socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n    this.abort = abort\n\n    socket[kWriting] = true\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @returns\n   */\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    socket.cork()\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload && request.reset !== false) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'latin1')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n\n    socket.uncork()\n\n    request.onBodySent(chunk)\n\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh()\n        }\n      }\n    }\n\n    return ret\n  }\n\n  /**\n   * @returns {void}\n   */\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'latin1')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    client[kResume]()\n  }\n\n  /**\n   * @param {Error} [err]\n   * @returns {void}\n   */\n  destroy (err) {\n    const { socket, client, abort } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      abort(err)\n    }\n  }\n}\n\nmodule.exports = connectH1\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC1oMS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQSxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLHFFQUFpQjtBQUN0QyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLG1GQUF3QjtBQUNyRCxlQUFlLG1CQUFPLENBQUMseUVBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsMkVBQW9COztBQUVoQyxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBd0I7QUFDbEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0RBQXNELG1CQUFPLENBQUMsdUZBQTBCOztBQUV4RjtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFPLENBQUMsaUdBQStCO0FBQzNFLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQkFBTyxDQUFDLHVGQUEwQjtBQUN4Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFFBQVE7QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsS0FBSztBQUN0QixpQkFBaUIsS0FBSztBQUN0QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsZUFBZSxzQkFBc0I7QUFDckMsZUFBZSxHQUFHO0FBQ2xCO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksaUJBQWlCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksaUJBQWlCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLFlBQVksK0NBQStDOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksc0NBQXNDOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBWSw4Q0FBOEM7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxZQUFZLDBGQUEwRjs7QUFFdEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsc0NBQXNDOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNK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QUFDUix3QkFBd0IsT0FBTyxrQkFBa0IsY0FBYztBQUMvRDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksK0VBQStFO0FBQzNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixPQUFPO0FBQy9CLFFBQVE7QUFDUix3QkFBd0IsT0FBTztBQUMvQjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQSxZQUFZLHdCQUF3Qjs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvY2xpZW50LWgxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKiBnbG9iYWwgV2ViQXNzZW1ibHkgKi9cblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbC5qcycpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi9jb3JlL2RpYWdub3N0aWNzLmpzJylcbmNvbnN0IHRpbWVycyA9IHJlcXVpcmUoJy4uL3V0aWwvdGltZXJzLmpzJylcbmNvbnN0IHtcbiAgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBSZXF1ZXN0QWJvcnRlZEVycm9yLFxuICBIZWFkZXJzVGltZW91dEVycm9yLFxuICBIZWFkZXJzT3ZlcmZsb3dFcnJvcixcbiAgU29ja2V0RXJyb3IsXG4gIEluZm9ybWF0aW9uYWxFcnJvcixcbiAgQm9keVRpbWVvdXRFcnJvcixcbiAgSFRUUFBhcnNlckVycm9yLFxuICBSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMuanMnKVxuY29uc3Qge1xuICBrVXJsLFxuICBrUmVzZXQsXG4gIGtDbGllbnQsXG4gIGtQYXJzZXIsXG4gIGtCbG9ja2luZyxcbiAga1J1bm5pbmcsXG4gIGtQZW5kaW5nLFxuICBrU2l6ZSxcbiAga1dyaXRpbmcsXG4gIGtRdWV1ZSxcbiAga05vUmVmLFxuICBrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXQsXG4gIGtIb3N0SGVhZGVyLFxuICBrUGVuZGluZ0lkeCxcbiAga1J1bm5pbmdJZHgsXG4gIGtFcnJvcixcbiAga1BpcGVsaW5pbmcsXG4gIGtTb2NrZXQsXG4gIGtLZWVwQWxpdmVUaW1lb3V0VmFsdWUsXG4gIGtNYXhIZWFkZXJzU2l6ZSxcbiAga0tlZXBBbGl2ZU1heFRpbWVvdXQsXG4gIGtLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkLFxuICBrSGVhZGVyc1RpbWVvdXQsXG4gIGtCb2R5VGltZW91dCxcbiAga1N0cmljdENvbnRlbnRMZW5ndGgsXG4gIGtNYXhSZXF1ZXN0cyxcbiAga0NvdW50ZXIsXG4gIGtNYXhSZXNwb25zZVNpemUsXG4gIGtPbkVycm9yLFxuICBrUmVzdW1lLFxuICBrSFRUUENvbnRleHQsXG4gIGtDbG9zZWRcbn0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMuanMnKVxuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9sbGh0dHAvY29uc3RhbnRzLmpzJylcbmNvbnN0IEVNUFRZX0JVRiA9IEJ1ZmZlci5hbGxvYygwKVxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc11cbmNvbnN0IHJlbW92ZUFsbExpc3RlbmVycyA9IHV0aWwucmVtb3ZlQWxsTGlzdGVuZXJzXG5cbmxldCBleHRyYWN0Qm9keVxuXG5hc3luYyBmdW5jdGlvbiBsYXp5bGxodHRwICgpIHtcbiAgY29uc3QgbGxodHRwV2FzbURhdGEgPSBwcm9jZXNzLmVudi5KRVNUX1dPUktFUl9JRCA/IHJlcXVpcmUoJy4uL2xsaHR0cC9sbGh0dHAtd2FzbS5qcycpIDogdW5kZWZpbmVkXG5cbiAgbGV0IG1vZFxuICB0cnkge1xuICAgIG1vZCA9IGF3YWl0IFdlYkFzc2VtYmx5LmNvbXBpbGUocmVxdWlyZSgnLi4vbGxodHRwL2xsaHR0cF9zaW1kLXdhc20uanMnKSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAvLyBXZSBjb3VsZCBjaGVjayBpZiB0aGUgZXJyb3Igd2FzIGNhdXNlZCBieSB0aGUgc2ltZCBvcHRpb24gbm90XG4gICAgLy8gYmVpbmcgZW5hYmxlZCwgYnV0IHRoZSBvY2N1cnJpbmcgb2YgdGhpcyBvdGhlciBlcnJvclxuICAgIC8vICogaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL2lzc3Vlcy8xMTQ5NVxuICAgIC8vIGdvdCBtZSB0byByZW1vdmUgdGhhdCBjaGVjayB0byBhdm9pZCBicmVha2luZyBOb2RlIDEyLlxuICAgIG1vZCA9IGF3YWl0IFdlYkFzc2VtYmx5LmNvbXBpbGUobGxodHRwV2FzbURhdGEgfHwgcmVxdWlyZSgnLi4vbGxodHRwL2xsaHR0cC13YXNtLmpzJykpXG4gIH1cblxuICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUobW9kLCB7XG4gICAgZW52OiB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gYXRcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHdhc21fb25fdXJsOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgd2FzbV9vbl9zdGF0dXM6IChwLCBhdCwgbGVuKSA9PiB7XG4gICAgICAgIGFzc2VydChjdXJyZW50UGFyc2VyLnB0ciA9PT0gcClcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBhdCAtIGN1cnJlbnRCdWZmZXJQdHIgKyBjdXJyZW50QnVmZmVyUmVmLmJ5dGVPZmZzZXRcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25TdGF0dXMobmV3IEZhc3RCdWZmZXIoY3VycmVudEJ1ZmZlclJlZi5idWZmZXIsIHN0YXJ0LCBsZW4pKVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHdhc21fb25fbWVzc2FnZV9iZWdpbjogKHApID0+IHtcbiAgICAgICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIucHRyID09PSBwKVxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbk1lc3NhZ2VCZWdpbigpXG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gcFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGF0XG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICB3YXNtX29uX2hlYWRlcl9maWVsZDogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIucHRyID09PSBwKVxuICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0ciArIGN1cnJlbnRCdWZmZXJSZWYuYnl0ZU9mZnNldFxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbkhlYWRlckZpZWxkKG5ldyBGYXN0QnVmZmVyKGN1cnJlbnRCdWZmZXJSZWYuYnVmZmVyLCBzdGFydCwgbGVuKSlcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gYXRcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHdhc21fb25faGVhZGVyX3ZhbHVlOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQoY3VycmVudFBhcnNlci5wdHIgPT09IHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uSGVhZGVyVmFsdWUobmV3IEZhc3RCdWZmZXIoY3VycmVudEJ1ZmZlclJlZi5idWZmZXIsIHN0YXJ0LCBsZW4pKVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNDb2RlXG4gICAgICAgKiBAcGFyYW0gezB8MX0gdXBncmFkZVxuICAgICAgICogQHBhcmFtIHswfDF9IHNob3VsZEtlZXBBbGl2ZVxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgd2FzbV9vbl9oZWFkZXJzX2NvbXBsZXRlOiAocCwgc3RhdHVzQ29kZSwgdXBncmFkZSwgc2hvdWxkS2VlcEFsaXZlKSA9PiB7XG4gICAgICAgIGFzc2VydChjdXJyZW50UGFyc2VyLnB0ciA9PT0gcClcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25IZWFkZXJzQ29tcGxldGUoc3RhdHVzQ29kZSwgdXBncmFkZSA9PT0gMSwgc2hvdWxkS2VlcEFsaXZlID09PSAxKVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgd2FzbV9vbl9ib2R5OiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQoY3VycmVudFBhcnNlci5wdHIgPT09IHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uQm9keShuZXcgRmFzdEJ1ZmZlcihjdXJyZW50QnVmZmVyUmVmLmJ1ZmZlciwgc3RhcnQsIGxlbikpXG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gcFxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgd2FzbV9vbl9tZXNzYWdlX2NvbXBsZXRlOiAocCkgPT4ge1xuICAgICAgICBhc3NlcnQoY3VycmVudFBhcnNlci5wdHIgPT09IHApXG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uTWVzc2FnZUNvbXBsZXRlKClcbiAgICAgIH1cblxuICAgIH1cbiAgfSlcbn1cblxubGV0IGxsaHR0cEluc3RhbmNlID0gbnVsbFxuLyoqXG4gKiBAdHlwZSB7UHJvbWlzZTxXZWJBc3NlbWJseS5JbnN0YW5jZT58bnVsbH1cbiAqL1xubGV0IGxsaHR0cFByb21pc2UgPSBsYXp5bGxodHRwKClcbmxsaHR0cFByb21pc2UuY2F0Y2goKVxuXG4vKipcbiAqIEB0eXBlIHtQYXJzZXJ8bnVsbH1cbiAqL1xubGV0IGN1cnJlbnRQYXJzZXIgPSBudWxsXG5sZXQgY3VycmVudEJ1ZmZlclJlZiA9IG51bGxcbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xubGV0IGN1cnJlbnRCdWZmZXJTaXplID0gMFxubGV0IGN1cnJlbnRCdWZmZXJQdHIgPSBudWxsXG5cbmNvbnN0IFVTRV9OQVRJVkVfVElNRVIgPSAwXG5jb25zdCBVU0VfRkFTVF9USU1FUiA9IDFcblxuLy8gVXNlIGZhc3QgdGltZXJzIGZvciBoZWFkZXJzIGFuZCBib2R5IHRvIHRha2UgZXZlbnR1YWwgZXZlbnQgbG9vcFxuLy8gbGF0ZW5jeSBpbnRvIGFjY291bnQuXG5jb25zdCBUSU1FT1VUX0hFQURFUlMgPSAyIHwgVVNFX0ZBU1RfVElNRVJcbmNvbnN0IFRJTUVPVVRfQk9EWSA9IDQgfCBVU0VfRkFTVF9USU1FUlxuXG4vLyBVc2UgbmF0aXZlIHRpbWVycyB0byBpZ25vcmUgZXZlbnQgbG9vcCBsYXRlbmN5IGZvciBrZWVwLWFsaXZlXG4vLyBoYW5kbGluZy5cbmNvbnN0IFRJTUVPVVRfS0VFUF9BTElWRSA9IDggfCBVU0VfTkFUSVZFX1RJTUVSXG5cbmNsYXNzIFBhcnNlciB7XG4gIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuL2NsaWVudC5qcycpfSBjbGllbnRcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnbmV0JykuU29ja2V0fSBzb2NrZXRcbiAgICAgKiBAcGFyYW0geyp9IGxsaHR0cFxuICAgICAqL1xuICBjb25zdHJ1Y3RvciAoY2xpZW50LCBzb2NrZXQsIHsgZXhwb3J0cyB9KSB7XG4gICAgdGhpcy5sbGh0dHAgPSBleHBvcnRzXG4gICAgdGhpcy5wdHIgPSB0aGlzLmxsaHR0cC5sbGh0dHBfYWxsb2MoY29uc3RhbnRzLlRZUEUuUkVTUE9OU0UpXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnRcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KCduZXQnKS5Tb2NrZXR9XG4gICAgICovXG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0VmFsdWUgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0VHlwZSA9IG51bGxcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSAwXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJydcbiAgICB0aGlzLnVwZ3JhZGUgPSBmYWxzZVxuICAgIHRoaXMuaGVhZGVycyA9IFtdXG4gICAgdGhpcy5oZWFkZXJzU2l6ZSA9IDBcbiAgICB0aGlzLmhlYWRlcnNNYXhTaXplID0gY2xpZW50W2tNYXhIZWFkZXJzU2l6ZV1cbiAgICB0aGlzLnNob3VsZEtlZXBBbGl2ZSA9IGZhbHNlXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICAgIHRoaXMucmVzdW1lID0gdGhpcy5yZXN1bWUuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5ieXRlc1JlYWQgPSAwXG5cbiAgICB0aGlzLmtlZXBBbGl2ZSA9ICcnXG4gICAgdGhpcy5jb250ZW50TGVuZ3RoID0gJydcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSAnJ1xuICAgIHRoaXMubWF4UmVzcG9uc2VTaXplID0gY2xpZW50W2tNYXhSZXNwb25zZVNpemVdXG4gIH1cblxuICBzZXRUaW1lb3V0IChkZWxheSwgdHlwZSkge1xuICAgIC8vIElmIHRoZSBleGlzdGluZyB0aW1lciBhbmQgdGhlIG5ldyB0aW1lciBhcmUgb2YgZGlmZmVyZW50IHRpbWVyIHR5cGVcbiAgICAvLyAoZmFzdCBvciBuYXRpdmUpIG9yIGhhdmUgZGlmZmVyZW50IGRlbGF5LCB3ZSBuZWVkIHRvIGNsZWFyIHRoZSBleGlzdGluZ1xuICAgIC8vIHRpbWVyIGFuZCBzZXQgYSBuZXcgb25lLlxuICAgIGlmIChcbiAgICAgIGRlbGF5ICE9PSB0aGlzLnRpbWVvdXRWYWx1ZSB8fFxuICAgICAgKHR5cGUgJiBVU0VfRkFTVF9USU1FUikgXiAodGhpcy50aW1lb3V0VHlwZSAmIFVTRV9GQVNUX1RJTUVSKVxuICAgICkge1xuICAgICAgLy8gSWYgYSB0aW1lb3V0IGlzIGFscmVhZHkgc2V0LCBjbGVhciBpdCB3aXRoIGNsZWFyVGltZW91dCBvZiB0aGUgZmFzdFxuICAgICAgLy8gdGltZXIgaW1wbGVtZW50YXRpb24sIGFzIGl0IGNhbiBjbGVhciBmYXN0IGFuZCBuYXRpdmUgdGltZXJzLlxuICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICB0aW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dClcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgaWYgKHR5cGUgJiBVU0VfRkFTVF9USU1FUikge1xuICAgICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVycy5zZXRGYXN0VGltZW91dChvblBhcnNlclRpbWVvdXQsIGRlbGF5LCBuZXcgV2Vha1JlZih0aGlzKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uUGFyc2VyVGltZW91dCwgZGVsYXksIG5ldyBXZWFrUmVmKHRoaXMpKVxuICAgICAgICAgIHRoaXMudGltZW91dD8udW5yZWYoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGltZW91dFZhbHVlID0gZGVsYXlcbiAgICB9IGVsc2UgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50aW1lb3V0VHlwZSA9IHR5cGVcbiAgfVxuXG4gIHJlc3VtZSAoKSB7XG4gICAgaWYgKHRoaXMuc29ja2V0LmRlc3Ryb3llZCB8fCAhdGhpcy5wYXVzZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLnB0ciAhPSBudWxsKVxuICAgIGFzc2VydChjdXJyZW50UGFyc2VyID09PSBudWxsKVxuXG4gICAgdGhpcy5sbGh0dHAubGxodHRwX3Jlc3VtZSh0aGlzLnB0cilcblxuICAgIGFzc2VydCh0aGlzLnRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0JPRFkpXG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICAgIHRoaXMuZXhlY3V0ZSh0aGlzLnNvY2tldC5yZWFkKCkgfHwgRU1QVFlfQlVGKSAvLyBGbHVzaCBwYXJzZXIuXG4gICAgdGhpcy5yZWFkTW9yZSgpXG4gIH1cblxuICByZWFkTW9yZSAoKSB7XG4gICAgd2hpbGUgKCF0aGlzLnBhdXNlZCAmJiB0aGlzLnB0cikge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLnNvY2tldC5yZWFkKClcbiAgICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgdGhpcy5leGVjdXRlKGNodW5rKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAgICovXG4gIGV4ZWN1dGUgKGNodW5rKSB7XG4gICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIgPT09IG51bGwpXG4gICAgYXNzZXJ0KHRoaXMucHRyICE9IG51bGwpXG4gICAgYXNzZXJ0KCF0aGlzLnBhdXNlZClcblxuICAgIGNvbnN0IHsgc29ja2V0LCBsbGh0dHAgfSA9IHRoaXNcblxuICAgIC8vIEFsbG9jYXRlIGEgbmV3IGJ1ZmZlciBpZiB0aGUgY3VycmVudCBidWZmZXIgaXMgdG9vIHNtYWxsLlxuICAgIGlmIChjaHVuay5sZW5ndGggPiBjdXJyZW50QnVmZmVyU2l6ZSkge1xuICAgICAgaWYgKGN1cnJlbnRCdWZmZXJQdHIpIHtcbiAgICAgICAgbGxodHRwLmZyZWUoY3VycmVudEJ1ZmZlclB0cilcbiAgICAgIH1cbiAgICAgIC8vIEFsbG9jYXRlIGEgYnVmZmVyIHRoYXQgaXMgYSBtdWx0aXBsZSBvZiA0MDk2IGJ5dGVzLlxuICAgICAgY3VycmVudEJ1ZmZlclNpemUgPSBNYXRoLmNlaWwoY2h1bmsubGVuZ3RoIC8gNDA5NikgKiA0MDk2XG4gICAgICBjdXJyZW50QnVmZmVyUHRyID0gbGxodHRwLm1hbGxvYyhjdXJyZW50QnVmZmVyU2l6ZSlcbiAgICB9XG5cbiAgICBuZXcgVWludDhBcnJheShsbGh0dHAubWVtb3J5LmJ1ZmZlciwgY3VycmVudEJ1ZmZlclB0ciwgY3VycmVudEJ1ZmZlclNpemUpLnNldChjaHVuaylcblxuICAgIC8vIENhbGwgYGV4ZWN1dGVgIG9uIHRoZSB3YXNtIHBhcnNlci5cbiAgICAvLyBXZSBwYXNzIHRoZSBgbGxodHRwX3BhcnNlcmAgcG9pbnRlciBhZGRyZXNzLCB0aGUgcG9pbnRlciBhZGRyZXNzIG9mIGJ1ZmZlciB2aWV3IGRhdGEsXG4gICAgLy8gYW5kIGZpbmFsbHkgdGhlIGxlbmd0aCBvZiBieXRlcyB0byBwYXJzZS5cbiAgICAvLyBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIGVycm9yIGNvZGUgb3IgYGNvbnN0YW50cy5FUlJPUi5PS2AuXG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXRcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY3VycmVudEJ1ZmZlclJlZiA9IGNodW5rXG4gICAgICAgIGN1cnJlbnRQYXJzZXIgPSB0aGlzXG4gICAgICAgIHJldCA9IGxsaHR0cC5sbGh0dHBfZXhlY3V0ZSh0aGlzLnB0ciwgY3VycmVudEJ1ZmZlclB0ciwgY2h1bmsubGVuZ3RoKVxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYXRjaCAqL1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UGFyc2VyID0gbnVsbFxuICAgICAgICBjdXJyZW50QnVmZmVyUmVmID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAocmV0ICE9PSBjb25zdGFudHMuRVJST1IuT0spIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNodW5rLnN1YmFycmF5KGxsaHR0cC5sbGh0dHBfZ2V0X2Vycm9yX3Bvcyh0aGlzLnB0cikgLSBjdXJyZW50QnVmZmVyUHRyKVxuXG4gICAgICAgIGlmIChyZXQgPT09IGNvbnN0YW50cy5FUlJPUi5QQVVTRURfVVBHUkFERSkge1xuICAgICAgICAgIHRoaXMub25VcGdyYWRlKGRhdGEpXG4gICAgICAgIH0gZWxzZSBpZiAocmV0ID09PSBjb25zdGFudHMuRVJST1IuUEFVU0VEKSB7XG4gICAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlXG4gICAgICAgICAgc29ja2V0LnVuc2hpZnQoZGF0YSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwdHIgPSBsbGh0dHAubGxodHRwX2dldF9lcnJvcl9yZWFzb24odGhpcy5wdHIpXG4gICAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJ1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICAgICAgICBpZiAocHRyKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBuZXcgVWludDhBcnJheShsbGh0dHAubWVtb3J5LmJ1ZmZlciwgcHRyKS5pbmRleE9mKDApXG4gICAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgICAgJ1Jlc3BvbnNlIGRvZXMgbm90IG1hdGNoIHRoZSBIVFRQLzEuMSBwcm90b2NvbCAoJyArXG4gICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGxsaHR0cC5tZW1vcnkuYnVmZmVyLCBwdHIsIGxlbikudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICcpJ1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgSFRUUFBhcnNlckVycm9yKG1lc3NhZ2UsIGNvbnN0YW50cy5FUlJPUltyZXRdLCBkYXRhKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBlcnIpXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIgPT09IG51bGwpXG4gICAgYXNzZXJ0KHRoaXMucHRyICE9IG51bGwpXG5cbiAgICB0aGlzLmxsaHR0cC5sbGh0dHBfZnJlZSh0aGlzLnB0cilcbiAgICB0aGlzLnB0ciA9IG51bGxcblxuICAgIHRoaXMudGltZW91dCAmJiB0aW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dClcbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0VmFsdWUgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0VHlwZSA9IG51bGxcblxuICAgIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gICAqIEByZXR1cm5zIHswfVxuICAgKi9cbiAgb25TdGF0dXMgKGJ1Zikge1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IGJ1Zi50b1N0cmluZygpXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7MHwtMX1cbiAgICovXG4gIG9uTWVzc2FnZUJlZ2luICgpIHtcbiAgICBjb25zdCB7IHNvY2tldCwgY2xpZW50IH0gPSB0aGlzXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIG1ha2UgYSB0ZXN0IGNhc2UgZm9yICovXG4gICAgaWYgKHNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJlcXVlc3Qub25SZXNwb25zZVN0YXJ0ZWQoKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBvbkhlYWRlckZpZWxkIChidWYpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmhlYWRlcnMubGVuZ3RoXG5cbiAgICBpZiAoKGxlbiAmIDEpID09PSAwKSB7XG4gICAgICB0aGlzLmhlYWRlcnMucHVzaChidWYpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVyc1tsZW4gLSAxXSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuaGVhZGVyc1tsZW4gLSAxXSwgYnVmXSlcbiAgICB9XG5cbiAgICB0aGlzLnRyYWNrSGVhZGVyKGJ1Zi5sZW5ndGgpXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIG9uSGVhZGVyVmFsdWUgKGJ1Zikge1xuICAgIGxldCBsZW4gPSB0aGlzLmhlYWRlcnMubGVuZ3RoXG5cbiAgICBpZiAoKGxlbiAmIDEpID09PSAxKSB7XG4gICAgICB0aGlzLmhlYWRlcnMucHVzaChidWYpXG4gICAgICBsZW4gKz0gMVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWRlcnNbbGVuIC0gMV0gPSBCdWZmZXIuY29uY2F0KFt0aGlzLmhlYWRlcnNbbGVuIC0gMV0sIGJ1Zl0pXG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gdGhpcy5oZWFkZXJzW2xlbiAtIDJdXG4gICAgaWYgKGtleS5sZW5ndGggPT09IDEwKSB7XG4gICAgICBjb25zdCBoZWFkZXJOYW1lID0gdXRpbC5idWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lKGtleSlcbiAgICAgIGlmIChoZWFkZXJOYW1lID09PSAna2VlcC1hbGl2ZScpIHtcbiAgICAgICAgdGhpcy5rZWVwQWxpdmUgKz0gYnVmLnRvU3RyaW5nKClcbiAgICAgIH0gZWxzZSBpZiAoaGVhZGVyTmFtZSA9PT0gJ2Nvbm5lY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiArPSBidWYudG9TdHJpbmcoKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA9PT0gMTQgJiYgdXRpbC5idWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lKGtleSkgPT09ICdjb250ZW50LWxlbmd0aCcpIHtcbiAgICAgIHRoaXMuY29udGVudExlbmd0aCArPSBidWYudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIHRoaXMudHJhY2tIZWFkZXIoYnVmLmxlbmd0aClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgdHJhY2tIZWFkZXIgKGxlbikge1xuICAgIHRoaXMuaGVhZGVyc1NpemUgKz0gbGVuXG4gICAgaWYgKHRoaXMuaGVhZGVyc1NpemUgPj0gdGhpcy5oZWFkZXJzTWF4U2l6ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHRoaXMuc29ja2V0LCBuZXcgSGVhZGVyc092ZXJmbG93RXJyb3IoKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWRcbiAgICovXG4gIG9uVXBncmFkZSAoaGVhZCkge1xuICAgIGNvbnN0IHsgdXBncmFkZSwgY2xpZW50LCBzb2NrZXQsIGhlYWRlcnMsIHN0YXR1c0NvZGUgfSA9IHRoaXNcblxuICAgIGFzc2VydCh1cGdyYWRlKVxuICAgIGFzc2VydChjbGllbnRba1NvY2tldF0gPT09IHNvY2tldClcbiAgICBhc3NlcnQoIXNvY2tldC5kZXN0cm95ZWQpXG4gICAgYXNzZXJ0KCF0aGlzLnBhdXNlZClcbiAgICBhc3NlcnQoKGhlYWRlcnMubGVuZ3RoICYgMSkgPT09IDApXG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBhc3NlcnQocmVxdWVzdClcbiAgICBhc3NlcnQocmVxdWVzdC51cGdyYWRlIHx8IHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcpXG5cbiAgICB0aGlzLnN0YXR1c0NvZGUgPSAwXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJydcbiAgICB0aGlzLnNob3VsZEtlZXBBbGl2ZSA9IGZhbHNlXG5cbiAgICB0aGlzLmhlYWRlcnMgPSBbXVxuICAgIHRoaXMuaGVhZGVyc1NpemUgPSAwXG5cbiAgICBzb2NrZXQudW5zaGlmdChoZWFkKVxuXG4gICAgc29ja2V0W2tQYXJzZXJdLmRlc3Ryb3koKVxuICAgIHNvY2tldFtrUGFyc2VyXSA9IG51bGxcblxuICAgIHNvY2tldFtrQ2xpZW50XSA9IG51bGxcbiAgICBzb2NrZXRba0Vycm9yXSA9IG51bGxcblxuICAgIHJlbW92ZUFsbExpc3RlbmVycyhzb2NrZXQpXG5cbiAgICBjbGllbnRba1NvY2tldF0gPSBudWxsXG4gICAgY2xpZW50W2tIVFRQQ29udGV4dF0gPSBudWxsIC8vIFRPRE8gKGZpeCk6IFRoaXMgaXMgaGFja3kuLi5cbiAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuICAgIGNsaWVudC5lbWl0KCdkaXNjb25uZWN0JywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcigndXBncmFkZScpKVxuXG4gICAgdHJ5IHtcbiAgICAgIHJlcXVlc3Qub25VcGdyYWRlKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIGVycilcbiAgICB9XG5cbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNDb2RlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXBncmFkZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZEtlZXBBbGl2ZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgb25IZWFkZXJzQ29tcGxldGUgKHN0YXR1c0NvZGUsIHVwZ3JhZGUsIHNob3VsZEtlZXBBbGl2ZSkge1xuICAgIGNvbnN0IHsgY2xpZW50LCBzb2NrZXQsIGhlYWRlcnMsIHN0YXR1c1RleHQgfSA9IHRoaXNcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIG1ha2UgYSB0ZXN0IGNhc2UgZm9yICovXG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBhc3NlcnQoIXRoaXMudXBncmFkZSlcbiAgICBhc3NlcnQodGhpcy5zdGF0dXNDb2RlIDwgMjAwKVxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPT09IDEwMCkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IFNvY2tldEVycm9yKCdiYWQgcmVzcG9uc2UnLCB1dGlsLmdldFNvY2tldEluZm8oc29ja2V0KSkpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICAvKiB0aGlzIGNhbiBvbmx5IGhhcHBlbiBpZiBzZXJ2ZXIgaXMgbWlzYmVoYXZpbmcgKi9cbiAgICBpZiAodXBncmFkZSAmJiAhcmVxdWVzdC51cGdyYWRlKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgU29ja2V0RXJyb3IoJ2JhZCB1cGdyYWRlJywgdXRpbC5nZXRTb2NrZXRJbmZvKHNvY2tldCkpKVxuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgYXNzZXJ0KHRoaXMudGltZW91dFR5cGUgPT09IFRJTUVPVVRfSEVBREVSUylcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGVcbiAgICB0aGlzLnNob3VsZEtlZXBBbGl2ZSA9IChcbiAgICAgIHNob3VsZEtlZXBBbGl2ZSB8fFxuICAgICAgLy8gT3ZlcnJpZGUgbGxodHRwIHZhbHVlIHdoaWNoIGRvZXMgbm90IGFsbG93IGtlZXBBbGl2ZSBmb3IgSEVBRC5cbiAgICAgIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnICYmICFzb2NrZXRba1Jlc2V0XSAmJiB0aGlzLmNvbm5lY3Rpb24udG9Mb3dlckNhc2UoKSA9PT0gJ2tlZXAtYWxpdmUnKVxuICAgIClcblxuICAgIGlmICh0aGlzLnN0YXR1c0NvZGUgPj0gMjAwKSB7XG4gICAgICBjb25zdCBib2R5VGltZW91dCA9IHJlcXVlc3QuYm9keVRpbWVvdXQgIT0gbnVsbFxuICAgICAgICA/IHJlcXVlc3QuYm9keVRpbWVvdXRcbiAgICAgICAgOiBjbGllbnRba0JvZHlUaW1lb3V0XVxuICAgICAgdGhpcy5zZXRUaW1lb3V0KGJvZHlUaW1lb3V0LCBUSU1FT1VUX0JPRFkpXG4gICAgfSBlbHNlIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICBpZiAodGhpcy50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMSlcbiAgICAgIHRoaXMudXBncmFkZSA9IHRydWVcbiAgICAgIHJldHVybiAyXG4gICAgfVxuXG4gICAgaWYgKHVwZ3JhZGUpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAxKVxuICAgICAgdGhpcy51cGdyYWRlID0gdHJ1ZVxuICAgICAgcmV0dXJuIDJcbiAgICB9XG5cbiAgICBhc3NlcnQoKHRoaXMuaGVhZGVycy5sZW5ndGggJiAxKSA9PT0gMClcbiAgICB0aGlzLmhlYWRlcnMgPSBbXVxuICAgIHRoaXMuaGVhZGVyc1NpemUgPSAwXG5cbiAgICBpZiAodGhpcy5zaG91bGRLZWVwQWxpdmUgJiYgY2xpZW50W2tQaXBlbGluaW5nXSkge1xuICAgICAgY29uc3Qga2VlcEFsaXZlVGltZW91dCA9IHRoaXMua2VlcEFsaXZlID8gdXRpbC5wYXJzZUtlZXBBbGl2ZVRpbWVvdXQodGhpcy5rZWVwQWxpdmUpIDogbnVsbFxuXG4gICAgICBpZiAoa2VlcEFsaXZlVGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBNYXRoLm1pbihcbiAgICAgICAgICBrZWVwQWxpdmVUaW1lb3V0IC0gY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkXSxcbiAgICAgICAgICBjbGllbnRba0tlZXBBbGl2ZU1heFRpbWVvdXRdXG4gICAgICAgIClcbiAgICAgICAgaWYgKHRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IHRpbWVvdXRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VmFsdWVdID0gY2xpZW50W2tLZWVwQWxpdmVEZWZhdWx0VGltZW91dF1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RvcCBtb3JlIHJlcXVlc3RzIGZyb20gYmVpbmcgZGlzcGF0Y2hlZC5cbiAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IHBhdXNlID0gcmVxdWVzdC5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgdGhpcy5yZXN1bWUsIHN0YXR1c1RleHQpID09PSBmYWxzZVxuXG4gICAgaWYgKHJlcXVlc3QuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgaWYgKHNvY2tldFtrQmxvY2tpbmddKSB7XG4gICAgICBzb2NrZXRba0Jsb2NraW5nXSA9IGZhbHNlXG4gICAgICBjbGllbnRba1Jlc3VtZV0oKVxuICAgIH1cblxuICAgIHJldHVybiBwYXVzZSA/IGNvbnN0YW50cy5FUlJPUi5QQVVTRUQgOiAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgb25Cb2R5IChidWYpIHtcbiAgICBjb25zdCB7IGNsaWVudCwgc29ja2V0LCBzdGF0dXNDb2RlLCBtYXhSZXNwb25zZVNpemUgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBhc3NlcnQocmVxdWVzdClcblxuICAgIGFzc2VydCh0aGlzLnRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0JPRFkpXG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgYXNzZXJ0KHN0YXR1c0NvZGUgPj0gMjAwKVxuXG4gICAgaWYgKG1heFJlc3BvbnNlU2l6ZSA+IC0xICYmIHRoaXMuYnl0ZXNSZWFkICsgYnVmLmxlbmd0aCA+IG1heFJlc3BvbnNlU2l6ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IoKSlcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIHRoaXMuYnl0ZXNSZWFkICs9IGJ1Zi5sZW5ndGhcblxuICAgIGlmIChyZXF1ZXN0Lm9uRGF0YShidWYpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50cy5FUlJPUi5QQVVTRURcbiAgICB9XG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBvbk1lc3NhZ2VDb21wbGV0ZSAoKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIHNvY2tldCwgc3RhdHVzQ29kZSwgdXBncmFkZSwgaGVhZGVycywgY29udGVudExlbmd0aCwgYnl0ZXNSZWFkLCBzaG91bGRLZWVwQWxpdmUgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkICYmICghc3RhdHVzQ29kZSB8fCBzaG91bGRLZWVwQWxpdmUpKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBhc3NlcnQoc3RhdHVzQ29kZSA+PSAxMDApXG4gICAgYXNzZXJ0KCh0aGlzLmhlYWRlcnMubGVuZ3RoICYgMSkgPT09IDApXG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBhc3NlcnQocmVxdWVzdClcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IDBcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICAgIHRoaXMuYnl0ZXNSZWFkID0gMFxuICAgIHRoaXMuY29udGVudExlbmd0aCA9ICcnXG4gICAgdGhpcy5rZWVwQWxpdmUgPSAnJ1xuICAgIHRoaXMuY29ubmVjdGlvbiA9ICcnXG5cbiAgICB0aGlzLmhlYWRlcnMgPSBbXVxuICAgIHRoaXMuaGVhZGVyc1NpemUgPSAwXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2hvdWxkIGJlIGhhbmRsZWQgYnkgbGxodHRwPyAqL1xuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnICYmIGNvbnRlbnRMZW5ndGggJiYgYnl0ZXNSZWFkICE9PSBwYXJzZUludChjb250ZW50TGVuZ3RoLCAxMCkpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9uQ29tcGxldGUoaGVhZGVycylcblxuICAgIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF0rK10gPSBudWxsXG5cbiAgICBpZiAoc29ja2V0W2tXcml0aW5nXSkge1xuICAgICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDApXG4gICAgICAvLyBSZXNwb25zZSBjb21wbGV0ZWQgYmVmb3JlIHJlcXVlc3QuXG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdyZXNldCcpKVxuICAgICAgcmV0dXJuIGNvbnN0YW50cy5FUlJPUi5QQVVTRURcbiAgICB9IGVsc2UgaWYgKCFzaG91bGRLZWVwQWxpdmUpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3Jlc2V0JykpXG4gICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRFxuICAgIH0gZWxzZSBpZiAoc29ja2V0W2tSZXNldF0gJiYgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCkge1xuICAgICAgLy8gRGVzdHJveSBzb2NrZXQgb25jZSBhbGwgcmVxdWVzdHMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICAvLyBUaGUgcmVxdWVzdCBhdCB0aGUgdGFpbCBvZiB0aGUgcGlwZWxpbmUgaXMgdGhlIG9uZVxuICAgICAgLy8gdGhhdCByZXF1ZXN0ZWQgcmVzZXQgYW5kIG5vIGZ1cnRoZXIgcmVxdWVzdHMgc2hvdWxkXG4gICAgICAvLyBoYXZlIGJlZW4gcXVldWVkIHNpbmNlIHRoZW4uXG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdyZXNldCcpKVxuICAgICAgcmV0dXJuIGNvbnN0YW50cy5FUlJPUi5QQVVTRURcbiAgICB9IGVsc2UgaWYgKGNsaWVudFtrUGlwZWxpbmluZ10gPT0gbnVsbCB8fCBjbGllbnRba1BpcGVsaW5pbmddID09PSAxKSB7XG4gICAgICAvLyBXZSBtdXN0IHdhaXQgYSBmdWxsIGV2ZW50IGxvb3AgY3ljbGUgdG8gcmV1c2UgdGhpcyBzb2NrZXQgdG8gbWFrZSBzdXJlXG4gICAgICAvLyB0aGF0IG5vbi1zcGVjIGNvbXBsaWFudCBzZXJ2ZXJzIGFyZSBub3QgY2xvc2luZyB0aGUgY29ubmVjdGlvbiBldmVuIGlmIHRoZXlcbiAgICAgIC8vIHNhaWQgdGhleSB3b24ndC5cbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiBjbGllbnRba1Jlc3VtZV0oKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2xpZW50W2tSZXN1bWVdKClcbiAgICB9XG5cbiAgICByZXR1cm4gMFxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUGFyc2VyVGltZW91dCAocGFyc2VyKSB7XG4gIGNvbnN0IHsgc29ja2V0LCB0aW1lb3V0VHlwZSwgY2xpZW50LCBwYXVzZWQgfSA9IHBhcnNlci5kZXJlZigpXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICBpZiAoIXNvY2tldFtrV3JpdGluZ10gfHwgc29ja2V0LndyaXRhYmxlTmVlZERyYWluIHx8IGNsaWVudFtrUnVubmluZ10gPiAxKSB7XG4gICAgICBhc3NlcnQoIXBhdXNlZCwgJ2Nhbm5vdCBiZSBwYXVzZWQgd2hpbGUgd2FpdGluZyBmb3IgaGVhZGVycycpXG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSGVhZGVyc1RpbWVvdXRFcnJvcigpKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9CT0RZKSB7XG4gICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBCb2R5VGltZW91dEVycm9yKCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0tFRVBfQUxJVkUpIHtcbiAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMCAmJiBjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0pXG4gICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcignc29ja2V0IGlkbGUgdGltZW91dCcpKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQgKCcuL2NsaWVudC5qcycpfSBjbGllbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCduZXQnKS5Tb2NrZXR9IHNvY2tldFxuICogQHJldHVybnNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY29ubmVjdEgxIChjbGllbnQsIHNvY2tldCkge1xuICBjbGllbnRba1NvY2tldF0gPSBzb2NrZXRcblxuICBpZiAoIWxsaHR0cEluc3RhbmNlKSB7XG4gICAgY29uc3Qgbm9vcCA9ICgpID0+IHt9XG4gICAgc29ja2V0Lm9uKCdlcnJvcicsIG5vb3ApXG4gICAgbGxodHRwSW5zdGFuY2UgPSBhd2FpdCBsbGh0dHBQcm9taXNlXG4gICAgbGxodHRwUHJvbWlzZSA9IG51bGxcbiAgICBzb2NrZXQub2ZmKCdlcnJvcicsIG5vb3ApXG4gIH1cblxuICBpZiAoc29ja2V0LmVycm9yZWQpIHtcbiAgICB0aHJvdyBzb2NrZXQuZXJyb3JlZFxuICB9XG5cbiAgaWYgKHNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICB0aHJvdyBuZXcgU29ja2V0RXJyb3IoJ2Rlc3Ryb3llZCcpXG4gIH1cblxuICBzb2NrZXRba05vUmVmXSA9IGZhbHNlXG4gIHNvY2tldFtrV3JpdGluZ10gPSBmYWxzZVxuICBzb2NrZXRba1Jlc2V0XSA9IGZhbHNlXG4gIHNvY2tldFtrQmxvY2tpbmddID0gZmFsc2VcbiAgc29ja2V0W2tQYXJzZXJdID0gbmV3IFBhcnNlcihjbGllbnQsIHNvY2tldCwgbGxodHRwSW5zdGFuY2UpXG5cbiAgdXRpbC5hZGRMaXN0ZW5lcihzb2NrZXQsICdlcnJvcicsIG9uSHR0cFNvY2tldEVycm9yKVxuICB1dGlsLmFkZExpc3RlbmVyKHNvY2tldCwgJ3JlYWRhYmxlJywgb25IdHRwU29ja2V0UmVhZGFibGUpXG4gIHV0aWwuYWRkTGlzdGVuZXIoc29ja2V0LCAnZW5kJywgb25IdHRwU29ja2V0RW5kKVxuICB1dGlsLmFkZExpc3RlbmVyKHNvY2tldCwgJ2Nsb3NlJywgb25IdHRwU29ja2V0Q2xvc2UpXG5cbiAgc29ja2V0W2tDbG9zZWRdID0gZmFsc2VcbiAgc29ja2V0Lm9uKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpXG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAnaDEnLFxuICAgIGRlZmF1bHRQaXBlbGluaW5nOiAxLFxuICAgIHdyaXRlIChyZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gd3JpdGVIMShjbGllbnQsIHJlcXVlc3QpXG4gICAgfSxcbiAgICByZXN1bWUgKCkge1xuICAgICAgcmVzdW1lSDEoY2xpZW50KVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFcnJvcnx1bmRlZmluZWR9IGVyclxuICAgICAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBkZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoc29ja2V0W2tDbG9zZWRdKSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ja2V0Lm9uKCdjbG9zZScsIGNhbGxiYWNrKVxuICAgICAgICBzb2NrZXQuZGVzdHJveShlcnIpXG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgZGVzdHJveWVkICgpIHtcbiAgICAgIHJldHVybiBzb2NrZXQuZGVzdHJveWVkXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29yZS9yZXF1ZXN0LmpzJyl9IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBidXN5IChyZXF1ZXN0KSB7XG4gICAgICBpZiAoc29ja2V0W2tXcml0aW5nXSB8fCBzb2NrZXRba1Jlc2V0XSB8fCBzb2NrZXRba0Jsb2NraW5nXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDAgJiYgIXJlcXVlc3QuaWRlbXBvdGVudCkge1xuICAgICAgICAgIC8vIE5vbi1pZGVtcG90ZW50IHJlcXVlc3QgY2Fubm90IGJlIHJldHJpZWQuXG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgbm8gb3RoZXIgcmVxdWVzdHMgYXJlIGluZmxpZ2h0IGFuZFxuICAgICAgICAgIC8vIGNvdWxkIGNhdXNlIGZhaWx1cmUuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiAocmVxdWVzdC51cGdyYWRlIHx8IHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcpKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgZGlzcGF0Y2ggYW4gdXBncmFkZSB1bnRpbCBhbGwgcHJlY2VkaW5nIHJlcXVlc3RzIGhhdmUgY29tcGxldGVkLlxuICAgICAgICAgIC8vIEEgbWlzYmVoYXZpbmcgc2VydmVyIG1pZ2h0IHVwZ3JhZGUgdGhlIGNvbm5lY3Rpb24gYmVmb3JlIGFsbCBwaXBlbGluZWRcbiAgICAgICAgICAvLyByZXF1ZXN0IGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiB1dGlsLmJvZHlMZW5ndGgocmVxdWVzdC5ib2R5KSAhPT0gMCAmJlxuICAgICAgICAgICh1dGlsLmlzU3RyZWFtKHJlcXVlc3QuYm9keSkgfHwgdXRpbC5pc0FzeW5jSXRlcmFibGUocmVxdWVzdC5ib2R5KSB8fCB1dGlsLmlzRm9ybURhdGFMaWtlKHJlcXVlc3QuYm9keSkpKSB7XG4gICAgICAgICAgLy8gUmVxdWVzdCB3aXRoIHN0cmVhbSBvciBpdGVyYXRvciBib2R5IGNhbiBlcnJvciB3aGlsZSBvdGhlciByZXF1ZXN0c1xuICAgICAgICAgIC8vIGFyZSBpbmZsaWdodCBhbmQgaW5kaXJlY3RseSBlcnJvciB0aG9zZSBhcyB3ZWxsLlxuICAgICAgICAgIC8vIEVuc3VyZSB0aGlzIGRvZXNuJ3QgaGFwcGVuIGJ5IHdhaXRpbmcgZm9yIGluZmxpZ2h0XG4gICAgICAgICAgLy8gdG8gY29tcGxldGUgYmVmb3JlIGRpc3BhdGNoaW5nLlxuXG4gICAgICAgICAgLy8gUmVxdWVzdCB3aXRoIHN0cmVhbSBvciBpdGVyYXRvciBib2R5IGNhbm5vdCBiZSByZXRyaWVkLlxuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IG5vIG90aGVyIHJlcXVlc3RzIGFyZSBpbmZsaWdodCBhbmRcbiAgICAgICAgICAvLyBjb3VsZCBjYXVzZSBmYWlsdXJlLlxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uSHR0cFNvY2tldEVycm9yIChlcnIpIHtcbiAgYXNzZXJ0KGVyci5jb2RlICE9PSAnRVJSX1RMU19DRVJUX0FMVE5BTUVfSU5WQUxJRCcpXG5cbiAgY29uc3QgcGFyc2VyID0gdGhpc1trUGFyc2VyXVxuXG4gIC8vIE9uIE1hYyBPUywgd2UgZ2V0IGFuIEVDT05OUkVTRVQgZXZlbiBpZiB0aGVyZSBpcyBhIGZ1bGwgYm9keSB0byBiZSBmb3J3YXJkZWRcbiAgLy8gdG8gdGhlIHVzZXIuXG4gIGlmIChlcnIuY29kZSA9PT0gJ0VDT05OUkVTRVQnICYmIHBhcnNlci5zdGF0dXNDb2RlICYmICFwYXJzZXIuc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgLy8gV2UgdHJlYXQgYWxsIGluY29taW5nIGRhdGEgc28gZm9yIGFzIGEgdmFsaWQgcmVzcG9uc2UuXG4gICAgcGFyc2VyLm9uTWVzc2FnZUNvbXBsZXRlKClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXNba0Vycm9yXSA9IGVyclxuXG4gIHRoaXNba0NsaWVudF1ba09uRXJyb3JdKGVycilcbn1cblxuZnVuY3Rpb24gb25IdHRwU29ja2V0UmVhZGFibGUgKCkge1xuICB0aGlzW2tQYXJzZXJdPy5yZWFkTW9yZSgpXG59XG5cbmZ1bmN0aW9uIG9uSHR0cFNvY2tldEVuZCAoKSB7XG4gIGNvbnN0IHBhcnNlciA9IHRoaXNba1BhcnNlcl1cblxuICBpZiAocGFyc2VyLnN0YXR1c0NvZGUgJiYgIXBhcnNlci5zaG91bGRLZWVwQWxpdmUpIHtcbiAgICAvLyBXZSB0cmVhdCBhbGwgaW5jb21pbmcgZGF0YSBzbyBmYXIgYXMgYSB2YWxpZCByZXNwb25zZS5cbiAgICBwYXJzZXIub25NZXNzYWdlQ29tcGxldGUoKVxuICAgIHJldHVyblxuICB9XG5cbiAgdXRpbC5kZXN0cm95KHRoaXMsIG5ldyBTb2NrZXRFcnJvcignb3RoZXIgc2lkZSBjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8odGhpcykpKVxufVxuXG5mdW5jdGlvbiBvbkh0dHBTb2NrZXRDbG9zZSAoKSB7XG4gIGNvbnN0IHBhcnNlciA9IHRoaXNba1BhcnNlcl1cblxuICBpZiAocGFyc2VyKSB7XG4gICAgaWYgKCF0aGlzW2tFcnJvcl0gJiYgcGFyc2VyLnN0YXR1c0NvZGUgJiYgIXBhcnNlci5zaG91bGRLZWVwQWxpdmUpIHtcbiAgICAgIC8vIFdlIHRyZWF0IGFsbCBpbmNvbWluZyBkYXRhIHNvIGZhciBhcyBhIHZhbGlkIHJlc3BvbnNlLlxuICAgICAgcGFyc2VyLm9uTWVzc2FnZUNvbXBsZXRlKClcbiAgICB9XG5cbiAgICB0aGlzW2tQYXJzZXJdLmRlc3Ryb3koKVxuICAgIHRoaXNba1BhcnNlcl0gPSBudWxsXG4gIH1cblxuICBjb25zdCBlcnIgPSB0aGlzW2tFcnJvcl0gfHwgbmV3IFNvY2tldEVycm9yKCdjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8odGhpcykpXG5cbiAgY29uc3QgY2xpZW50ID0gdGhpc1trQ2xpZW50XVxuXG4gIGNsaWVudFtrU29ja2V0XSA9IG51bGxcbiAgY2xpZW50W2tIVFRQQ29udGV4dF0gPSBudWxsIC8vIFRPRE8gKGZpeCk6IFRoaXMgaXMgaGFja3kuLi5cblxuICBpZiAoY2xpZW50LmRlc3Ryb3llZCkge1xuICAgIGFzc2VydChjbGllbnRba1BlbmRpbmddID09PSAwKVxuXG4gICAgLy8gRmFpbCBlbnRpcmUgcXVldWUuXG4gICAgY29uc3QgcmVxdWVzdHMgPSBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tSdW5uaW5nSWR4XSlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHNbaV1cbiAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgIH1cbiAgfSBlbHNlIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiBlcnIuY29kZSAhPT0gJ1VORF9FUlJfSU5GTycpIHtcbiAgICAvLyBGYWlsIGhlYWQgb2YgcGlwZWxpbmUuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcblxuICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICB9XG5cbiAgY2xpZW50W2tQZW5kaW5nSWR4XSA9IGNsaWVudFtrUnVubmluZ0lkeF1cblxuICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcblxuICBjbGllbnQuZW1pdCgnZGlzY29ubmVjdCcsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIGVycilcblxuICBjbGllbnRba1Jlc3VtZV0oKVxufVxuXG5mdW5jdGlvbiBvblNvY2tldENsb3NlICgpIHtcbiAgdGhpc1trQ2xvc2VkXSA9IHRydWVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9jbGllbnQuanMnKX0gY2xpZW50XG4gKi9cbmZ1bmN0aW9uIHJlc3VtZUgxIChjbGllbnQpIHtcbiAgY29uc3Qgc29ja2V0ID0gY2xpZW50W2tTb2NrZXRdXG5cbiAgaWYgKHNvY2tldCAmJiAhc29ja2V0LmRlc3Ryb3llZCkge1xuICAgIGlmIChjbGllbnRba1NpemVdID09PSAwKSB7XG4gICAgICBpZiAoIXNvY2tldFtrTm9SZWZdICYmIHNvY2tldC51bnJlZikge1xuICAgICAgICBzb2NrZXQudW5yZWYoKVxuICAgICAgICBzb2NrZXRba05vUmVmXSA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNvY2tldFtrTm9SZWZdICYmIHNvY2tldC5yZWYpIHtcbiAgICAgIHNvY2tldC5yZWYoKVxuICAgICAgc29ja2V0W2tOb1JlZl0gPSBmYWxzZVxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1NpemVdID09PSAwKSB7XG4gICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlICE9PSBUSU1FT1VUX0tFRVBfQUxJVkUpIHtcbiAgICAgICAgc29ja2V0W2tQYXJzZXJdLnNldFRpbWVvdXQoY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VmFsdWVdLCBUSU1FT1VUX0tFRVBfQUxJVkUpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiBzb2NrZXRba1BhcnNlcl0uc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0VHlwZSAhPT0gVElNRU9VVF9IRUFERVJTKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgICAgICBjb25zdCBoZWFkZXJzVGltZW91dCA9IHJlcXVlc3QuaGVhZGVyc1RpbWVvdXQgIT0gbnVsbFxuICAgICAgICAgID8gcmVxdWVzdC5oZWFkZXJzVGltZW91dFxuICAgICAgICAgIDogY2xpZW50W2tIZWFkZXJzVGltZW91dF1cbiAgICAgICAgc29ja2V0W2tQYXJzZXJdLnNldFRpbWVvdXQoaGVhZGVyc1RpbWVvdXQsIFRJTUVPVVRfSEVBREVSUylcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzAjc2VjdGlvbi0zLjMuMlxuZnVuY3Rpb24gc2hvdWxkU2VuZENvbnRlbnRMZW5ndGggKG1ldGhvZCkge1xuICByZXR1cm4gbWV0aG9kICE9PSAnR0VUJyAmJiBtZXRob2QgIT09ICdIRUFEJyAmJiBtZXRob2QgIT09ICdPUFRJT05TJyAmJiBtZXRob2QgIT09ICdUUkFDRScgJiYgbWV0aG9kICE9PSAnQ09OTkVDVCdcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9jbGllbnQuanMnKX0gY2xpZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29yZS9yZXF1ZXN0LmpzJyl9IHJlcXVlc3RcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHdyaXRlSDEgKGNsaWVudCwgcmVxdWVzdCkge1xuICBjb25zdCB7IG1ldGhvZCwgcGF0aCwgaG9zdCwgdXBncmFkZSwgYmxvY2tpbmcsIHJlc2V0IH0gPSByZXF1ZXN0XG5cbiAgbGV0IHsgYm9keSwgaGVhZGVycywgY29udGVudExlbmd0aCB9ID0gcmVxdWVzdFxuXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjFcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuMlxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy41XG5cbiAgLy8gU2VuZGluZyBhIHBheWxvYWQgYm9keSBvbiBhIHJlcXVlc3QgdGhhdCBkb2VzIG5vdFxuICAvLyBleHBlY3QgaXQgY2FuIGNhdXNlIHVuZGVmaW5lZCBiZWhhdmlvciBvbiBzb21lXG4gIC8vIHNlcnZlcnMgYW5kIGNvcnJ1cHQgY29ubmVjdGlvbiBzdGF0ZS4gRG8gbm90XG4gIC8vIHJlLXVzZSB0aGUgY29ubmVjdGlvbiBmb3IgZnVydGhlciByZXF1ZXN0cy5cblxuICBjb25zdCBleHBlY3RzUGF5bG9hZCA9IChcbiAgICBtZXRob2QgPT09ICdQVVQnIHx8XG4gICAgbWV0aG9kID09PSAnUE9TVCcgfHxcbiAgICBtZXRob2QgPT09ICdQQVRDSCcgfHxcbiAgICBtZXRob2QgPT09ICdRVUVSWScgfHxcbiAgICBtZXRob2QgPT09ICdQUk9QRklORCcgfHxcbiAgICBtZXRob2QgPT09ICdQUk9QUEFUQ0gnXG4gIClcblxuICBpZiAodXRpbC5pc0Zvcm1EYXRhTGlrZShib2R5KSkge1xuICAgIGlmICghZXh0cmFjdEJvZHkpIHtcbiAgICAgIGV4dHJhY3RCb2R5ID0gcmVxdWlyZSgnLi4vd2ViL2ZldGNoL2JvZHkuanMnKS5leHRyYWN0Qm9keVxuICAgIH1cblxuICAgIGNvbnN0IFtib2R5U3RyZWFtLCBjb250ZW50VHlwZV0gPSBleHRyYWN0Qm9keShib2R5KVxuICAgIGlmIChyZXF1ZXN0LmNvbnRlbnRUeXBlID09IG51bGwpIHtcbiAgICAgIGhlYWRlcnMucHVzaCgnY29udGVudC10eXBlJywgY29udGVudFR5cGUpXG4gICAgfVxuICAgIGJvZHkgPSBib2R5U3RyZWFtLnN0cmVhbVxuICAgIGNvbnRlbnRMZW5ndGggPSBib2R5U3RyZWFtLmxlbmd0aFxuICB9IGVsc2UgaWYgKHV0aWwuaXNCbG9iTGlrZShib2R5KSAmJiByZXF1ZXN0LmNvbnRlbnRUeXBlID09IG51bGwgJiYgYm9keS50eXBlKSB7XG4gICAgaGVhZGVycy5wdXNoKCdjb250ZW50LXR5cGUnLCBib2R5LnR5cGUpXG4gIH1cblxuICBpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5yZWFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVHJ5IHRvIHJlYWQgRU9GIGluIG9yZGVyIHRvIGdldCBsZW5ndGguXG4gICAgYm9keS5yZWFkKDApXG4gIH1cblxuICBjb25zdCBib2R5TGVuZ3RoID0gdXRpbC5ib2R5TGVuZ3RoKGJvZHkpXG5cbiAgY29udGVudExlbmd0aCA9IGJvZHlMZW5ndGggPz8gY29udGVudExlbmd0aFxuXG4gIGlmIChjb250ZW50TGVuZ3RoID09PSBudWxsKSB7XG4gICAgY29udGVudExlbmd0aCA9IHJlcXVlc3QuY29udGVudExlbmd0aFxuICB9XG5cbiAgaWYgKGNvbnRlbnRMZW5ndGggPT09IDAgJiYgIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjMuMlxuICAgIC8vIEEgdXNlciBhZ2VudCBTSE9VTEQgTk9UIHNlbmQgYSBDb250ZW50LUxlbmd0aCBoZWFkZXIgZmllbGQgd2hlblxuICAgIC8vIHRoZSByZXF1ZXN0IG1lc3NhZ2UgZG9lcyBub3QgY29udGFpbiBhIHBheWxvYWQgYm9keSBhbmQgdGhlIG1ldGhvZFxuICAgIC8vIHNlbWFudGljcyBkbyBub3QgYW50aWNpcGF0ZSBzdWNoIGEgYm9keS5cblxuICAgIGNvbnRlbnRMZW5ndGggPSBudWxsXG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjA0NlxuICAvLyBBIHVzZXIgYWdlbnQgbWF5IHNlbmQgYSBDb250ZW50LUxlbmd0aCBoZWFkZXIgd2l0aCAwIHZhbHVlLCB0aGlzIHNob3VsZCBiZSBhbGxvd2VkLlxuICBpZiAoc2hvdWxkU2VuZENvbnRlbnRMZW5ndGgobWV0aG9kKSAmJiBjb250ZW50TGVuZ3RoID4gMCAmJiByZXF1ZXN0LmNvbnRlbnRMZW5ndGggIT09IG51bGwgJiYgcmVxdWVzdC5jb250ZW50TGVuZ3RoICE9PSBjb250ZW50TGVuZ3RoKSB7XG4gICAgaWYgKGNsaWVudFtrU3RyaWN0Q29udGVudExlbmd0aF0pIHtcbiAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gIH1cblxuICBjb25zdCBzb2NrZXQgPSBjbGllbnRba1NvY2tldF1cblxuICAvKipcbiAgICogQHBhcmFtIHtFcnJvcn0gW2Vycl1cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjb25zdCBhYm9ydCA9IChlcnIpID0+IHtcbiAgICBpZiAocmVxdWVzdC5hYm9ydGVkIHx8IHJlcXVlc3QuY29tcGxldGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVyciB8fCBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpKVxuXG4gICAgdXRpbC5kZXN0cm95KGJvZHkpXG4gICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcignYWJvcnRlZCcpKVxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXF1ZXN0Lm9uQ29ubmVjdChhYm9ydClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gIH1cblxuICBpZiAocmVxdWVzdC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAobWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWNvbGxpbmEvdW5kaWNpL2lzc3Vlcy8yNThcbiAgICAvLyBDbG9zZSBhZnRlciBhIEhFQUQgcmVxdWVzdCB0byBpbnRlcm9wIHdpdGggbWlzYmVoYXZpbmcgc2VydmVyc1xuICAgIC8vIHRoYXQgbWF5IHNlbmQgYSBib2R5IGluIHRoZSByZXNwb25zZS5cblxuICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICB9XG5cbiAgaWYgKHVwZ3JhZGUgfHwgbWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAvLyBPbiBDT05ORUNUIG9yIHVwZ3JhZGUsIGJsb2NrIHBpcGVsaW5lIGZyb20gZGlzcGF0Y2hpbmcgZnVydGhlclxuICAgIC8vIHJlcXVlc3RzIG9uIHRoaXMgY29ubmVjdGlvbi5cblxuICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICB9XG5cbiAgaWYgKHJlc2V0ICE9IG51bGwpIHtcbiAgICBzb2NrZXRba1Jlc2V0XSA9IHJlc2V0XG4gIH1cblxuICBpZiAoY2xpZW50W2tNYXhSZXF1ZXN0c10gJiYgc29ja2V0W2tDb3VudGVyXSsrID49IGNsaWVudFtrTWF4UmVxdWVzdHNdKSB7XG4gICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gIH1cblxuICBpZiAoYmxvY2tpbmcpIHtcbiAgICBzb2NrZXRba0Jsb2NraW5nXSA9IHRydWVcbiAgfVxuXG4gIGxldCBoZWFkZXIgPSBgJHttZXRob2R9ICR7cGF0aH0gSFRUUC8xLjFcXHJcXG5gXG5cbiAgaWYgKHR5cGVvZiBob3N0ID09PSAnc3RyaW5nJykge1xuICAgIGhlYWRlciArPSBgaG9zdDogJHtob3N0fVxcclxcbmBcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXIgKz0gY2xpZW50W2tIb3N0SGVhZGVyXVxuICB9XG5cbiAgaWYgKHVwZ3JhZGUpIHtcbiAgICBoZWFkZXIgKz0gYGNvbm5lY3Rpb246IHVwZ3JhZGVcXHJcXG51cGdyYWRlOiAke3VwZ3JhZGV9XFxyXFxuYFxuICB9IGVsc2UgaWYgKGNsaWVudFtrUGlwZWxpbmluZ10gJiYgIXNvY2tldFtrUmVzZXRdKSB7XG4gICAgaGVhZGVyICs9ICdjb25uZWN0aW9uOiBrZWVwLWFsaXZlXFxyXFxuJ1xuICB9IGVsc2Uge1xuICAgIGhlYWRlciArPSAnY29ubmVjdGlvbjogY2xvc2VcXHJcXG4nXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgaGVhZGVycy5sZW5ndGg7IG4gKz0gMikge1xuICAgICAgY29uc3Qga2V5ID0gaGVhZGVyc1tuICsgMF1cbiAgICAgIGNvbnN0IHZhbCA9IGhlYWRlcnNbbiArIDFdXG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBoZWFkZXIgKz0gYCR7a2V5fTogJHt2YWxbaV19XFxyXFxuYFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkZXIgKz0gYCR7a2V5fTogJHt2YWx9XFxyXFxuYFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjaGFubmVscy5zZW5kSGVhZGVycy5oYXNTdWJzY3JpYmVycykge1xuICAgIGNoYW5uZWxzLnNlbmRIZWFkZXJzLnB1Ymxpc2goeyByZXF1ZXN0LCBoZWFkZXJzOiBoZWFkZXIsIHNvY2tldCB9KVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGFzc2VydGlvbiAqL1xuICBpZiAoIWJvZHkgfHwgYm9keUxlbmd0aCA9PT0gMCkge1xuICAgIHdyaXRlQnVmZmVyKGFib3J0LCBudWxsLCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgd3JpdGVCdWZmZXIoYWJvcnQsIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKVxuICB9IGVsc2UgaWYgKHV0aWwuaXNCbG9iTGlrZShib2R5KSkge1xuICAgIGlmICh0eXBlb2YgYm9keS5zdHJlYW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdyaXRlSXRlcmFibGUoYWJvcnQsIGJvZHkuc3RyZWFtKCksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKVxuICAgIH0gZWxzZSB7XG4gICAgICB3cml0ZUJsb2IoYWJvcnQsIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKVxuICAgIH1cbiAgfSBlbHNlIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgd3JpdGVTdHJlYW0oYWJvcnQsIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKVxuICB9IGVsc2UgaWYgKHV0aWwuaXNJdGVyYWJsZShib2R5KSkge1xuICAgIHdyaXRlSXRlcmFibGUoYWJvcnQsIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtBYm9ydENhbGxiYWNrfSBhYm9ydFxuICogQHBhcmFtIHtpbXBvcnQoJ3N0cmVhbScpLlN0cmVhbX0gYm9keVxuICogQHBhcmFtIHtpbXBvcnQoJy4vY2xpZW50LmpzJyl9IGNsaWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2NvcmUvcmVxdWVzdC5qcycpfSByZXF1ZXN0XG4gKiBAcGFyYW0ge2ltcG9ydCgnbmV0JykuU29ja2V0fSBzb2NrZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb250ZW50TGVuZ3RoXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4cGVjdHNQYXlsb2FkXG4gKi9cbmZ1bmN0aW9uIHdyaXRlU3RyZWFtIChhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggIT09IDAgfHwgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCwgJ3N0cmVhbSBib2R5IGNhbm5vdCBiZSBwaXBlbGluZWQnKVxuXG4gIGxldCBmaW5pc2hlZCA9IGZhbHNlXG5cbiAgY29uc3Qgd3JpdGVyID0gbmV3IEFzeW5jV3JpdGVyKHsgYWJvcnQsIHNvY2tldCwgcmVxdWVzdCwgY29udGVudExlbmd0aCwgY2xpZW50LCBleHBlY3RzUGF5bG9hZCwgaGVhZGVyIH0pXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVua1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGNvbnN0IG9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghd3JpdGVyLndyaXRlKGNodW5rKSAmJiB0aGlzLnBhdXNlKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdXRpbC5kZXN0cm95KHRoaXMsIGVycilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjb25zdCBvbkRyYWluID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGJvZHkucmVzdW1lKSB7XG4gICAgICBib2R5LnJlc3VtZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgY29uc3Qgb25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyAnY2xvc2UnIG1pZ2h0IGJlIGVtaXR0ZWQgKmJlZm9yZSogJ2Vycm9yJyBmb3JcbiAgICAvLyBicm9rZW4gc3RyZWFtcy4gV2FpdCBhIHRpY2sgdG8gYXZvaWQgdGhpcyBjYXNlLlxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIC8vIEl0J3Mgb25seSBzYWZlIHRvIHJlbW92ZSAnZXJyb3InIGxpc3RlbmVyIGFmdGVyXG4gICAgICAvLyAnY2xvc2UnLlxuICAgICAgYm9keS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkZpbmlzaGVkKVxuICAgIH0pXG5cbiAgICBpZiAoIWZpbmlzaGVkKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBvbkZpbmlzaGVkKGVycikpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXJyb3J9IFtlcnJdXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBjb25zdCBvbkZpbmlzaGVkID0gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZmluaXNoZWQgPSB0cnVlXG5cbiAgICBhc3NlcnQoc29ja2V0LmRlc3Ryb3llZCB8fCAoc29ja2V0W2tXcml0aW5nXSAmJiBjbGllbnRba1J1bm5pbmddIDw9IDEpKVxuXG4gICAgc29ja2V0XG4gICAgICAub2ZmKCdkcmFpbicsIG9uRHJhaW4pXG4gICAgICAub2ZmKCdlcnJvcicsIG9uRmluaXNoZWQpXG5cbiAgICBib2R5XG4gICAgICAucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbkRhdGEpXG4gICAgICAucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRmluaXNoZWQpXG4gICAgICAucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25DbG9zZSlcblxuICAgIGlmICghZXJyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB3cml0ZXIuZW5kKClcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGVyciA9IGVyXG4gICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVyLmRlc3Ryb3koZXJyKVxuXG4gICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgIT09ICdVTkRfRVJSX0lORk8nIHx8IGVyci5tZXNzYWdlICE9PSAncmVzZXQnKSkge1xuICAgICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5kZXN0cm95KGJvZHkpXG4gICAgfVxuICB9XG5cbiAgYm9keVxuICAgIC5vbignZGF0YScsIG9uRGF0YSlcbiAgICAub24oJ2VuZCcsIG9uRmluaXNoZWQpXG4gICAgLm9uKCdlcnJvcicsIG9uRmluaXNoZWQpXG4gICAgLm9uKCdjbG9zZScsIG9uQ2xvc2UpXG5cbiAgaWYgKGJvZHkucmVzdW1lKSB7XG4gICAgYm9keS5yZXN1bWUoKVxuICB9XG5cbiAgc29ja2V0XG4gICAgLm9uKCdkcmFpbicsIG9uRHJhaW4pXG4gICAgLm9uKCdlcnJvcicsIG9uRmluaXNoZWQpXG5cbiAgaWYgKGJvZHkuZXJyb3JFbWl0dGVkID8/IGJvZHkuZXJyb3JlZCkge1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiBvbkZpbmlzaGVkKGJvZHkuZXJyb3JlZCkpXG4gIH0gZWxzZSBpZiAoYm9keS5lbmRFbWl0dGVkID8/IGJvZHkucmVhZGFibGVFbmRlZCkge1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiBvbkZpbmlzaGVkKG51bGwpKVxuICB9XG5cbiAgaWYgKGJvZHkuY2xvc2VFbWl0dGVkID8/IGJvZHkuY2xvc2VkKSB7XG4gICAgc2V0SW1tZWRpYXRlKG9uQ2xvc2UpXG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBBYm9ydENhbGxiYWNrXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfSBbZXJyXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0Fib3J0Q2FsbGJhY2t9IGFib3J0XG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8bnVsbH0gYm9keVxuICogQHBhcmFtIHtpbXBvcnQoJy4vY2xpZW50LmpzJyl9IGNsaWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2NvcmUvcmVxdWVzdC5qcycpfSByZXF1ZXN0XG4gKiBAcGFyYW0ge2ltcG9ydCgnbmV0JykuU29ja2V0fSBzb2NrZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb250ZW50TGVuZ3RoXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4cGVjdHNQYXlsb2FkXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gd3JpdGVCdWZmZXIgKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCkge1xuICB0cnkge1xuICAgIGlmICghYm9keSkge1xuICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IDApIHtcbiAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogMFxcclxcblxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IG51bGwsICdubyBib2R5IG11c3Qgbm90IGhhdmUgY29udGVudCBsZW5ndGgnKVxuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfVxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodXRpbC5pc0J1ZmZlcihib2R5KSkge1xuICAgICAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuYnl0ZUxlbmd0aCwgJ2J1ZmZlciBib2R5IG11c3QgaGF2ZSBjb250ZW50IGxlbmd0aCcpXG5cbiAgICAgIHNvY2tldC5jb3JrKClcbiAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9Y29udGVudC1sZW5ndGg6ICR7Y29udGVudExlbmd0aH1cXHJcXG5cXHJcXG5gLCAnbGF0aW4xJylcbiAgICAgIHNvY2tldC53cml0ZShib2R5KVxuICAgICAgc29ja2V0LnVuY29yaygpXG4gICAgICByZXF1ZXN0Lm9uQm9keVNlbnQoYm9keSlcblxuICAgICAgaWYgKCFleHBlY3RzUGF5bG9hZCAmJiByZXF1ZXN0LnJlc2V0ICE9PSBmYWxzZSkge1xuICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGFib3J0KGVycilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJvcnRDYWxsYmFja30gYWJvcnRcbiAqIEBwYXJhbSB7QmxvYn0gYm9keVxuICogQHBhcmFtIHtpbXBvcnQoJy4vY2xpZW50LmpzJyl9IGNsaWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2NvcmUvcmVxdWVzdC5qcycpfSByZXF1ZXN0XG4gKiBAcGFyYW0ge2ltcG9ydCgnbmV0JykuU29ja2V0fSBzb2NrZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb250ZW50TGVuZ3RoXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4cGVjdHNQYXlsb2FkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gd3JpdGVCbG9iIChhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuc2l6ZSwgJ2Jsb2IgYm9keSBtdXN0IGhhdmUgY29udGVudCBsZW5ndGgnKVxuXG4gIHRyeSB7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBjb250ZW50TGVuZ3RoICE9PSBib2R5LnNpemUpIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKVxuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGF3YWl0IGJvZHkuYXJyYXlCdWZmZXIoKSlcblxuICAgIHNvY2tldC5jb3JrKClcbiAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgc29ja2V0LndyaXRlKGJ1ZmZlcilcbiAgICBzb2NrZXQudW5jb3JrKClcblxuICAgIHJlcXVlc3Qub25Cb2R5U2VudChidWZmZXIpXG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgIGlmICghZXhwZWN0c1BheWxvYWQgJiYgcmVxdWVzdC5yZXNldCAhPT0gZmFsc2UpIHtcbiAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgIH1cblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGFib3J0KGVycilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJvcnRDYWxsYmFja30gYWJvcnRcbiAqIEBwYXJhbSB7SXRlcmFibGV9IGJvZHlcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2NsaWVudC5qcycpfSBjbGllbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9jb3JlL3JlcXVlc3QuanMnKX0gcmVxdWVzdFxuICogQHBhcmFtIHtpbXBvcnQoJ25ldCcpLlNvY2tldH0gc29ja2V0XG4gKiBAcGFyYW0ge251bWJlcn0gY29udGVudExlbmd0aFxuICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlclxuICogQHBhcmFtIHtib29sZWFufSBleHBlY3RzUGF5bG9hZFxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlSXRlcmFibGUgKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCkge1xuICBhc3NlcnQoY29udGVudExlbmd0aCAhPT0gMCB8fCBjbGllbnRba1J1bm5pbmddID09PSAwLCAnaXRlcmF0b3IgYm9keSBjYW5ub3QgYmUgcGlwZWxpbmVkJylcblxuICBsZXQgY2FsbGJhY2sgPSBudWxsXG4gIGZ1bmN0aW9uIG9uRHJhaW4gKCkge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY29uc3QgY2IgPSBjYWxsYmFja1xuICAgICAgY2FsbGJhY2sgPSBudWxsXG4gICAgICBjYigpXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgd2FpdEZvckRyYWluID0gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGFzc2VydChjYWxsYmFjayA9PT0gbnVsbClcblxuICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgcmVqZWN0KHNvY2tldFtrRXJyb3JdKVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayA9IHJlc29sdmVcbiAgICB9XG4gIH0pXG5cbiAgc29ja2V0XG4gICAgLm9uKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgLm9uKCdkcmFpbicsIG9uRHJhaW4pXG5cbiAgY29uc3Qgd3JpdGVyID0gbmV3IEFzeW5jV3JpdGVyKHsgYWJvcnQsIHNvY2tldCwgcmVxdWVzdCwgY29udGVudExlbmd0aCwgY2xpZW50LCBleHBlY3RzUGF5bG9hZCwgaGVhZGVyIH0pXG4gIHRyeSB7XG4gICAgLy8gSXQncyB1cCB0byB0aGUgdXNlciB0byBzb21laG93IGFib3J0IHRoZSBhc3luYyBpdGVyYWJsZS5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGJvZHkpIHtcbiAgICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgICB0aHJvdyBzb2NrZXRba0Vycm9yXVxuICAgICAgfVxuXG4gICAgICBpZiAoIXdyaXRlci53cml0ZShjaHVuaykpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvckRyYWluKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3cml0ZXIuZW5kKClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgd3JpdGVyLmRlc3Ryb3koZXJyKVxuICB9IGZpbmFsbHkge1xuICAgIHNvY2tldFxuICAgICAgLm9mZignY2xvc2UnLCBvbkRyYWluKVxuICAgICAgLm9mZignZHJhaW4nLCBvbkRyYWluKVxuICB9XG59XG5cbmNsYXNzIEFzeW5jV3JpdGVyIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdcbiAgICogQHBhcmFtIHtBYm9ydENhbGxiYWNrfSBhcmcuYWJvcnRcbiAgICogQHBhcmFtIHtpbXBvcnQoJ25ldCcpLlNvY2tldH0gYXJnLnNvY2tldFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29yZS9yZXF1ZXN0LmpzJyl9IGFyZy5yZXF1ZXN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhcmcuY29udGVudExlbmd0aFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9jbGllbnQuanMnKX0gYXJnLmNsaWVudFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFyZy5leHBlY3RzUGF5bG9hZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXJnLmhlYWRlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKHsgYWJvcnQsIHNvY2tldCwgcmVxdWVzdCwgY29udGVudExlbmd0aCwgY2xpZW50LCBleHBlY3RzUGF5bG9hZCwgaGVhZGVyIH0pIHtcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3RcbiAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSBjb250ZW50TGVuZ3RoXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnRcbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDBcbiAgICB0aGlzLmV4cGVjdHNQYXlsb2FkID0gZXhwZWN0c1BheWxvYWRcbiAgICB0aGlzLmhlYWRlciA9IGhlYWRlclxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuXG4gICAgc29ja2V0W2tXcml0aW5nXSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAgICogQHJldHVybnNcbiAgICovXG4gIHdyaXRlIChjaHVuaykge1xuICAgIGNvbnN0IHsgc29ja2V0LCByZXF1ZXN0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGJ5dGVzV3JpdHRlbiwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9ID0gdGhpc1xuXG4gICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICB0aHJvdyBzb2NrZXRba0Vycm9yXVxuICAgIH1cblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBsZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChjaHVuaylcbiAgICBpZiAoIWxlbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBXZSBzaG91bGQgZGVmZXIgd3JpdGluZyBjaHVua3MuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT09IG51bGwgJiYgYnl0ZXNXcml0dGVuICsgbGVuID4gY29udGVudExlbmd0aCkge1xuICAgICAgaWYgKGNsaWVudFtrU3RyaWN0Q29udGVudExlbmd0aF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpXG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgIH1cblxuICAgIHNvY2tldC5jb3JrKClcblxuICAgIGlmIChieXRlc1dyaXR0ZW4gPT09IDApIHtcbiAgICAgIGlmICghZXhwZWN0c1BheWxvYWQgJiYgcmVxdWVzdC5yZXNldCAhPT0gZmFsc2UpIHtcbiAgICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChjb250ZW50TGVuZ3RoID09PSBudWxsKSB7XG4gICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9dHJhbnNmZXItZW5jb2Rpbmc6IGNodW5rZWRcXHJcXG5gLCAnbGF0aW4xJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9Y29udGVudC1sZW5ndGg6ICR7Y29udGVudExlbmd0aH1cXHJcXG5cXHJcXG5gLCAnbGF0aW4xJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgc29ja2V0LndyaXRlKGBcXHJcXG4ke2xlbi50b1N0cmluZygxNil9XFxyXFxuYCwgJ2xhdGluMScpXG4gICAgfVxuXG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gKz0gbGVuXG5cbiAgICBjb25zdCByZXQgPSBzb2NrZXQud3JpdGUoY2h1bmspXG5cbiAgICBzb2NrZXQudW5jb3JrKClcblxuICAgIHJlcXVlc3Qub25Cb2R5U2VudChjaHVuaylcblxuICAgIGlmICghcmV0KSB7XG4gICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQgJiYgc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgICBzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGVuZCAoKSB7XG4gICAgY29uc3QgeyBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgYnl0ZXNXcml0dGVuLCBleHBlY3RzUGF5bG9hZCwgaGVhZGVyLCByZXF1ZXN0IH0gPSB0aGlzXG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgIHNvY2tldFtrV3JpdGluZ10gPSBmYWxzZVxuXG4gICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICB0aHJvdyBzb2NrZXRba0Vycm9yXVxuICAgIH1cblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoYnl0ZXNXcml0dGVuID09PSAwKSB7XG4gICAgICBpZiAoZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjMuMlxuICAgICAgICAvLyBBIHVzZXIgYWdlbnQgU0hPVUxEIHNlbmQgYSBDb250ZW50LUxlbmd0aCBpbiBhIHJlcXVlc3QgbWVzc2FnZSB3aGVuXG4gICAgICAgIC8vIG5vIFRyYW5zZmVyLUVuY29kaW5nIGlzIHNlbnQgYW5kIHRoZSByZXF1ZXN0IG1ldGhvZCBkZWZpbmVzIGEgbWVhbmluZ1xuICAgICAgICAvLyBmb3IgYW4gZW5jbG9zZWQgcGF5bG9hZCBib2R5LlxuXG4gICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9Y29udGVudC1sZW5ndGg6IDBcXHJcXG5cXHJcXG5gLCAnbGF0aW4xJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9XFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250ZW50TGVuZ3RoID09PSBudWxsKSB7XG4gICAgICBzb2NrZXQud3JpdGUoJ1xcclxcbjBcXHJcXG5cXHJcXG4nLCAnbGF0aW4xJylcbiAgICB9XG5cbiAgICBpZiAoY29udGVudExlbmd0aCAhPT0gbnVsbCAmJiBieXRlc1dyaXR0ZW4gIT09IGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIGlmIChjbGllbnRba1N0cmljdENvbnRlbnRMZW5ndGhdKSB7XG4gICAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0ICYmIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9IRUFERVJTKSB7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogb25seSBmb3IgamVzdFxuICAgICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xpZW50W2tSZXN1bWVdKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Vycm9yfSBbZXJyXVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGRlc3Ryb3kgKGVycikge1xuICAgIGNvbnN0IHsgc29ja2V0LCBjbGllbnQsIGFib3J0IH0gPSB0aGlzXG5cbiAgICBzb2NrZXRba1dyaXRpbmddID0gZmFsc2VcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddIDw9IDEsICdwaXBlbGluZSBzaG91bGQgb25seSBjb250YWluIHRoaXMgcmVxdWVzdCcpXG4gICAgICBhYm9ydChlcnIpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29ubmVjdEgxXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/client-h1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/client-h2.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client-h2.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { pipeline } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst util = __webpack_require__(/*! ../core/util.js */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst {\n  RequestContentLengthMismatchError,\n  RequestAbortedError,\n  SocketError,\n  InformationalError\n} = __webpack_require__(/*! ../core/errors.js */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst {\n  kUrl,\n  kReset,\n  kClient,\n  kRunning,\n  kPending,\n  kQueue,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kSocket,\n  kStrictContentLength,\n  kOnError,\n  kMaxConcurrentStreams,\n  kHTTP2Session,\n  kResume,\n  kSize,\n  kHTTPContext,\n  kClosed,\n  kBodyTimeout\n} = __webpack_require__(/*! ../core/symbols.js */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { channels } = __webpack_require__(/*! ../core/diagnostics.js */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\n\nconst kOpenStreams = Symbol('open streams')\n\nlet extractBody\n\n/** @type {import('http2')} */\nlet http2\ntry {\n  http2 = __webpack_require__(/*! node:http2 */ \"node:http2\")\n} catch {\n  // @ts-ignore\n  http2 = { constants: {} }\n}\n\nconst {\n  constants: {\n    HTTP2_HEADER_AUTHORITY,\n    HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH,\n    HTTP2_HEADER_SCHEME,\n    HTTP2_HEADER_CONTENT_LENGTH,\n    HTTP2_HEADER_EXPECT,\n    HTTP2_HEADER_STATUS\n  }\n} = http2\n\nfunction parseH2Headers (headers) {\n  const result = []\n\n  for (const [name, value] of Object.entries(headers)) {\n    // h2 may concat the header value by array\n    // e.g. Set-Cookie\n    if (Array.isArray(value)) {\n      for (const subvalue of value) {\n        // we need to provide each header value of header name\n        // because the headers handler expect name-value pair\n        result.push(Buffer.from(name), Buffer.from(subvalue))\n      }\n    } else {\n      result.push(Buffer.from(name), Buffer.from(value))\n    }\n  }\n\n  return result\n}\n\nasync function connectH2 (client, socket) {\n  client[kSocket] = socket\n\n  const session = http2.connect(client[kUrl], {\n    createConnection: () => socket,\n    peerMaxConcurrentStreams: client[kMaxConcurrentStreams],\n    settings: {\n      // TODO(metcoder95): add support for PUSH\n      enablePush: false\n    }\n  })\n\n  session[kOpenStreams] = 0\n  session[kClient] = client\n  session[kSocket] = socket\n  session[kHTTP2Session] = null\n\n  util.addListener(session, 'error', onHttp2SessionError)\n  util.addListener(session, 'frameError', onHttp2FrameError)\n  util.addListener(session, 'end', onHttp2SessionEnd)\n  util.addListener(session, 'goaway', onHttp2SessionGoAway)\n  util.addListener(session, 'close', onHttp2SessionClose)\n\n  session.unref()\n\n  client[kHTTP2Session] = session\n  socket[kHTTP2Session] = session\n\n  util.addListener(socket, 'error', onHttp2SocketError)\n  util.addListener(socket, 'end', onHttp2SocketEnd)\n  util.addListener(socket, 'close', onHttp2SocketClose)\n\n  socket[kClosed] = false\n  socket.on('close', onSocketClose)\n\n  return {\n    version: 'h2',\n    defaultPipelining: Infinity,\n    write (request) {\n      return writeH2(client, request)\n    },\n    resume () {\n      resumeH2(client)\n    },\n    destroy (err, callback) {\n      if (socket[kClosed]) {\n        queueMicrotask(callback)\n      } else {\n        socket.destroy(err).on('close', callback)\n      }\n    },\n    get destroyed () {\n      return socket.destroyed\n    },\n    busy () {\n      return false\n    }\n  }\n}\n\nfunction resumeH2 (client) {\n  const socket = client[kSocket]\n\n  if (socket?.destroyed === false) {\n    if (client[kSize] === 0 || client[kMaxConcurrentStreams] === 0) {\n      socket.unref()\n      client[kHTTP2Session].unref()\n    } else {\n      socket.ref()\n      client[kHTTP2Session].ref()\n    }\n  }\n}\n\nfunction onHttp2SessionError (err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  this[kSocket][kError] = err\n  this[kClient][kOnError](err)\n}\n\nfunction onHttp2FrameError (type, code, id) {\n  if (id === 0) {\n    const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`)\n    this[kSocket][kError] = err\n    this[kClient][kOnError](err)\n  }\n}\n\nfunction onHttp2SessionEnd () {\n  const err = new SocketError('other side closed', util.getSocketInfo(this[kSocket]))\n  this.destroy(err)\n  util.destroy(this[kSocket], err)\n}\n\n/**\n * This is the root cause of #3011\n * We need to handle GOAWAY frames properly, and trigger the session close\n * along with the socket right away\n *\n * @this {import('http2').ClientHttp2Session}\n * @param {number} errorCode\n */\nfunction onHttp2SessionGoAway (errorCode) {\n  // TODO(mcollina): Verify if GOAWAY implements the spec correctly:\n  // https://datatracker.ietf.org/doc/html/rfc7540#section-6.8\n  // Specifically, we do not verify the \"valid\" stream id.\n\n  const err = this[kError] || new SocketError(`HTTP/2: \"GOAWAY\" frame received with code ${errorCode}`, util.getSocketInfo(this[kSocket]))\n  const client = this[kClient]\n\n  client[kSocket] = null\n  client[kHTTPContext] = null\n\n  // this is an HTTP2 session\n  this.close()\n  this[kHTTP2Session] = null\n\n  util.destroy(this[kSocket], err)\n\n  // Fail head of pipeline.\n  if (client[kRunningIdx] < client[kQueue].length) {\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n    util.errorRequest(client, request, err)\n    client[kPendingIdx] = client[kRunningIdx]\n  }\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n  client.emit('connectionError', client[kUrl], [client], err)\n\n  client[kResume]()\n}\n\nfunction onHttp2SessionClose () {\n  const { [kClient]: client } = this\n  const { [kSocket]: socket } = client\n\n  const err = this[kSocket][kError] || this[kError] || new SocketError('closed', util.getSocketInfo(socket))\n\n  client[kSocket] = null\n  client[kHTTPContext] = null\n\n  if (client.destroyed) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      util.errorRequest(client, request, err)\n    }\n  }\n}\n\nfunction onHttp2SocketClose () {\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  const client = this[kHTTP2Session][kClient]\n\n  client[kSocket] = null\n  client[kHTTPContext] = null\n\n  if (this[kHTTP2Session] !== null) {\n    this[kHTTP2Session].destroy(err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  client[kResume]()\n}\n\nfunction onHttp2SocketError (err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  this[kError] = err\n\n  this[kClient][kOnError](err)\n}\n\nfunction onHttp2SocketEnd () {\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onSocketClose () {\n  this[kClosed] = true\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength (method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'\n}\n\nfunction writeH2 (client, request) {\n  const requestTimeout = request.bodyTimeout ?? client[kBodyTimeout]\n  const session = client[kHTTP2Session]\n  const { method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request\n  let { body } = request\n\n  if (upgrade) {\n    util.errorRequest(client, request, new Error('Upgrade not supported for H2'))\n    return false\n  }\n\n  const headers = {}\n  for (let n = 0; n < reqHeaders.length; n += 2) {\n    const key = reqHeaders[n + 0]\n    const val = reqHeaders[n + 1]\n\n    if (Array.isArray(val)) {\n      for (let i = 0; i < val.length; i++) {\n        if (headers[key]) {\n          headers[key] += `, ${val[i]}`\n        } else {\n          headers[key] = val[i]\n        }\n      }\n    } else if (headers[key]) {\n      headers[key] += `, ${val}`\n    } else {\n      headers[key] = val\n    }\n  }\n\n  /** @type {import('node:http2').ClientHttp2Stream} */\n  let stream = null\n\n  const { hostname, port } = client[kUrl]\n\n  headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ''}`\n  headers[HTTP2_HEADER_METHOD] = method\n\n  const abort = (err) => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    err = err || new RequestAbortedError()\n\n    util.errorRequest(client, request, err)\n\n    if (stream != null) {\n      // Some chunks might still come after abort,\n      // let's ignore them\n      stream.removeAllListeners('data')\n\n      // On Abort, we close the stream to send RST_STREAM frame\n      stream.close()\n\n      // We move the running index to the next request\n      client[kOnError](err)\n      client[kResume]()\n    }\n\n    // We do not destroy the socket as we can continue using the session\n    // the stream gets destroyed and the session remains to create new streams\n    util.destroy(body, err)\n  }\n\n  try {\n    // We are already connected, streams are pending.\n    // We can call on connect, and wait for abort\n    request.onConnect(abort)\n  } catch (err) {\n    util.errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'CONNECT') {\n    session.ref()\n    // We are already connected, streams are pending, first request\n    // will create a new stream. We trigger a request to create the stream and wait until\n    // `ready` event is triggered\n    // We disabled endStream to allow the user to write to the stream\n    stream = session.request(headers, { endStream: false, signal })\n\n    if (!stream.pending) {\n      request.onUpgrade(null, null, stream)\n      ++session[kOpenStreams]\n      client[kQueue][client[kRunningIdx]++] = null\n    } else {\n      stream.once('ready', () => {\n        request.onUpgrade(null, null, stream)\n        ++session[kOpenStreams]\n        client[kQueue][client[kRunningIdx]++] = null\n      })\n    }\n\n    stream.once('close', () => {\n      session[kOpenStreams] -= 1\n      if (session[kOpenStreams] === 0) session.unref()\n    })\n    stream.setTimeout(requestTimeout)\n\n    return true\n  }\n\n  // https://tools.ietf.org/html/rfc7540#section-8.3\n  // :path and :scheme headers must be omitted when sending CONNECT\n\n  headers[HTTP2_HEADER_PATH] = path\n  headers[HTTP2_HEADER_SCHEME] = 'https'\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (util.isFormDataLike(body)) {\n    extractBody ??= (__webpack_require__(/*! ../web/fetch/body.js */ \"(rsc)/./node_modules/undici/lib/web/fetch/body.js\").extractBody)\n\n    const [bodyStream, contentType] = extractBody(body)\n    headers['content-type'] = contentType\n\n    body = bodyStream.stream\n    contentLength = bodyStream.length\n  }\n\n  if (contentLength == null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 || !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      util.errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  if (contentLength != null) {\n    assert(body, 'no body must not have content length')\n    headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`\n  }\n\n  session.ref()\n\n  if (channels.sendHeaders.hasSubscribers) {\n    let header = ''\n    for (const key in headers) {\n      header += `${key}: ${headers[key]}\\r\\n`\n    }\n    channels.sendHeaders.publish({ request, headers: header, socket: session[kSocket] })\n  }\n\n  // TODO(metcoder95): add support for sending trailers\n  const shouldEndStream = method === 'GET' || method === 'HEAD' || body === null\n  if (expectContinue) {\n    headers[HTTP2_HEADER_EXPECT] = '100-continue'\n    stream = session.request(headers, { endStream: shouldEndStream, signal })\n\n    stream.once('continue', writeBodyH2)\n  } else {\n    stream = session.request(headers, {\n      endStream: shouldEndStream,\n      signal\n    })\n\n    writeBodyH2()\n  }\n\n  // Increment counter as we have new streams open\n  ++session[kOpenStreams]\n  stream.setTimeout(requestTimeout)\n\n  stream.once('response', headers => {\n    const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers\n    request.onResponseStarted()\n\n    // Due to the stream nature, it is possible we face a race condition\n    // where the stream has been assigned, but the request has been aborted\n    // the request remains in-flight and headers hasn't been received yet\n    // for those scenarios, best effort is to destroy the stream immediately\n    // as there's no value to keep it open.\n    if (request.aborted) {\n      stream.removeAllListeners('data')\n      return\n    }\n\n    if (request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), '') === false) {\n      stream.pause()\n    }\n  })\n\n  stream.on('data', (chunk) => {\n    if (request.onData(chunk) === false) {\n      stream.pause()\n    }\n  })\n\n  stream.once('end', (err) => {\n    stream.removeAllListeners('data')\n    // When state is null, it means we haven't consumed body and the stream still do not have\n    // a state.\n    // Present specially when using pipeline or stream\n    if (stream.state?.state == null || stream.state.state < 6) {\n      // Do not complete the request if it was aborted\n      // Not prone to happen for as safety net to avoid race conditions with 'trailers'\n      if (!request.aborted && !request.completed) {\n        request.onComplete({})\n      }\n\n      client[kQueue][client[kRunningIdx]++] = null\n      client[kResume]()\n    } else {\n      // Stream is closed or half-closed-remote (6), decrement counter and cleanup\n      // It does not have sense to continue working with the stream as we do not\n      // have yet RST_STREAM support on client-side\n      --session[kOpenStreams]\n      if (session[kOpenStreams] === 0) {\n        session.unref()\n      }\n\n      abort(err ?? new InformationalError('HTTP/2: stream half-closed (remote)'))\n      client[kQueue][client[kRunningIdx]++] = null\n      client[kPendingIdx] = client[kRunningIdx]\n      client[kResume]()\n    }\n  })\n\n  stream.once('close', () => {\n    stream.removeAllListeners('data')\n    session[kOpenStreams] -= 1\n    if (session[kOpenStreams] === 0) {\n      session.unref()\n    }\n  })\n\n  stream.once('error', function (err) {\n    stream.removeAllListeners('data')\n    abort(err)\n  })\n\n  stream.once('frameError', (type, code) => {\n    stream.removeAllListeners('data')\n    abort(new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`))\n  })\n\n  stream.on('aborted', () => {\n    stream.removeAllListeners('data')\n  })\n\n  stream.on('timeout', () => {\n    const err = new InformationalError(`HTTP/2: \"stream timeout after ${requestTimeout}\"`)\n    stream.removeAllListeners('data')\n    session[kOpenStreams] -= 1\n\n    if (session[kOpenStreams] === 0) {\n      session.unref()\n    }\n\n    abort(err)\n  })\n\n  stream.once('trailers', trailers => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    request.onComplete(trailers)\n  })\n\n  return true\n\n  function writeBodyH2 () {\n    /* istanbul ignore else: assertion */\n    if (!body || contentLength === 0) {\n      writeBuffer(\n        abort,\n        stream,\n        null,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else if (util.isBuffer(body)) {\n      writeBuffer(\n        abort,\n        stream,\n        body,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else if (util.isBlobLike(body)) {\n      if (typeof body.stream === 'function') {\n        writeIterable(\n          abort,\n          stream,\n          body.stream(),\n          client,\n          request,\n          client[kSocket],\n          contentLength,\n          expectsPayload\n        )\n      } else {\n        writeBlob(\n          abort,\n          stream,\n          body,\n          client,\n          request,\n          client[kSocket],\n          contentLength,\n          expectsPayload\n        )\n      }\n    } else if (util.isStream(body)) {\n      writeStream(\n        abort,\n        client[kSocket],\n        expectsPayload,\n        stream,\n        body,\n        client,\n        request,\n        contentLength\n      )\n    } else if (util.isIterable(body)) {\n      writeIterable(\n        abort,\n        stream,\n        body,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else {\n      assert(false)\n    }\n  }\n}\n\nfunction writeBuffer (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  try {\n    if (body != null && util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n      h2stream.cork()\n      h2stream.write(body)\n      h2stream.uncork()\n      h2stream.end()\n\n      request.onBodySent(body)\n    }\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    request.onRequestSent()\n    client[kResume]()\n  } catch (error) {\n    abort(error)\n  }\n}\n\nfunction writeStream (abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  // For HTTP/2, is enough to pipe the stream\n  const pipe = pipeline(\n    body,\n    h2stream,\n    (err) => {\n      if (err) {\n        util.destroy(pipe, err)\n        abort(err)\n      } else {\n        util.removeAllListeners(pipe)\n        request.onRequestSent()\n\n        if (!expectsPayload) {\n          socket[kReset] = true\n        }\n\n        client[kResume]()\n      }\n    }\n  )\n\n  util.addListener(pipe, 'data', onPipeData)\n\n  function onPipeData (chunk) {\n    request.onBodySent(chunk)\n  }\n}\n\nasync function writeBlob (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    h2stream.cork()\n    h2stream.write(buffer)\n    h2stream.uncork()\n    h2stream.end()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\nasync function writeIterable (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  h2stream\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      const res = h2stream.write(chunk)\n      request.onBodySent(chunk)\n      if (!res) {\n        await waitForDrain()\n      }\n    }\n\n    h2stream.end()\n\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  } finally {\n    h2stream\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nmodule.exports = connectH2\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC1oMi5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJFQUFvQjtBQUNoQyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLG1GQUF3Qjs7QUFFckQ7O0FBRUE7O0FBRUEsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyw4QkFBWTtBQUM5QixFQUFFO0FBQ0Y7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Es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Q0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvY2xpZW50LWgyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IHBpcGVsaW5lIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsLmpzJylcbmNvbnN0IHtcbiAgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBSZXF1ZXN0QWJvcnRlZEVycm9yLFxuICBTb2NrZXRFcnJvcixcbiAgSW5mb3JtYXRpb25hbEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMuanMnKVxuY29uc3Qge1xuICBrVXJsLFxuICBrUmVzZXQsXG4gIGtDbGllbnQsXG4gIGtSdW5uaW5nLFxuICBrUGVuZGluZyxcbiAga1F1ZXVlLFxuICBrUGVuZGluZ0lkeCxcbiAga1J1bm5pbmdJZHgsXG4gIGtFcnJvcixcbiAga1NvY2tldCxcbiAga1N0cmljdENvbnRlbnRMZW5ndGgsXG4gIGtPbkVycm9yLFxuICBrTWF4Q29uY3VycmVudFN0cmVhbXMsXG4gIGtIVFRQMlNlc3Npb24sXG4gIGtSZXN1bWUsXG4gIGtTaXplLFxuICBrSFRUUENvbnRleHQsXG4gIGtDbG9zZWQsXG4gIGtCb2R5VGltZW91dFxufSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scy5qcycpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi9jb3JlL2RpYWdub3N0aWNzLmpzJylcblxuY29uc3Qga09wZW5TdHJlYW1zID0gU3ltYm9sKCdvcGVuIHN0cmVhbXMnKVxuXG5sZXQgZXh0cmFjdEJvZHlcblxuLyoqIEB0eXBlIHtpbXBvcnQoJ2h0dHAyJyl9ICovXG5sZXQgaHR0cDJcbnRyeSB7XG4gIGh0dHAyID0gcmVxdWlyZSgnbm9kZTpodHRwMicpXG59IGNhdGNoIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBodHRwMiA9IHsgY29uc3RhbnRzOiB7fSB9XG59XG5cbmNvbnN0IHtcbiAgY29uc3RhbnRzOiB7XG4gICAgSFRUUDJfSEVBREVSX0FVVEhPUklUWSxcbiAgICBIVFRQMl9IRUFERVJfTUVUSE9ELFxuICAgIEhUVFAyX0hFQURFUl9QQVRILFxuICAgIEhUVFAyX0hFQURFUl9TQ0hFTUUsXG4gICAgSFRUUDJfSEVBREVSX0NPTlRFTlRfTEVOR1RILFxuICAgIEhUVFAyX0hFQURFUl9FWFBFQ1QsXG4gICAgSFRUUDJfSEVBREVSX1NUQVRVU1xuICB9XG59ID0gaHR0cDJcblxuZnVuY3Rpb24gcGFyc2VIMkhlYWRlcnMgKGhlYWRlcnMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW11cblxuICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAvLyBoMiBtYXkgY29uY2F0IHRoZSBoZWFkZXIgdmFsdWUgYnkgYXJyYXlcbiAgICAvLyBlLmcuIFNldC1Db29raWVcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAoY29uc3Qgc3VidmFsdWUgb2YgdmFsdWUpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBwcm92aWRlIGVhY2ggaGVhZGVyIHZhbHVlIG9mIGhlYWRlciBuYW1lXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGhlYWRlcnMgaGFuZGxlciBleHBlY3QgbmFtZS12YWx1ZSBwYWlyXG4gICAgICAgIHJlc3VsdC5wdXNoKEJ1ZmZlci5mcm9tKG5hbWUpLCBCdWZmZXIuZnJvbShzdWJ2YWx1ZSkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKEJ1ZmZlci5mcm9tKG5hbWUpLCBCdWZmZXIuZnJvbSh2YWx1ZSkpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5hc3luYyBmdW5jdGlvbiBjb25uZWN0SDIgKGNsaWVudCwgc29ja2V0KSB7XG4gIGNsaWVudFtrU29ja2V0XSA9IHNvY2tldFxuXG4gIGNvbnN0IHNlc3Npb24gPSBodHRwMi5jb25uZWN0KGNsaWVudFtrVXJsXSwge1xuICAgIGNyZWF0ZUNvbm5lY3Rpb246ICgpID0+IHNvY2tldCxcbiAgICBwZWVyTWF4Q29uY3VycmVudFN0cmVhbXM6IGNsaWVudFtrTWF4Q29uY3VycmVudFN0cmVhbXNdLFxuICAgIHNldHRpbmdzOiB7XG4gICAgICAvLyBUT0RPKG1ldGNvZGVyOTUpOiBhZGQgc3VwcG9ydCBmb3IgUFVTSFxuICAgICAgZW5hYmxlUHVzaDogZmFsc2VcbiAgICB9XG4gIH0pXG5cbiAgc2Vzc2lvbltrT3BlblN0cmVhbXNdID0gMFxuICBzZXNzaW9uW2tDbGllbnRdID0gY2xpZW50XG4gIHNlc3Npb25ba1NvY2tldF0gPSBzb2NrZXRcbiAgc2Vzc2lvbltrSFRUUDJTZXNzaW9uXSA9IG51bGxcblxuICB1dGlsLmFkZExpc3RlbmVyKHNlc3Npb24sICdlcnJvcicsIG9uSHR0cDJTZXNzaW9uRXJyb3IpXG4gIHV0aWwuYWRkTGlzdGVuZXIoc2Vzc2lvbiwgJ2ZyYW1lRXJyb3InLCBvbkh0dHAyRnJhbWVFcnJvcilcbiAgdXRpbC5hZGRMaXN0ZW5lcihzZXNzaW9uLCAnZW5kJywgb25IdHRwMlNlc3Npb25FbmQpXG4gIHV0aWwuYWRkTGlzdGVuZXIoc2Vzc2lvbiwgJ2dvYXdheScsIG9uSHR0cDJTZXNzaW9uR29Bd2F5KVxuICB1dGlsLmFkZExpc3RlbmVyKHNlc3Npb24sICdjbG9zZScsIG9uSHR0cDJTZXNzaW9uQ2xvc2UpXG5cbiAgc2Vzc2lvbi51bnJlZigpXG5cbiAgY2xpZW50W2tIVFRQMlNlc3Npb25dID0gc2Vzc2lvblxuICBzb2NrZXRba0hUVFAyU2Vzc2lvbl0gPSBzZXNzaW9uXG5cbiAgdXRpbC5hZGRMaXN0ZW5lcihzb2NrZXQsICdlcnJvcicsIG9uSHR0cDJTb2NrZXRFcnJvcilcbiAgdXRpbC5hZGRMaXN0ZW5lcihzb2NrZXQsICdlbmQnLCBvbkh0dHAyU29ja2V0RW5kKVxuICB1dGlsLmFkZExpc3RlbmVyKHNvY2tldCwgJ2Nsb3NlJywgb25IdHRwMlNvY2tldENsb3NlKVxuXG4gIHNvY2tldFtrQ2xvc2VkXSA9IGZhbHNlXG4gIHNvY2tldC5vbignY2xvc2UnLCBvblNvY2tldENsb3NlKVxuXG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogJ2gyJyxcbiAgICBkZWZhdWx0UGlwZWxpbmluZzogSW5maW5pdHksXG4gICAgd3JpdGUgKHJlcXVlc3QpIHtcbiAgICAgIHJldHVybiB3cml0ZUgyKGNsaWVudCwgcmVxdWVzdClcbiAgICB9LFxuICAgIHJlc3VtZSAoKSB7XG4gICAgICByZXN1bWVIMihjbGllbnQpXG4gICAgfSxcbiAgICBkZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoc29ja2V0W2tDbG9zZWRdKSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ja2V0LmRlc3Ryb3koZXJyKS5vbignY2xvc2UnLCBjYWxsYmFjaylcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCBkZXN0cm95ZWQgKCkge1xuICAgICAgcmV0dXJuIHNvY2tldC5kZXN0cm95ZWRcbiAgICB9LFxuICAgIGJ1c3kgKCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZUgyIChjbGllbnQpIHtcbiAgY29uc3Qgc29ja2V0ID0gY2xpZW50W2tTb2NrZXRdXG5cbiAgaWYgKHNvY2tldD8uZGVzdHJveWVkID09PSBmYWxzZSkge1xuICAgIGlmIChjbGllbnRba1NpemVdID09PSAwIHx8IGNsaWVudFtrTWF4Q29uY3VycmVudFN0cmVhbXNdID09PSAwKSB7XG4gICAgICBzb2NrZXQudW5yZWYoKVxuICAgICAgY2xpZW50W2tIVFRQMlNlc3Npb25dLnVucmVmKClcbiAgICB9IGVsc2Uge1xuICAgICAgc29ja2V0LnJlZigpXG4gICAgICBjbGllbnRba0hUVFAyU2Vzc2lvbl0ucmVmKClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25IdHRwMlNlc3Npb25FcnJvciAoZXJyKSB7XG4gIGFzc2VydChlcnIuY29kZSAhPT0gJ0VSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSUQnKVxuXG4gIHRoaXNba1NvY2tldF1ba0Vycm9yXSA9IGVyclxuICB0aGlzW2tDbGllbnRdW2tPbkVycm9yXShlcnIpXG59XG5cbmZ1bmN0aW9uIG9uSHR0cDJGcmFtZUVycm9yICh0eXBlLCBjb2RlLCBpZCkge1xuICBpZiAoaWQgPT09IDApIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgSW5mb3JtYXRpb25hbEVycm9yKGBIVFRQLzI6IFwiZnJhbWVFcnJvclwiIHJlY2VpdmVkIC0gdHlwZSAke3R5cGV9LCBjb2RlICR7Y29kZX1gKVxuICAgIHRoaXNba1NvY2tldF1ba0Vycm9yXSA9IGVyclxuICAgIHRoaXNba0NsaWVudF1ba09uRXJyb3JdKGVycilcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkh0dHAyU2Vzc2lvbkVuZCAoKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBTb2NrZXRFcnJvcignb3RoZXIgc2lkZSBjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8odGhpc1trU29ja2V0XSkpXG4gIHRoaXMuZGVzdHJveShlcnIpXG4gIHV0aWwuZGVzdHJveSh0aGlzW2tTb2NrZXRdLCBlcnIpXG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgcm9vdCBjYXVzZSBvZiAjMzAxMVxuICogV2UgbmVlZCB0byBoYW5kbGUgR09BV0FZIGZyYW1lcyBwcm9wZXJseSwgYW5kIHRyaWdnZXIgdGhlIHNlc3Npb24gY2xvc2VcbiAqIGFsb25nIHdpdGggdGhlIHNvY2tldCByaWdodCBhd2F5XG4gKlxuICogQHRoaXMge2ltcG9ydCgnaHR0cDInKS5DbGllbnRIdHRwMlNlc3Npb259XG4gKiBAcGFyYW0ge251bWJlcn0gZXJyb3JDb2RlXG4gKi9cbmZ1bmN0aW9uIG9uSHR0cDJTZXNzaW9uR29Bd2F5IChlcnJvckNvZGUpIHtcbiAgLy8gVE9ETyhtY29sbGluYSk6IFZlcmlmeSBpZiBHT0FXQVkgaW1wbGVtZW50cyB0aGUgc3BlYyBjb3JyZWN0bHk6XG4gIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzU0MCNzZWN0aW9uLTYuOFxuICAvLyBTcGVjaWZpY2FsbHksIHdlIGRvIG5vdCB2ZXJpZnkgdGhlIFwidmFsaWRcIiBzdHJlYW0gaWQuXG5cbiAgY29uc3QgZXJyID0gdGhpc1trRXJyb3JdIHx8IG5ldyBTb2NrZXRFcnJvcihgSFRUUC8yOiBcIkdPQVdBWVwiIGZyYW1lIHJlY2VpdmVkIHdpdGggY29kZSAke2Vycm9yQ29kZX1gLCB1dGlsLmdldFNvY2tldEluZm8odGhpc1trU29ja2V0XSkpXG4gIGNvbnN0IGNsaWVudCA9IHRoaXNba0NsaWVudF1cblxuICBjbGllbnRba1NvY2tldF0gPSBudWxsXG4gIGNsaWVudFtrSFRUUENvbnRleHRdID0gbnVsbFxuXG4gIC8vIHRoaXMgaXMgYW4gSFRUUDIgc2Vzc2lvblxuICB0aGlzLmNsb3NlKClcbiAgdGhpc1trSFRUUDJTZXNzaW9uXSA9IG51bGxcblxuICB1dGlsLmRlc3Ryb3kodGhpc1trU29ja2V0XSwgZXJyKVxuXG4gIC8vIEZhaWwgaGVhZCBvZiBwaXBlbGluZS5cbiAgaWYgKGNsaWVudFtrUnVubmluZ0lkeF0gPCBjbGllbnRba1F1ZXVlXS5sZW5ndGgpIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgIGNsaWVudFtrUGVuZGluZ0lkeF0gPSBjbGllbnRba1J1bm5pbmdJZHhdXG4gIH1cblxuICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcblxuICBjbGllbnQuZW1pdCgnZGlzY29ubmVjdCcsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIGVycilcbiAgY2xpZW50LmVtaXQoJ2Nvbm5lY3Rpb25FcnJvcicsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIGVycilcblxuICBjbGllbnRba1Jlc3VtZV0oKVxufVxuXG5mdW5jdGlvbiBvbkh0dHAyU2Vzc2lvbkNsb3NlICgpIHtcbiAgY29uc3QgeyBba0NsaWVudF06IGNsaWVudCB9ID0gdGhpc1xuICBjb25zdCB7IFtrU29ja2V0XTogc29ja2V0IH0gPSBjbGllbnRcblxuICBjb25zdCBlcnIgPSB0aGlzW2tTb2NrZXRdW2tFcnJvcl0gfHwgdGhpc1trRXJyb3JdIHx8IG5ldyBTb2NrZXRFcnJvcignY2xvc2VkJywgdXRpbC5nZXRTb2NrZXRJbmZvKHNvY2tldCkpXG5cbiAgY2xpZW50W2tTb2NrZXRdID0gbnVsbFxuICBjbGllbnRba0hUVFBDb250ZXh0XSA9IG51bGxcblxuICBpZiAoY2xpZW50LmRlc3Ryb3llZCkge1xuICAgIGFzc2VydChjbGllbnRba1BlbmRpbmddID09PSAwKVxuXG4gICAgLy8gRmFpbCBlbnRpcmUgcXVldWUuXG4gICAgY29uc3QgcmVxdWVzdHMgPSBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tSdW5uaW5nSWR4XSlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHNbaV1cbiAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbkh0dHAyU29ja2V0Q2xvc2UgKCkge1xuICBjb25zdCBlcnIgPSB0aGlzW2tFcnJvcl0gfHwgbmV3IFNvY2tldEVycm9yKCdjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8odGhpcykpXG5cbiAgY29uc3QgY2xpZW50ID0gdGhpc1trSFRUUDJTZXNzaW9uXVtrQ2xpZW50XVxuXG4gIGNsaWVudFtrU29ja2V0XSA9IG51bGxcbiAgY2xpZW50W2tIVFRQQ29udGV4dF0gPSBudWxsXG5cbiAgaWYgKHRoaXNba0hUVFAyU2Vzc2lvbl0gIT09IG51bGwpIHtcbiAgICB0aGlzW2tIVFRQMlNlc3Npb25dLmRlc3Ryb3koZXJyKVxuICB9XG5cbiAgY2xpZW50W2tQZW5kaW5nSWR4XSA9IGNsaWVudFtrUnVubmluZ0lkeF1cblxuICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcblxuICBjbGllbnQuZW1pdCgnZGlzY29ubmVjdCcsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIGVycilcblxuICBjbGllbnRba1Jlc3VtZV0oKVxufVxuXG5mdW5jdGlvbiBvbkh0dHAyU29ja2V0RXJyb3IgKGVycikge1xuICBhc3NlcnQoZXJyLmNvZGUgIT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJylcblxuICB0aGlzW2tFcnJvcl0gPSBlcnJcblxuICB0aGlzW2tDbGllbnRdW2tPbkVycm9yXShlcnIpXG59XG5cbmZ1bmN0aW9uIG9uSHR0cDJTb2NrZXRFbmQgKCkge1xuICB1dGlsLmRlc3Ryb3kodGhpcywgbmV3IFNvY2tldEVycm9yKCdvdGhlciBzaWRlIGNsb3NlZCcsIHV0aWwuZ2V0U29ja2V0SW5mbyh0aGlzKSkpXG59XG5cbmZ1bmN0aW9uIG9uU29ja2V0Q2xvc2UgKCkge1xuICB0aGlzW2tDbG9zZWRdID0gdHJ1ZVxufVxuXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzIzMCNzZWN0aW9uLTMuMy4yXG5mdW5jdGlvbiBzaG91bGRTZW5kQ29udGVudExlbmd0aCAobWV0aG9kKSB7XG4gIHJldHVybiBtZXRob2QgIT09ICdHRVQnICYmIG1ldGhvZCAhPT0gJ0hFQUQnICYmIG1ldGhvZCAhPT0gJ09QVElPTlMnICYmIG1ldGhvZCAhPT0gJ1RSQUNFJyAmJiBtZXRob2QgIT09ICdDT05ORUNUJ1xufVxuXG5mdW5jdGlvbiB3cml0ZUgyIChjbGllbnQsIHJlcXVlc3QpIHtcbiAgY29uc3QgcmVxdWVzdFRpbWVvdXQgPSByZXF1ZXN0LmJvZHlUaW1lb3V0ID8/IGNsaWVudFtrQm9keVRpbWVvdXRdXG4gIGNvbnN0IHNlc3Npb24gPSBjbGllbnRba0hUVFAyU2Vzc2lvbl1cbiAgY29uc3QgeyBtZXRob2QsIHBhdGgsIGhvc3QsIHVwZ3JhZGUsIGV4cGVjdENvbnRpbnVlLCBzaWduYWwsIGhlYWRlcnM6IHJlcUhlYWRlcnMgfSA9IHJlcXVlc3RcbiAgbGV0IHsgYm9keSB9ID0gcmVxdWVzdFxuXG4gIGlmICh1cGdyYWRlKSB7XG4gICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBuZXcgRXJyb3IoJ1VwZ3JhZGUgbm90IHN1cHBvcnRlZCBmb3IgSDInKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGhlYWRlcnMgPSB7fVxuICBmb3IgKGxldCBuID0gMDsgbiA8IHJlcUhlYWRlcnMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICBjb25zdCBrZXkgPSByZXFIZWFkZXJzW24gKyAwXVxuICAgIGNvbnN0IHZhbCA9IHJlcUhlYWRlcnNbbiArIDFdXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaGVhZGVyc1trZXldKSB7XG4gICAgICAgICAgaGVhZGVyc1trZXldICs9IGAsICR7dmFsW2ldfWBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWxbaV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGVhZGVyc1trZXldKSB7XG4gICAgICBoZWFkZXJzW2tleV0gKz0gYCwgJHt2YWx9YFxuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXJzW2tleV0gPSB2YWxcbiAgICB9XG4gIH1cblxuICAvKiogQHR5cGUge2ltcG9ydCgnbm9kZTpodHRwMicpLkNsaWVudEh0dHAyU3RyZWFtfSAqL1xuICBsZXQgc3RyZWFtID0gbnVsbFxuXG4gIGNvbnN0IHsgaG9zdG5hbWUsIHBvcnQgfSA9IGNsaWVudFtrVXJsXVxuXG4gIGhlYWRlcnNbSFRUUDJfSEVBREVSX0FVVEhPUklUWV0gPSBob3N0IHx8IGAke2hvc3RuYW1lfSR7cG9ydCA/IGA6JHtwb3J0fWAgOiAnJ31gXG4gIGhlYWRlcnNbSFRUUDJfSEVBREVSX01FVEhPRF0gPSBtZXRob2RcblxuICBjb25zdCBhYm9ydCA9IChlcnIpID0+IHtcbiAgICBpZiAocmVxdWVzdC5hYm9ydGVkIHx8IHJlcXVlc3QuY29tcGxldGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBlcnIgPSBlcnIgfHwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuXG4gICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG5cbiAgICBpZiAoc3RyZWFtICE9IG51bGwpIHtcbiAgICAgIC8vIFNvbWUgY2h1bmtzIG1pZ2h0IHN0aWxsIGNvbWUgYWZ0ZXIgYWJvcnQsXG4gICAgICAvLyBsZXQncyBpZ25vcmUgdGhlbVxuICAgICAgc3RyZWFtLnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpXG5cbiAgICAgIC8vIE9uIEFib3J0LCB3ZSBjbG9zZSB0aGUgc3RyZWFtIHRvIHNlbmQgUlNUX1NUUkVBTSBmcmFtZVxuICAgICAgc3RyZWFtLmNsb3NlKClcblxuICAgICAgLy8gV2UgbW92ZSB0aGUgcnVubmluZyBpbmRleCB0byB0aGUgbmV4dCByZXF1ZXN0XG4gICAgICBjbGllbnRba09uRXJyb3JdKGVycilcbiAgICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gICAgfVxuXG4gICAgLy8gV2UgZG8gbm90IGRlc3Ryb3kgdGhlIHNvY2tldCBhcyB3ZSBjYW4gY29udGludWUgdXNpbmcgdGhlIHNlc3Npb25cbiAgICAvLyB0aGUgc3RyZWFtIGdldHMgZGVzdHJveWVkIGFuZCB0aGUgc2Vzc2lvbiByZW1haW5zIHRvIGNyZWF0ZSBuZXcgc3RyZWFtc1xuICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gIH1cblxuICB0cnkge1xuICAgIC8vIFdlIGFyZSBhbHJlYWR5IGNvbm5lY3RlZCwgc3RyZWFtcyBhcmUgcGVuZGluZy5cbiAgICAvLyBXZSBjYW4gY2FsbCBvbiBjb25uZWN0LCBhbmQgd2FpdCBmb3IgYWJvcnRcbiAgICByZXF1ZXN0Lm9uQ29ubmVjdChhYm9ydClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gIH1cblxuICBpZiAocmVxdWVzdC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAobWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICBzZXNzaW9uLnJlZigpXG4gICAgLy8gV2UgYXJlIGFscmVhZHkgY29ubmVjdGVkLCBzdHJlYW1zIGFyZSBwZW5kaW5nLCBmaXJzdCByZXF1ZXN0XG4gICAgLy8gd2lsbCBjcmVhdGUgYSBuZXcgc3RyZWFtLiBXZSB0cmlnZ2VyIGEgcmVxdWVzdCB0byBjcmVhdGUgdGhlIHN0cmVhbSBhbmQgd2FpdCB1bnRpbFxuICAgIC8vIGByZWFkeWAgZXZlbnQgaXMgdHJpZ2dlcmVkXG4gICAgLy8gV2UgZGlzYWJsZWQgZW5kU3RyZWFtIHRvIGFsbG93IHRoZSB1c2VyIHRvIHdyaXRlIHRvIHRoZSBzdHJlYW1cbiAgICBzdHJlYW0gPSBzZXNzaW9uLnJlcXVlc3QoaGVhZGVycywgeyBlbmRTdHJlYW06IGZhbHNlLCBzaWduYWwgfSlcblxuICAgIGlmICghc3RyZWFtLnBlbmRpbmcpIHtcbiAgICAgIHJlcXVlc3Qub25VcGdyYWRlKG51bGwsIG51bGwsIHN0cmVhbSlcbiAgICAgICsrc2Vzc2lvbltrT3BlblN0cmVhbXNdXG4gICAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ub25jZSgncmVhZHknLCAoKSA9PiB7XG4gICAgICAgIHJlcXVlc3Qub25VcGdyYWRlKG51bGwsIG51bGwsIHN0cmVhbSlcbiAgICAgICAgKytzZXNzaW9uW2tPcGVuU3RyZWFtc11cbiAgICAgICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgc2Vzc2lvbltrT3BlblN0cmVhbXNdIC09IDFcbiAgICAgIGlmIChzZXNzaW9uW2tPcGVuU3RyZWFtc10gPT09IDApIHNlc3Npb24udW5yZWYoKVxuICAgIH0pXG4gICAgc3RyZWFtLnNldFRpbWVvdXQocmVxdWVzdFRpbWVvdXQpXG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1NDAjc2VjdGlvbi04LjNcbiAgLy8gOnBhdGggYW5kIDpzY2hlbWUgaGVhZGVycyBtdXN0IGJlIG9taXR0ZWQgd2hlbiBzZW5kaW5nIENPTk5FQ1RcblxuICBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXSA9IHBhdGhcbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfU0NIRU1FXSA9ICdodHRwcydcblxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy4xXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjJcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuNVxuXG4gIC8vIFNlbmRpbmcgYSBwYXlsb2FkIGJvZHkgb24gYSByZXF1ZXN0IHRoYXQgZG9lcyBub3RcbiAgLy8gZXhwZWN0IGl0IGNhbiBjYXVzZSB1bmRlZmluZWQgYmVoYXZpb3Igb24gc29tZVxuICAvLyBzZXJ2ZXJzIGFuZCBjb3JydXB0IGNvbm5lY3Rpb24gc3RhdGUuIERvIG5vdFxuICAvLyByZS11c2UgdGhlIGNvbm5lY3Rpb24gZm9yIGZ1cnRoZXIgcmVxdWVzdHMuXG5cbiAgY29uc3QgZXhwZWN0c1BheWxvYWQgPSAoXG4gICAgbWV0aG9kID09PSAnUFVUJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BPU1QnIHx8XG4gICAgbWV0aG9kID09PSAnUEFUQ0gnXG4gIClcblxuICBpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5yZWFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVHJ5IHRvIHJlYWQgRU9GIGluIG9yZGVyIHRvIGdldCBsZW5ndGguXG4gICAgYm9keS5yZWFkKDApXG4gIH1cblxuICBsZXQgY29udGVudExlbmd0aCA9IHV0aWwuYm9keUxlbmd0aChib2R5KVxuXG4gIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKGJvZHkpKSB7XG4gICAgZXh0cmFjdEJvZHkgPz89IHJlcXVpcmUoJy4uL3dlYi9mZXRjaC9ib2R5LmpzJykuZXh0cmFjdEJvZHlcblxuICAgIGNvbnN0IFtib2R5U3RyZWFtLCBjb250ZW50VHlwZV0gPSBleHRyYWN0Qm9keShib2R5KVxuICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gY29udGVudFR5cGVcblxuICAgIGJvZHkgPSBib2R5U3RyZWFtLnN0cmVhbVxuICAgIGNvbnRlbnRMZW5ndGggPSBib2R5U3RyZWFtLmxlbmd0aFxuICB9XG5cbiAgaWYgKGNvbnRlbnRMZW5ndGggPT0gbnVsbCkge1xuICAgIGNvbnRlbnRMZW5ndGggPSByZXF1ZXN0LmNvbnRlbnRMZW5ndGhcbiAgfVxuXG4gIGlmIChjb250ZW50TGVuZ3RoID09PSAwIHx8ICFleHBlY3RzUGF5bG9hZCkge1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4zLjJcbiAgICAvLyBBIHVzZXIgYWdlbnQgU0hPVUxEIE5PVCBzZW5kIGEgQ29udGVudC1MZW5ndGggaGVhZGVyIGZpZWxkIHdoZW5cbiAgICAvLyB0aGUgcmVxdWVzdCBtZXNzYWdlIGRvZXMgbm90IGNvbnRhaW4gYSBwYXlsb2FkIGJvZHkgYW5kIHRoZSBtZXRob2RcbiAgICAvLyBzZW1hbnRpY3MgZG8gbm90IGFudGljaXBhdGUgc3VjaCBhIGJvZHkuXG5cbiAgICBjb250ZW50TGVuZ3RoID0gbnVsbFxuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzIwNDZcbiAgLy8gQSB1c2VyIGFnZW50IG1heSBzZW5kIGEgQ29udGVudC1MZW5ndGggaGVhZGVyIHdpdGggMCB2YWx1ZSwgdGhpcyBzaG91bGQgYmUgYWxsb3dlZC5cbiAgaWYgKHNob3VsZFNlbmRDb250ZW50TGVuZ3RoKG1ldGhvZCkgJiYgY29udGVudExlbmd0aCA+IDAgJiYgcmVxdWVzdC5jb250ZW50TGVuZ3RoICE9IG51bGwgJiYgcmVxdWVzdC5jb250ZW50TGVuZ3RoICE9PSBjb250ZW50TGVuZ3RoKSB7XG4gICAgaWYgKGNsaWVudFtrU3RyaWN0Q29udGVudExlbmd0aF0pIHtcbiAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbWl0V2FybmluZyhuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gIH1cblxuICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsKSB7XG4gICAgYXNzZXJ0KGJvZHksICdubyBib2R5IG11c3Qgbm90IGhhdmUgY29udGVudCBsZW5ndGgnKVxuICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX0NPTlRFTlRfTEVOR1RIXSA9IGAke2NvbnRlbnRMZW5ndGh9YFxuICB9XG5cbiAgc2Vzc2lvbi5yZWYoKVxuXG4gIGlmIChjaGFubmVscy5zZW5kSGVhZGVycy5oYXNTdWJzY3JpYmVycykge1xuICAgIGxldCBoZWFkZXIgPSAnJ1xuICAgIGZvciAoY29uc3Qga2V5IGluIGhlYWRlcnMpIHtcbiAgICAgIGhlYWRlciArPSBgJHtrZXl9OiAke2hlYWRlcnNba2V5XX1cXHJcXG5gXG4gICAgfVxuICAgIGNoYW5uZWxzLnNlbmRIZWFkZXJzLnB1Ymxpc2goeyByZXF1ZXN0LCBoZWFkZXJzOiBoZWFkZXIsIHNvY2tldDogc2Vzc2lvbltrU29ja2V0XSB9KVxuICB9XG5cbiAgLy8gVE9ETyhtZXRjb2Rlcjk1KTogYWRkIHN1cHBvcnQgZm9yIHNlbmRpbmcgdHJhaWxlcnNcbiAgY29uc3Qgc2hvdWxkRW5kU3RyZWFtID0gbWV0aG9kID09PSAnR0VUJyB8fCBtZXRob2QgPT09ICdIRUFEJyB8fCBib2R5ID09PSBudWxsXG4gIGlmIChleHBlY3RDb250aW51ZSkge1xuICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX0VYUEVDVF0gPSAnMTAwLWNvbnRpbnVlJ1xuICAgIHN0cmVhbSA9IHNlc3Npb24ucmVxdWVzdChoZWFkZXJzLCB7IGVuZFN0cmVhbTogc2hvdWxkRW5kU3RyZWFtLCBzaWduYWwgfSlcblxuICAgIHN0cmVhbS5vbmNlKCdjb250aW51ZScsIHdyaXRlQm9keUgyKVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbSA9IHNlc3Npb24ucmVxdWVzdChoZWFkZXJzLCB7XG4gICAgICBlbmRTdHJlYW06IHNob3VsZEVuZFN0cmVhbSxcbiAgICAgIHNpZ25hbFxuICAgIH0pXG5cbiAgICB3cml0ZUJvZHlIMigpXG4gIH1cblxuICAvLyBJbmNyZW1lbnQgY291bnRlciBhcyB3ZSBoYXZlIG5ldyBzdHJlYW1zIG9wZW5cbiAgKytzZXNzaW9uW2tPcGVuU3RyZWFtc11cbiAgc3RyZWFtLnNldFRpbWVvdXQocmVxdWVzdFRpbWVvdXQpXG5cbiAgc3RyZWFtLm9uY2UoJ3Jlc3BvbnNlJywgaGVhZGVycyA9PiB7XG4gICAgY29uc3QgeyBbSFRUUDJfSEVBREVSX1NUQVRVU106IHN0YXR1c0NvZGUsIC4uLnJlYWxIZWFkZXJzIH0gPSBoZWFkZXJzXG4gICAgcmVxdWVzdC5vblJlc3BvbnNlU3RhcnRlZCgpXG5cbiAgICAvLyBEdWUgdG8gdGhlIHN0cmVhbSBuYXR1cmUsIGl0IGlzIHBvc3NpYmxlIHdlIGZhY2UgYSByYWNlIGNvbmRpdGlvblxuICAgIC8vIHdoZXJlIHRoZSBzdHJlYW0gaGFzIGJlZW4gYXNzaWduZWQsIGJ1dCB0aGUgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkXG4gICAgLy8gdGhlIHJlcXVlc3QgcmVtYWlucyBpbi1mbGlnaHQgYW5kIGhlYWRlcnMgaGFzbid0IGJlZW4gcmVjZWl2ZWQgeWV0XG4gICAgLy8gZm9yIHRob3NlIHNjZW5hcmlvcywgYmVzdCBlZmZvcnQgaXMgdG8gZGVzdHJveSB0aGUgc3RyZWFtIGltbWVkaWF0ZWx5XG4gICAgLy8gYXMgdGhlcmUncyBubyB2YWx1ZSB0byBrZWVwIGl0IG9wZW4uXG4gICAgaWYgKHJlcXVlc3QuYWJvcnRlZCkge1xuICAgICAgc3RyZWFtLnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5vbkhlYWRlcnMoTnVtYmVyKHN0YXR1c0NvZGUpLCBwYXJzZUgySGVhZGVycyhyZWFsSGVhZGVycyksIHN0cmVhbS5yZXN1bWUuYmluZChzdHJlYW0pLCAnJykgPT09IGZhbHNlKSB7XG4gICAgICBzdHJlYW0ucGF1c2UoKVxuICAgIH1cbiAgfSlcblxuICBzdHJlYW0ub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICBpZiAocmVxdWVzdC5vbkRhdGEoY2h1bmspID09PSBmYWxzZSkge1xuICAgICAgc3RyZWFtLnBhdXNlKClcbiAgICB9XG4gIH0pXG5cbiAgc3RyZWFtLm9uY2UoJ2VuZCcsIChlcnIpID0+IHtcbiAgICBzdHJlYW0ucmVtb3ZlQWxsTGlzdGVuZXJzKCdkYXRhJylcbiAgICAvLyBXaGVuIHN0YXRlIGlzIG51bGwsIGl0IG1lYW5zIHdlIGhhdmVuJ3QgY29uc3VtZWQgYm9keSBhbmQgdGhlIHN0cmVhbSBzdGlsbCBkbyBub3QgaGF2ZVxuICAgIC8vIGEgc3RhdGUuXG4gICAgLy8gUHJlc2VudCBzcGVjaWFsbHkgd2hlbiB1c2luZyBwaXBlbGluZSBvciBzdHJlYW1cbiAgICBpZiAoc3RyZWFtLnN0YXRlPy5zdGF0ZSA9PSBudWxsIHx8IHN0cmVhbS5zdGF0ZS5zdGF0ZSA8IDYpIHtcbiAgICAgIC8vIERvIG5vdCBjb21wbGV0ZSB0aGUgcmVxdWVzdCBpZiBpdCB3YXMgYWJvcnRlZFxuICAgICAgLy8gTm90IHByb25lIHRvIGhhcHBlbiBmb3IgYXMgc2FmZXR5IG5ldCB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnMgd2l0aCAndHJhaWxlcnMnXG4gICAgICBpZiAoIXJlcXVlc3QuYWJvcnRlZCAmJiAhcmVxdWVzdC5jb21wbGV0ZWQpIHtcbiAgICAgICAgcmVxdWVzdC5vbkNvbXBsZXRlKHt9KVxuICAgICAgfVxuXG4gICAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuICAgICAgY2xpZW50W2tSZXN1bWVdKClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RyZWFtIGlzIGNsb3NlZCBvciBoYWxmLWNsb3NlZC1yZW1vdGUgKDYpLCBkZWNyZW1lbnQgY291bnRlciBhbmQgY2xlYW51cFxuICAgICAgLy8gSXQgZG9lcyBub3QgaGF2ZSBzZW5zZSB0byBjb250aW51ZSB3b3JraW5nIHdpdGggdGhlIHN0cmVhbSBhcyB3ZSBkbyBub3RcbiAgICAgIC8vIGhhdmUgeWV0IFJTVF9TVFJFQU0gc3VwcG9ydCBvbiBjbGllbnQtc2lkZVxuICAgICAgLS1zZXNzaW9uW2tPcGVuU3RyZWFtc11cbiAgICAgIGlmIChzZXNzaW9uW2tPcGVuU3RyZWFtc10gPT09IDApIHtcbiAgICAgICAgc2Vzc2lvbi51bnJlZigpXG4gICAgICB9XG5cbiAgICAgIGFib3J0KGVyciA/PyBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdIVFRQLzI6IHN0cmVhbSBoYWxmLWNsb3NlZCAocmVtb3RlKScpKVxuICAgICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcbiAgICAgIGNsaWVudFtrUGVuZGluZ0lkeF0gPSBjbGllbnRba1J1bm5pbmdJZHhdXG4gICAgICBjbGllbnRba1Jlc3VtZV0oKVxuICAgIH1cbiAgfSlcblxuICBzdHJlYW0ub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgc3RyZWFtLnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpXG4gICAgc2Vzc2lvbltrT3BlblN0cmVhbXNdIC09IDFcbiAgICBpZiAoc2Vzc2lvbltrT3BlblN0cmVhbXNdID09PSAwKSB7XG4gICAgICBzZXNzaW9uLnVucmVmKClcbiAgICB9XG4gIH0pXG5cbiAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHN0cmVhbS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKVxuICAgIGFib3J0KGVycilcbiAgfSlcblxuICBzdHJlYW0ub25jZSgnZnJhbWVFcnJvcicsICh0eXBlLCBjb2RlKSA9PiB7XG4gICAgc3RyZWFtLnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpXG4gICAgYWJvcnQobmV3IEluZm9ybWF0aW9uYWxFcnJvcihgSFRUUC8yOiBcImZyYW1lRXJyb3JcIiByZWNlaXZlZCAtIHR5cGUgJHt0eXBlfSwgY29kZSAke2NvZGV9YCkpXG4gIH0pXG5cbiAgc3RyZWFtLm9uKCdhYm9ydGVkJywgKCkgPT4ge1xuICAgIHN0cmVhbS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKVxuICB9KVxuXG4gIHN0cmVhbS5vbigndGltZW91dCcsICgpID0+IHtcbiAgICBjb25zdCBlcnIgPSBuZXcgSW5mb3JtYXRpb25hbEVycm9yKGBIVFRQLzI6IFwic3RyZWFtIHRpbWVvdXQgYWZ0ZXIgJHtyZXF1ZXN0VGltZW91dH1cImApXG4gICAgc3RyZWFtLnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpXG4gICAgc2Vzc2lvbltrT3BlblN0cmVhbXNdIC09IDFcblxuICAgIGlmIChzZXNzaW9uW2tPcGVuU3RyZWFtc10gPT09IDApIHtcbiAgICAgIHNlc3Npb24udW5yZWYoKVxuICAgIH1cblxuICAgIGFib3J0KGVycilcbiAgfSlcblxuICBzdHJlYW0ub25jZSgndHJhaWxlcnMnLCB0cmFpbGVycyA9PiB7XG4gICAgaWYgKHJlcXVlc3QuYWJvcnRlZCB8fCByZXF1ZXN0LmNvbXBsZXRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcmVxdWVzdC5vbkNvbXBsZXRlKHRyYWlsZXJzKVxuICB9KVxuXG4gIHJldHVybiB0cnVlXG5cbiAgZnVuY3Rpb24gd3JpdGVCb2R5SDIgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBhc3NlcnRpb24gKi9cbiAgICBpZiAoIWJvZHkgfHwgY29udGVudExlbmd0aCA9PT0gMCkge1xuICAgICAgd3JpdGVCdWZmZXIoXG4gICAgICAgIGFib3J0LFxuICAgICAgICBzdHJlYW0sXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICBleHBlY3RzUGF5bG9hZFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAodXRpbC5pc0J1ZmZlcihib2R5KSkge1xuICAgICAgd3JpdGVCdWZmZXIoXG4gICAgICAgIGFib3J0LFxuICAgICAgICBzdHJlYW0sXG4gICAgICAgIGJvZHksXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICBleHBlY3RzUGF5bG9hZFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAodXRpbC5pc0Jsb2JMaWtlKGJvZHkpKSB7XG4gICAgICBpZiAodHlwZW9mIGJvZHkuc3RyZWFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdyaXRlSXRlcmFibGUoXG4gICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgIGJvZHkuc3RyZWFtKCksXG4gICAgICAgICAgY2xpZW50LFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgZXhwZWN0c1BheWxvYWRcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVCbG9iKFxuICAgICAgICAgIGFib3J0LFxuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGNsaWVudFtrU29ja2V0XSxcbiAgICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICAgIGV4cGVjdHNQYXlsb2FkXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgIHdyaXRlU3RyZWFtKFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICBleHBlY3RzUGF5bG9hZCxcbiAgICAgICAgc3RyZWFtLFxuICAgICAgICBib2R5LFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGNvbnRlbnRMZW5ndGhcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNJdGVyYWJsZShib2R5KSkge1xuICAgICAgd3JpdGVJdGVyYWJsZShcbiAgICAgICAgYWJvcnQsXG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgY2xpZW50LFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBjbGllbnRba1NvY2tldF0sXG4gICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgIGV4cGVjdHNQYXlsb2FkXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChmYWxzZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JpdGVCdWZmZXIgKGFib3J0LCBoMnN0cmVhbSwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGV4cGVjdHNQYXlsb2FkKSB7XG4gIHRyeSB7XG4gICAgaWYgKGJvZHkgIT0gbnVsbCAmJiB1dGlsLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICBhc3NlcnQoY29udGVudExlbmd0aCA9PT0gYm9keS5ieXRlTGVuZ3RoLCAnYnVmZmVyIGJvZHkgbXVzdCBoYXZlIGNvbnRlbnQgbGVuZ3RoJylcbiAgICAgIGgyc3RyZWFtLmNvcmsoKVxuICAgICAgaDJzdHJlYW0ud3JpdGUoYm9keSlcbiAgICAgIGgyc3RyZWFtLnVuY29yaygpXG4gICAgICBoMnN0cmVhbS5lbmQoKVxuXG4gICAgICByZXF1ZXN0Lm9uQm9keVNlbnQoYm9keSlcbiAgICB9XG5cbiAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgYWJvcnQoZXJyb3IpXG4gIH1cbn1cblxuZnVuY3Rpb24gd3JpdGVTdHJlYW0gKGFib3J0LCBzb2NrZXQsIGV4cGVjdHNQYXlsb2FkLCBoMnN0cmVhbSwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBjb250ZW50TGVuZ3RoKSB7XG4gIGFzc2VydChjb250ZW50TGVuZ3RoICE9PSAwIHx8IGNsaWVudFtrUnVubmluZ10gPT09IDAsICdzdHJlYW0gYm9keSBjYW5ub3QgYmUgcGlwZWxpbmVkJylcblxuICAvLyBGb3IgSFRUUC8yLCBpcyBlbm91Z2ggdG8gcGlwZSB0aGUgc3RyZWFtXG4gIGNvbnN0IHBpcGUgPSBwaXBlbGluZShcbiAgICBib2R5LFxuICAgIGgyc3RyZWFtLFxuICAgIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KHBpcGUsIGVycilcbiAgICAgICAgYWJvcnQoZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5yZW1vdmVBbGxMaXN0ZW5lcnMocGlwZSlcbiAgICAgICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgICAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBjbGllbnRba1Jlc3VtZV0oKVxuICAgICAgfVxuICAgIH1cbiAgKVxuXG4gIHV0aWwuYWRkTGlzdGVuZXIocGlwZSwgJ2RhdGEnLCBvblBpcGVEYXRhKVxuXG4gIGZ1bmN0aW9uIG9uUGlwZURhdGEgKGNodW5rKSB7XG4gICAgcmVxdWVzdC5vbkJvZHlTZW50KGNodW5rKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlQmxvYiAoYWJvcnQsIGgyc3RyZWFtLCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgZXhwZWN0c1BheWxvYWQpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuc2l6ZSwgJ2Jsb2IgYm9keSBtdXN0IGhhdmUgY29udGVudCBsZW5ndGgnKVxuXG4gIHRyeSB7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBjb250ZW50TGVuZ3RoICE9PSBib2R5LnNpemUpIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKVxuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGF3YWl0IGJvZHkuYXJyYXlCdWZmZXIoKSlcblxuICAgIGgyc3RyZWFtLmNvcmsoKVxuICAgIGgyc3RyZWFtLndyaXRlKGJ1ZmZlcilcbiAgICBoMnN0cmVhbS51bmNvcmsoKVxuICAgIGgyc3RyZWFtLmVuZCgpXG5cbiAgICByZXF1ZXN0Lm9uQm9keVNlbnQoYnVmZmVyKVxuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICB9XG5cbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBhYm9ydChlcnIpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVJdGVyYWJsZSAoYWJvcnQsIGgyc3RyZWFtLCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgZXhwZWN0c1BheWxvYWQpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggIT09IDAgfHwgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCwgJ2l0ZXJhdG9yIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZCcpXG5cbiAgbGV0IGNhbGxiYWNrID0gbnVsbFxuICBmdW5jdGlvbiBvbkRyYWluICgpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgIGNhbGxiYWNrID0gbnVsbFxuICAgICAgY2IoKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHdhaXRGb3JEcmFpbiA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBhc3NlcnQoY2FsbGJhY2sgPT09IG51bGwpXG5cbiAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgIHJlamVjdChzb2NrZXRba0Vycm9yXSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sgPSByZXNvbHZlXG4gICAgfVxuICB9KVxuXG4gIGgyc3RyZWFtXG4gICAgLm9uKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgLm9uKCdkcmFpbicsIG9uRHJhaW4pXG5cbiAgdHJ5IHtcbiAgICAvLyBJdCdzIHVwIHRvIHRoZSB1c2VyIHRvIHNvbWVob3cgYWJvcnQgdGhlIGFzeW5jIGl0ZXJhYmxlLlxuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYm9keSkge1xuICAgICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICAgIHRocm93IHNvY2tldFtrRXJyb3JdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcyA9IGgyc3RyZWFtLndyaXRlKGNodW5rKVxuICAgICAgcmVxdWVzdC5vbkJvZHlTZW50KGNodW5rKVxuICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvckRyYWluKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoMnN0cmVhbS5lbmQoKVxuXG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgIGlmICghZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgIH1cblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGFib3J0KGVycilcbiAgfSBmaW5hbGx5IHtcbiAgICBoMnN0cmVhbVxuICAgICAgLm9mZignY2xvc2UnLCBvbkRyYWluKVxuICAgICAgLm9mZignZHJhaW4nLCBvbkRyYWluKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29ubmVjdEgyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/client-h2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/client.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst net = __webpack_require__(/*! node:net */ \"node:net\")\nconst http = __webpack_require__(/*! node:http */ \"node:http\")\nconst util = __webpack_require__(/*! ../core/util.js */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { ClientStats } = __webpack_require__(/*! ../util/stats.js */ \"(rsc)/./node_modules/undici/lib/util/stats.js\")\nconst { channels } = __webpack_require__(/*! ../core/diagnostics.js */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\nconst Request = __webpack_require__(/*! ../core/request.js */ \"(rsc)/./node_modules/undici/lib/core/request.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst {\n  InvalidArgumentError,\n  InformationalError,\n  ClientDestroyedError\n} = __webpack_require__(/*! ../core/errors.js */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst buildConnector = __webpack_require__(/*! ../core/connect.js */ \"(rsc)/./node_modules/undici/lib/core/connect.js\")\nconst {\n  kUrl,\n  kServerName,\n  kClient,\n  kBusy,\n  kConnect,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kLocalAddress,\n  kMaxResponseSize,\n  kOnError,\n  kHTTPContext,\n  kMaxConcurrentStreams,\n  kResume\n} = __webpack_require__(/*! ../core/symbols.js */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst connectH1 = __webpack_require__(/*! ./client-h1.js */ \"(rsc)/./node_modules/undici/lib/dispatcher/client-h1.js\")\nconst connectH2 = __webpack_require__(/*! ./client-h2.js */ \"(rsc)/./node_modules/undici/lib/dispatcher/client-h2.js\")\n\nconst kClosedResolve = Symbol('kClosedResolve')\n\nconst getDefaultNodeMaxHeaderSize = http &&\n  http.maxHeaderSize &&\n  Number.isInteger(http.maxHeaderSize) &&\n  http.maxHeaderSize > 0\n  ? () => http.maxHeaderSize\n  : () => { throw new InvalidArgumentError('http module not available or http.maxHeaderSize invalid') }\n\nconst noop = () => {}\n\nfunction getPipelining (client) {\n  return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1\n}\n\n/**\n * @type {import('../../types/client.js').default}\n */\nclass Client extends DispatcherBase {\n  /**\n   *\n   * @param {string|URL} url\n   * @param {import('../../types/client.js').Client.Options} options\n   */\n  constructor (url, {\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    connect,\n    maxRequestsPerClient,\n    localAddress,\n    maxResponseSize,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    // h2\n    maxConcurrentStreams,\n    allowH2\n  } = {}) {\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null) {\n      if (!Number.isInteger(maxHeaderSize) || maxHeaderSize < 1) {\n        throw new InvalidArgumentError('invalid maxHeaderSize')\n      }\n    } else {\n      // If maxHeaderSize is not provided, use the default value from the http module\n      // or if that is not available, throw an error.\n      maxHeaderSize = getDefaultNodeMaxHeaderSize()\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address')\n    }\n\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number')\n    }\n\n    if (\n      autoSelectFamilyAttemptTimeout != null &&\n      (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)\n    ) {\n      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number')\n    }\n\n    // h2\n    if (allowH2 != null && typeof allowH2 !== 'boolean') {\n      throw new InvalidArgumentError('allowH2 must be a valid boolean value')\n    }\n\n    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {\n      throw new InvalidArgumentError('maxConcurrentStreams must be a positive integer, greater than 0')\n    }\n\n    super()\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(typeof autoSelectFamily === 'boolean' ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kServerName] = null\n    this[kLocalAddress] = localAddress != null ? localAddress : null\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRequests] = maxRequestsPerClient\n    this[kClosedResolve] = null\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1\n    this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server\n    this[kHTTPContext] = null\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n\n    this[kResume] = (sync) => resume(this, sync)\n    this[kOnError] = (err) => onError(this, err)\n  }\n\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  set pipelining (value) {\n    this[kPipelining] = value\n    this[kResume](true)\n  }\n\n  get stats () {\n    return new ClientStats(this)\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed\n  }\n\n  get [kBusy] () {\n    return Boolean(\n      this[kHTTPContext]?.busy(null) ||\n      (this[kSize] >= (getPipelining(this) || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  [kDispatch] (opts, handler) {\n    const origin = opts.origin || this[kUrl].origin\n    const request = new Request(origin, opts, handler)\n\n    this[kQueue].push(request)\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1\n      queueMicrotask(() => resume(this))\n    } else {\n      this[kResume](true)\n    }\n\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  async [kClose] () {\n    // TODO: for H2 we need to gracefully flush the remaining enqueued\n    // request and close each stream.\n    return new Promise((resolve) => {\n      if (this[kSize]) {\n        this[kClosedResolve] = resolve\n      } else {\n        resolve(null)\n      }\n    })\n  }\n\n  async [kDestroy] (err) {\n    return new Promise((resolve) => {\n      const requests = this[kQueue].splice(this[kPendingIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        util.errorRequest(this, request, err)\n      }\n\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          // TODO (fix): Should we error here with ClientDestroyedError?\n          this[kClosedResolve]()\n          this[kClosedResolve] = null\n        }\n        resolve(null)\n      }\n\n      if (this[kHTTPContext]) {\n        this[kHTTPContext].destroy(err, callback)\n        this[kHTTPContext] = null\n      } else {\n        queueMicrotask(callback)\n      }\n\n      this[kResume]()\n    })\n  }\n}\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      util.errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\n/**\n * @param {Client} client\n * @returns\n */\nasync function connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kHTTPContext])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substring(1, idx)\n\n    assert(net.isIPv6(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        version: client[kHTTPContext]?.version,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      }, (err, socket) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(socket)\n        }\n      })\n    })\n\n    if (client.destroyed) {\n      util.destroy(socket.on('error', noop), new ClientDestroyedError())\n      return\n    }\n\n    assert(socket)\n\n    try {\n      client[kHTTPContext] = socket.alpnProtocol === 'h2'\n        ? await connectH2(client, socket)\n        : await connectH1(client, socket)\n    } catch (err) {\n      socket.destroy().on('error', noop)\n      throw err\n    }\n\n    client[kConnecting] = false\n\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket[kClient] = client\n    socket[kError] = null\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          version: client[kHTTPContext]?.version,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n    client.emit('connect', client[kUrl], [client])\n  } catch (err) {\n    if (client.destroyed) {\n      return\n    }\n\n    client[kConnecting] = false\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          version: client[kHTTPContext]?.version,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        error: err\n      })\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0)\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++]\n        util.errorRequest(client, request, err)\n      }\n    } else {\n      onError(client, err)\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err)\n  }\n\n  client[kResume]()\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client[kClosedResolve] && !client[kSize]) {\n      client[kClosedResolve]()\n      client[kClosedResolve] = null\n      return\n    }\n\n    if (client[kHTTPContext]) {\n      client[kHTTPContext].resume()\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        queueMicrotask(() => emitDrain(client))\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (getPipelining(client) || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n      client[kHTTPContext]?.destroy(new InformationalError('servername changed'), () => {\n        client[kHTTPContext] = null\n        resume(client)\n      })\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!client[kHTTPContext]) {\n      connect(client)\n      return\n    }\n\n    if (client[kHTTPContext].destroyed) {\n      return\n    }\n\n    if (client[kHTTPContext].busy(request)) {\n      return\n    }\n\n    if (!request.aborted && client[kHTTPContext].write(request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nmodule.exports = Client\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsWUFBWSxtQkFBTyxDQUFDLDBCQUFVO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyw0QkFBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsdUVBQWtCO0FBQ2xELFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsbUZBQXdCO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLDJFQUFvQjtBQUM1Qyx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDL0IsdUJBQXVCLG1CQUFPLENBQUMsMkVBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJFQUFvQjtBQUNoQyxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBZ0I7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQWdCOztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxnREFBZ0Q7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCBuZXQgPSByZXF1aXJlKCdub2RlOm5ldCcpXG5jb25zdCBodHRwID0gcmVxdWlyZSgnbm9kZTpodHRwJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwuanMnKVxuY29uc3QgeyBDbGllbnRTdGF0cyB9ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0cy5qcycpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi9jb3JlL2RpYWdub3N0aWNzLmpzJylcbmNvbnN0IFJlcXVlc3QgPSByZXF1aXJlKCcuLi9jb3JlL3JlcXVlc3QuanMnKVxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbmZvcm1hdGlvbmFsRXJyb3IsXG4gIENsaWVudERlc3Ryb3llZEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMuanMnKVxuY29uc3QgYnVpbGRDb25uZWN0b3IgPSByZXF1aXJlKCcuLi9jb3JlL2Nvbm5lY3QuanMnKVxuY29uc3Qge1xuICBrVXJsLFxuICBrU2VydmVyTmFtZSxcbiAga0NsaWVudCxcbiAga0J1c3ksXG4gIGtDb25uZWN0LFxuICBrUmVzdW1pbmcsXG4gIGtSdW5uaW5nLFxuICBrUGVuZGluZyxcbiAga1NpemUsXG4gIGtRdWV1ZSxcbiAga0Nvbm5lY3RlZCxcbiAga0Nvbm5lY3RpbmcsXG4gIGtOZWVkRHJhaW4sXG4gIGtLZWVwQWxpdmVEZWZhdWx0VGltZW91dCxcbiAga0hvc3RIZWFkZXIsXG4gIGtQZW5kaW5nSWR4LFxuICBrUnVubmluZ0lkeCxcbiAga0Vycm9yLFxuICBrUGlwZWxpbmluZyxcbiAga0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZSxcbiAga01heEhlYWRlcnNTaXplLFxuICBrS2VlcEFsaXZlTWF4VGltZW91dCxcbiAga0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQsXG4gIGtIZWFkZXJzVGltZW91dCxcbiAga0JvZHlUaW1lb3V0LFxuICBrU3RyaWN0Q29udGVudExlbmd0aCxcbiAga0Nvbm5lY3RvcixcbiAga01heFJlcXVlc3RzLFxuICBrQ291bnRlcixcbiAga0Nsb3NlLFxuICBrRGVzdHJveSxcbiAga0Rpc3BhdGNoLFxuICBrTG9jYWxBZGRyZXNzLFxuICBrTWF4UmVzcG9uc2VTaXplLFxuICBrT25FcnJvcixcbiAga0hUVFBDb250ZXh0LFxuICBrTWF4Q29uY3VycmVudFN0cmVhbXMsXG4gIGtSZXN1bWVcbn0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMuanMnKVxuY29uc3QgY29ubmVjdEgxID0gcmVxdWlyZSgnLi9jbGllbnQtaDEuanMnKVxuY29uc3QgY29ubmVjdEgyID0gcmVxdWlyZSgnLi9jbGllbnQtaDIuanMnKVxuXG5jb25zdCBrQ2xvc2VkUmVzb2x2ZSA9IFN5bWJvbCgna0Nsb3NlZFJlc29sdmUnKVxuXG5jb25zdCBnZXREZWZhdWx0Tm9kZU1heEhlYWRlclNpemUgPSBodHRwICYmXG4gIGh0dHAubWF4SGVhZGVyU2l6ZSAmJlxuICBOdW1iZXIuaXNJbnRlZ2VyKGh0dHAubWF4SGVhZGVyU2l6ZSkgJiZcbiAgaHR0cC5tYXhIZWFkZXJTaXplID4gMFxuICA/ICgpID0+IGh0dHAubWF4SGVhZGVyU2l6ZVxuICA6ICgpID0+IHsgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdodHRwIG1vZHVsZSBub3QgYXZhaWxhYmxlIG9yIGh0dHAubWF4SGVhZGVyU2l6ZSBpbnZhbGlkJykgfVxuXG5jb25zdCBub29wID0gKCkgPT4ge31cblxuZnVuY3Rpb24gZ2V0UGlwZWxpbmluZyAoY2xpZW50KSB7XG4gIHJldHVybiBjbGllbnRba1BpcGVsaW5pbmddID8/IGNsaWVudFtrSFRUUENvbnRleHRdPy5kZWZhdWx0UGlwZWxpbmluZyA/PyAxXG59XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2xpZW50LmpzJykuZGVmYXVsdH1cbiAqL1xuY2xhc3MgQ2xpZW50IGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmxcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NsaWVudC5qcycpLkNsaWVudC5PcHRpb25zfSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodXJsLCB7XG4gICAgbWF4SGVhZGVyU2l6ZSxcbiAgICBoZWFkZXJzVGltZW91dCxcbiAgICBzb2NrZXRUaW1lb3V0LFxuICAgIHJlcXVlc3RUaW1lb3V0LFxuICAgIGNvbm5lY3RUaW1lb3V0LFxuICAgIGJvZHlUaW1lb3V0LFxuICAgIGlkbGVUaW1lb3V0LFxuICAgIGtlZXBBbGl2ZSxcbiAgICBrZWVwQWxpdmVUaW1lb3V0LFxuICAgIG1heEtlZXBBbGl2ZVRpbWVvdXQsXG4gICAga2VlcEFsaXZlTWF4VGltZW91dCxcbiAgICBrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkLFxuICAgIHNvY2tldFBhdGgsXG4gICAgcGlwZWxpbmluZyxcbiAgICB0bHMsXG4gICAgc3RyaWN0Q29udGVudExlbmd0aCxcbiAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICBjb25uZWN0LFxuICAgIG1heFJlcXVlc3RzUGVyQ2xpZW50LFxuICAgIGxvY2FsQWRkcmVzcyxcbiAgICBtYXhSZXNwb25zZVNpemUsXG4gICAgYXV0b1NlbGVjdEZhbWlseSxcbiAgICBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQsXG4gICAgLy8gaDJcbiAgICBtYXhDb25jdXJyZW50U3RyZWFtcyxcbiAgICBhbGxvd0gyXG4gIH0gPSB7fSkge1xuICAgIGlmIChrZWVwQWxpdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBrZWVwQWxpdmUsIHVzZSBwaXBlbGluaW5nPTAgaW5zdGVhZCcpXG4gICAgfVxuXG4gICAgaWYgKHNvY2tldFRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBzb2NrZXRUaW1lb3V0LCB1c2UgaGVhZGVyc1RpbWVvdXQgJiBib2R5VGltZW91dCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdFRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCByZXF1ZXN0VGltZW91dCwgdXNlIGhlYWRlcnNUaW1lb3V0ICYgYm9keVRpbWVvdXQgaW5zdGVhZCcpXG4gICAgfVxuXG4gICAgaWYgKGlkbGVUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQgaWRsZVRpbWVvdXQsIHVzZSBrZWVwQWxpdmVUaW1lb3V0IGluc3RlYWQnKVxuICAgIH1cblxuICAgIGlmIChtYXhLZWVwQWxpdmVUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQgbWF4S2VlcEFsaXZlVGltZW91dCwgdXNlIGtlZXBBbGl2ZU1heFRpbWVvdXQgaW5zdGVhZCcpXG4gICAgfVxuXG4gICAgaWYgKG1heEhlYWRlclNpemUgIT0gbnVsbCkge1xuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heEhlYWRlclNpemUpIHx8IG1heEhlYWRlclNpemUgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBtYXhIZWFkZXJTaXplJylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbWF4SGVhZGVyU2l6ZSBpcyBub3QgcHJvdmlkZWQsIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSBodHRwIG1vZHVsZVxuICAgICAgLy8gb3IgaWYgdGhhdCBpcyBub3QgYXZhaWxhYmxlLCB0aHJvdyBhbiBlcnJvci5cbiAgICAgIG1heEhlYWRlclNpemUgPSBnZXREZWZhdWx0Tm9kZU1heEhlYWRlclNpemUoKVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRQYXRoICE9IG51bGwgJiYgdHlwZW9mIHNvY2tldFBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgc29ja2V0UGF0aCcpXG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3RUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoY29ubmVjdFRpbWVvdXQpIHx8IGNvbm5lY3RUaW1lb3V0IDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjb25uZWN0VGltZW91dCcpXG4gICAgfVxuXG4gICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShrZWVwQWxpdmVUaW1lb3V0KSB8fCBrZWVwQWxpdmVUaW1lb3V0IDw9IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQga2VlcEFsaXZlVGltZW91dCcpXG4gICAgfVxuXG4gICAgaWYgKGtlZXBBbGl2ZU1heFRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShrZWVwQWxpdmVNYXhUaW1lb3V0KSB8fCBrZWVwQWxpdmVNYXhUaW1lb3V0IDw9IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQga2VlcEFsaXZlTWF4VGltZW91dCcpXG4gICAgfVxuXG4gICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQgIT0gbnVsbCAmJiAhTnVtYmVyLmlzRmluaXRlKGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCcpXG4gICAgfVxuXG4gICAgaWYgKGhlYWRlcnNUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKGhlYWRlcnNUaW1lb3V0KSB8fCBoZWFkZXJzVGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnNUaW1lb3V0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHplcm8nKVxuICAgIH1cblxuICAgIGlmIChib2R5VGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihib2R5VGltZW91dCkgfHwgYm9keVRpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdib2R5VGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciB6ZXJvJylcbiAgICB9XG5cbiAgICBpZiAoY29ubmVjdCAhPSBudWxsICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdjb25uZWN0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QnKVxuICAgIH1cblxuICAgIGlmIChtYXhSZXF1ZXN0c1BlckNsaWVudCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXF1ZXN0c1BlckNsaWVudCkgfHwgbWF4UmVxdWVzdHNQZXJDbGllbnQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZXF1ZXN0c1BlckNsaWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAobG9jYWxBZGRyZXNzICE9IG51bGwgJiYgKHR5cGVvZiBsb2NhbEFkZHJlc3MgIT09ICdzdHJpbmcnIHx8IG5ldC5pc0lQKGxvY2FsQWRkcmVzcykgPT09IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2xvY2FsQWRkcmVzcyBtdXN0IGJlIHZhbGlkIHN0cmluZyBJUCBhZGRyZXNzJylcbiAgICB9XG5cbiAgICBpZiAobWF4UmVzcG9uc2VTaXplICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlc3BvbnNlU2l6ZSkgfHwgbWF4UmVzcG9uc2VTaXplIDwgLTEpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFJlc3BvbnNlU2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQgIT0gbnVsbCAmJlxuICAgICAgKCFOdW1iZXIuaXNJbnRlZ2VyKGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCkgfHwgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IDwgLTEpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2F1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICAvLyBoMlxuICAgIGlmIChhbGxvd0gyICE9IG51bGwgJiYgdHlwZW9mIGFsbG93SDIgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdhbGxvd0gyIG11c3QgYmUgYSB2YWxpZCBib29sZWFuIHZhbHVlJylcbiAgICB9XG5cbiAgICBpZiAobWF4Q29uY3VycmVudFN0cmVhbXMgIT0gbnVsbCAmJiAodHlwZW9mIG1heENvbmN1cnJlbnRTdHJlYW1zICE9PSAnbnVtYmVyJyB8fCBtYXhDb25jdXJyZW50U3RyZWFtcyA8IDEpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heENvbmN1cnJlbnRTdHJlYW1zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBncmVhdGVyIHRoYW4gMCcpXG4gICAgfVxuXG4gICAgc3VwZXIoKVxuXG4gICAgaWYgKHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25uZWN0ID0gYnVpbGRDb25uZWN0b3Ioe1xuICAgICAgICAuLi50bHMsXG4gICAgICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgICAgICBhbGxvd0gyLFxuICAgICAgICBzb2NrZXRQYXRoLFxuICAgICAgICB0aW1lb3V0OiBjb25uZWN0VGltZW91dCxcbiAgICAgICAgLi4uKHR5cGVvZiBhdXRvU2VsZWN0RmFtaWx5ID09PSAnYm9vbGVhbicgPyB7IGF1dG9TZWxlY3RGYW1pbHksIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCB9IDogdW5kZWZpbmVkKSxcbiAgICAgICAgLi4uY29ubmVjdFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzW2tVcmxdID0gdXRpbC5wYXJzZU9yaWdpbih1cmwpXG4gICAgdGhpc1trQ29ubmVjdG9yXSA9IGNvbm5lY3RcbiAgICB0aGlzW2tQaXBlbGluaW5nXSA9IHBpcGVsaW5pbmcgIT0gbnVsbCA/IHBpcGVsaW5pbmcgOiAxXG4gICAgdGhpc1trTWF4SGVhZGVyc1NpemVdID0gbWF4SGVhZGVyU2l6ZVxuICAgIHRoaXNba0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0XSA9IGtlZXBBbGl2ZVRpbWVvdXQgPT0gbnVsbCA/IDRlMyA6IGtlZXBBbGl2ZVRpbWVvdXRcbiAgICB0aGlzW2tLZWVwQWxpdmVNYXhUaW1lb3V0XSA9IGtlZXBBbGl2ZU1heFRpbWVvdXQgPT0gbnVsbCA/IDYwMGUzIDoga2VlcEFsaXZlTWF4VGltZW91dFxuICAgIHRoaXNba0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGRdID0ga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCA9PSBudWxsID8gMmUzIDoga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZFxuICAgIHRoaXNba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0gPSB0aGlzW2tLZWVwQWxpdmVEZWZhdWx0VGltZW91dF1cbiAgICB0aGlzW2tTZXJ2ZXJOYW1lXSA9IG51bGxcbiAgICB0aGlzW2tMb2NhbEFkZHJlc3NdID0gbG9jYWxBZGRyZXNzICE9IG51bGwgPyBsb2NhbEFkZHJlc3MgOiBudWxsXG4gICAgdGhpc1trUmVzdW1pbmddID0gMCAvLyAwLCBpZGxlLCAxLCBzY2hlZHVsZWQsIDIgcmVzdW1pbmdcbiAgICB0aGlzW2tOZWVkRHJhaW5dID0gMCAvLyAwLCBpZGxlLCAxLCBzY2hlZHVsZWQsIDIgcmVzdW1pbmdcbiAgICB0aGlzW2tIb3N0SGVhZGVyXSA9IGBob3N0OiAke3RoaXNba1VybF0uaG9zdG5hbWV9JHt0aGlzW2tVcmxdLnBvcnQgPyBgOiR7dGhpc1trVXJsXS5wb3J0fWAgOiAnJ31cXHJcXG5gXG4gICAgdGhpc1trQm9keVRpbWVvdXRdID0gYm9keVRpbWVvdXQgIT0gbnVsbCA/IGJvZHlUaW1lb3V0IDogMzAwZTNcbiAgICB0aGlzW2tIZWFkZXJzVGltZW91dF0gPSBoZWFkZXJzVGltZW91dCAhPSBudWxsID8gaGVhZGVyc1RpbWVvdXQgOiAzMDBlM1xuICAgIHRoaXNba1N0cmljdENvbnRlbnRMZW5ndGhdID0gc3RyaWN0Q29udGVudExlbmd0aCA9PSBudWxsID8gdHJ1ZSA6IHN0cmljdENvbnRlbnRMZW5ndGhcbiAgICB0aGlzW2tNYXhSZXF1ZXN0c10gPSBtYXhSZXF1ZXN0c1BlckNsaWVudFxuICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdID0gbnVsbFxuICAgIHRoaXNba01heFJlc3BvbnNlU2l6ZV0gPSBtYXhSZXNwb25zZVNpemUgPiAtMSA/IG1heFJlc3BvbnNlU2l6ZSA6IC0xXG4gICAgdGhpc1trTWF4Q29uY3VycmVudFN0cmVhbXNdID0gbWF4Q29uY3VycmVudFN0cmVhbXMgIT0gbnVsbCA/IG1heENvbmN1cnJlbnRTdHJlYW1zIDogMTAwIC8vIE1heCBwZWVyQ29uY3VycmVudFN0cmVhbXMgZm9yIGEgTm9kZSBoMiBzZXJ2ZXJcbiAgICB0aGlzW2tIVFRQQ29udGV4dF0gPSBudWxsXG5cbiAgICAvLyBrUXVldWUgaXMgYnVpbHQgdXAgb2YgMyBzZWN0aW9ucyBzZXBhcmF0ZWQgYnlcbiAgICAvLyB0aGUga1J1bm5pbmdJZHggYW5kIGtQZW5kaW5nSWR4IGluZGljZXMuXG4gICAgLy8gfCAgIGNvbXBsZXRlICAgfCAgIHJ1bm5pbmcgICB8ICAgcGVuZGluZyAgIHxcbiAgICAvLyAgICAgICAgICAgICAgICBeIGtSdW5uaW5nSWR4IF4ga1BlbmRpbmdJZHggXiBrUXVldWUubGVuZ3RoXG4gICAgLy8ga1J1bm5pbmdJZHggcG9pbnRzIHRvIHRoZSBmaXJzdCBydW5uaW5nIGVsZW1lbnQuXG4gICAgLy8ga1BlbmRpbmdJZHggcG9pbnRzIHRvIHRoZSBmaXJzdCBwZW5kaW5nIGVsZW1lbnQuXG4gICAgLy8gVGhpcyBpbXBsZW1lbnRzIGEgZmFzdCBxdWV1ZSB3aXRoIGFuIGFtb3J0aXplZFxuICAgIC8vIHRpbWUgb2YgTygxKS5cblxuICAgIHRoaXNba1F1ZXVlXSA9IFtdXG4gICAgdGhpc1trUnVubmluZ0lkeF0gPSAwXG4gICAgdGhpc1trUGVuZGluZ0lkeF0gPSAwXG5cbiAgICB0aGlzW2tSZXN1bWVdID0gKHN5bmMpID0+IHJlc3VtZSh0aGlzLCBzeW5jKVxuICAgIHRoaXNba09uRXJyb3JdID0gKGVycikgPT4gb25FcnJvcih0aGlzLCBlcnIpXG4gIH1cblxuICBnZXQgcGlwZWxpbmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1BpcGVsaW5pbmddXG4gIH1cblxuICBzZXQgcGlwZWxpbmluZyAodmFsdWUpIHtcbiAgICB0aGlzW2tQaXBlbGluaW5nXSA9IHZhbHVlXG4gICAgdGhpc1trUmVzdW1lXSh0cnVlKVxuICB9XG5cbiAgZ2V0IHN0YXRzICgpIHtcbiAgICByZXR1cm4gbmV3IENsaWVudFN0YXRzKHRoaXMpXG4gIH1cblxuICBnZXQgW2tQZW5kaW5nXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1F1ZXVlXS5sZW5ndGggLSB0aGlzW2tQZW5kaW5nSWR4XVxuICB9XG5cbiAgZ2V0IFtrUnVubmluZ10gKCkge1xuICAgIHJldHVybiB0aGlzW2tQZW5kaW5nSWR4XSAtIHRoaXNba1J1bm5pbmdJZHhdXG4gIH1cblxuICBnZXQgW2tTaXplXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1F1ZXVlXS5sZW5ndGggLSB0aGlzW2tSdW5uaW5nSWR4XVxuICB9XG5cbiAgZ2V0IFtrQ29ubmVjdGVkXSAoKSB7XG4gICAgcmV0dXJuICEhdGhpc1trSFRUUENvbnRleHRdICYmICF0aGlzW2tDb25uZWN0aW5nXSAmJiAhdGhpc1trSFRUUENvbnRleHRdLmRlc3Ryb3llZFxuICB9XG5cbiAgZ2V0IFtrQnVzeV0gKCkge1xuICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgdGhpc1trSFRUUENvbnRleHRdPy5idXN5KG51bGwpIHx8XG4gICAgICAodGhpc1trU2l6ZV0gPj0gKGdldFBpcGVsaW5pbmcodGhpcykgfHwgMSkpIHx8XG4gICAgICB0aGlzW2tQZW5kaW5nXSA+IDBcbiAgICApXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmU6IG9ubHkgdXNlZCBmb3IgdGVzdCAqL1xuICBba0Nvbm5lY3RdIChjYikge1xuICAgIGNvbm5lY3QodGhpcylcbiAgICB0aGlzLm9uY2UoJ2Nvbm5lY3QnLCBjYilcbiAgfVxuXG4gIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3Qgb3JpZ2luID0gb3B0cy5vcmlnaW4gfHwgdGhpc1trVXJsXS5vcmlnaW5cbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3Qob3JpZ2luLCBvcHRzLCBoYW5kbGVyKVxuXG4gICAgdGhpc1trUXVldWVdLnB1c2gocmVxdWVzdClcbiAgICBpZiAodGhpc1trUmVzdW1pbmddKSB7XG4gICAgICAvLyBEbyBub3RoaW5nLlxuICAgIH0gZWxzZSBpZiAodXRpbC5ib2R5TGVuZ3RoKHJlcXVlc3QuYm9keSkgPT0gbnVsbCAmJiB1dGlsLmlzSXRlcmFibGUocmVxdWVzdC5ib2R5KSkge1xuICAgICAgLy8gV2FpdCBhIHRpY2sgaW4gY2FzZSBzdHJlYW0vaXRlcmF0b3IgaXMgZW5kZWQgaW4gdGhlIHNhbWUgdGljay5cbiAgICAgIHRoaXNba1Jlc3VtaW5nXSA9IDFcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHJlc3VtZSh0aGlzKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trUmVzdW1lXSh0cnVlKVxuICAgIH1cblxuICAgIGlmICh0aGlzW2tSZXN1bWluZ10gJiYgdGhpc1trTmVlZERyYWluXSAhPT0gMiAmJiB0aGlzW2tCdXN5XSkge1xuICAgICAgdGhpc1trTmVlZERyYWluXSA9IDJcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1trTmVlZERyYWluXSA8IDJcbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICAvLyBUT0RPOiBmb3IgSDIgd2UgbmVlZCB0byBncmFjZWZ1bGx5IGZsdXNoIHRoZSByZW1haW5pbmcgZW5xdWV1ZWRcbiAgICAvLyByZXF1ZXN0IGFuZCBjbG9zZSBlYWNoIHN0cmVhbS5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmICh0aGlzW2tTaXplXSkge1xuICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IHJlc29sdmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUobnVsbClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgW2tEZXN0cm95XSAoZXJyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0cyA9IHRoaXNba1F1ZXVlXS5zcGxpY2UodGhpc1trUGVuZGluZ0lkeF0pXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0c1tpXVxuICAgICAgICB1dGlsLmVycm9yUmVxdWVzdCh0aGlzLCByZXF1ZXN0LCBlcnIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpc1trQ2xvc2VkUmVzb2x2ZV0pIHtcbiAgICAgICAgICAvLyBUT0RPIChmaXgpOiBTaG91bGQgd2UgZXJyb3IgaGVyZSB3aXRoIENsaWVudERlc3Ryb3llZEVycm9yP1xuICAgICAgICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdKClcbiAgICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKG51bGwpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW2tIVFRQQ29udGV4dF0pIHtcbiAgICAgICAgdGhpc1trSFRUUENvbnRleHRdLmRlc3Ryb3koZXJyLCBjYWxsYmFjaylcbiAgICAgICAgdGhpc1trSFRUUENvbnRleHRdID0gbnVsbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soY2FsbGJhY2spXG4gICAgICB9XG5cbiAgICAgIHRoaXNba1Jlc3VtZV0oKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gb25FcnJvciAoY2xpZW50LCBlcnIpIHtcbiAgaWYgKFxuICAgIGNsaWVudFtrUnVubmluZ10gPT09IDAgJiZcbiAgICBlcnIuY29kZSAhPT0gJ1VORF9FUlJfSU5GTycgJiZcbiAgICBlcnIuY29kZSAhPT0gJ1VORF9FUlJfU09DS0VUJ1xuICApIHtcbiAgICAvLyBFcnJvciBpcyBub3QgY2F1c2VkIGJ5IHJ1bm5pbmcgcmVxdWVzdCBhbmQgbm90IGEgcmVjb3ZlcmFibGVcbiAgICAvLyBzb2NrZXQgZXJyb3IuXG5cbiAgICBhc3NlcnQoY2xpZW50W2tQZW5kaW5nSWR4XSA9PT0gY2xpZW50W2tSdW5uaW5nSWR4XSlcblxuICAgIGNvbnN0IHJlcXVlc3RzID0gY2xpZW50W2tRdWV1ZV0uc3BsaWNlKGNsaWVudFtrUnVubmluZ0lkeF0pXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHNbaV1cbiAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgIH1cbiAgICBhc3NlcnQoY2xpZW50W2tTaXplXSA9PT0gMClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2xpZW50fSBjbGllbnRcbiAqIEByZXR1cm5zXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbm5lY3QgKGNsaWVudCkge1xuICBhc3NlcnQoIWNsaWVudFtrQ29ubmVjdGluZ10pXG4gIGFzc2VydCghY2xpZW50W2tIVFRQQ29udGV4dF0pXG5cbiAgbGV0IHsgaG9zdCwgaG9zdG5hbWUsIHByb3RvY29sLCBwb3J0IH0gPSBjbGllbnRba1VybF1cblxuICAvLyBSZXNvbHZlIGlwdjZcbiAgaWYgKGhvc3RuYW1lWzBdID09PSAnWycpIHtcbiAgICBjb25zdCBpZHggPSBob3N0bmFtZS5pbmRleE9mKCddJylcblxuICAgIGFzc2VydChpZHggIT09IC0xKVxuICAgIGNvbnN0IGlwID0gaG9zdG5hbWUuc3Vic3RyaW5nKDEsIGlkeClcblxuICAgIGFzc2VydChuZXQuaXNJUHY2KGlwKSlcbiAgICBob3N0bmFtZSA9IGlwXG4gIH1cblxuICBjbGllbnRba0Nvbm5lY3RpbmddID0gdHJ1ZVxuXG4gIGlmIChjaGFubmVscy5iZWZvcmVDb25uZWN0Lmhhc1N1YnNjcmliZXJzKSB7XG4gICAgY2hhbm5lbHMuYmVmb3JlQ29ubmVjdC5wdWJsaXNoKHtcbiAgICAgIGNvbm5lY3RQYXJhbXM6IHtcbiAgICAgICAgaG9zdCxcbiAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgIHByb3RvY29sLFxuICAgICAgICBwb3J0LFxuICAgICAgICB2ZXJzaW9uOiBjbGllbnRba0hUVFBDb250ZXh0XT8udmVyc2lvbixcbiAgICAgICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXSxcbiAgICAgICAgbG9jYWxBZGRyZXNzOiBjbGllbnRba0xvY2FsQWRkcmVzc11cbiAgICAgIH0sXG4gICAgICBjb25uZWN0b3I6IGNsaWVudFtrQ29ubmVjdG9yXVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHNvY2tldCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNsaWVudFtrQ29ubmVjdG9yXSh7XG4gICAgICAgIGhvc3QsXG4gICAgICAgIGhvc3RuYW1lLFxuICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgcG9ydCxcbiAgICAgICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXSxcbiAgICAgICAgbG9jYWxBZGRyZXNzOiBjbGllbnRba0xvY2FsQWRkcmVzc11cbiAgICAgIH0sIChlcnIsIHNvY2tldCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHNvY2tldClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQub24oJ2Vycm9yJywgbm9vcCksIG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXNzZXJ0KHNvY2tldClcblxuICAgIHRyeSB7XG4gICAgICBjbGllbnRba0hUVFBDb250ZXh0XSA9IHNvY2tldC5hbHBuUHJvdG9jb2wgPT09ICdoMidcbiAgICAgICAgPyBhd2FpdCBjb25uZWN0SDIoY2xpZW50LCBzb2NrZXQpXG4gICAgICAgIDogYXdhaXQgY29ubmVjdEgxKGNsaWVudCwgc29ja2V0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc29ja2V0LmRlc3Ryb3koKS5vbignZXJyb3InLCBub29wKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgY2xpZW50W2tDb25uZWN0aW5nXSA9IGZhbHNlXG5cbiAgICBzb2NrZXRba0NvdW50ZXJdID0gMFxuICAgIHNvY2tldFtrTWF4UmVxdWVzdHNdID0gY2xpZW50W2tNYXhSZXF1ZXN0c11cbiAgICBzb2NrZXRba0NsaWVudF0gPSBjbGllbnRcbiAgICBzb2NrZXRba0Vycm9yXSA9IG51bGxcblxuICAgIGlmIChjaGFubmVscy5jb25uZWN0ZWQuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmNvbm5lY3RlZC5wdWJsaXNoKHtcbiAgICAgICAgY29ubmVjdFBhcmFtczoge1xuICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgcG9ydCxcbiAgICAgICAgICB2ZXJzaW9uOiBjbGllbnRba0hUVFBDb250ZXh0XT8udmVyc2lvbixcbiAgICAgICAgICBzZXJ2ZXJuYW1lOiBjbGllbnRba1NlcnZlck5hbWVdLFxuICAgICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3RvcjogY2xpZW50W2tDb25uZWN0b3JdLFxuICAgICAgICBzb2NrZXRcbiAgICAgIH0pXG4gICAgfVxuICAgIGNsaWVudC5lbWl0KCdjb25uZWN0JywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNsaWVudFtrQ29ubmVjdGluZ10gPSBmYWxzZVxuXG4gICAgaWYgKGNoYW5uZWxzLmNvbm5lY3RFcnJvci5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuY29ubmVjdEVycm9yLnB1Ymxpc2goe1xuICAgICAgICBjb25uZWN0UGFyYW1zOiB7XG4gICAgICAgICAgaG9zdCxcbiAgICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICBwb3J0LFxuICAgICAgICAgIHZlcnNpb246IGNsaWVudFtrSFRUUENvbnRleHRdPy52ZXJzaW9uLFxuICAgICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgICAgbG9jYWxBZGRyZXNzOiBjbGllbnRba0xvY2FsQWRkcmVzc11cbiAgICAgICAgfSxcbiAgICAgICAgY29ubmVjdG9yOiBjbGllbnRba0Nvbm5lY3Rvcl0sXG4gICAgICAgIGVycm9yOiBlcnJcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGVyci5jb2RlID09PSAnRVJSX1RMU19DRVJUX0FMVE5BTUVfSU5WQUxJRCcpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAwKVxuICAgICAgd2hpbGUgKGNsaWVudFtrUGVuZGluZ10gPiAwICYmIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUGVuZGluZ0lkeF1dLnNlcnZlcm5hbWUgPT09IGNsaWVudFtrU2VydmVyTmFtZV0pIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUGVuZGluZ0lkeF0rK11cbiAgICAgICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uRXJyb3IoY2xpZW50LCBlcnIpXG4gICAgfVxuXG4gICAgY2xpZW50LmVtaXQoJ2Nvbm5lY3Rpb25FcnJvcicsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIGVycilcbiAgfVxuXG4gIGNsaWVudFtrUmVzdW1lXSgpXG59XG5cbmZ1bmN0aW9uIGVtaXREcmFpbiAoY2xpZW50KSB7XG4gIGNsaWVudFtrTmVlZERyYWluXSA9IDBcbiAgY2xpZW50LmVtaXQoJ2RyYWluJywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSlcbn1cblxuZnVuY3Rpb24gcmVzdW1lIChjbGllbnQsIHN5bmMpIHtcbiAgaWYgKGNsaWVudFtrUmVzdW1pbmddID09PSAyKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjbGllbnRba1Jlc3VtaW5nXSA9IDJcblxuICBfcmVzdW1lKGNsaWVudCwgc3luYylcbiAgY2xpZW50W2tSZXN1bWluZ10gPSAwXG5cbiAgaWYgKGNsaWVudFtrUnVubmluZ0lkeF0gPiAyNTYpIHtcbiAgICBjbGllbnRba1F1ZXVlXS5zcGxpY2UoMCwgY2xpZW50W2tSdW5uaW5nSWR4XSlcbiAgICBjbGllbnRba1BlbmRpbmdJZHhdIC09IGNsaWVudFtrUnVubmluZ0lkeF1cbiAgICBjbGllbnRba1J1bm5pbmdJZHhdID0gMFxuICB9XG59XG5cbmZ1bmN0aW9uIF9yZXN1bWUgKGNsaWVudCwgc3luYykge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tQZW5kaW5nXSA9PT0gMClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba0Nsb3NlZFJlc29sdmVdICYmICFjbGllbnRba1NpemVdKSB7XG4gICAgICBjbGllbnRba0Nsb3NlZFJlc29sdmVdKClcbiAgICAgIGNsaWVudFtrQ2xvc2VkUmVzb2x2ZV0gPSBudWxsXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tIVFRQQ29udGV4dF0pIHtcbiAgICAgIGNsaWVudFtrSFRUUENvbnRleHRdLnJlc3VtZSgpXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrQnVzeV0pIHtcbiAgICAgIGNsaWVudFtrTmVlZERyYWluXSA9IDJcbiAgICB9IGVsc2UgaWYgKGNsaWVudFtrTmVlZERyYWluXSA9PT0gMikge1xuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgY2xpZW50W2tOZWVkRHJhaW5dID0gMVxuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBlbWl0RHJhaW4oY2xpZW50KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVtaXREcmFpbihjbGllbnQpXG4gICAgICB9XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1BlbmRpbmddID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+PSAoZ2V0UGlwZWxpbmluZyhjbGllbnQpIHx8IDEpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tQZW5kaW5nSWR4XV1cblxuICAgIGlmIChjbGllbnRba1VybF0ucHJvdG9jb2wgPT09ICdodHRwczonICYmIGNsaWVudFtrU2VydmVyTmFtZV0gIT09IHJlcXVlc3Quc2VydmVybmFtZSkge1xuICAgICAgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjbGllbnRba1NlcnZlck5hbWVdID0gcmVxdWVzdC5zZXJ2ZXJuYW1lXG4gICAgICBjbGllbnRba0hUVFBDb250ZXh0XT8uZGVzdHJveShuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdzZXJ2ZXJuYW1lIGNoYW5nZWQnKSwgKCkgPT4ge1xuICAgICAgICBjbGllbnRba0hUVFBDb250ZXh0XSA9IG51bGxcbiAgICAgICAgcmVzdW1lKGNsaWVudClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrQ29ubmVjdGluZ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghY2xpZW50W2tIVFRQQ29udGV4dF0pIHtcbiAgICAgIGNvbm5lY3QoY2xpZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrSFRUUENvbnRleHRdLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrSFRUUENvbnRleHRdLmJ1c3kocmVxdWVzdCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghcmVxdWVzdC5hYm9ydGVkICYmIGNsaWVudFtrSFRUUENvbnRleHRdLndyaXRlKHJlcXVlc3QpKSB7XG4gICAgICBjbGllbnRba1BlbmRpbmdJZHhdKytcbiAgICB9IGVsc2Uge1xuICAgICAgY2xpZW50W2tRdWV1ZV0uc3BsaWNlKGNsaWVudFtrUGVuZGluZ0lkeF0sIDEpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js":
/*!***************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/dispatcher-base.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js\")\nconst UnwrapHandler = __webpack_require__(/*! ../handler/unwrap-handler */ \"(rsc)/./node_modules/undici/lib/handler/unwrap-handler.js\")\nconst {\n  ClientDestroyedError,\n  ClientClosedError,\n  InvalidArgumentError\n} = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { kDestroy, kClose, kClosed, kDestroyed, kDispatch } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\nconst kOnDestroyed = Symbol('onDestroyed')\nconst kOnClosed = Symbol('onClosed')\n\nclass DispatcherBase extends Dispatcher {\n  constructor () {\n    super()\n\n    this[kDestroyed] = false\n    this[kOnDestroyed] = null\n    this[kClosed] = false\n    this[kOnClosed] = []\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  get closed () {\n    return this[kClosed]\n  }\n\n  close (callback) {\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.close((err, data) => {\n          return err ? reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      queueMicrotask(() => callback(new ClientDestroyedError(), null))\n      return\n    }\n\n    if (this[kClosed]) {\n      if (this[kOnClosed]) {\n        this[kOnClosed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    this[kClosed] = true\n    this[kOnClosed].push(callback)\n\n    const onClosed = () => {\n      const callbacks = this[kOnClosed]\n      this[kOnClosed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    // Should not error.\n    this[kClose]()\n      .then(() => this.destroy())\n      .then(() => {\n        queueMicrotask(onClosed)\n      })\n  }\n\n  destroy (err, callback) {\n    if (typeof err === 'function') {\n      callback = err\n      err = null\n    }\n\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.destroy(err, (err, data) => {\n          return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      if (this[kOnDestroyed]) {\n        this[kOnDestroyed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError()\n    }\n\n    this[kDestroyed] = true\n    this[kOnDestroyed] = this[kOnDestroyed] || []\n    this[kOnDestroyed].push(callback)\n\n    const onDestroyed = () => {\n      const callbacks = this[kOnDestroyed]\n      this[kOnDestroyed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    // Should not error.\n    this[kDestroy](err).then(() => {\n      queueMicrotask(onDestroyed)\n    })\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object')\n    }\n\n    handler = UnwrapHandler.unwrap(handler)\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.')\n      }\n\n      if (this[kDestroyed] || this[kOnDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError()\n      }\n\n      return this[kDispatch](opts, handler)\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw err\n      }\n\n      handler.onError(err)\n\n      return false\n    }\n  }\n}\n\nmodule.exports = DispatcherBase\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXItYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBYztBQUN6QyxzQkFBc0IsbUJBQU8sQ0FBQyw0RkFBMkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDNUIsUUFBUSxtREFBbUQsRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjs7QUFFdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci9kaXNwYXRjaGVyLWJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXInKVxuY29uc3QgVW53cmFwSGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvdW53cmFwLWhhbmRsZXInKVxuY29uc3Qge1xuICBDbGllbnREZXN0cm95ZWRFcnJvcixcbiAgQ2xpZW50Q2xvc2VkRXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgeyBrRGVzdHJveSwga0Nsb3NlLCBrQ2xvc2VkLCBrRGVzdHJveWVkLCBrRGlzcGF0Y2ggfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5cbmNvbnN0IGtPbkRlc3Ryb3llZCA9IFN5bWJvbCgnb25EZXN0cm95ZWQnKVxuY29uc3Qga09uQ2xvc2VkID0gU3ltYm9sKCdvbkNsb3NlZCcpXG5cbmNsYXNzIERpc3BhdGNoZXJCYXNlIGV4dGVuZHMgRGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzW2tEZXN0cm95ZWRdID0gZmFsc2VcbiAgICB0aGlzW2tPbkRlc3Ryb3llZF0gPSBudWxsXG4gICAgdGhpc1trQ2xvc2VkXSA9IGZhbHNlXG4gICAgdGhpc1trT25DbG9zZWRdID0gW11cbiAgfVxuXG4gIGdldCBkZXN0cm95ZWQgKCkge1xuICAgIHJldHVybiB0aGlzW2tEZXN0cm95ZWRdXG4gIH1cblxuICBnZXQgY2xvc2VkICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ2xvc2VkXVxuICB9XG5cbiAgY2xvc2UgKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2UoKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgIHJldHVybiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICB9XG5cbiAgICBpZiAodGhpc1trRGVzdHJveWVkXSkge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2sobmV3IENsaWVudERlc3Ryb3llZEVycm9yKCksIG51bGwpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0Nsb3NlZF0pIHtcbiAgICAgIGlmICh0aGlzW2tPbkNsb3NlZF0pIHtcbiAgICAgICAgdGhpc1trT25DbG9zZWRdLnB1c2goY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhudWxsLCBudWxsKSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXNba0Nsb3NlZF0gPSB0cnVlXG4gICAgdGhpc1trT25DbG9zZWRdLnB1c2goY2FsbGJhY2spXG5cbiAgICBjb25zdCBvbkNsb3NlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXNba09uQ2xvc2VkXVxuICAgICAgdGhpc1trT25DbG9zZWRdID0gbnVsbFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldKG51bGwsIG51bGwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2hvdWxkIG5vdCBlcnJvci5cbiAgICB0aGlzW2tDbG9zZV0oKVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcy5kZXN0cm95KCkpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKG9uQ2xvc2VkKVxuICAgICAgfSlcbiAgfVxuXG4gIGRlc3Ryb3kgKGVyciwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGVyciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBlcnJcbiAgICAgIGVyciA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5kZXN0cm95KGVyciwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgIHJldHVybiBlcnIgPyAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2hvdWxkIG5ldmVyIGVycm9yICovIHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgIH1cblxuICAgIGlmICh0aGlzW2tEZXN0cm95ZWRdKSB7XG4gICAgICBpZiAodGhpc1trT25EZXN0cm95ZWRdKSB7XG4gICAgICAgIHRoaXNba09uRGVzdHJveWVkXS5wdXNoKGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2sobnVsbCwgbnVsbCkpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIWVycikge1xuICAgICAgZXJyID0gbmV3IENsaWVudERlc3Ryb3llZEVycm9yKClcbiAgICB9XG5cbiAgICB0aGlzW2tEZXN0cm95ZWRdID0gdHJ1ZVxuICAgIHRoaXNba09uRGVzdHJveWVkXSA9IHRoaXNba09uRGVzdHJveWVkXSB8fCBbXVxuICAgIHRoaXNba09uRGVzdHJveWVkXS5wdXNoKGNhbGxiYWNrKVxuXG4gICAgY29uc3Qgb25EZXN0cm95ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzW2tPbkRlc3Ryb3llZF1cbiAgICAgIHRoaXNba09uRGVzdHJveWVkXSA9IG51bGxcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXShudWxsLCBudWxsKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNob3VsZCBub3QgZXJyb3IuXG4gICAgdGhpc1trRGVzdHJveV0oZXJyKS50aGVuKCgpID0+IHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKG9uRGVzdHJveWVkKVxuICAgIH0pXG4gIH1cblxuICBkaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAgIGlmICghaGFuZGxlciB8fCB0eXBlb2YgaGFuZGxlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGFuZGxlciBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgaGFuZGxlciA9IFVud3JhcEhhbmRsZXIudW53cmFwKGhhbmRsZXIpXG5cbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdHMgbXVzdCBiZSBhbiBvYmplY3QuJylcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNba0Rlc3Ryb3llZF0gfHwgdGhpc1trT25EZXN0cm95ZWRdKSB7XG4gICAgICAgIHRocm93IG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW2tDbG9zZWRdKSB7XG4gICAgICAgIHRocm93IG5ldyBDbGllbnRDbG9zZWRFcnJvcigpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzW2tEaXNwYXRjaF0ob3B0cywgaGFuZGxlcilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuXG4gICAgICBoYW5kbGVyLm9uRXJyb3IoZXJyKVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaXNwYXRjaGVyQmFzZVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/dispatcher.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EventEmitter = __webpack_require__(/*! node:events */ \"node:events\")\nconst WrapHandler = __webpack_require__(/*! ../handler/wrap-handler */ \"(rsc)/./node_modules/undici/lib/handler/wrap-handler.js\")\n\nconst wrapInterceptor = (dispatch) => (opts, handler) => dispatch(opts, WrapHandler.wrap(handler))\n\nclass Dispatcher extends EventEmitter {\n  dispatch () {\n    throw new Error('not implemented')\n  }\n\n  close () {\n    throw new Error('not implemented')\n  }\n\n  destroy () {\n    throw new Error('not implemented')\n  }\n\n  compose (...args) {\n    // So we handle [interceptor1, interceptor2] or interceptor1, interceptor2, ...\n    const interceptors = Array.isArray(args[0]) ? args[0] : args\n    let dispatch = this.dispatch.bind(this)\n\n    for (const interceptor of interceptors) {\n      if (interceptor == null) {\n        continue\n      }\n\n      if (typeof interceptor !== 'function') {\n        throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`)\n      }\n\n      dispatch = interceptor(dispatch)\n      dispatch = wrapInterceptor(dispatch)\n\n      if (dispatch == null || typeof dispatch !== 'function' || dispatch.length !== 2) {\n        throw new TypeError('invalid interceptor')\n      }\n    }\n\n    return new Proxy(this, {\n      get: (target, key) => key === 'dispatch' ? dispatch : target[key]\n    })\n  }\n}\n\nmodule.exports = Dispatcher\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixxQkFBcUIsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxvQkFBb0IsbUJBQU8sQ0FBQyx3RkFBeUI7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrRUFBK0UsbUJBQW1CO0FBQ2xHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJylcbmNvbnN0IFdyYXBIYW5kbGVyID0gcmVxdWlyZSgnLi4vaGFuZGxlci93cmFwLWhhbmRsZXInKVxuXG5jb25zdCB3cmFwSW50ZXJjZXB0b3IgPSAoZGlzcGF0Y2gpID0+IChvcHRzLCBoYW5kbGVyKSA9PiBkaXNwYXRjaChvcHRzLCBXcmFwSGFuZGxlci53cmFwKGhhbmRsZXIpKVxuXG5jbGFzcyBEaXNwYXRjaGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgZGlzcGF0Y2ggKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgfVxuXG4gIGNsb3NlICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gIH1cblxuICBjb21wb3NlICguLi5hcmdzKSB7XG4gICAgLy8gU28gd2UgaGFuZGxlIFtpbnRlcmNlcHRvcjEsIGludGVyY2VwdG9yMl0gb3IgaW50ZXJjZXB0b3IxLCBpbnRlcmNlcHRvcjIsIC4uLlxuICAgIGNvbnN0IGludGVyY2VwdG9ycyA9IEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJnc1xuICAgIGxldCBkaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKVxuXG4gICAgZm9yIChjb25zdCBpbnRlcmNlcHRvciBvZiBpbnRlcmNlcHRvcnMpIHtcbiAgICAgIGlmIChpbnRlcmNlcHRvciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW50ZXJjZXB0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBpbnRlcmNlcHRvciwgZXhwZWN0ZWQgZnVuY3Rpb24gcmVjZWl2ZWQgJHt0eXBlb2YgaW50ZXJjZXB0b3J9YClcbiAgICAgIH1cblxuICAgICAgZGlzcGF0Y2ggPSBpbnRlcmNlcHRvcihkaXNwYXRjaClcbiAgICAgIGRpc3BhdGNoID0gd3JhcEludGVyY2VwdG9yKGRpc3BhdGNoKVxuXG4gICAgICBpZiAoZGlzcGF0Y2ggPT0gbnVsbCB8fCB0eXBlb2YgZGlzcGF0Y2ggIT09ICdmdW5jdGlvbicgfHwgZGlzcGF0Y2gubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaW50ZXJjZXB0b3InKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgZ2V0OiAodGFyZ2V0LCBrZXkpID0+IGtleSA9PT0gJ2Rpc3BhdGNoJyA/IGRpc3BhdGNoIDogdGFyZ2V0W2tleV1cbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2hlclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js":
/*!********************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst ProxyAgent = __webpack_require__(/*! ./proxy-agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/proxy-agent.js\")\nconst Agent = __webpack_require__(/*! ./agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/agent.js\")\n\nconst DEFAULT_PORTS = {\n  'http:': 80,\n  'https:': 443\n}\n\nclass EnvHttpProxyAgent extends DispatcherBase {\n  #noProxyValue = null\n  #noProxyEntries = null\n  #opts = null\n\n  constructor (opts = {}) {\n    super()\n    this.#opts = opts\n\n    const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts\n\n    this[kNoProxyAgent] = new Agent(agentOpts)\n\n    const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY\n    if (HTTP_PROXY) {\n      this[kHttpProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTP_PROXY })\n    } else {\n      this[kHttpProxyAgent] = this[kNoProxyAgent]\n    }\n\n    const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY\n    if (HTTPS_PROXY) {\n      this[kHttpsProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTPS_PROXY })\n    } else {\n      this[kHttpsProxyAgent] = this[kHttpProxyAgent]\n    }\n\n    this.#parseNoProxy()\n  }\n\n  [kDispatch] (opts, handler) {\n    const url = new URL(opts.origin)\n    const agent = this.#getProxyAgentForUrl(url)\n    return agent.dispatch(opts, handler)\n  }\n\n  async [kClose] () {\n    await this[kNoProxyAgent].close()\n    if (!this[kHttpProxyAgent][kClosed]) {\n      await this[kHttpProxyAgent].close()\n    }\n    if (!this[kHttpsProxyAgent][kClosed]) {\n      await this[kHttpsProxyAgent].close()\n    }\n  }\n\n  async [kDestroy] (err) {\n    await this[kNoProxyAgent].destroy(err)\n    if (!this[kHttpProxyAgent][kDestroyed]) {\n      await this[kHttpProxyAgent].destroy(err)\n    }\n    if (!this[kHttpsProxyAgent][kDestroyed]) {\n      await this[kHttpsProxyAgent].destroy(err)\n    }\n  }\n\n  #getProxyAgentForUrl (url) {\n    let { protocol, host: hostname, port } = url\n\n    // Stripping ports in this way instead of using parsedUrl.hostname to make\n    // sure that the brackets around IPv6 addresses are kept.\n    hostname = hostname.replace(/:\\d*$/, '').toLowerCase()\n    port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0\n    if (!this.#shouldProxy(hostname, port)) {\n      return this[kNoProxyAgent]\n    }\n    if (protocol === 'https:') {\n      return this[kHttpsProxyAgent]\n    }\n    return this[kHttpProxyAgent]\n  }\n\n  #shouldProxy (hostname, port) {\n    if (this.#noProxyChanged) {\n      this.#parseNoProxy()\n    }\n\n    if (this.#noProxyEntries.length === 0) {\n      return true // Always proxy if NO_PROXY is not set or empty.\n    }\n    if (this.#noProxyValue === '*') {\n      return false // Never proxy if wildcard is set.\n    }\n\n    for (let i = 0; i < this.#noProxyEntries.length; i++) {\n      const entry = this.#noProxyEntries[i]\n      if (entry.port && entry.port !== port) {\n        continue // Skip if ports don't match.\n      }\n      if (!/^[.*]/.test(entry.hostname)) {\n        // No wildcards, so don't proxy only if there is not an exact match.\n        if (hostname === entry.hostname) {\n          return false\n        }\n      } else {\n        // Don't proxy if the hostname ends with the no_proxy host.\n        if (hostname.endsWith(entry.hostname.replace(/^\\*/, ''))) {\n          return false\n        }\n      }\n    }\n\n    return true\n  }\n\n  #parseNoProxy () {\n    const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv\n    const noProxySplit = noProxyValue.split(/[,\\s]/)\n    const noProxyEntries = []\n\n    for (let i = 0; i < noProxySplit.length; i++) {\n      const entry = noProxySplit[i]\n      if (!entry) {\n        continue\n      }\n      const parsed = entry.match(/^(.+):(\\d+)$/)\n      noProxyEntries.push({\n        hostname: (parsed ? parsed[1] : entry).toLowerCase(),\n        port: parsed ? Number.parseInt(parsed[2], 10) : 0\n      })\n    }\n\n    this.#noProxyValue = noProxyValue\n    this.#noProxyEntries = noProxyEntries\n  }\n\n  get #noProxyChanged () {\n    if (this.#opts.noProxy !== undefined) {\n      return false\n    }\n    return this.#noProxyValue !== this.#noProxyEnv\n  }\n\n  get #noProxyEnv () {\n    return process.env.no_proxy ?? process.env.NO_PROXY ?? ''\n  }\n}\n\nmodule.exports = EnvHttpProxyAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Vudi1odHRwLXByb3h5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLHVCQUF1QixtQkFBTyxDQUFDLHdGQUFtQjtBQUNsRCxRQUFRLHFHQUFxRyxFQUFFLG1CQUFPLENBQUMsd0VBQWlCO0FBQ3hJLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFlO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUEsWUFBWSwrQ0FBK0M7O0FBRTNEOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsK0JBQStCO0FBQzlFLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsZ0NBQWdDO0FBQ2hGLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxpQ0FBaUM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci9lbnYtaHR0cC1wcm94eS1hZ2VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCB7IGtDbG9zZSwga0Rlc3Ryb3ksIGtDbG9zZWQsIGtEZXN0cm95ZWQsIGtEaXNwYXRjaCwga05vUHJveHlBZ2VudCwga0h0dHBQcm94eUFnZW50LCBrSHR0cHNQcm94eUFnZW50IH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgUHJveHlBZ2VudCA9IHJlcXVpcmUoJy4vcHJveHktYWdlbnQnKVxuY29uc3QgQWdlbnQgPSByZXF1aXJlKCcuL2FnZW50JylcblxuY29uc3QgREVGQVVMVF9QT1JUUyA9IHtcbiAgJ2h0dHA6JzogODAsXG4gICdodHRwczonOiA0NDNcbn1cblxuY2xhc3MgRW52SHR0cFByb3h5QWdlbnQgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gICNub1Byb3h5VmFsdWUgPSBudWxsXG4gICNub1Byb3h5RW50cmllcyA9IG51bGxcbiAgI29wdHMgPSBudWxsXG5cbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLiNvcHRzID0gb3B0c1xuXG4gICAgY29uc3QgeyBodHRwUHJveHksIGh0dHBzUHJveHksIG5vUHJveHksIC4uLmFnZW50T3B0cyB9ID0gb3B0c1xuXG4gICAgdGhpc1trTm9Qcm94eUFnZW50XSA9IG5ldyBBZ2VudChhZ2VudE9wdHMpXG5cbiAgICBjb25zdCBIVFRQX1BST1hZID0gaHR0cFByb3h5ID8/IHByb2Nlc3MuZW52Lmh0dHBfcHJveHkgPz8gcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWVxuICAgIGlmIChIVFRQX1BST1hZKSB7XG4gICAgICB0aGlzW2tIdHRwUHJveHlBZ2VudF0gPSBuZXcgUHJveHlBZ2VudCh7IC4uLmFnZW50T3B0cywgdXJpOiBIVFRQX1BST1hZIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0h0dHBQcm94eUFnZW50XSA9IHRoaXNba05vUHJveHlBZ2VudF1cbiAgICB9XG5cbiAgICBjb25zdCBIVFRQU19QUk9YWSA9IGh0dHBzUHJveHkgPz8gcHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkgPz8gcHJvY2Vzcy5lbnYuSFRUUFNfUFJPWFlcbiAgICBpZiAoSFRUUFNfUFJPWFkpIHtcbiAgICAgIHRoaXNba0h0dHBzUHJveHlBZ2VudF0gPSBuZXcgUHJveHlBZ2VudCh7IC4uLmFnZW50T3B0cywgdXJpOiBIVFRQU19QUk9YWSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tIdHRwc1Byb3h5QWdlbnRdID0gdGhpc1trSHR0cFByb3h5QWdlbnRdXG4gICAgfVxuXG4gICAgdGhpcy4jcGFyc2VOb1Byb3h5KClcbiAgfVxuXG4gIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChvcHRzLm9yaWdpbilcbiAgICBjb25zdCBhZ2VudCA9IHRoaXMuI2dldFByb3h5QWdlbnRGb3JVcmwodXJsKVxuICAgIHJldHVybiBhZ2VudC5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGF3YWl0IHRoaXNba05vUHJveHlBZ2VudF0uY2xvc2UoKVxuICAgIGlmICghdGhpc1trSHR0cFByb3h5QWdlbnRdW2tDbG9zZWRdKSB7XG4gICAgICBhd2FpdCB0aGlzW2tIdHRwUHJveHlBZ2VudF0uY2xvc2UoKVxuICAgIH1cbiAgICBpZiAoIXRoaXNba0h0dHBzUHJveHlBZ2VudF1ba0Nsb3NlZF0pIHtcbiAgICAgIGF3YWl0IHRoaXNba0h0dHBzUHJveHlBZ2VudF0uY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKGVycikge1xuICAgIGF3YWl0IHRoaXNba05vUHJveHlBZ2VudF0uZGVzdHJveShlcnIpXG4gICAgaWYgKCF0aGlzW2tIdHRwUHJveHlBZ2VudF1ba0Rlc3Ryb3llZF0pIHtcbiAgICAgIGF3YWl0IHRoaXNba0h0dHBQcm94eUFnZW50XS5kZXN0cm95KGVycilcbiAgICB9XG4gICAgaWYgKCF0aGlzW2tIdHRwc1Byb3h5QWdlbnRdW2tEZXN0cm95ZWRdKSB7XG4gICAgICBhd2FpdCB0aGlzW2tIdHRwc1Byb3h5QWdlbnRdLmRlc3Ryb3koZXJyKVxuICAgIH1cbiAgfVxuXG4gICNnZXRQcm94eUFnZW50Rm9yVXJsICh1cmwpIHtcbiAgICBsZXQgeyBwcm90b2NvbCwgaG9zdDogaG9zdG5hbWUsIHBvcnQgfSA9IHVybFxuXG4gICAgLy8gU3RyaXBwaW5nIHBvcnRzIGluIHRoaXMgd2F5IGluc3RlYWQgb2YgdXNpbmcgcGFyc2VkVXJsLmhvc3RuYW1lIHRvIG1ha2VcbiAgICAvLyBzdXJlIHRoYXQgdGhlIGJyYWNrZXRzIGFyb3VuZCBJUHY2IGFkZHJlc3NlcyBhcmUga2VwdC5cbiAgICBob3N0bmFtZSA9IGhvc3RuYW1lLnJlcGxhY2UoLzpcXGQqJC8sICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgcG9ydCA9IE51bWJlci5wYXJzZUludChwb3J0LCAxMCkgfHwgREVGQVVMVF9QT1JUU1twcm90b2NvbF0gfHwgMFxuICAgIGlmICghdGhpcy4jc2hvdWxkUHJveHkoaG9zdG5hbWUsIHBvcnQpKSB7XG4gICAgICByZXR1cm4gdGhpc1trTm9Qcm94eUFnZW50XVxuICAgIH1cbiAgICBpZiAocHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICByZXR1cm4gdGhpc1trSHR0cHNQcm94eUFnZW50XVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1trSHR0cFByb3h5QWdlbnRdXG4gIH1cblxuICAjc2hvdWxkUHJveHkgKGhvc3RuYW1lLCBwb3J0KSB7XG4gICAgaWYgKHRoaXMuI25vUHJveHlDaGFuZ2VkKSB7XG4gICAgICB0aGlzLiNwYXJzZU5vUHJveHkoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLiNub1Byb3h5RW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlIC8vIEFsd2F5cyBwcm94eSBpZiBOT19QUk9YWSBpcyBub3Qgc2V0IG9yIGVtcHR5LlxuICAgIH1cbiAgICBpZiAodGhpcy4jbm9Qcm94eVZhbHVlID09PSAnKicpIHtcbiAgICAgIHJldHVybiBmYWxzZSAvLyBOZXZlciBwcm94eSBpZiB3aWxkY2FyZCBpcyBzZXQuXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLiNub1Byb3h5RW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLiNub1Byb3h5RW50cmllc1tpXVxuICAgICAgaWYgKGVudHJ5LnBvcnQgJiYgZW50cnkucG9ydCAhPT0gcG9ydCkge1xuICAgICAgICBjb250aW51ZSAvLyBTa2lwIGlmIHBvcnRzIGRvbid0IG1hdGNoLlxuICAgICAgfVxuICAgICAgaWYgKCEvXlsuKl0vLnRlc3QoZW50cnkuaG9zdG5hbWUpKSB7XG4gICAgICAgIC8vIE5vIHdpbGRjYXJkcywgc28gZG9uJ3QgcHJveHkgb25seSBpZiB0aGVyZSBpcyBub3QgYW4gZXhhY3QgbWF0Y2guXG4gICAgICAgIGlmIChob3N0bmFtZSA9PT0gZW50cnkuaG9zdG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRG9uJ3QgcHJveHkgaWYgdGhlIGhvc3RuYW1lIGVuZHMgd2l0aCB0aGUgbm9fcHJveHkgaG9zdC5cbiAgICAgICAgaWYgKGhvc3RuYW1lLmVuZHNXaXRoKGVudHJ5Lmhvc3RuYW1lLnJlcGxhY2UoL15cXCovLCAnJykpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgI3BhcnNlTm9Qcm94eSAoKSB7XG4gICAgY29uc3Qgbm9Qcm94eVZhbHVlID0gdGhpcy4jb3B0cy5ub1Byb3h5ID8/IHRoaXMuI25vUHJveHlFbnZcbiAgICBjb25zdCBub1Byb3h5U3BsaXQgPSBub1Byb3h5VmFsdWUuc3BsaXQoL1ssXFxzXS8pXG4gICAgY29uc3Qgbm9Qcm94eUVudHJpZXMgPSBbXVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub1Byb3h5U3BsaXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gbm9Qcm94eVNwbGl0W2ldXG4gICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZWQgPSBlbnRyeS5tYXRjaCgvXiguKyk6KFxcZCspJC8pXG4gICAgICBub1Byb3h5RW50cmllcy5wdXNoKHtcbiAgICAgICAgaG9zdG5hbWU6IChwYXJzZWQgPyBwYXJzZWRbMV0gOiBlbnRyeSkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgcG9ydDogcGFyc2VkID8gTnVtYmVyLnBhcnNlSW50KHBhcnNlZFsyXSwgMTApIDogMFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLiNub1Byb3h5VmFsdWUgPSBub1Byb3h5VmFsdWVcbiAgICB0aGlzLiNub1Byb3h5RW50cmllcyA9IG5vUHJveHlFbnRyaWVzXG4gIH1cblxuICBnZXQgI25vUHJveHlDaGFuZ2VkICgpIHtcbiAgICBpZiAodGhpcy4jb3B0cy5ub1Byb3h5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jbm9Qcm94eVZhbHVlICE9PSB0aGlzLiNub1Byb3h5RW52XG4gIH1cblxuICBnZXQgI25vUHJveHlFbnYgKCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5ub19wcm94eSA/PyBwcm9jZXNzLmVudi5OT19QUk9YWSA/PyAnJ1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRW52SHR0cFByb3h5QWdlbnRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/fixed-queue.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/fixed-queue.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\n\n// Extracted from node/lib/internal/fixed_queue.js\n\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048\nconst kMask = kSize - 1\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       | undefined |\n// |   item    |               |   item    |                  | undefined |\n// |   item    |               |   item    |                  | undefined |\n// |   item    |               |   item    |                  | undefined |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// | undefined | <-- top       |   item    |                  |   item    |\n// | undefined |               |   item    |                  |   item    |\n// | undefined |               | undefined | <-- top  top --> | undefined |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// | undefined |                               |   item    |\n// | undefined |                               |   item    |\n// |   item    | <-- bottom            top --> | undefined |\n// |   item    |                               | undefined |\n// | undefined | <-- top            bottom --> |   item    |\n// | undefined |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\n/**\n * @type {FixedCircularBuffer}\n * @template T\n */\nclass FixedCircularBuffer {\n  constructor () {\n    /**\n     * @type {number}\n     */\n    this.bottom = 0\n    /**\n     * @type {number}\n     */\n    this.top = 0\n    /**\n     * @type {Array<T|undefined>}\n     */\n    this.list = new Array(kSize).fill(undefined)\n    /**\n     * @type {T|null}\n     */\n    this.next = null\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  isEmpty () {\n    return this.top === this.bottom\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  isFull () {\n    return ((this.top + 1) & kMask) === this.bottom\n  }\n\n  /**\n   * @param {T} data\n   * @returns {void}\n   */\n  push (data) {\n    this.list[this.top] = data\n    this.top = (this.top + 1) & kMask\n  }\n\n  /**\n   * @returns {T|null}\n   */\n  shift () {\n    const nextItem = this.list[this.bottom]\n    if (nextItem === undefined) { return null }\n    this.list[this.bottom] = undefined\n    this.bottom = (this.bottom + 1) & kMask\n    return nextItem\n  }\n}\n\n/**\n * @template T\n */\nmodule.exports = class FixedQueue {\n  constructor () {\n    /**\n     * @type {FixedCircularBuffer<T>}\n     */\n    this.head = this.tail = new FixedCircularBuffer()\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  isEmpty () {\n    return this.head.isEmpty()\n  }\n\n  /**\n   * @param {T} data\n   */\n  push (data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer()\n    }\n    this.head.push(data)\n  }\n\n  /**\n   * @returns {T|null}\n   */\n  shift () {\n    const tail = this.tail\n    const next = tail.shift()\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next\n      tail.next = null\n    }\n    return next\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2ZpeGVkLXF1ZXVlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2ZpeGVkLXF1ZXVlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBFeHRyYWN0ZWQgZnJvbSBub2RlL2xpYi9pbnRlcm5hbC9maXhlZF9xdWV1ZS5qc1xuXG4vLyBDdXJyZW50bHkgb3B0aW1hbCBxdWV1ZSBzaXplLCB0ZXN0ZWQgb24gVjggNi4wIC0gNi42LiBNdXN0IGJlIHBvd2VyIG9mIHR3by5cbmNvbnN0IGtTaXplID0gMjA0OFxuY29uc3Qga01hc2sgPSBrU2l6ZSAtIDFcblxuLy8gVGhlIEZpeGVkUXVldWUgaXMgaW1wbGVtZW50ZWQgYXMgYSBzaW5nbHktbGlua2VkIGxpc3Qgb2YgZml4ZWQtc2l6ZVxuLy8gY2lyY3VsYXIgYnVmZmVycy4gSXQgbG9va3Mgc29tZXRoaW5nIGxpa2UgdGhpczpcbi8vXG4vLyAgaGVhZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWlsXG4vLyAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbi8vICAgIHYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdlxuLy8gKy0tLS0tLS0tLS0tKyA8LS0tLS1cXCAgICAgICArLS0tLS0tLS0tLS0rIDwtLS0tLS1cXCAgICAgICAgICstLS0tLS0tLS0tLStcbi8vIHwgIFtudWxsXSAgIHwgICAgICAgIFxcLS0tLS0gfCAgIG5leHQgICAgfCAgICAgICAgIFxcLS0tLS0tLSB8ICAgbmV4dCAgICB8XG4vLyArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbi8vIHwgICBpdGVtICAgIHwgPC0tIGJvdHRvbSAgICB8ICAgaXRlbSAgICB8IDwtLSBib3R0b20gICAgICAgfCB1bmRlZmluZWQgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8IHVuZGVmaW5lZCB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgdW5kZWZpbmVkIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCB1bmRlZmluZWQgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgYm90dG9tIC0tPiB8ICAgaXRlbSAgICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgICAgLi4uICAgIHwgICAgICAgICAgICAgICB8ICAgIC4uLiAgICB8ICAgICAgICAgICAgICAgICAgfCAgICAuLi4gICAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgdW5kZWZpbmVkIHwgPC0tIHRvcCAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCB1bmRlZmluZWQgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8IHVuZGVmaW5lZCB8ICAgICAgICAgICAgICAgfCB1bmRlZmluZWQgfCA8LS0gdG9wICB0b3AgLS0+IHwgdW5kZWZpbmVkIHxcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy9cbi8vIE9yLCBpZiB0aGVyZSBpcyBvbmx5IG9uZSBjaXJjdWxhciBidWZmZXIsIGl0IGxvb2tzIHNvbWV0aGluZ1xuLy8gbGlrZSBlaXRoZXIgb2YgdGhlc2U6XG4vL1xuLy8gIGhlYWQgICB0YWlsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZCAgIHRhaWxcbi8vICAgIHwgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgfFxuLy8gICAgdiAgICAgdiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ICAgICB2XG4vLyArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbi8vIHwgIFtudWxsXSAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgW251bGxdICAgfFxuLy8gKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4vLyB8IHVuZGVmaW5lZCB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgdW5kZWZpbmVkIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgIGl0ZW0gICAgfCA8LS0gYm90dG9tICAgICAgICAgICAgdG9wIC0tPiB8IHVuZGVmaW5lZCB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdW5kZWZpbmVkIHxcbi8vIHwgdW5kZWZpbmVkIHwgPC0tIHRvcCAgICAgICAgICAgIGJvdHRvbSAtLT4gfCAgIGl0ZW0gICAgfFxuLy8gfCB1bmRlZmluZWQgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbi8vXG4vLyBBZGRpbmcgYSB2YWx1ZSBtZWFucyBtb3ZpbmcgYHRvcGAgZm9yd2FyZCBieSBvbmUsIHJlbW92aW5nIG1lYW5zXG4vLyBtb3ZpbmcgYGJvdHRvbWAgZm9yd2FyZCBieSBvbmUuIEFmdGVyIHJlYWNoaW5nIHRoZSBlbmQsIHRoZSBxdWV1ZVxuLy8gd3JhcHMgYXJvdW5kLlxuLy9cbi8vIFdoZW4gYHRvcCA9PT0gYm90dG9tYCB0aGUgY3VycmVudCBxdWV1ZSBpcyBlbXB0eSBhbmQgd2hlblxuLy8gYHRvcCArIDEgPT09IGJvdHRvbWAgaXQncyBmdWxsLiBUaGlzIHdhc3RlcyBhIHNpbmdsZSBzcGFjZSBvZiBzdG9yYWdlXG4vLyBidXQgYWxsb3dzIG11Y2ggcXVpY2tlciBjaGVja3MuXG5cbi8qKlxuICogQHR5cGUge0ZpeGVkQ2lyY3VsYXJCdWZmZXJ9XG4gKiBAdGVtcGxhdGUgVFxuICovXG5jbGFzcyBGaXhlZENpcmN1bGFyQnVmZmVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ib3R0b20gPSAwXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRvcCA9IDBcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8VHx1bmRlZmluZWQ+fVxuICAgICAqL1xuICAgIHRoaXMubGlzdCA9IG5ldyBBcnJheShrU2l6ZSkuZmlsbCh1bmRlZmluZWQpXG4gICAgLyoqXG4gICAgICogQHR5cGUge1R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0VtcHR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy50b3AgPT09IHRoaXMuYm90dG9tXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0Z1bGwgKCkge1xuICAgIHJldHVybiAoKHRoaXMudG9wICsgMSkgJiBrTWFzaykgPT09IHRoaXMuYm90dG9tXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUfSBkYXRhXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcHVzaCAoZGF0YSkge1xuICAgIHRoaXMubGlzdFt0aGlzLnRvcF0gPSBkYXRhXG4gICAgdGhpcy50b3AgPSAodGhpcy50b3AgKyAxKSAmIGtNYXNrXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge1R8bnVsbH1cbiAgICovXG4gIHNoaWZ0ICgpIHtcbiAgICBjb25zdCBuZXh0SXRlbSA9IHRoaXMubGlzdFt0aGlzLmJvdHRvbV1cbiAgICBpZiAobmV4dEl0ZW0gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gbnVsbCB9XG4gICAgdGhpcy5saXN0W3RoaXMuYm90dG9tXSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuYm90dG9tID0gKHRoaXMuYm90dG9tICsgMSkgJiBrTWFza1xuICAgIHJldHVybiBuZXh0SXRlbVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBGaXhlZFF1ZXVlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtGaXhlZENpcmN1bGFyQnVmZmVyPFQ+fVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBGaXhlZENpcmN1bGFyQnVmZmVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRW1wdHkgKCkge1xuICAgIHJldHVybiB0aGlzLmhlYWQuaXNFbXB0eSgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUfSBkYXRhXG4gICAqL1xuICBwdXNoIChkYXRhKSB7XG4gICAgaWYgKHRoaXMuaGVhZC5pc0Z1bGwoKSkge1xuICAgICAgLy8gSGVhZCBpcyBmdWxsOiBDcmVhdGVzIGEgbmV3IHF1ZXVlLCBzZXRzIHRoZSBvbGQgcXVldWUncyBgLm5leHRgIHRvIGl0LFxuICAgICAgLy8gYW5kIHNldHMgaXQgYXMgdGhlIG5ldyBtYWluIHF1ZXVlLlxuICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQgPSBuZXcgRml4ZWRDaXJjdWxhckJ1ZmZlcigpXG4gICAgfVxuICAgIHRoaXMuaGVhZC5wdXNoKGRhdGEpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge1R8bnVsbH1cbiAgICovXG4gIHNoaWZ0ICgpIHtcbiAgICBjb25zdCB0YWlsID0gdGhpcy50YWlsXG4gICAgY29uc3QgbmV4dCA9IHRhaWwuc2hpZnQoKVxuICAgIGlmICh0YWlsLmlzRW1wdHkoKSAmJiB0YWlsLm5leHQgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGFub3RoZXIgcXVldWUsIGl0IGZvcm1zIHRoZSBuZXcgdGFpbC5cbiAgICAgIHRoaXMudGFpbCA9IHRhaWwubmV4dFxuICAgICAgdGFpbC5uZXh0ID0gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gbmV4dFxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/fixed-queue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/h2c-client.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/h2c-client.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { connect } = __webpack_require__(/*! node:net */ \"node:net\")\n\nconst { kClose, kDestroy } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nconst Client = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\n\nclass H2CClient extends DispatcherBase {\n  #client = null\n\n  constructor (origin, clientOpts) {\n    super()\n\n    if (typeof origin === 'string') {\n      origin = new URL(origin)\n    }\n\n    if (origin.protocol !== 'http:') {\n      throw new InvalidArgumentError(\n        'h2c-client: Only h2c protocol is supported'\n      )\n    }\n\n    const { connect, maxConcurrentStreams, pipelining, ...opts } =\n      clientOpts ?? {}\n    let defaultMaxConcurrentStreams = 100\n    let defaultPipelining = 100\n\n    if (\n      maxConcurrentStreams != null &&\n      Number.isInteger(maxConcurrentStreams) &&\n      maxConcurrentStreams > 0\n    ) {\n      defaultMaxConcurrentStreams = maxConcurrentStreams\n    }\n\n    if (pipelining != null && Number.isInteger(pipelining) && pipelining > 0) {\n      defaultPipelining = pipelining\n    }\n\n    if (defaultPipelining > defaultMaxConcurrentStreams) {\n      throw new InvalidArgumentError(\n        'h2c-client: pipelining cannot be greater than maxConcurrentStreams'\n      )\n    }\n\n    this.#client = new Client(origin, {\n      ...opts,\n      connect: this.#buildConnector(connect),\n      maxConcurrentStreams: defaultMaxConcurrentStreams,\n      pipelining: defaultPipelining,\n      allowH2: true\n    })\n  }\n\n  #buildConnector (connectOpts) {\n    return (opts, callback) => {\n      const timeout = connectOpts?.connectOpts ?? 10e3\n      const { hostname, port, pathname } = opts\n      const socket = connect({\n        ...opts,\n        host: hostname,\n        port,\n        pathname\n      })\n\n      // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n      if (opts.keepAlive == null || opts.keepAlive) {\n        const keepAliveInitialDelay =\n          opts.keepAliveInitialDelay == null ? 60e3 : opts.keepAliveInitialDelay\n        socket.setKeepAlive(true, keepAliveInitialDelay)\n      }\n\n      socket.alpnProtocol = 'h2'\n\n      const clearConnectTimeout = util.setupConnectTimeout(\n        new WeakRef(socket),\n        { timeout, hostname, port }\n      )\n\n      socket\n        .setNoDelay(true)\n        .once('connect', function () {\n          queueMicrotask(clearConnectTimeout)\n\n          if (callback) {\n            const cb = callback\n            callback = null\n            cb(null, this)\n          }\n        })\n        .on('error', function (err) {\n          queueMicrotask(clearConnectTimeout)\n\n          if (callback) {\n            const cb = callback\n            callback = null\n            cb(err)\n          }\n        })\n\n      return socket\n    }\n  }\n\n  dispatch (opts, handler) {\n    return this.#client.dispatch(opts, handler)\n  }\n\n  async [kClose] () {\n    await this.#client.close()\n  }\n\n  async [kDestroy] () {\n    await this.#client.destroy()\n  }\n}\n\nmodule.exports = H2CClient\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2gyYy1jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLDBCQUFVOztBQUV0QyxRQUFRLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsd0VBQWlCO0FBQ3RELFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDekQsYUFBYSxtQkFBTyxDQUFDLGtFQUFjOztBQUVuQyxlQUFlLG1CQUFPLENBQUMsc0VBQVU7QUFDakMsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQW1COztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxxREFBcUQ7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci9oMmMtY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgeyBjb25uZWN0IH0gPSByZXF1aXJlKCdub2RlOm5ldCcpXG5cbmNvbnN0IHsga0Nsb3NlLCBrRGVzdHJveSB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpXG5jb25zdCBEaXNwYXRjaGVyQmFzZSA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci1iYXNlJylcblxuY2xhc3MgSDJDQ2xpZW50IGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICAjY2xpZW50ID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yIChvcmlnaW4sIGNsaWVudE9wdHMpIHtcbiAgICBzdXBlcigpXG5cbiAgICBpZiAodHlwZW9mIG9yaWdpbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9yaWdpbiA9IG5ldyBVUkwob3JpZ2luKVxuICAgIH1cblxuICAgIGlmIChvcmlnaW4ucHJvdG9jb2wgIT09ICdodHRwOicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgJ2gyYy1jbGllbnQ6IE9ubHkgaDJjIHByb3RvY29sIGlzIHN1cHBvcnRlZCdcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCB7IGNvbm5lY3QsIG1heENvbmN1cnJlbnRTdHJlYW1zLCBwaXBlbGluaW5nLCAuLi5vcHRzIH0gPVxuICAgICAgY2xpZW50T3B0cyA/PyB7fVxuICAgIGxldCBkZWZhdWx0TWF4Q29uY3VycmVudFN0cmVhbXMgPSAxMDBcbiAgICBsZXQgZGVmYXVsdFBpcGVsaW5pbmcgPSAxMDBcblxuICAgIGlmIChcbiAgICAgIG1heENvbmN1cnJlbnRTdHJlYW1zICE9IG51bGwgJiZcbiAgICAgIE51bWJlci5pc0ludGVnZXIobWF4Q29uY3VycmVudFN0cmVhbXMpICYmXG4gICAgICBtYXhDb25jdXJyZW50U3RyZWFtcyA+IDBcbiAgICApIHtcbiAgICAgIGRlZmF1bHRNYXhDb25jdXJyZW50U3RyZWFtcyA9IG1heENvbmN1cnJlbnRTdHJlYW1zXG4gICAgfVxuXG4gICAgaWYgKHBpcGVsaW5pbmcgIT0gbnVsbCAmJiBOdW1iZXIuaXNJbnRlZ2VyKHBpcGVsaW5pbmcpICYmIHBpcGVsaW5pbmcgPiAwKSB7XG4gICAgICBkZWZhdWx0UGlwZWxpbmluZyA9IHBpcGVsaW5pbmdcbiAgICB9XG5cbiAgICBpZiAoZGVmYXVsdFBpcGVsaW5pbmcgPiBkZWZhdWx0TWF4Q29uY3VycmVudFN0cmVhbXMpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgJ2gyYy1jbGllbnQ6IHBpcGVsaW5pbmcgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiBtYXhDb25jdXJyZW50U3RyZWFtcydcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLiNjbGllbnQgPSBuZXcgQ2xpZW50KG9yaWdpbiwge1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGNvbm5lY3Q6IHRoaXMuI2J1aWxkQ29ubmVjdG9yKGNvbm5lY3QpLFxuICAgICAgbWF4Q29uY3VycmVudFN0cmVhbXM6IGRlZmF1bHRNYXhDb25jdXJyZW50U3RyZWFtcyxcbiAgICAgIHBpcGVsaW5pbmc6IGRlZmF1bHRQaXBlbGluaW5nLFxuICAgICAgYWxsb3dIMjogdHJ1ZVxuICAgIH0pXG4gIH1cblxuICAjYnVpbGRDb25uZWN0b3IgKGNvbm5lY3RPcHRzKSB7XG4gICAgcmV0dXJuIChvcHRzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgdGltZW91dCA9IGNvbm5lY3RPcHRzPy5jb25uZWN0T3B0cyA/PyAxMGUzXG4gICAgICBjb25zdCB7IGhvc3RuYW1lLCBwb3J0LCBwYXRobmFtZSB9ID0gb3B0c1xuICAgICAgY29uc3Qgc29ja2V0ID0gY29ubmVjdCh7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGhvc3Q6IGhvc3RuYW1lLFxuICAgICAgICBwb3J0LFxuICAgICAgICBwYXRobmFtZVxuICAgICAgfSlcblxuICAgICAgLy8gU2V0IFRDUCBrZWVwIGFsaXZlIG9wdGlvbnMgb24gdGhlIHNvY2tldCBoZXJlIGluc3RlYWQgb2YgaW4gY29ubmVjdCgpIGZvciB0aGUgY2FzZSBvZiBhc3NpZ25pbmcgdGhlIHNvY2tldFxuICAgICAgaWYgKG9wdHMua2VlcEFsaXZlID09IG51bGwgfHwgb3B0cy5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29uc3Qga2VlcEFsaXZlSW5pdGlhbERlbGF5ID1cbiAgICAgICAgICBvcHRzLmtlZXBBbGl2ZUluaXRpYWxEZWxheSA9PSBudWxsID8gNjBlMyA6IG9wdHMua2VlcEFsaXZlSW5pdGlhbERlbGF5XG4gICAgICAgIHNvY2tldC5zZXRLZWVwQWxpdmUodHJ1ZSwga2VlcEFsaXZlSW5pdGlhbERlbGF5KVxuICAgICAgfVxuXG4gICAgICBzb2NrZXQuYWxwblByb3RvY29sID0gJ2gyJ1xuXG4gICAgICBjb25zdCBjbGVhckNvbm5lY3RUaW1lb3V0ID0gdXRpbC5zZXR1cENvbm5lY3RUaW1lb3V0KFxuICAgICAgICBuZXcgV2Vha1JlZihzb2NrZXQpLFxuICAgICAgICB7IHRpbWVvdXQsIGhvc3RuYW1lLCBwb3J0IH1cbiAgICAgIClcblxuICAgICAgc29ja2V0XG4gICAgICAgIC5zZXROb0RlbGF5KHRydWUpXG4gICAgICAgIC5vbmNlKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKGNsZWFyQ29ubmVjdFRpbWVvdXQpXG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbFxuICAgICAgICAgICAgY2IobnVsbCwgdGhpcylcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soY2xlYXJDb25uZWN0VGltZW91dClcblxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY29uc3QgY2IgPSBjYWxsYmFja1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsXG4gICAgICAgICAgICBjYihlcnIpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICByZXR1cm4gc29ja2V0XG4gICAgfVxuICB9XG5cbiAgZGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gdGhpcy4jY2xpZW50LmRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgYXdhaXQgdGhpcy4jY2xpZW50LmNsb3NlKClcbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKCkge1xuICAgIGF3YWl0IHRoaXMuI2NsaWVudC5kZXN0cm95KClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEgyQ0NsaWVudFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/h2c-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/pool-base.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool-base.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { PoolStats } = __webpack_require__(/*! ../util/stats.js */ \"(rsc)/./node_modules/undici/lib/util/stats.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst FixedQueue = __webpack_require__(/*! ./fixed-queue */ \"(rsc)/./node_modules/undici/lib/dispatcher/fixed-queue.js\")\nconst { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\nconst kClients = Symbol('clients')\nconst kNeedDrain = Symbol('needDrain')\nconst kQueue = Symbol('queue')\nconst kClosedResolve = Symbol('closed resolve')\nconst kOnDrain = Symbol('onDrain')\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kGetDispatcher = Symbol('get dispatcher')\nconst kAddClient = Symbol('add client')\nconst kRemoveClient = Symbol('remove client')\n\nclass PoolBase extends DispatcherBase {\n  constructor () {\n    super()\n\n    this[kQueue] = new FixedQueue()\n    this[kClients] = []\n    this[kQueued] = 0\n\n    const pool = this\n\n    this[kOnDrain] = function onDrain (origin, targets) {\n      const queue = pool[kQueue]\n\n      let needDrain = false\n\n      while (!needDrain) {\n        const item = queue.shift()\n        if (!item) {\n          break\n        }\n        pool[kQueued]--\n        needDrain = !this.dispatch(item.opts, item.handler)\n      }\n\n      this[kNeedDrain] = needDrain\n\n      if (!this[kNeedDrain] && pool[kNeedDrain]) {\n        pool[kNeedDrain] = false\n        pool.emit('drain', origin, [pool, ...targets])\n      }\n\n      if (pool[kClosedResolve] && queue.isEmpty()) {\n        Promise\n          .all(pool[kClients].map(c => c.close()))\n          .then(pool[kClosedResolve])\n      }\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      pool.emit('connect', origin, [pool, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      pool.emit('disconnect', origin, [pool, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      pool.emit('connectionError', origin, [pool, ...targets], err)\n    }\n  }\n\n  get [kBusy] () {\n    return this[kNeedDrain]\n  }\n\n  get [kConnected] () {\n    return this[kClients].filter(client => client[kConnected]).length\n  }\n\n  get [kFree] () {\n    return this[kClients].filter(client => client[kConnected] && !client[kNeedDrain]).length\n  }\n\n  get [kPending] () {\n    let ret = this[kQueued]\n    for (const { [kPending]: pending } of this[kClients]) {\n      ret += pending\n    }\n    return ret\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const { [kRunning]: running } of this[kClients]) {\n      ret += running\n    }\n    return ret\n  }\n\n  get [kSize] () {\n    let ret = this[kQueued]\n    for (const { [kSize]: size } of this[kClients]) {\n      ret += size\n    }\n    return ret\n  }\n\n  get stats () {\n    return new PoolStats(this)\n  }\n\n  async [kClose] () {\n    if (this[kQueue].isEmpty()) {\n      await Promise.all(this[kClients].map(c => c.close()))\n    } else {\n      await new Promise((resolve) => {\n        this[kClosedResolve] = resolve\n      })\n    }\n  }\n\n  async [kDestroy] (err) {\n    while (true) {\n      const item = this[kQueue].shift()\n      if (!item) {\n        break\n      }\n      item.handler.onError(err)\n    }\n\n    await Promise.all(this[kClients].map(c => c.destroy(err)))\n  }\n\n  [kDispatch] (opts, handler) {\n    const dispatcher = this[kGetDispatcher]()\n\n    if (!dispatcher) {\n      this[kNeedDrain] = true\n      this[kQueue].push({ opts, handler })\n      this[kQueued]++\n    } else if (!dispatcher.dispatch(opts, handler)) {\n      dispatcher[kNeedDrain] = true\n      this[kNeedDrain] = !this[kGetDispatcher]()\n    }\n\n    return !this[kNeedDrain]\n  }\n\n  [kAddClient] (client) {\n    client\n      .on('drain', this[kOnDrain])\n      .on('connect', this[kOnConnect])\n      .on('disconnect', this[kOnDisconnect])\n      .on('connectionError', this[kOnConnectionError])\n\n    this[kClients].push(client)\n\n    if (this[kNeedDrain]) {\n      queueMicrotask(() => {\n        if (this[kNeedDrain]) {\n          this[kOnDrain](client[kUrl], [this, client])\n        }\n      })\n    }\n\n    return this\n  }\n\n  [kRemoveClient] (client) {\n    client.close(() => {\n      const idx = this[kClients].indexOf(client)\n      if (idx !== -1) {\n        this[kClients].splice(idx, 1)\n      }\n    })\n\n    this[kNeedDrain] = this[kClients].some(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n  }\n}\n\nmodule.exports = {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wtYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLHVFQUFrQjtBQUNoRCx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWU7QUFDMUMsUUFBUSxrR0FBa0csRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjs7QUFFckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci9wb29sLWJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgUG9vbFN0YXRzIH0gPSByZXF1aXJlKCcuLi91dGlsL3N0YXRzLmpzJylcbmNvbnN0IERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLWJhc2UnKVxuY29uc3QgRml4ZWRRdWV1ZSA9IHJlcXVpcmUoJy4vZml4ZWQtcXVldWUnKVxuY29uc3QgeyBrQ29ubmVjdGVkLCBrU2l6ZSwga1J1bm5pbmcsIGtQZW5kaW5nLCBrUXVldWVkLCBrQnVzeSwga0ZyZWUsIGtVcmwsIGtDbG9zZSwga0Rlc3Ryb3ksIGtEaXNwYXRjaCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcblxuY29uc3Qga0NsaWVudHMgPSBTeW1ib2woJ2NsaWVudHMnKVxuY29uc3Qga05lZWREcmFpbiA9IFN5bWJvbCgnbmVlZERyYWluJylcbmNvbnN0IGtRdWV1ZSA9IFN5bWJvbCgncXVldWUnKVxuY29uc3Qga0Nsb3NlZFJlc29sdmUgPSBTeW1ib2woJ2Nsb3NlZCByZXNvbHZlJylcbmNvbnN0IGtPbkRyYWluID0gU3ltYm9sKCdvbkRyYWluJylcbmNvbnN0IGtPbkNvbm5lY3QgPSBTeW1ib2woJ29uQ29ubmVjdCcpXG5jb25zdCBrT25EaXNjb25uZWN0ID0gU3ltYm9sKCdvbkRpc2Nvbm5lY3QnKVxuY29uc3Qga09uQ29ubmVjdGlvbkVycm9yID0gU3ltYm9sKCdvbkNvbm5lY3Rpb25FcnJvcicpXG5jb25zdCBrR2V0RGlzcGF0Y2hlciA9IFN5bWJvbCgnZ2V0IGRpc3BhdGNoZXInKVxuY29uc3Qga0FkZENsaWVudCA9IFN5bWJvbCgnYWRkIGNsaWVudCcpXG5jb25zdCBrUmVtb3ZlQ2xpZW50ID0gU3ltYm9sKCdyZW1vdmUgY2xpZW50JylcblxuY2xhc3MgUG9vbEJhc2UgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzW2tRdWV1ZV0gPSBuZXcgRml4ZWRRdWV1ZSgpXG4gICAgdGhpc1trQ2xpZW50c10gPSBbXVxuICAgIHRoaXNba1F1ZXVlZF0gPSAwXG5cbiAgICBjb25zdCBwb29sID0gdGhpc1xuXG4gICAgdGhpc1trT25EcmFpbl0gPSBmdW5jdGlvbiBvbkRyYWluIChvcmlnaW4sIHRhcmdldHMpIHtcbiAgICAgIGNvbnN0IHF1ZXVlID0gcG9vbFtrUXVldWVdXG5cbiAgICAgIGxldCBuZWVkRHJhaW4gPSBmYWxzZVxuXG4gICAgICB3aGlsZSAoIW5lZWREcmFpbikge1xuICAgICAgICBjb25zdCBpdGVtID0gcXVldWUuc2hpZnQoKVxuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHBvb2xba1F1ZXVlZF0tLVxuICAgICAgICBuZWVkRHJhaW4gPSAhdGhpcy5kaXNwYXRjaChpdGVtLm9wdHMsIGl0ZW0uaGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgdGhpc1trTmVlZERyYWluXSA9IG5lZWREcmFpblxuXG4gICAgICBpZiAoIXRoaXNba05lZWREcmFpbl0gJiYgcG9vbFtrTmVlZERyYWluXSkge1xuICAgICAgICBwb29sW2tOZWVkRHJhaW5dID0gZmFsc2VcbiAgICAgICAgcG9vbC5lbWl0KCdkcmFpbicsIG9yaWdpbiwgW3Bvb2wsIC4uLnRhcmdldHNdKVxuICAgICAgfVxuXG4gICAgICBpZiAocG9vbFtrQ2xvc2VkUmVzb2x2ZV0gJiYgcXVldWUuaXNFbXB0eSgpKSB7XG4gICAgICAgIFByb21pc2VcbiAgICAgICAgICAuYWxsKHBvb2xba0NsaWVudHNdLm1hcChjID0+IGMuY2xvc2UoKSkpXG4gICAgICAgICAgLnRoZW4ocG9vbFtrQ2xvc2VkUmVzb2x2ZV0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpc1trT25Db25uZWN0XSA9IChvcmlnaW4sIHRhcmdldHMpID0+IHtcbiAgICAgIHBvb2wuZW1pdCgnY29ubmVjdCcsIG9yaWdpbiwgW3Bvb2wsIC4uLnRhcmdldHNdKVxuICAgIH1cblxuICAgIHRoaXNba09uRGlzY29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzLCBlcnIpID0+IHtcbiAgICAgIHBvb2wuZW1pdCgnZGlzY29ubmVjdCcsIG9yaWdpbiwgW3Bvb2wsIC4uLnRhcmdldHNdLCBlcnIpXG4gICAgfVxuXG4gICAgdGhpc1trT25Db25uZWN0aW9uRXJyb3JdID0gKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICBwb29sLmVtaXQoJ2Nvbm5lY3Rpb25FcnJvcicsIG9yaWdpbiwgW3Bvb2wsIC4uLnRhcmdldHNdLCBlcnIpXG4gICAgfVxuICB9XG5cbiAgZ2V0IFtrQnVzeV0gKCkge1xuICAgIHJldHVybiB0aGlzW2tOZWVkRHJhaW5dXG4gIH1cblxuICBnZXQgW2tDb25uZWN0ZWRdICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ2xpZW50c10uZmlsdGVyKGNsaWVudCA9PiBjbGllbnRba0Nvbm5lY3RlZF0pLmxlbmd0aFxuICB9XG5cbiAgZ2V0IFtrRnJlZV0gKCkge1xuICAgIHJldHVybiB0aGlzW2tDbGllbnRzXS5maWx0ZXIoY2xpZW50ID0+IGNsaWVudFtrQ29ubmVjdGVkXSAmJiAhY2xpZW50W2tOZWVkRHJhaW5dKS5sZW5ndGhcbiAgfVxuXG4gIGdldCBba1BlbmRpbmddICgpIHtcbiAgICBsZXQgcmV0ID0gdGhpc1trUXVldWVkXVxuICAgIGZvciAoY29uc3QgeyBba1BlbmRpbmddOiBwZW5kaW5nIH0gb2YgdGhpc1trQ2xpZW50c10pIHtcbiAgICAgIHJldCArPSBwZW5kaW5nXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGdldCBba1J1bm5pbmddICgpIHtcbiAgICBsZXQgcmV0ID0gMFxuICAgIGZvciAoY29uc3QgeyBba1J1bm5pbmddOiBydW5uaW5nIH0gb2YgdGhpc1trQ2xpZW50c10pIHtcbiAgICAgIHJldCArPSBydW5uaW5nXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGdldCBba1NpemVdICgpIHtcbiAgICBsZXQgcmV0ID0gdGhpc1trUXVldWVkXVxuICAgIGZvciAoY29uc3QgeyBba1NpemVdOiBzaXplIH0gb2YgdGhpc1trQ2xpZW50c10pIHtcbiAgICAgIHJldCArPSBzaXplXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGdldCBzdGF0cyAoKSB7XG4gICAgcmV0dXJuIG5ldyBQb29sU3RhdHModGhpcylcbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBpZiAodGhpc1trUXVldWVdLmlzRW1wdHkoKSkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpc1trQ2xpZW50c10ubWFwKGMgPT4gYy5jbG9zZSgpKSlcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0gPSByZXNvbHZlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKGVycikge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpc1trUXVldWVdLnNoaWZ0KClcbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaXRlbS5oYW5kbGVyLm9uRXJyb3IoZXJyKVxuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXNba0NsaWVudHNdLm1hcChjID0+IGMuZGVzdHJveShlcnIpKSlcbiAgfVxuXG4gIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0dldERpc3BhdGNoZXJdKClcblxuICAgIGlmICghZGlzcGF0Y2hlcikge1xuICAgICAgdGhpc1trTmVlZERyYWluXSA9IHRydWVcbiAgICAgIHRoaXNba1F1ZXVlXS5wdXNoKHsgb3B0cywgaGFuZGxlciB9KVxuICAgICAgdGhpc1trUXVldWVkXSsrXG4gICAgfSBlbHNlIGlmICghZGlzcGF0Y2hlci5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKSkge1xuICAgICAgZGlzcGF0Y2hlcltrTmVlZERyYWluXSA9IHRydWVcbiAgICAgIHRoaXNba05lZWREcmFpbl0gPSAhdGhpc1trR2V0RGlzcGF0Y2hlcl0oKVxuICAgIH1cblxuICAgIHJldHVybiAhdGhpc1trTmVlZERyYWluXVxuICB9XG5cbiAgW2tBZGRDbGllbnRdIChjbGllbnQpIHtcbiAgICBjbGllbnRcbiAgICAgIC5vbignZHJhaW4nLCB0aGlzW2tPbkRyYWluXSlcbiAgICAgIC5vbignY29ubmVjdCcsIHRoaXNba09uQ29ubmVjdF0pXG4gICAgICAub24oJ2Rpc2Nvbm5lY3QnLCB0aGlzW2tPbkRpc2Nvbm5lY3RdKVxuICAgICAgLm9uKCdjb25uZWN0aW9uRXJyb3InLCB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0pXG5cbiAgICB0aGlzW2tDbGllbnRzXS5wdXNoKGNsaWVudClcblxuICAgIGlmICh0aGlzW2tOZWVkRHJhaW5dKSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzW2tOZWVkRHJhaW5dKSB7XG4gICAgICAgICAgdGhpc1trT25EcmFpbl0oY2xpZW50W2tVcmxdLCBbdGhpcywgY2xpZW50XSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgW2tSZW1vdmVDbGllbnRdIChjbGllbnQpIHtcbiAgICBjbGllbnQuY2xvc2UoKCkgPT4ge1xuICAgICAgY29uc3QgaWR4ID0gdGhpc1trQ2xpZW50c10uaW5kZXhPZihjbGllbnQpXG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICB0aGlzW2tDbGllbnRzXS5zcGxpY2UoaWR4LCAxKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzW2tOZWVkRHJhaW5dID0gdGhpc1trQ2xpZW50c10uc29tZShkaXNwYXRjaGVyID0+IChcbiAgICAgICFkaXNwYXRjaGVyW2tOZWVkRHJhaW5dICYmXG4gICAgICBkaXNwYXRjaGVyLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgZGlzcGF0Y2hlci5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBQb29sQmFzZSxcbiAga0NsaWVudHMsXG4gIGtOZWVkRHJhaW4sXG4gIGtBZGRDbGllbnQsXG4gIGtSZW1vdmVDbGllbnQsXG4gIGtHZXREaXNwYXRjaGVyXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/pool-base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/pool.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kGetDispatcher,\n  kRemoveClient\n} = __webpack_require__(/*! ./pool-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool-base.js\")\nconst Client = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\nconst {\n  InvalidArgumentError\n} = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { kUrl } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst buildConnector = __webpack_require__(/*! ../core/connect */ \"(rsc)/./node_modules/undici/lib/core/connect.js\")\n\nconst kOptions = Symbol('options')\nconst kConnections = Symbol('connections')\nconst kFactory = Symbol('factory')\n\nfunction defaultFactory (origin, opts) {\n  return new Client(origin, opts)\n}\n\nclass Pool extends PoolBase {\n  constructor (origin, {\n    connections,\n    factory = defaultFactory,\n    connect,\n    connectTimeout,\n    tls,\n    maxCachedSessions,\n    socketPath,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    allowH2,\n    clientTtl,\n    ...options\n  } = {}) {\n    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n      throw new InvalidArgumentError('invalid connections')\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    super()\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(typeof autoSelectFamily === 'boolean' ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    this[kConnections] = connections || null\n    this[kUrl] = util.parseOrigin(origin)\n    this[kOptions] = { ...util.deepClone(options), connect, allowH2, clientTtl }\n    this[kOptions].interceptors = options.interceptors\n      ? { ...options.interceptors }\n      : undefined\n    this[kFactory] = factory\n\n    this.on('connect', (origin, targets) => {\n      if (clientTtl != null && clientTtl > 0) {\n        for (const target of targets) {\n          Object.assign(target, { ttl: Date.now() })\n        }\n      }\n    })\n\n    this.on('connectionError', (origin, targets, error) => {\n      // If a connection error occurs, we remove the client from the pool,\n      // and emit a connectionError event. They will not be re-used.\n      // Fixes https://github.com/nodejs/undici/issues/3895\n      for (const target of targets) {\n        // Do not use kRemoveClient here, as it will close the client,\n        // but the client cannot be closed in this state.\n        const idx = this[kClients].indexOf(target)\n        if (idx !== -1) {\n          this[kClients].splice(idx, 1)\n        }\n      }\n    })\n  }\n\n  [kGetDispatcher] () {\n    const clientTtlOption = this[kOptions].clientTtl\n    for (const client of this[kClients]) {\n      // check ttl of client and if it's stale, remove it from the pool\n      if (clientTtlOption != null && clientTtlOption > 0 && client.ttl && ((Date.now() - client.ttl) > clientTtlOption)) {\n        this[kRemoveClient](client)\n      } else if (!client[kNeedDrain]) {\n        return client\n      }\n    }\n\n    if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n      const dispatcher = this[kFactory](this[kUrl], this[kOptions])\n      this[kAddClient](dispatcher)\n      return dispatcher\n    }\n  }\n}\n\nmodule.exports = Pool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw0RUFBYTtBQUN6QixlQUFlLG1CQUFPLENBQUMsc0VBQVU7QUFDakM7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUM1QixhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDMUMsdUJBQXVCLG1CQUFPLENBQUMsd0VBQWlCOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtREFBbUQ7QUFDekc7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci9wb29sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIFBvb2xCYXNlLFxuICBrQ2xpZW50cyxcbiAga05lZWREcmFpbixcbiAga0FkZENsaWVudCxcbiAga0dldERpc3BhdGNoZXIsXG4gIGtSZW1vdmVDbGllbnRcbn0gPSByZXF1aXJlKCcuL3Bvb2wtYmFzZScpXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGtVcmwgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBidWlsZENvbm5lY3RvciA9IHJlcXVpcmUoJy4uL2NvcmUvY29ubmVjdCcpXG5cbmNvbnN0IGtPcHRpb25zID0gU3ltYm9sKCdvcHRpb25zJylcbmNvbnN0IGtDb25uZWN0aW9ucyA9IFN5bWJvbCgnY29ubmVjdGlvbnMnKVxuY29uc3Qga0ZhY3RvcnkgPSBTeW1ib2woJ2ZhY3RvcnknKVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgQ2xpZW50KG9yaWdpbiwgb3B0cylcbn1cblxuY2xhc3MgUG9vbCBleHRlbmRzIFBvb2xCYXNlIHtcbiAgY29uc3RydWN0b3IgKG9yaWdpbiwge1xuICAgIGNvbm5lY3Rpb25zLFxuICAgIGZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSxcbiAgICBjb25uZWN0LFxuICAgIGNvbm5lY3RUaW1lb3V0LFxuICAgIHRscyxcbiAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICBzb2NrZXRQYXRoLFxuICAgIGF1dG9TZWxlY3RGYW1pbHksXG4gICAgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0LFxuICAgIGFsbG93SDIsXG4gICAgY2xpZW50VHRsLFxuICAgIC4uLm9wdGlvbnNcbiAgfSA9IHt9KSB7XG4gICAgaWYgKGNvbm5lY3Rpb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoY29ubmVjdGlvbnMpIHx8IGNvbm5lY3Rpb25zIDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjb25uZWN0aW9ucycpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpXG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3QgIT0gbnVsbCAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignY29ubmVjdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0JylcbiAgICB9XG5cbiAgICBzdXBlcigpXG5cbiAgICBpZiAodHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbm5lY3QgPSBidWlsZENvbm5lY3Rvcih7XG4gICAgICAgIC4uLnRscyxcbiAgICAgICAgbWF4Q2FjaGVkU2Vzc2lvbnMsXG4gICAgICAgIGFsbG93SDIsXG4gICAgICAgIHNvY2tldFBhdGgsXG4gICAgICAgIHRpbWVvdXQ6IGNvbm5lY3RUaW1lb3V0LFxuICAgICAgICAuLi4odHlwZW9mIGF1dG9TZWxlY3RGYW1pbHkgPT09ICdib29sZWFuJyA/IHsgYXV0b1NlbGVjdEZhbWlseSwgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IH0gOiB1bmRlZmluZWQpLFxuICAgICAgICAuLi5jb25uZWN0XG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXNba0Nvbm5lY3Rpb25zXSA9IGNvbm5lY3Rpb25zIHx8IG51bGxcbiAgICB0aGlzW2tVcmxdID0gdXRpbC5wYXJzZU9yaWdpbihvcmlnaW4pXG4gICAgdGhpc1trT3B0aW9uc10gPSB7IC4uLnV0aWwuZGVlcENsb25lKG9wdGlvbnMpLCBjb25uZWN0LCBhbGxvd0gyLCBjbGllbnRUdGwgfVxuICAgIHRoaXNba09wdGlvbnNdLmludGVyY2VwdG9ycyA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzXG4gICAgICA/IHsgLi4ub3B0aW9ucy5pbnRlcmNlcHRvcnMgfVxuICAgICAgOiB1bmRlZmluZWRcbiAgICB0aGlzW2tGYWN0b3J5XSA9IGZhY3RvcnlcblxuICAgIHRoaXMub24oJ2Nvbm5lY3QnLCAob3JpZ2luLCB0YXJnZXRzKSA9PiB7XG4gICAgICBpZiAoY2xpZW50VHRsICE9IG51bGwgJiYgY2xpZW50VHRsID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHsgdHRsOiBEYXRlLm5vdygpIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5vbignY29ubmVjdGlvbkVycm9yJywgKG9yaWdpbiwgdGFyZ2V0cywgZXJyb3IpID0+IHtcbiAgICAgIC8vIElmIGEgY29ubmVjdGlvbiBlcnJvciBvY2N1cnMsIHdlIHJlbW92ZSB0aGUgY2xpZW50IGZyb20gdGhlIHBvb2wsXG4gICAgICAvLyBhbmQgZW1pdCBhIGNvbm5lY3Rpb25FcnJvciBldmVudC4gVGhleSB3aWxsIG5vdCBiZSByZS11c2VkLlxuICAgICAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzM4OTVcbiAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgICAgLy8gRG8gbm90IHVzZSBrUmVtb3ZlQ2xpZW50IGhlcmUsIGFzIGl0IHdpbGwgY2xvc2UgdGhlIGNsaWVudCxcbiAgICAgICAgLy8gYnV0IHRoZSBjbGllbnQgY2Fubm90IGJlIGNsb3NlZCBpbiB0aGlzIHN0YXRlLlxuICAgICAgICBjb25zdCBpZHggPSB0aGlzW2tDbGllbnRzXS5pbmRleE9mKHRhcmdldClcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzW2tDbGllbnRzXS5zcGxpY2UoaWR4LCAxKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIFtrR2V0RGlzcGF0Y2hlcl0gKCkge1xuICAgIGNvbnN0IGNsaWVudFR0bE9wdGlvbiA9IHRoaXNba09wdGlvbnNdLmNsaWVudFR0bFxuICAgIGZvciAoY29uc3QgY2xpZW50IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICAvLyBjaGVjayB0dGwgb2YgY2xpZW50IGFuZCBpZiBpdCdzIHN0YWxlLCByZW1vdmUgaXQgZnJvbSB0aGUgcG9vbFxuICAgICAgaWYgKGNsaWVudFR0bE9wdGlvbiAhPSBudWxsICYmIGNsaWVudFR0bE9wdGlvbiA+IDAgJiYgY2xpZW50LnR0bCAmJiAoKERhdGUubm93KCkgLSBjbGllbnQudHRsKSA+IGNsaWVudFR0bE9wdGlvbikpIHtcbiAgICAgICAgdGhpc1trUmVtb3ZlQ2xpZW50XShjbGllbnQpXG4gICAgICB9IGVsc2UgaWYgKCFjbGllbnRba05lZWREcmFpbl0pIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpc1trQ29ubmVjdGlvbnNdIHx8IHRoaXNba0NsaWVudHNdLmxlbmd0aCA8IHRoaXNba0Nvbm5lY3Rpb25zXSkge1xuICAgICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKHRoaXNba1VybF0sIHRoaXNba09wdGlvbnNdKVxuICAgICAgdGhpc1trQWRkQ2xpZW50XShkaXNwYXRjaGVyKVxuICAgICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb29sXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/proxy-agent.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/proxy-agent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { kProxy, kClose, kDestroy, kDispatch, kConnector } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { URL } = __webpack_require__(/*! node:url */ \"node:url\")\nconst Agent = __webpack_require__(/*! ./agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/agent.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst buildConnector = __webpack_require__(/*! ../core/connect */ \"(rsc)/./node_modules/undici/lib/core/connect.js\")\nconst Client = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\n\nconst kAgent = Symbol('proxy agent')\nconst kClient = Symbol('proxy client')\nconst kProxyHeaders = Symbol('proxy headers')\nconst kRequestTls = Symbol('request tls settings')\nconst kProxyTls = Symbol('proxy tls settings')\nconst kConnectEndpoint = Symbol('connect endpoint function')\nconst kTunnelProxy = Symbol('tunnel proxy')\n\nfunction defaultProtocolPort (protocol) {\n  return protocol === 'https:' ? 443 : 80\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nconst noop = () => {}\n\nclass ProxyClient extends DispatcherBase {\n  #client = null\n  constructor (origin, opts) {\n    if (typeof origin === 'string') {\n      origin = new URL(origin)\n    }\n\n    if (origin.protocol !== 'http:' && origin.protocol !== 'https:') {\n      throw new InvalidArgumentError('ProxyClient only supports http and https protocols')\n    }\n\n    super()\n\n    this.#client = new Client(origin, opts)\n  }\n\n  async [kClose] () {\n    await this.#client.close()\n  }\n\n  async [kDestroy] () {\n    await this.#client.destroy()\n  }\n\n  async [kDispatch] (opts, handler) {\n    const { method, origin } = opts\n    if (method === 'CONNECT') {\n      this.#client[kConnector]({\n        origin,\n        port: opts.port || defaultProtocolPort(opts.protocol),\n        path: opts.host,\n        signal: opts.signal,\n        headers: {\n          ...this[kProxyHeaders],\n          host: opts.host\n        },\n        servername: this[kProxyTls]?.servername || opts.servername\n      },\n      (err, socket) => {\n        if (err) {\n          handler.callback(err)\n        } else {\n          handler.callback(null, { socket, statusCode: 200 })\n        }\n      }\n      )\n      return\n    }\n    if (typeof origin === 'string') {\n      opts.origin = new URL(origin)\n    }\n\n    return this.#client.dispatch(opts, handler)\n  }\n}\nclass ProxyAgent extends DispatcherBase {\n  constructor (opts) {\n    if (!opts || (typeof opts === 'object' && !(opts instanceof URL) && !opts.uri)) {\n      throw new InvalidArgumentError('Proxy uri is mandatory')\n    }\n\n    const { clientFactory = defaultFactory } = opts\n    if (typeof clientFactory !== 'function') {\n      throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.')\n    }\n\n    const { proxyTunnel = true } = opts\n\n    super()\n\n    const url = this.#getUrl(opts)\n    const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url\n\n    this[kProxy] = { uri: href, protocol }\n    this[kRequestTls] = opts.requestTls\n    this[kProxyTls] = opts.proxyTls\n    this[kProxyHeaders] = opts.headers || {}\n\n    if (opts.auth && opts.token) {\n      throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token')\n    } else if (opts.auth) {\n      /* @deprecated in favour of opts.token */\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`\n    } else if (opts.token) {\n      this[kProxyHeaders]['proxy-authorization'] = opts.token\n    } else if (username && password) {\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`\n    }\n\n    const factory = (!proxyTunnel && protocol === 'http:')\n      ? (origin, options) => {\n          if (origin.protocol === 'http:') {\n            return new ProxyClient(origin, options)\n          }\n          return new Client(origin, options)\n        }\n      : undefined\n\n    const connect = buildConnector({ ...opts.proxyTls })\n    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls })\n    this[kClient] = clientFactory(url, { connect, factory })\n    this[kTunnelProxy] = proxyTunnel\n    this[kAgent] = new Agent({\n      ...opts,\n      connect: async (opts, callback) => {\n        let requestedPath = opts.host\n        if (!opts.port) {\n          requestedPath += `:${defaultProtocolPort(opts.protocol)}`\n        }\n        try {\n          const { socket, statusCode } = await this[kClient].connect({\n            origin,\n            port,\n            path: requestedPath,\n            signal: opts.signal,\n            headers: {\n              ...this[kProxyHeaders],\n              host: opts.host,\n              ...(opts.connections == null || opts.connections > 0 ? { 'proxy-connection': 'keep-alive' } : {})\n            },\n            servername: this[kProxyTls]?.servername || proxyHostname\n          })\n          if (statusCode !== 200) {\n            socket.on('error', noop).destroy()\n            callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`))\n          }\n          if (opts.protocol !== 'https:') {\n            callback(null, socket)\n            return\n          }\n          let servername\n          if (this[kRequestTls]) {\n            servername = this[kRequestTls].servername\n          } else {\n            servername = opts.servername\n          }\n          this[kConnectEndpoint]({ ...opts, servername, httpSocket: socket }, callback)\n        } catch (err) {\n          if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n            // Throw a custom error to avoid loop in client.js#connect\n            callback(new SecureProxyConnectionError(err))\n          } else {\n            callback(err)\n          }\n        }\n      }\n    })\n  }\n\n  dispatch (opts, handler) {\n    const headers = buildHeaders(opts.headers)\n    throwIfProxyAuthIsSent(headers)\n\n    if (headers && !('host' in headers) && !('Host' in headers)) {\n      const { host } = new URL(opts.origin)\n      headers.host = host\n    }\n\n    if (!this.#shouldConnect(new URL(opts.origin))) {\n      opts.path = opts.origin + opts.path\n    }\n\n    return this[kAgent].dispatch(\n      {\n        ...opts,\n        headers\n      },\n      handler\n    )\n  }\n\n  /**\n   * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts\n   * @returns {URL}\n   */\n  #getUrl (opts) {\n    if (typeof opts === 'string') {\n      return new URL(opts)\n    } else if (opts instanceof URL) {\n      return opts\n    } else {\n      return new URL(opts.uri)\n    }\n  }\n\n  async [kClose] () {\n    await this[kAgent].close()\n    await this[kClient].close()\n  }\n\n  async [kDestroy] () {\n    await this[kAgent].destroy()\n    await this[kClient].destroy()\n  }\n\n  #shouldConnect (uri) {\n    if (typeof uri === 'string') {\n      uri = new URL(uri)\n    }\n    if (this[kTunnelProxy]) {\n      return true\n    }\n    if (uri.protocol !== 'http:' || this[kProxy].protocol !== 'http:') {\n      return true\n    }\n    return false\n  }\n}\n\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */\nfunction buildHeaders (headers) {\n  // When using undici.fetch, the headers list is stored\n  // as an array.\n  if (Array.isArray(headers)) {\n    /** @type {Record<string, string>} */\n    const headersPair = {}\n\n    for (let i = 0; i < headers.length; i += 2) {\n      headersPair[headers[i]] = headers[i + 1]\n    }\n\n    return headersPair\n  }\n\n  return headers\n}\n\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */\nfunction throwIfProxyAuthIsSent (headers) {\n  const existProxyAuth = headers && Object.keys(headers)\n    .find((key) => key.toLowerCase() === 'proxy-authorization')\n  if (existProxyAuth) {\n    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor')\n  }\n}\n\nmodule.exports = ProxyAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Byb3h5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsa0RBQWtELEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDckYsUUFBUSxNQUFNLEVBQUUsbUJBQU8sQ0FBQywwQkFBVTtBQUNsQyxjQUFjLG1CQUFPLENBQUMsb0VBQVM7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLGtFQUFRO0FBQzdCLHVCQUF1QixtQkFBTyxDQUFDLHdGQUFtQjtBQUNsRCxRQUFRLHdFQUF3RSxFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQzFHLHVCQUF1QixtQkFBTyxDQUFDLHdFQUFpQjtBQUNoRCxlQUFlLG1CQUFPLENBQUMsc0VBQVU7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1DQUFtQyx5QkFBeUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLHFCQUFxQjs7QUFFakM7O0FBRUE7QUFDQSxZQUFZLDRFQUE0RTs7QUFFeEYscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNERBQTRELFVBQVU7QUFDdEUsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLDREQUE0RCxlQUFlLDZCQUE2QixHQUFHLDZCQUE2QixzQkFBc0I7QUFDOUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZELDhDQUE4QyxvQkFBb0I7QUFDbEUseUNBQXlDLGtCQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUNBQW1DO0FBQ2xFO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLG1DQUFtQyxJQUFJO0FBQzlHLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsZ0VBQWdFLFdBQVc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsbUNBQW1DLHlDQUF5QztBQUM1RSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtFQUFrRTtBQUMvRSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2Qzs7QUFFQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci9wcm94eS1hZ2VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBrUHJveHksIGtDbG9zZSwga0Rlc3Ryb3ksIGtEaXNwYXRjaCwga0Nvbm5lY3RvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCdub2RlOnVybCcpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vYWdlbnQnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vcG9vbCcpXG5jb25zdCBEaXNwYXRjaGVyQmFzZSA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci1iYXNlJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFJlcXVlc3RBYm9ydGVkRXJyb3IsIFNlY3VyZVByb3h5Q29ubmVjdGlvbkVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBidWlsZENvbm5lY3RvciA9IHJlcXVpcmUoJy4uL2NvcmUvY29ubmVjdCcpXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpXG5cbmNvbnN0IGtBZ2VudCA9IFN5bWJvbCgncHJveHkgYWdlbnQnKVxuY29uc3Qga0NsaWVudCA9IFN5bWJvbCgncHJveHkgY2xpZW50JylcbmNvbnN0IGtQcm94eUhlYWRlcnMgPSBTeW1ib2woJ3Byb3h5IGhlYWRlcnMnKVxuY29uc3Qga1JlcXVlc3RUbHMgPSBTeW1ib2woJ3JlcXVlc3QgdGxzIHNldHRpbmdzJylcbmNvbnN0IGtQcm94eVRscyA9IFN5bWJvbCgncHJveHkgdGxzIHNldHRpbmdzJylcbmNvbnN0IGtDb25uZWN0RW5kcG9pbnQgPSBTeW1ib2woJ2Nvbm5lY3QgZW5kcG9pbnQgZnVuY3Rpb24nKVxuY29uc3Qga1R1bm5lbFByb3h5ID0gU3ltYm9sKCd0dW5uZWwgcHJveHknKVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJvdG9jb2xQb3J0IChwcm90b2NvbCkge1xuICByZXR1cm4gcHJvdG9jb2wgPT09ICdodHRwczonID8gNDQzIDogODBcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEZhY3RvcnkgKG9yaWdpbiwgb3B0cykge1xuICByZXR1cm4gbmV3IFBvb2wob3JpZ2luLCBvcHRzKVxufVxuXG5jb25zdCBub29wID0gKCkgPT4ge31cblxuY2xhc3MgUHJveHlDbGllbnQgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gICNjbGllbnQgPSBudWxsXG4gIGNvbnN0cnVjdG9yIChvcmlnaW4sIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIG9yaWdpbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9yaWdpbiA9IG5ldyBVUkwob3JpZ2luKVxuICAgIH1cblxuICAgIGlmIChvcmlnaW4ucHJvdG9jb2wgIT09ICdodHRwOicgJiYgb3JpZ2luLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdQcm94eUNsaWVudCBvbmx5IHN1cHBvcnRzIGh0dHAgYW5kIGh0dHBzIHByb3RvY29scycpXG4gICAgfVxuXG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy4jY2xpZW50ID0gbmV3IENsaWVudChvcmlnaW4sIG9wdHMpXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgYXdhaXQgdGhpcy4jY2xpZW50LmNsb3NlKClcbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKCkge1xuICAgIGF3YWl0IHRoaXMuI2NsaWVudC5kZXN0cm95KClcbiAgfVxuXG4gIGFzeW5jIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgeyBtZXRob2QsIG9yaWdpbiB9ID0gb3B0c1xuICAgIGlmIChtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgICAgdGhpcy4jY2xpZW50W2tDb25uZWN0b3JdKHtcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICBwb3J0OiBvcHRzLnBvcnQgfHwgZGVmYXVsdFByb3RvY29sUG9ydChvcHRzLnByb3RvY29sKSxcbiAgICAgICAgcGF0aDogb3B0cy5ob3N0LFxuICAgICAgICBzaWduYWw6IG9wdHMuc2lnbmFsLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4udGhpc1trUHJveHlIZWFkZXJzXSxcbiAgICAgICAgICBob3N0OiBvcHRzLmhvc3RcbiAgICAgICAgfSxcbiAgICAgICAgc2VydmVybmFtZTogdGhpc1trUHJveHlUbHNdPy5zZXJ2ZXJuYW1lIHx8IG9wdHMuc2VydmVybmFtZVxuICAgICAgfSxcbiAgICAgIChlcnIsIHNvY2tldCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgaGFuZGxlci5jYWxsYmFjayhlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlci5jYWxsYmFjayhudWxsLCB7IHNvY2tldCwgc3RhdHVzQ29kZTogMjAwIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9yaWdpbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdHMub3JpZ2luID0gbmV3IFVSTChvcmlnaW4pXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuI2NsaWVudC5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICB9XG59XG5jbGFzcyBQcm94eUFnZW50IGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIGlmICghb3B0cyB8fCAodHlwZW9mIG9wdHMgPT09ICdvYmplY3QnICYmICEob3B0cyBpbnN0YW5jZW9mIFVSTCkgJiYgIW9wdHMudXJpKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdQcm94eSB1cmkgaXMgbWFuZGF0b3J5JylcbiAgICB9XG5cbiAgICBjb25zdCB7IGNsaWVudEZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSB9ID0gb3B0c1xuICAgIGlmICh0eXBlb2YgY2xpZW50RmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdQcm94eSBvcHRzLmNsaWVudEZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpXG4gICAgfVxuXG4gICAgY29uc3QgeyBwcm94eVR1bm5lbCA9IHRydWUgfSA9IG9wdHNcblxuICAgIHN1cGVyKClcblxuICAgIGNvbnN0IHVybCA9IHRoaXMuI2dldFVybChvcHRzKVxuICAgIGNvbnN0IHsgaHJlZiwgb3JpZ2luLCBwb3J0LCBwcm90b2NvbCwgdXNlcm5hbWUsIHBhc3N3b3JkLCBob3N0bmFtZTogcHJveHlIb3N0bmFtZSB9ID0gdXJsXG5cbiAgICB0aGlzW2tQcm94eV0gPSB7IHVyaTogaHJlZiwgcHJvdG9jb2wgfVxuICAgIHRoaXNba1JlcXVlc3RUbHNdID0gb3B0cy5yZXF1ZXN0VGxzXG4gICAgdGhpc1trUHJveHlUbHNdID0gb3B0cy5wcm94eVRsc1xuICAgIHRoaXNba1Byb3h5SGVhZGVyc10gPSBvcHRzLmhlYWRlcnMgfHwge31cblxuICAgIGlmIChvcHRzLmF1dGggJiYgb3B0cy50b2tlbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzLmF1dGggY2Fubm90IGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBvcHRzLnRva2VuJylcbiAgICB9IGVsc2UgaWYgKG9wdHMuYXV0aCkge1xuICAgICAgLyogQGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIG9wdHMudG9rZW4gKi9cbiAgICAgIHRoaXNba1Byb3h5SGVhZGVyc11bJ3Byb3h5LWF1dGhvcml6YXRpb24nXSA9IGBCYXNpYyAke29wdHMuYXV0aH1gXG4gICAgfSBlbHNlIGlmIChvcHRzLnRva2VuKSB7XG4gICAgICB0aGlzW2tQcm94eUhlYWRlcnNdWydwcm94eS1hdXRob3JpemF0aW9uJ10gPSBvcHRzLnRva2VuXG4gICAgfSBlbHNlIGlmICh1c2VybmFtZSAmJiBwYXNzd29yZCkge1xuICAgICAgdGhpc1trUHJveHlIZWFkZXJzXVsncHJveHktYXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7QnVmZmVyLmZyb20oYCR7ZGVjb2RlVVJJQ29tcG9uZW50KHVzZXJuYW1lKX06JHtkZWNvZGVVUklDb21wb25lbnQocGFzc3dvcmQpfWApLnRvU3RyaW5nKCdiYXNlNjQnKX1gXG4gICAgfVxuXG4gICAgY29uc3QgZmFjdG9yeSA9ICghcHJveHlUdW5uZWwgJiYgcHJvdG9jb2wgPT09ICdodHRwOicpXG4gICAgICA/IChvcmlnaW4sIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICBpZiAob3JpZ2luLnByb3RvY29sID09PSAnaHR0cDonKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3h5Q2xpZW50KG9yaWdpbiwgb3B0aW9ucylcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBDbGllbnQob3JpZ2luLCBvcHRpb25zKVxuICAgICAgICB9XG4gICAgICA6IHVuZGVmaW5lZFxuXG4gICAgY29uc3QgY29ubmVjdCA9IGJ1aWxkQ29ubmVjdG9yKHsgLi4ub3B0cy5wcm94eVRscyB9KVxuICAgIHRoaXNba0Nvbm5lY3RFbmRwb2ludF0gPSBidWlsZENvbm5lY3Rvcih7IC4uLm9wdHMucmVxdWVzdFRscyB9KVxuICAgIHRoaXNba0NsaWVudF0gPSBjbGllbnRGYWN0b3J5KHVybCwgeyBjb25uZWN0LCBmYWN0b3J5IH0pXG4gICAgdGhpc1trVHVubmVsUHJveHldID0gcHJveHlUdW5uZWxcbiAgICB0aGlzW2tBZ2VudF0gPSBuZXcgQWdlbnQoe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGNvbm5lY3Q6IGFzeW5jIChvcHRzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBsZXQgcmVxdWVzdGVkUGF0aCA9IG9wdHMuaG9zdFxuICAgICAgICBpZiAoIW9wdHMucG9ydCkge1xuICAgICAgICAgIHJlcXVlc3RlZFBhdGggKz0gYDoke2RlZmF1bHRQcm90b2NvbFBvcnQob3B0cy5wcm90b2NvbCl9YFxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBzb2NrZXQsIHN0YXR1c0NvZGUgfSA9IGF3YWl0IHRoaXNba0NsaWVudF0uY29ubmVjdCh7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICBwb3J0LFxuICAgICAgICAgICAgcGF0aDogcmVxdWVzdGVkUGF0aCxcbiAgICAgICAgICAgIHNpZ25hbDogb3B0cy5zaWduYWwsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIC4uLnRoaXNba1Byb3h5SGVhZGVyc10sXG4gICAgICAgICAgICAgIGhvc3Q6IG9wdHMuaG9zdCxcbiAgICAgICAgICAgICAgLi4uKG9wdHMuY29ubmVjdGlvbnMgPT0gbnVsbCB8fCBvcHRzLmNvbm5lY3Rpb25zID4gMCA/IHsgJ3Byb3h5LWNvbm5lY3Rpb24nOiAna2VlcC1hbGl2ZScgfSA6IHt9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcnZlcm5hbWU6IHRoaXNba1Byb3h5VGxzXT8uc2VydmVybmFtZSB8fCBwcm94eUhvc3RuYW1lXG4gICAgICAgICAgfSlcbiAgICAgICAgICBpZiAoc3RhdHVzQ29kZSAhPT0gMjAwKSB7XG4gICAgICAgICAgICBzb2NrZXQub24oJ2Vycm9yJywgbm9vcCkuZGVzdHJveSgpXG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcihgUHJveHkgcmVzcG9uc2UgKCR7c3RhdHVzQ29kZX0pICE9PSAyMDAgd2hlbiBIVFRQIFR1bm5lbGluZ2ApKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0cy5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHNvY2tldClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgc2VydmVybmFtZVxuICAgICAgICAgIGlmICh0aGlzW2tSZXF1ZXN0VGxzXSkge1xuICAgICAgICAgICAgc2VydmVybmFtZSA9IHRoaXNba1JlcXVlc3RUbHNdLnNlcnZlcm5hbWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VydmVybmFtZSA9IG9wdHMuc2VydmVybmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzW2tDb25uZWN0RW5kcG9pbnRdKHsgLi4ub3B0cywgc2VydmVybmFtZSwgaHR0cFNvY2tldDogc29ja2V0IH0sIGNhbGxiYWNrKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJykge1xuICAgICAgICAgICAgLy8gVGhyb3cgYSBjdXN0b20gZXJyb3IgdG8gYXZvaWQgbG9vcCBpbiBjbGllbnQuanMjY29ubmVjdFxuICAgICAgICAgICAgY2FsbGJhY2sobmV3IFNlY3VyZVByb3h5Q29ubmVjdGlvbkVycm9yKGVycikpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gYnVpbGRIZWFkZXJzKG9wdHMuaGVhZGVycylcbiAgICB0aHJvd0lmUHJveHlBdXRoSXNTZW50KGhlYWRlcnMpXG5cbiAgICBpZiAoaGVhZGVycyAmJiAhKCdob3N0JyBpbiBoZWFkZXJzKSAmJiAhKCdIb3N0JyBpbiBoZWFkZXJzKSkge1xuICAgICAgY29uc3QgeyBob3N0IH0gPSBuZXcgVVJMKG9wdHMub3JpZ2luKVxuICAgICAgaGVhZGVycy5ob3N0ID0gaG9zdFxuICAgIH1cblxuICAgIGlmICghdGhpcy4jc2hvdWxkQ29ubmVjdChuZXcgVVJMKG9wdHMub3JpZ2luKSkpIHtcbiAgICAgIG9wdHMucGF0aCA9IG9wdHMub3JpZ2luICsgb3B0cy5wYXRoXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNba0FnZW50XS5kaXNwYXRjaChcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfSxcbiAgICAgIGhhbmRsZXJcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL3Byb3h5LWFnZW50JykuUHJveHlBZ2VudC5PcHRpb25zIHwgc3RyaW5nIHwgVVJMfSBvcHRzXG4gICAqIEByZXR1cm5zIHtVUkx9XG4gICAqL1xuICAjZ2V0VXJsIChvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG5ldyBVUkwob3B0cylcbiAgICB9IGVsc2UgaWYgKG9wdHMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgIHJldHVybiBvcHRzXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgVVJMKG9wdHMudXJpKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBhd2FpdCB0aGlzW2tBZ2VudF0uY2xvc2UoKVxuICAgIGF3YWl0IHRoaXNba0NsaWVudF0uY2xvc2UoKVxuICB9XG5cbiAgYXN5bmMgW2tEZXN0cm95XSAoKSB7XG4gICAgYXdhaXQgdGhpc1trQWdlbnRdLmRlc3Ryb3koKVxuICAgIGF3YWl0IHRoaXNba0NsaWVudF0uZGVzdHJveSgpXG4gIH1cblxuICAjc2hvdWxkQ29ubmVjdCAodXJpKSB7XG4gICAgaWYgKHR5cGVvZiB1cmkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB1cmkgPSBuZXcgVVJMKHVyaSlcbiAgICB9XG4gICAgaWYgKHRoaXNba1R1bm5lbFByb3h5XSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHVyaS5wcm90b2NvbCAhPT0gJ2h0dHA6JyB8fCB0aGlzW2tQcm94eV0ucHJvdG9jb2wgIT09ICdodHRwOicpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXSB8IFJlY29yZDxzdHJpbmcsIHN0cmluZz59IGhlYWRlcnNcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBidWlsZEhlYWRlcnMgKGhlYWRlcnMpIHtcbiAgLy8gV2hlbiB1c2luZyB1bmRpY2kuZmV0Y2gsIHRoZSBoZWFkZXJzIGxpc3QgaXMgc3RvcmVkXG4gIC8vIGFzIGFuIGFycmF5LlxuICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICBjb25zdCBoZWFkZXJzUGFpciA9IHt9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGhlYWRlcnNQYWlyW2hlYWRlcnNbaV1dID0gaGVhZGVyc1tpICsgMV1cbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyc1BhaXJcbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzXG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBoZWFkZXJzXG4gKlxuICogUHJldmlvdXMgdmVyc2lvbnMgb2YgUHJveHlBZ2VudCBzdWdnZXN0cyB0aGUgUHJveHktQXV0aG9yaXphdGlvbiBpbiByZXF1ZXN0IGhlYWRlcnNcbiAqIE5ldmVydGhlbGVzcywgaXQgd2FzIGNoYW5nZWQgYW5kIHRvIGF2b2lkIGEgc2VjdXJpdHkgdnVsbmVyYWJpbGl0eSBieSBlbmQgdXNlcnNcbiAqIHRoaXMgY2hlY2sgd2FzIGNyZWF0ZWQuXG4gKiBJdCBzaG91bGQgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZQcm94eUF1dGhJc1NlbnQgKGhlYWRlcnMpIHtcbiAgY29uc3QgZXhpc3RQcm94eUF1dGggPSBoZWFkZXJzICYmIE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgLmZpbmQoKGtleSkgPT4ga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdwcm94eS1hdXRob3JpemF0aW9uJylcbiAgaWYgKGV4aXN0UHJveHlBdXRoKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdQcm94eS1BdXRob3JpemF0aW9uIHNob3VsZCBiZSBzZW50IGluIFByb3h5QWdlbnQgY29uc3RydWN0b3InKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJveHlBZ2VudFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/proxy-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/retry-agent.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/retry-agent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js\")\nconst RetryHandler = __webpack_require__(/*! ../handler/retry-handler */ \"(rsc)/./node_modules/undici/lib/handler/retry-handler.js\")\n\nclass RetryAgent extends Dispatcher {\n  #agent = null\n  #options = null\n  constructor (agent, options = {}) {\n    super(options)\n    this.#agent = agent\n    this.#options = options\n  }\n\n  dispatch (opts, handler) {\n    const retry = new RetryHandler({\n      ...opts,\n      retryOptions: this.#options\n    }, {\n      dispatch: this.#agent.dispatch.bind(this.#agent),\n      handler\n    })\n    return this.#agent.dispatch(opts, retry)\n  }\n\n  close () {\n    return this.#agent.close()\n  }\n\n  destroy () {\n    return this.#agent.destroy()\n  }\n}\n\nmodule.exports = RetryAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3JldHJ5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLG1CQUFtQixtQkFBTyxDQUFDLDhFQUFjO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLDBGQUEwQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci9yZXRyeS1hZ2VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlcicpXG5jb25zdCBSZXRyeUhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL3JldHJ5LWhhbmRsZXInKVxuXG5jbGFzcyBSZXRyeUFnZW50IGV4dGVuZHMgRGlzcGF0Y2hlciB7XG4gICNhZ2VudCA9IG51bGxcbiAgI29wdGlvbnMgPSBudWxsXG4gIGNvbnN0cnVjdG9yIChhZ2VudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucylcbiAgICB0aGlzLiNhZ2VudCA9IGFnZW50XG4gICAgdGhpcy4jb3B0aW9ucyA9IG9wdGlvbnNcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgcmV0cnkgPSBuZXcgUmV0cnlIYW5kbGVyKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICByZXRyeU9wdGlvbnM6IHRoaXMuI29wdGlvbnNcbiAgICB9LCB7XG4gICAgICBkaXNwYXRjaDogdGhpcy4jYWdlbnQuZGlzcGF0Y2guYmluZCh0aGlzLiNhZ2VudCksXG4gICAgICBoYW5kbGVyXG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy4jYWdlbnQuZGlzcGF0Y2gob3B0cywgcmV0cnkpXG4gIH1cblxuICBjbG9zZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FnZW50LmNsb3NlKClcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHJldHVybiB0aGlzLiNhZ2VudC5kZXN0cm95KClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJldHJ5QWdlbnRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/retry-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/global.js":
/*!*******************************************!*\
  !*** ./node_modules/undici/lib/global.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// We include a version number for the Dispatcher API. In case of breaking changes,\n// this version number must be increased to avoid conflicts.\nconst globalDispatcher = Symbol.for('undici.globalDispatcher.1')\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst Agent = __webpack_require__(/*! ./dispatcher/agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/agent.js\")\n\nif (getGlobalDispatcher() === undefined) {\n  setGlobalDispatcher(new Agent())\n}\n\nfunction setGlobalDispatcher (agent) {\n  if (!agent || typeof agent.dispatch !== 'function') {\n    throw new InvalidArgumentError('Argument agent must implement Agent')\n  }\n  Object.defineProperty(globalThis, globalDispatcher, {\n    value: agent,\n    writable: true,\n    enumerable: false,\n    configurable: false\n  })\n}\n\nfunction getGlobalDispatcher () {\n  return globalThis[globalDispatcher]\n}\n\nmodule.exports = {\n  setGlobalDispatcher,\n  getGlobalDispatcher\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9nbG9iYWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLHFFQUFlO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQywrRUFBb0I7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2dsb2JhbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gV2UgaW5jbHVkZSBhIHZlcnNpb24gbnVtYmVyIGZvciB0aGUgRGlzcGF0Y2hlciBBUEkuIEluIGNhc2Ugb2YgYnJlYWtpbmcgY2hhbmdlcyxcbi8vIHRoaXMgdmVyc2lvbiBudW1iZXIgbXVzdCBiZSBpbmNyZWFzZWQgdG8gYXZvaWQgY29uZmxpY3RzLlxuY29uc3QgZ2xvYmFsRGlzcGF0Y2hlciA9IFN5bWJvbC5mb3IoJ3VuZGljaS5nbG9iYWxEaXNwYXRjaGVyLjEnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci9hZ2VudCcpXG5cbmlmIChnZXRHbG9iYWxEaXNwYXRjaGVyKCkgPT09IHVuZGVmaW5lZCkge1xuICBzZXRHbG9iYWxEaXNwYXRjaGVyKG5ldyBBZ2VudCgpKVxufVxuXG5mdW5jdGlvbiBzZXRHbG9iYWxEaXNwYXRjaGVyIChhZ2VudCkge1xuICBpZiAoIWFnZW50IHx8IHR5cGVvZiBhZ2VudC5kaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQXJndW1lbnQgYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnQnKVxuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLCBnbG9iYWxEaXNwYXRjaGVyLCB7XG4gICAgdmFsdWU6IGFnZW50LFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0R2xvYmFsRGlzcGF0Y2hlciAoKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzW2dsb2JhbERpc3BhdGNoZXJdXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXRHbG9iYWxEaXNwYXRjaGVyLFxuICBnZXRHbG9iYWxEaXNwYXRjaGVyXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/global.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/cache-handler.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/handler/cache-handler.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst {\n  parseCacheControlHeader,\n  parseVaryHeader,\n  isEtagUsable\n} = __webpack_require__(/*! ../util/cache */ \"(rsc)/./node_modules/undici/lib/util/cache.js\")\nconst { parseHttpDate } = __webpack_require__(/*! ../util/date.js */ \"(rsc)/./node_modules/undici/lib/util/date.js\")\n\nfunction noop () {}\n\n// Status codes that we can use some heuristics on to cache\nconst HEURISTICALLY_CACHEABLE_STATUS_CODES = [\n  200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, 501\n]\n\nconst MAX_RESPONSE_AGE = 2147483647000\n\n/**\n * @typedef {import('../../types/dispatcher.d.ts').default.DispatchHandler} DispatchHandler\n *\n * @implements {DispatchHandler}\n */\nclass CacheHandler {\n  /**\n   * @type {import('../../types/cache-interceptor.d.ts').default.CacheKey}\n   */\n  #cacheKey\n\n  /**\n   * @type {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions['type']}\n   */\n  #cacheType\n\n  /**\n   * @type {number | undefined}\n   */\n  #cacheByDefault\n\n  /**\n   * @type {import('../../types/cache-interceptor.d.ts').default.CacheStore}\n   */\n  #store\n\n  /**\n   * @type {import('../../types/dispatcher.d.ts').default.DispatchHandler}\n   */\n  #handler\n\n  /**\n   * @type {import('node:stream').Writable | undefined}\n   */\n  #writeStream\n\n  /**\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions} opts\n   * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} cacheKey\n   * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler\n   */\n  constructor ({ store, type, cacheByDefault }, cacheKey, handler) {\n    this.#store = store\n    this.#cacheType = type\n    this.#cacheByDefault = cacheByDefault\n    this.#cacheKey = cacheKey\n    this.#handler = handler\n  }\n\n  onRequestStart (controller, context) {\n    this.#writeStream?.destroy()\n    this.#writeStream = undefined\n    this.#handler.onRequestStart?.(controller, context)\n  }\n\n  onRequestUpgrade (controller, statusCode, headers, socket) {\n    this.#handler.onRequestUpgrade?.(controller, statusCode, headers, socket)\n  }\n\n  /**\n   * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller\n   * @param {number} statusCode\n   * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders\n   * @param {string} statusMessage\n   */\n  onResponseStart (\n    controller,\n    statusCode,\n    resHeaders,\n    statusMessage\n  ) {\n    const downstreamOnHeaders = () =>\n      this.#handler.onResponseStart?.(\n        controller,\n        statusCode,\n        resHeaders,\n        statusMessage\n      )\n\n    if (\n      !util.safeHTTPMethods.includes(this.#cacheKey.method) &&\n      statusCode >= 200 &&\n      statusCode <= 399\n    ) {\n      // Successful response to an unsafe method, delete it from cache\n      //  https://www.rfc-editor.org/rfc/rfc9111.html#name-invalidating-stored-response\n      try {\n        this.#store.delete(this.#cacheKey)?.catch?.(noop)\n      } catch {\n        // Fail silently\n      }\n      return downstreamOnHeaders()\n    }\n\n    const cacheControlHeader = resHeaders['cache-control']\n    const heuristicallyCacheable = resHeaders['last-modified'] && HEURISTICALLY_CACHEABLE_STATUS_CODES.includes(statusCode)\n    if (\n      !cacheControlHeader &&\n      !resHeaders['expires'] &&\n      !heuristicallyCacheable &&\n      !this.#cacheByDefault\n    ) {\n      // Don't have anything to tell us this response is cachable and we're not\n      //  caching by default\n      return downstreamOnHeaders()\n    }\n\n    const cacheControlDirectives = cacheControlHeader ? parseCacheControlHeader(cacheControlHeader) : {}\n    if (!canCacheResponse(this.#cacheType, statusCode, resHeaders, cacheControlDirectives)) {\n      return downstreamOnHeaders()\n    }\n\n    const now = Date.now()\n    const resAge = resHeaders.age ? getAge(resHeaders.age) : undefined\n    if (resAge && resAge >= MAX_RESPONSE_AGE) {\n      // Response considered stale\n      return downstreamOnHeaders()\n    }\n\n    const resDate = typeof resHeaders.date === 'string'\n      ? parseHttpDate(resHeaders.date)\n      : undefined\n\n    const staleAt =\n      determineStaleAt(this.#cacheType, now, resAge, resHeaders, resDate, cacheControlDirectives) ??\n      this.#cacheByDefault\n    if (staleAt === undefined || (resAge && resAge > staleAt)) {\n      return downstreamOnHeaders()\n    }\n\n    const baseTime = resDate ? resDate.getTime() : now\n    const absoluteStaleAt = staleAt + baseTime\n    if (now >= absoluteStaleAt) {\n      // Response is already stale\n      return downstreamOnHeaders()\n    }\n\n    let varyDirectives\n    if (this.#cacheKey.headers && resHeaders.vary) {\n      varyDirectives = parseVaryHeader(resHeaders.vary, this.#cacheKey.headers)\n      if (!varyDirectives) {\n        // Parse error\n        return downstreamOnHeaders()\n      }\n    }\n\n    const deleteAt = determineDeleteAt(baseTime, cacheControlDirectives, absoluteStaleAt)\n    const strippedHeaders = stripNecessaryHeaders(resHeaders, cacheControlDirectives)\n\n    /**\n     * @type {import('../../types/cache-interceptor.d.ts').default.CacheValue}\n     */\n    const value = {\n      statusCode,\n      statusMessage,\n      headers: strippedHeaders,\n      vary: varyDirectives,\n      cacheControlDirectives,\n      cachedAt: resAge ? now - resAge : now,\n      staleAt: absoluteStaleAt,\n      deleteAt\n    }\n\n    if (typeof resHeaders.etag === 'string' && isEtagUsable(resHeaders.etag)) {\n      value.etag = resHeaders.etag\n    }\n\n    this.#writeStream = this.#store.createWriteStream(this.#cacheKey, value)\n    if (!this.#writeStream) {\n      return downstreamOnHeaders()\n    }\n\n    const handler = this\n    this.#writeStream\n      .on('drain', () => controller.resume())\n      .on('error', function () {\n        // TODO (fix): Make error somehow observable?\n        handler.#writeStream = undefined\n\n        // Delete the value in case the cache store is holding onto state from\n        //  the call to createWriteStream\n        handler.#store.delete(handler.#cacheKey)\n      })\n      .on('close', function () {\n        if (handler.#writeStream === this) {\n          handler.#writeStream = undefined\n        }\n\n        // TODO (fix): Should we resume even if was paused downstream?\n        controller.resume()\n      })\n\n    return downstreamOnHeaders()\n  }\n\n  onResponseData (controller, chunk) {\n    if (this.#writeStream?.write(chunk) === false) {\n      controller.pause()\n    }\n\n    this.#handler.onResponseData?.(controller, chunk)\n  }\n\n  onResponseEnd (controller, trailers) {\n    this.#writeStream?.end()\n    this.#handler.onResponseEnd?.(controller, trailers)\n  }\n\n  onResponseError (controller, err) {\n    this.#writeStream?.destroy(err)\n    this.#writeStream = undefined\n    this.#handler.onResponseError?.(controller, err)\n  }\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc9111.html#name-storing-responses-to-authen\n *\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheOptions['type']} cacheType\n * @param {number} statusCode\n * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives} cacheControlDirectives\n */\nfunction canCacheResponse (cacheType, statusCode, resHeaders, cacheControlDirectives) {\n  if (statusCode !== 200 && statusCode !== 307) {\n    return false\n  }\n\n  if (cacheControlDirectives['no-store']) {\n    return false\n  }\n\n  if (cacheType === 'shared' && cacheControlDirectives.private === true) {\n    return false\n  }\n\n  // https://www.rfc-editor.org/rfc/rfc9111.html#section-4.1-5\n  if (resHeaders.vary?.includes('*')) {\n    return false\n  }\n\n  // https://www.rfc-editor.org/rfc/rfc9111.html#name-storing-responses-to-authen\n  if (resHeaders.authorization) {\n    if (!cacheControlDirectives.public || typeof resHeaders.authorization !== 'string') {\n      return false\n    }\n\n    if (\n      Array.isArray(cacheControlDirectives['no-cache']) &&\n      cacheControlDirectives['no-cache'].includes('authorization')\n    ) {\n      return false\n    }\n\n    if (\n      Array.isArray(cacheControlDirectives['private']) &&\n      cacheControlDirectives['private'].includes('authorization')\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {string | string[]} ageHeader\n * @returns {number | undefined}\n */\nfunction getAge (ageHeader) {\n  const age = parseInt(Array.isArray(ageHeader) ? ageHeader[0] : ageHeader)\n\n  return isNaN(age) ? undefined : age * 1000\n}\n\n/**\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheOptions['type']} cacheType\n * @param {number} now\n * @param {number | undefined} age\n * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders\n * @param {Date | undefined} responseDate\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives} cacheControlDirectives\n *\n * @returns {number | undefined} time that the value is stale at in seconds or undefined if it shouldn't be cached\n */\nfunction determineStaleAt (cacheType, now, age, resHeaders, responseDate, cacheControlDirectives) {\n  if (cacheType === 'shared') {\n    // Prioritize s-maxage since we're a shared cache\n    //  s-maxage > max-age > Expire\n    //  https://www.rfc-editor.org/rfc/rfc9111.html#section-5.2.2.10-3\n    const sMaxAge = cacheControlDirectives['s-maxage']\n    if (sMaxAge !== undefined) {\n      return sMaxAge > 0 ? sMaxAge * 1000 : undefined\n    }\n  }\n\n  const maxAge = cacheControlDirectives['max-age']\n  if (maxAge !== undefined) {\n    return maxAge > 0 ? maxAge * 1000 : undefined\n  }\n\n  if (typeof resHeaders.expires === 'string') {\n    // https://www.rfc-editor.org/rfc/rfc9111.html#section-5.3\n    const expiresDate = parseHttpDate(resHeaders.expires)\n    if (expiresDate) {\n      if (now >= expiresDate.getTime()) {\n        return undefined\n      }\n\n      if (responseDate) {\n        if (responseDate >= expiresDate) {\n          return undefined\n        }\n\n        if (age !== undefined && age > (expiresDate - responseDate)) {\n          return undefined\n        }\n      }\n\n      return expiresDate.getTime() - now\n    }\n  }\n\n  if (typeof resHeaders['last-modified'] === 'string') {\n    // https://www.rfc-editor.org/rfc/rfc9111.html#name-calculating-heuristic-fresh\n    const lastModified = new Date(resHeaders['last-modified'])\n    if (isValidDate(lastModified)) {\n      if (lastModified.getTime() >= now) {\n        return undefined\n      }\n\n      const responseAge = now - lastModified.getTime()\n\n      return responseAge * 0.1\n    }\n  }\n\n  if (cacheControlDirectives.immutable) {\n    // https://www.rfc-editor.org/rfc/rfc8246.html#section-2.2\n    return 31536000\n  }\n\n  return undefined\n}\n\n/**\n * @param {number} now\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives} cacheControlDirectives\n * @param {number} staleAt\n */\nfunction determineDeleteAt (now, cacheControlDirectives, staleAt) {\n  let staleWhileRevalidate = -Infinity\n  let staleIfError = -Infinity\n  let immutable = -Infinity\n\n  if (cacheControlDirectives['stale-while-revalidate']) {\n    staleWhileRevalidate = staleAt + (cacheControlDirectives['stale-while-revalidate'] * 1000)\n  }\n\n  if (cacheControlDirectives['stale-if-error']) {\n    staleIfError = staleAt + (cacheControlDirectives['stale-if-error'] * 1000)\n  }\n\n  if (staleWhileRevalidate === -Infinity && staleIfError === -Infinity) {\n    immutable = now + 31536000000\n  }\n\n  return Math.max(staleAt, staleWhileRevalidate, staleIfError, immutable)\n}\n\n/**\n * Strips headers required to be removed in cached responses\n * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives} cacheControlDirectives\n * @returns {Record<string, string | string []>}\n */\nfunction stripNecessaryHeaders (resHeaders, cacheControlDirectives) {\n  const headersToRemove = [\n    'connection',\n    'proxy-authenticate',\n    'proxy-authentication-info',\n    'proxy-authorization',\n    'proxy-connection',\n    'te',\n    'transfer-encoding',\n    'upgrade',\n    // We'll add age back when serving it\n    'age'\n  ]\n\n  if (resHeaders['connection']) {\n    if (Array.isArray(resHeaders['connection'])) {\n      // connection: a\n      // connection: b\n      headersToRemove.push(...resHeaders['connection'].map(header => header.trim()))\n    } else {\n      // connection: a, b\n      headersToRemove.push(...resHeaders['connection'].split(',').map(header => header.trim()))\n    }\n  }\n\n  if (Array.isArray(cacheControlDirectives['no-cache'])) {\n    headersToRemove.push(...cacheControlDirectives['no-cache'])\n  }\n\n  if (Array.isArray(cacheControlDirectives['private'])) {\n    headersToRemove.push(...cacheControlDirectives['private'])\n  }\n\n  let strippedHeaders\n  for (const headerName of headersToRemove) {\n    if (resHeaders[headerName]) {\n      strippedHeaders ??= { ...resHeaders }\n      delete strippedHeaders[headerName]\n    }\n  }\n\n  return strippedHeaders ?? resHeaders\n}\n\n/**\n * @param {Date} date\n * @returns {boolean}\n */\nfunction isValidDate (date) {\n  return date instanceof Date && Number.isFinite(date.valueOf())\n}\n\nmodule.exports = CacheHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL2NhY2hlLWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsb0VBQWU7QUFDM0IsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLHFFQUFpQjs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLCtEQUErRDtBQUM1RTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDBFQUEwRTtBQUN2RixhQUFhLCtEQUErRDtBQUM1RSxhQUFhLCtEQUErRDtBQUM1RTtBQUNBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxrRUFBa0U7QUFDL0UsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsdURBQXVEO0FBQ3BFLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVywyRUFBMkU7QUFDdEYsV0FBVyxRQUFRO0FBQ25CLFdBQVcsdURBQXVEO0FBQ2xFLFdBQVcsNkVBQTZFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVywyRUFBMkU7QUFDdEYsV0FBVyxRQUFRO0FBQ25CLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsdURBQXVEO0FBQ2xFLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsNkVBQTZFO0FBQ3hGO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyw2RUFBNkU7QUFDeEYsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyx1REFBdUQ7QUFDbEUsV0FBVyw2RUFBNkU7QUFDeEYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaGFuZGxlci9jYWNoZS1oYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHtcbiAgcGFyc2VDYWNoZUNvbnRyb2xIZWFkZXIsXG4gIHBhcnNlVmFyeUhlYWRlcixcbiAgaXNFdGFnVXNhYmxlXG59ID0gcmVxdWlyZSgnLi4vdXRpbC9jYWNoZScpXG5jb25zdCB7IHBhcnNlSHR0cERhdGUgfSA9IHJlcXVpcmUoJy4uL3V0aWwvZGF0ZS5qcycpXG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuLy8gU3RhdHVzIGNvZGVzIHRoYXQgd2UgY2FuIHVzZSBzb21lIGhldXJpc3RpY3Mgb24gdG8gY2FjaGVcbmNvbnN0IEhFVVJJU1RJQ0FMTFlfQ0FDSEVBQkxFX1NUQVRVU19DT0RFUyA9IFtcbiAgMjAwLCAyMDMsIDIwNCwgMjA2LCAzMDAsIDMwMSwgMzA4LCA0MDQsIDQwNSwgNDEwLCA0MTQsIDUwMVxuXVxuXG5jb25zdCBNQVhfUkVTUE9OU0VfQUdFID0gMjE0NzQ4MzY0NzAwMFxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2Rpc3BhdGNoZXIuZC50cycpLmRlZmF1bHQuRGlzcGF0Y2hIYW5kbGVyfSBEaXNwYXRjaEhhbmRsZXJcbiAqXG4gKiBAaW1wbGVtZW50cyB7RGlzcGF0Y2hIYW5kbGVyfVxuICovXG5jbGFzcyBDYWNoZUhhbmRsZXIge1xuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVLZXl9XG4gICAqL1xuICAjY2FjaGVLZXlcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVIYW5kbGVyT3B0aW9uc1sndHlwZSddfVxuICAgKi9cbiAgI2NhY2hlVHlwZVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICAgKi9cbiAgI2NhY2hlQnlEZWZhdWx0XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlU3RvcmV9XG4gICAqL1xuICAjc3RvcmVcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnLi4vLi4vdHlwZXMvZGlzcGF0Y2hlci5kLnRzJykuZGVmYXVsdC5EaXNwYXRjaEhhbmRsZXJ9XG4gICAqL1xuICAjaGFuZGxlclxuXG4gIC8qKlxuICAgKiBAdHlwZSB7aW1wb3J0KCdub2RlOnN0cmVhbScpLldyaXRhYmxlIHwgdW5kZWZpbmVkfVxuICAgKi9cbiAgI3dyaXRlU3RyZWFtXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZUhhbmRsZXJPcHRpb25zfSBvcHRzXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZUtleX0gY2FjaGVLZXlcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2Rpc3BhdGNoZXIuZC50cycpLmRlZmF1bHQuRGlzcGF0Y2hIYW5kbGVyfSBoYW5kbGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeyBzdG9yZSwgdHlwZSwgY2FjaGVCeURlZmF1bHQgfSwgY2FjaGVLZXksIGhhbmRsZXIpIHtcbiAgICB0aGlzLiNzdG9yZSA9IHN0b3JlXG4gICAgdGhpcy4jY2FjaGVUeXBlID0gdHlwZVxuICAgIHRoaXMuI2NhY2hlQnlEZWZhdWx0ID0gY2FjaGVCeURlZmF1bHRcbiAgICB0aGlzLiNjYWNoZUtleSA9IGNhY2hlS2V5XG4gICAgdGhpcy4jaGFuZGxlciA9IGhhbmRsZXJcbiAgfVxuXG4gIG9uUmVxdWVzdFN0YXJ0IChjb250cm9sbGVyLCBjb250ZXh0KSB7XG4gICAgdGhpcy4jd3JpdGVTdHJlYW0/LmRlc3Ryb3koKVxuICAgIHRoaXMuI3dyaXRlU3RyZWFtID0gdW5kZWZpbmVkXG4gICAgdGhpcy4jaGFuZGxlci5vblJlcXVlc3RTdGFydD8uKGNvbnRyb2xsZXIsIGNvbnRleHQpXG4gIH1cblxuICBvblJlcXVlc3RVcGdyYWRlIChjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICB0aGlzLiNoYW5kbGVyLm9uUmVxdWVzdFVwZ3JhZGU/Lihjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2Rpc3BhdGNoZXIuZC50cycpLmRlZmF1bHQuRGlzcGF0Y2hDb250cm9sbGVyfSBjb250cm9sbGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNDb2RlXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9oZWFkZXIuZC50cycpLkluY29taW5nSHR0cEhlYWRlcnN9IHJlc0hlYWRlcnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1c01lc3NhZ2VcbiAgICovXG4gIG9uUmVzcG9uc2VTdGFydCAoXG4gICAgY29udHJvbGxlcixcbiAgICBzdGF0dXNDb2RlLFxuICAgIHJlc0hlYWRlcnMsXG4gICAgc3RhdHVzTWVzc2FnZVxuICApIHtcbiAgICBjb25zdCBkb3duc3RyZWFtT25IZWFkZXJzID0gKCkgPT5cbiAgICAgIHRoaXMuI2hhbmRsZXIub25SZXNwb25zZVN0YXJ0Py4oXG4gICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgIHJlc0hlYWRlcnMsXG4gICAgICAgIHN0YXR1c01lc3NhZ2VcbiAgICAgIClcblxuICAgIGlmIChcbiAgICAgICF1dGlsLnNhZmVIVFRQTWV0aG9kcy5pbmNsdWRlcyh0aGlzLiNjYWNoZUtleS5tZXRob2QpICYmXG4gICAgICBzdGF0dXNDb2RlID49IDIwMCAmJlxuICAgICAgc3RhdHVzQ29kZSA8PSAzOTlcbiAgICApIHtcbiAgICAgIC8vIFN1Y2Nlc3NmdWwgcmVzcG9uc2UgdG8gYW4gdW5zYWZlIG1ldGhvZCwgZGVsZXRlIGl0IGZyb20gY2FjaGVcbiAgICAgIC8vICBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMS5odG1sI25hbWUtaW52YWxpZGF0aW5nLXN0b3JlZC1yZXNwb25zZVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy4jc3RvcmUuZGVsZXRlKHRoaXMuI2NhY2hlS2V5KT8uY2F0Y2g/Lihub29wKVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIEZhaWwgc2lsZW50bHlcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb3duc3RyZWFtT25IZWFkZXJzKClcbiAgICB9XG5cbiAgICBjb25zdCBjYWNoZUNvbnRyb2xIZWFkZXIgPSByZXNIZWFkZXJzWydjYWNoZS1jb250cm9sJ11cbiAgICBjb25zdCBoZXVyaXN0aWNhbGx5Q2FjaGVhYmxlID0gcmVzSGVhZGVyc1snbGFzdC1tb2RpZmllZCddICYmIEhFVVJJU1RJQ0FMTFlfQ0FDSEVBQkxFX1NUQVRVU19DT0RFUy5pbmNsdWRlcyhzdGF0dXNDb2RlKVxuICAgIGlmIChcbiAgICAgICFjYWNoZUNvbnRyb2xIZWFkZXIgJiZcbiAgICAgICFyZXNIZWFkZXJzWydleHBpcmVzJ10gJiZcbiAgICAgICFoZXVyaXN0aWNhbGx5Q2FjaGVhYmxlICYmXG4gICAgICAhdGhpcy4jY2FjaGVCeURlZmF1bHRcbiAgICApIHtcbiAgICAgIC8vIERvbid0IGhhdmUgYW55dGhpbmcgdG8gdGVsbCB1cyB0aGlzIHJlc3BvbnNlIGlzIGNhY2hhYmxlIGFuZCB3ZSdyZSBub3RcbiAgICAgIC8vICBjYWNoaW5nIGJ5IGRlZmF1bHRcbiAgICAgIHJldHVybiBkb3duc3RyZWFtT25IZWFkZXJzKClcbiAgICB9XG5cbiAgICBjb25zdCBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzID0gY2FjaGVDb250cm9sSGVhZGVyID8gcGFyc2VDYWNoZUNvbnRyb2xIZWFkZXIoY2FjaGVDb250cm9sSGVhZGVyKSA6IHt9XG4gICAgaWYgKCFjYW5DYWNoZVJlc3BvbnNlKHRoaXMuI2NhY2hlVHlwZSwgc3RhdHVzQ29kZSwgcmVzSGVhZGVycywgY2FjaGVDb250cm9sRGlyZWN0aXZlcykpIHtcbiAgICAgIHJldHVybiBkb3duc3RyZWFtT25IZWFkZXJzKClcbiAgICB9XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgcmVzQWdlID0gcmVzSGVhZGVycy5hZ2UgPyBnZXRBZ2UocmVzSGVhZGVycy5hZ2UpIDogdW5kZWZpbmVkXG4gICAgaWYgKHJlc0FnZSAmJiByZXNBZ2UgPj0gTUFYX1JFU1BPTlNFX0FHRSkge1xuICAgICAgLy8gUmVzcG9uc2UgY29uc2lkZXJlZCBzdGFsZVxuICAgICAgcmV0dXJuIGRvd25zdHJlYW1PbkhlYWRlcnMoKVxuICAgIH1cblxuICAgIGNvbnN0IHJlc0RhdGUgPSB0eXBlb2YgcmVzSGVhZGVycy5kYXRlID09PSAnc3RyaW5nJ1xuICAgICAgPyBwYXJzZUh0dHBEYXRlKHJlc0hlYWRlcnMuZGF0ZSlcbiAgICAgIDogdW5kZWZpbmVkXG5cbiAgICBjb25zdCBzdGFsZUF0ID1cbiAgICAgIGRldGVybWluZVN0YWxlQXQodGhpcy4jY2FjaGVUeXBlLCBub3csIHJlc0FnZSwgcmVzSGVhZGVycywgcmVzRGF0ZSwgY2FjaGVDb250cm9sRGlyZWN0aXZlcykgPz9cbiAgICAgIHRoaXMuI2NhY2hlQnlEZWZhdWx0XG4gICAgaWYgKHN0YWxlQXQgPT09IHVuZGVmaW5lZCB8fCAocmVzQWdlICYmIHJlc0FnZSA+IHN0YWxlQXQpKSB7XG4gICAgICByZXR1cm4gZG93bnN0cmVhbU9uSGVhZGVycygpXG4gICAgfVxuXG4gICAgY29uc3QgYmFzZVRpbWUgPSByZXNEYXRlID8gcmVzRGF0ZS5nZXRUaW1lKCkgOiBub3dcbiAgICBjb25zdCBhYnNvbHV0ZVN0YWxlQXQgPSBzdGFsZUF0ICsgYmFzZVRpbWVcbiAgICBpZiAobm93ID49IGFic29sdXRlU3RhbGVBdCkge1xuICAgICAgLy8gUmVzcG9uc2UgaXMgYWxyZWFkeSBzdGFsZVxuICAgICAgcmV0dXJuIGRvd25zdHJlYW1PbkhlYWRlcnMoKVxuICAgIH1cblxuICAgIGxldCB2YXJ5RGlyZWN0aXZlc1xuICAgIGlmICh0aGlzLiNjYWNoZUtleS5oZWFkZXJzICYmIHJlc0hlYWRlcnMudmFyeSkge1xuICAgICAgdmFyeURpcmVjdGl2ZXMgPSBwYXJzZVZhcnlIZWFkZXIocmVzSGVhZGVycy52YXJ5LCB0aGlzLiNjYWNoZUtleS5oZWFkZXJzKVxuICAgICAgaWYgKCF2YXJ5RGlyZWN0aXZlcykge1xuICAgICAgICAvLyBQYXJzZSBlcnJvclxuICAgICAgICByZXR1cm4gZG93bnN0cmVhbU9uSGVhZGVycygpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZGVsZXRlQXQgPSBkZXRlcm1pbmVEZWxldGVBdChiYXNlVGltZSwgY2FjaGVDb250cm9sRGlyZWN0aXZlcywgYWJzb2x1dGVTdGFsZUF0KVxuICAgIGNvbnN0IHN0cmlwcGVkSGVhZGVycyA9IHN0cmlwTmVjZXNzYXJ5SGVhZGVycyhyZXNIZWFkZXJzLCBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzKVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVWYWx1ZX1cbiAgICAgKi9cbiAgICBjb25zdCB2YWx1ZSA9IHtcbiAgICAgIHN0YXR1c0NvZGUsXG4gICAgICBzdGF0dXNNZXNzYWdlLFxuICAgICAgaGVhZGVyczogc3RyaXBwZWRIZWFkZXJzLFxuICAgICAgdmFyeTogdmFyeURpcmVjdGl2ZXMsXG4gICAgICBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzLFxuICAgICAgY2FjaGVkQXQ6IHJlc0FnZSA/IG5vdyAtIHJlc0FnZSA6IG5vdyxcbiAgICAgIHN0YWxlQXQ6IGFic29sdXRlU3RhbGVBdCxcbiAgICAgIGRlbGV0ZUF0XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZXNIZWFkZXJzLmV0YWcgPT09ICdzdHJpbmcnICYmIGlzRXRhZ1VzYWJsZShyZXNIZWFkZXJzLmV0YWcpKSB7XG4gICAgICB2YWx1ZS5ldGFnID0gcmVzSGVhZGVycy5ldGFnXG4gICAgfVxuXG4gICAgdGhpcy4jd3JpdGVTdHJlYW0gPSB0aGlzLiNzdG9yZS5jcmVhdGVXcml0ZVN0cmVhbSh0aGlzLiNjYWNoZUtleSwgdmFsdWUpXG4gICAgaWYgKCF0aGlzLiN3cml0ZVN0cmVhbSkge1xuICAgICAgcmV0dXJuIGRvd25zdHJlYW1PbkhlYWRlcnMoKVxuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzXG4gICAgdGhpcy4jd3JpdGVTdHJlYW1cbiAgICAgIC5vbignZHJhaW4nLCAoKSA9PiBjb250cm9sbGVyLnJlc3VtZSgpKVxuICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVE9ETyAoZml4KTogTWFrZSBlcnJvciBzb21laG93IG9ic2VydmFibGU/XG4gICAgICAgIGhhbmRsZXIuI3dyaXRlU3RyZWFtID0gdW5kZWZpbmVkXG5cbiAgICAgICAgLy8gRGVsZXRlIHRoZSB2YWx1ZSBpbiBjYXNlIHRoZSBjYWNoZSBzdG9yZSBpcyBob2xkaW5nIG9udG8gc3RhdGUgZnJvbVxuICAgICAgICAvLyAgdGhlIGNhbGwgdG8gY3JlYXRlV3JpdGVTdHJlYW1cbiAgICAgICAgaGFuZGxlci4jc3RvcmUuZGVsZXRlKGhhbmRsZXIuI2NhY2hlS2V5KVxuICAgICAgfSlcbiAgICAgIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChoYW5kbGVyLiN3cml0ZVN0cmVhbSA9PT0gdGhpcykge1xuICAgICAgICAgIGhhbmRsZXIuI3dyaXRlU3RyZWFtID0gdW5kZWZpbmVkXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPIChmaXgpOiBTaG91bGQgd2UgcmVzdW1lIGV2ZW4gaWYgd2FzIHBhdXNlZCBkb3duc3RyZWFtP1xuICAgICAgICBjb250cm9sbGVyLnJlc3VtZSgpXG4gICAgICB9KVxuXG4gICAgcmV0dXJuIGRvd25zdHJlYW1PbkhlYWRlcnMoKVxuICB9XG5cbiAgb25SZXNwb25zZURhdGEgKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gICAgaWYgKHRoaXMuI3dyaXRlU3RyZWFtPy53cml0ZShjaHVuaykgPT09IGZhbHNlKSB7XG4gICAgICBjb250cm9sbGVyLnBhdXNlKClcbiAgICB9XG5cbiAgICB0aGlzLiNoYW5kbGVyLm9uUmVzcG9uc2VEYXRhPy4oY29udHJvbGxlciwgY2h1bmspXG4gIH1cblxuICBvblJlc3BvbnNlRW5kIChjb250cm9sbGVyLCB0cmFpbGVycykge1xuICAgIHRoaXMuI3dyaXRlU3RyZWFtPy5lbmQoKVxuICAgIHRoaXMuI2hhbmRsZXIub25SZXNwb25zZUVuZD8uKGNvbnRyb2xsZXIsIHRyYWlsZXJzKVxuICB9XG5cbiAgb25SZXNwb25zZUVycm9yIChjb250cm9sbGVyLCBlcnIpIHtcbiAgICB0aGlzLiN3cml0ZVN0cmVhbT8uZGVzdHJveShlcnIpXG4gICAgdGhpcy4jd3JpdGVTdHJlYW0gPSB1bmRlZmluZWRcbiAgICB0aGlzLiNoYW5kbGVyLm9uUmVzcG9uc2VFcnJvcj8uKGNvbnRyb2xsZXIsIGVycilcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTEuaHRtbCNuYW1lLXN0b3JpbmctcmVzcG9uc2VzLXRvLWF1dGhlblxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZU9wdGlvbnNbJ3R5cGUnXX0gY2FjaGVUeXBlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzQ29kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2hlYWRlci5kLnRzJykuSW5jb21pbmdIdHRwSGVhZGVyc30gcmVzSGVhZGVyc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlQ29udHJvbERpcmVjdGl2ZXN9IGNhY2hlQ29udHJvbERpcmVjdGl2ZXNcbiAqL1xuZnVuY3Rpb24gY2FuQ2FjaGVSZXNwb25zZSAoY2FjaGVUeXBlLCBzdGF0dXNDb2RlLCByZXNIZWFkZXJzLCBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzKSB7XG4gIGlmIChzdGF0dXNDb2RlICE9PSAyMDAgJiYgc3RhdHVzQ29kZSAhPT0gMzA3KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoY2FjaGVDb250cm9sRGlyZWN0aXZlc1snbm8tc3RvcmUnXSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGNhY2hlVHlwZSA9PT0gJ3NoYXJlZCcgJiYgY2FjaGVDb250cm9sRGlyZWN0aXZlcy5wcml2YXRlID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMS5odG1sI3NlY3Rpb24tNC4xLTVcbiAgaWYgKHJlc0hlYWRlcnMudmFyeT8uaW5jbHVkZXMoJyonKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTEuaHRtbCNuYW1lLXN0b3JpbmctcmVzcG9uc2VzLXRvLWF1dGhlblxuICBpZiAocmVzSGVhZGVycy5hdXRob3JpemF0aW9uKSB7XG4gICAgaWYgKCFjYWNoZUNvbnRyb2xEaXJlY3RpdmVzLnB1YmxpYyB8fCB0eXBlb2YgcmVzSGVhZGVycy5hdXRob3JpemF0aW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgQXJyYXkuaXNBcnJheShjYWNoZUNvbnRyb2xEaXJlY3RpdmVzWyduby1jYWNoZSddKSAmJlxuICAgICAgY2FjaGVDb250cm9sRGlyZWN0aXZlc1snbm8tY2FjaGUnXS5pbmNsdWRlcygnYXV0aG9yaXphdGlvbicpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBBcnJheS5pc0FycmF5KGNhY2hlQ29udHJvbERpcmVjdGl2ZXNbJ3ByaXZhdGUnXSkgJiZcbiAgICAgIGNhY2hlQ29udHJvbERpcmVjdGl2ZXNbJ3ByaXZhdGUnXS5pbmNsdWRlcygnYXV0aG9yaXphdGlvbicpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGFnZUhlYWRlclxuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZ2V0QWdlIChhZ2VIZWFkZXIpIHtcbiAgY29uc3QgYWdlID0gcGFyc2VJbnQoQXJyYXkuaXNBcnJheShhZ2VIZWFkZXIpID8gYWdlSGVhZGVyWzBdIDogYWdlSGVhZGVyKVxuXG4gIHJldHVybiBpc05hTihhZ2UpID8gdW5kZWZpbmVkIDogYWdlICogMTAwMFxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZU9wdGlvbnNbJ3R5cGUnXX0gY2FjaGVUeXBlXG4gKiBAcGFyYW0ge251bWJlcn0gbm93XG4gKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gYWdlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvaGVhZGVyLmQudHMnKS5JbmNvbWluZ0h0dHBIZWFkZXJzfSByZXNIZWFkZXJzXG4gKiBAcGFyYW0ge0RhdGUgfCB1bmRlZmluZWR9IHJlc3BvbnNlRGF0ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlQ29udHJvbERpcmVjdGl2ZXN9IGNhY2hlQ29udHJvbERpcmVjdGl2ZXNcbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfSB0aW1lIHRoYXQgdGhlIHZhbHVlIGlzIHN0YWxlIGF0IGluIHNlY29uZHMgb3IgdW5kZWZpbmVkIGlmIGl0IHNob3VsZG4ndCBiZSBjYWNoZWRcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lU3RhbGVBdCAoY2FjaGVUeXBlLCBub3csIGFnZSwgcmVzSGVhZGVycywgcmVzcG9uc2VEYXRlLCBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzKSB7XG4gIGlmIChjYWNoZVR5cGUgPT09ICdzaGFyZWQnKSB7XG4gICAgLy8gUHJpb3JpdGl6ZSBzLW1heGFnZSBzaW5jZSB3ZSdyZSBhIHNoYXJlZCBjYWNoZVxuICAgIC8vICBzLW1heGFnZSA+IG1heC1hZ2UgPiBFeHBpcmVcbiAgICAvLyAgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTEuaHRtbCNzZWN0aW9uLTUuMi4yLjEwLTNcbiAgICBjb25zdCBzTWF4QWdlID0gY2FjaGVDb250cm9sRGlyZWN0aXZlc1sncy1tYXhhZ2UnXVxuICAgIGlmIChzTWF4QWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBzTWF4QWdlID4gMCA/IHNNYXhBZ2UgKiAxMDAwIDogdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWF4QWdlID0gY2FjaGVDb250cm9sRGlyZWN0aXZlc1snbWF4LWFnZSddXG4gIGlmIChtYXhBZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBtYXhBZ2UgPiAwID8gbWF4QWdlICogMTAwMCA6IHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKHR5cGVvZiByZXNIZWFkZXJzLmV4cGlyZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTEuaHRtbCNzZWN0aW9uLTUuM1xuICAgIGNvbnN0IGV4cGlyZXNEYXRlID0gcGFyc2VIdHRwRGF0ZShyZXNIZWFkZXJzLmV4cGlyZXMpXG4gICAgaWYgKGV4cGlyZXNEYXRlKSB7XG4gICAgICBpZiAobm93ID49IGV4cGlyZXNEYXRlLmdldFRpbWUoKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGlmIChyZXNwb25zZURhdGUpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlRGF0ZSA+PSBleHBpcmVzRGF0ZSkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZ2UgIT09IHVuZGVmaW5lZCAmJiBhZ2UgPiAoZXhwaXJlc0RhdGUgLSByZXNwb25zZURhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHBpcmVzRGF0ZS5nZXRUaW1lKCkgLSBub3dcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHJlc0hlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMS5odG1sI25hbWUtY2FsY3VsYXRpbmctaGV1cmlzdGljLWZyZXNoXG4gICAgY29uc3QgbGFzdE1vZGlmaWVkID0gbmV3IERhdGUocmVzSGVhZGVyc1snbGFzdC1tb2RpZmllZCddKVxuICAgIGlmIChpc1ZhbGlkRGF0ZShsYXN0TW9kaWZpZWQpKSB7XG4gICAgICBpZiAobGFzdE1vZGlmaWVkLmdldFRpbWUoKSA+PSBub3cpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZUFnZSA9IG5vdyAtIGxhc3RNb2RpZmllZC5nZXRUaW1lKClcblxuICAgICAgcmV0dXJuIHJlc3BvbnNlQWdlICogMC4xXG4gICAgfVxuICB9XG5cbiAgaWYgKGNhY2hlQ29udHJvbERpcmVjdGl2ZXMuaW1tdXRhYmxlKSB7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzgyNDYuaHRtbCNzZWN0aW9uLTIuMlxuICAgIHJldHVybiAzMTUzNjAwMFxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBub3dcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZUNvbnRyb2xEaXJlY3RpdmVzfSBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhbGVBdFxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVEZWxldGVBdCAobm93LCBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzLCBzdGFsZUF0KSB7XG4gIGxldCBzdGFsZVdoaWxlUmV2YWxpZGF0ZSA9IC1JbmZpbml0eVxuICBsZXQgc3RhbGVJZkVycm9yID0gLUluZmluaXR5XG4gIGxldCBpbW11dGFibGUgPSAtSW5maW5pdHlcblxuICBpZiAoY2FjaGVDb250cm9sRGlyZWN0aXZlc1snc3RhbGUtd2hpbGUtcmV2YWxpZGF0ZSddKSB7XG4gICAgc3RhbGVXaGlsZVJldmFsaWRhdGUgPSBzdGFsZUF0ICsgKGNhY2hlQ29udHJvbERpcmVjdGl2ZXNbJ3N0YWxlLXdoaWxlLXJldmFsaWRhdGUnXSAqIDEwMDApXG4gIH1cblxuICBpZiAoY2FjaGVDb250cm9sRGlyZWN0aXZlc1snc3RhbGUtaWYtZXJyb3InXSkge1xuICAgIHN0YWxlSWZFcnJvciA9IHN0YWxlQXQgKyAoY2FjaGVDb250cm9sRGlyZWN0aXZlc1snc3RhbGUtaWYtZXJyb3InXSAqIDEwMDApXG4gIH1cblxuICBpZiAoc3RhbGVXaGlsZVJldmFsaWRhdGUgPT09IC1JbmZpbml0eSAmJiBzdGFsZUlmRXJyb3IgPT09IC1JbmZpbml0eSkge1xuICAgIGltbXV0YWJsZSA9IG5vdyArIDMxNTM2MDAwMDAwXG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXgoc3RhbGVBdCwgc3RhbGVXaGlsZVJldmFsaWRhdGUsIHN0YWxlSWZFcnJvciwgaW1tdXRhYmxlKVxufVxuXG4vKipcbiAqIFN0cmlwcyBoZWFkZXJzIHJlcXVpcmVkIHRvIGJlIHJlbW92ZWQgaW4gY2FjaGVkIHJlc3BvbnNlc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2hlYWRlci5kLnRzJykuSW5jb21pbmdIdHRwSGVhZGVyc30gcmVzSGVhZGVyc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlQ29udHJvbERpcmVjdGl2ZXN9IGNhY2hlQ29udHJvbERpcmVjdGl2ZXNcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmcgW10+fVxuICovXG5mdW5jdGlvbiBzdHJpcE5lY2Vzc2FyeUhlYWRlcnMgKHJlc0hlYWRlcnMsIGNhY2hlQ29udHJvbERpcmVjdGl2ZXMpIHtcbiAgY29uc3QgaGVhZGVyc1RvUmVtb3ZlID0gW1xuICAgICdjb25uZWN0aW9uJyxcbiAgICAncHJveHktYXV0aGVudGljYXRlJyxcbiAgICAncHJveHktYXV0aGVudGljYXRpb24taW5mbycsXG4gICAgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAgICdwcm94eS1jb25uZWN0aW9uJyxcbiAgICAndGUnLFxuICAgICd0cmFuc2Zlci1lbmNvZGluZycsXG4gICAgJ3VwZ3JhZGUnLFxuICAgIC8vIFdlJ2xsIGFkZCBhZ2UgYmFjayB3aGVuIHNlcnZpbmcgaXRcbiAgICAnYWdlJ1xuICBdXG5cbiAgaWYgKHJlc0hlYWRlcnNbJ2Nvbm5lY3Rpb24nXSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc0hlYWRlcnNbJ2Nvbm5lY3Rpb24nXSkpIHtcbiAgICAgIC8vIGNvbm5lY3Rpb246IGFcbiAgICAgIC8vIGNvbm5lY3Rpb246IGJcbiAgICAgIGhlYWRlcnNUb1JlbW92ZS5wdXNoKC4uLnJlc0hlYWRlcnNbJ2Nvbm5lY3Rpb24nXS5tYXAoaGVhZGVyID0+IGhlYWRlci50cmltKCkpKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25uZWN0aW9uOiBhLCBiXG4gICAgICBoZWFkZXJzVG9SZW1vdmUucHVzaCguLi5yZXNIZWFkZXJzWydjb25uZWN0aW9uJ10uc3BsaXQoJywnKS5tYXAoaGVhZGVyID0+IGhlYWRlci50cmltKCkpKVxuICAgIH1cbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGNhY2hlQ29udHJvbERpcmVjdGl2ZXNbJ25vLWNhY2hlJ10pKSB7XG4gICAgaGVhZGVyc1RvUmVtb3ZlLnB1c2goLi4uY2FjaGVDb250cm9sRGlyZWN0aXZlc1snbm8tY2FjaGUnXSlcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGNhY2hlQ29udHJvbERpcmVjdGl2ZXNbJ3ByaXZhdGUnXSkpIHtcbiAgICBoZWFkZXJzVG9SZW1vdmUucHVzaCguLi5jYWNoZUNvbnRyb2xEaXJlY3RpdmVzWydwcml2YXRlJ10pXG4gIH1cblxuICBsZXQgc3RyaXBwZWRIZWFkZXJzXG4gIGZvciAoY29uc3QgaGVhZGVyTmFtZSBvZiBoZWFkZXJzVG9SZW1vdmUpIHtcbiAgICBpZiAocmVzSGVhZGVyc1toZWFkZXJOYW1lXSkge1xuICAgICAgc3RyaXBwZWRIZWFkZXJzID8/PSB7IC4uLnJlc0hlYWRlcnMgfVxuICAgICAgZGVsZXRlIHN0cmlwcGVkSGVhZGVyc1toZWFkZXJOYW1lXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHJpcHBlZEhlYWRlcnMgPz8gcmVzSGVhZGVyc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWREYXRlIChkYXRlKSB7XG4gIHJldHVybiBkYXRlIGluc3RhbmNlb2YgRGF0ZSAmJiBOdW1iZXIuaXNGaW5pdGUoZGF0ZS52YWx1ZU9mKCkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FjaGVIYW5kbGVyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/cache-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/cache-revalidation-handler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/undici/lib/handler/cache-revalidation-handler.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\n/**\n * This takes care of revalidation requests we send to the origin. If we get\n *  a response indicating that what we have is cached (via a HTTP 304), we can\n *  continue using the cached value. Otherwise, we'll receive the new response\n *  here, which we then just pass on to the next handler (most likely a\n *  CacheHandler). Note that this assumes the proper headers were already\n *  included in the request to tell the origin that we want to revalidate the\n *  response (i.e. if-modified-since or if-none-match).\n *\n * @see https://www.rfc-editor.org/rfc/rfc9111.html#name-validation\n *\n * @implements {import('../../types/dispatcher.d.ts').default.DispatchHandler}\n */\nclass CacheRevalidationHandler {\n  #successful = false\n\n  /**\n   * @type {((boolean, any) => void) | null}\n   */\n  #callback\n\n  /**\n   * @type {(import('../../types/dispatcher.d.ts').default.DispatchHandler)}\n   */\n  #handler\n\n  #context\n\n  /**\n   * @type {boolean}\n   */\n  #allowErrorStatusCodes\n\n  /**\n   * @param {(boolean) => void} callback Function to call if the cached value is valid\n   * @param {import('../../types/dispatcher.d.ts').default.DispatchHandlers} handler\n   * @param {boolean} allowErrorStatusCodes\n   */\n  constructor (callback, handler, allowErrorStatusCodes) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function')\n    }\n\n    this.#callback = callback\n    this.#handler = handler\n    this.#allowErrorStatusCodes = allowErrorStatusCodes\n  }\n\n  onRequestStart (_, context) {\n    this.#successful = false\n    this.#context = context\n  }\n\n  onRequestUpgrade (controller, statusCode, headers, socket) {\n    this.#handler.onRequestUpgrade?.(controller, statusCode, headers, socket)\n  }\n\n  onResponseStart (\n    controller,\n    statusCode,\n    headers,\n    statusMessage\n  ) {\n    assert(this.#callback != null)\n\n    // https://www.rfc-editor.org/rfc/rfc9111.html#name-handling-a-validation-respo\n    // https://datatracker.ietf.org/doc/html/rfc5861#section-4\n    this.#successful = statusCode === 304 ||\n      (this.#allowErrorStatusCodes && statusCode >= 500 && statusCode <= 504)\n    this.#callback(this.#successful, this.#context)\n    this.#callback = null\n\n    if (this.#successful) {\n      return true\n    }\n\n    this.#handler.onRequestStart?.(controller, this.#context)\n    this.#handler.onResponseStart?.(\n      controller,\n      statusCode,\n      headers,\n      statusMessage\n    )\n  }\n\n  onResponseData (controller, chunk) {\n    if (this.#successful) {\n      return\n    }\n\n    return this.#handler.onResponseData?.(controller, chunk)\n  }\n\n  onResponseEnd (controller, trailers) {\n    if (this.#successful) {\n      return\n    }\n\n    this.#handler.onResponseEnd?.(controller, trailers)\n  }\n\n  onResponseError (controller, err) {\n    if (this.#successful) {\n      return\n    }\n\n    if (this.#callback) {\n      this.#callback(false)\n      this.#callback = null\n    }\n\n    if (typeof this.#handler.onResponseError === 'function') {\n      this.#handler.onResponseError(controller, err)\n    } else {\n      throw err\n    }\n  }\n}\n\nmodule.exports = CacheRevalidationHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL2NhY2hlLXJldmFsaWRhdGlvbi1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLGdFQUFnRTtBQUM3RSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2hhbmRsZXIvY2FjaGUtcmV2YWxpZGF0aW9uLWhhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcblxuLyoqXG4gKiBUaGlzIHRha2VzIGNhcmUgb2YgcmV2YWxpZGF0aW9uIHJlcXVlc3RzIHdlIHNlbmQgdG8gdGhlIG9yaWdpbi4gSWYgd2UgZ2V0XG4gKiAgYSByZXNwb25zZSBpbmRpY2F0aW5nIHRoYXQgd2hhdCB3ZSBoYXZlIGlzIGNhY2hlZCAodmlhIGEgSFRUUCAzMDQpLCB3ZSBjYW5cbiAqICBjb250aW51ZSB1c2luZyB0aGUgY2FjaGVkIHZhbHVlLiBPdGhlcndpc2UsIHdlJ2xsIHJlY2VpdmUgdGhlIG5ldyByZXNwb25zZVxuICogIGhlcmUsIHdoaWNoIHdlIHRoZW4ganVzdCBwYXNzIG9uIHRvIHRoZSBuZXh0IGhhbmRsZXIgKG1vc3QgbGlrZWx5IGFcbiAqICBDYWNoZUhhbmRsZXIpLiBOb3RlIHRoYXQgdGhpcyBhc3N1bWVzIHRoZSBwcm9wZXIgaGVhZGVycyB3ZXJlIGFscmVhZHlcbiAqICBpbmNsdWRlZCBpbiB0aGUgcmVxdWVzdCB0byB0ZWxsIHRoZSBvcmlnaW4gdGhhdCB3ZSB3YW50IHRvIHJldmFsaWRhdGUgdGhlXG4gKiAgcmVzcG9uc2UgKGkuZS4gaWYtbW9kaWZpZWQtc2luY2Ugb3IgaWYtbm9uZS1tYXRjaCkuXG4gKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMS5odG1sI25hbWUtdmFsaWRhdGlvblxuICpcbiAqIEBpbXBsZW1lbnRzIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2Rpc3BhdGNoZXIuZC50cycpLmRlZmF1bHQuRGlzcGF0Y2hIYW5kbGVyfVxuICovXG5jbGFzcyBDYWNoZVJldmFsaWRhdGlvbkhhbmRsZXIge1xuICAjc3VjY2Vzc2Z1bCA9IGZhbHNlXG5cbiAgLyoqXG4gICAqIEB0eXBlIHsoKGJvb2xlYW4sIGFueSkgPT4gdm9pZCkgfCBudWxsfVxuICAgKi9cbiAgI2NhbGxiYWNrXG5cbiAgLyoqXG4gICAqIEB0eXBlIHsoaW1wb3J0KCcuLi8uLi90eXBlcy9kaXNwYXRjaGVyLmQudHMnKS5kZWZhdWx0LkRpc3BhdGNoSGFuZGxlcil9XG4gICAqL1xuICAjaGFuZGxlclxuXG4gICNjb250ZXh0XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgI2FsbG93RXJyb3JTdGF0dXNDb2Rlc1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyhib29sZWFuKSA9PiB2b2lkfSBjYWxsYmFjayBGdW5jdGlvbiB0byBjYWxsIGlmIHRoZSBjYWNoZWQgdmFsdWUgaXMgdmFsaWRcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2Rpc3BhdGNoZXIuZC50cycpLmRlZmF1bHQuRGlzcGF0Y2hIYW5kbGVyc30gaGFuZGxlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93RXJyb3JTdGF0dXNDb2Rlc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGNhbGxiYWNrLCBoYW5kbGVyLCBhbGxvd0Vycm9yU3RhdHVzQ29kZXMpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICAgIH1cblxuICAgIHRoaXMuI2NhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLiNoYW5kbGVyID0gaGFuZGxlclxuICAgIHRoaXMuI2FsbG93RXJyb3JTdGF0dXNDb2RlcyA9IGFsbG93RXJyb3JTdGF0dXNDb2Rlc1xuICB9XG5cbiAgb25SZXF1ZXN0U3RhcnQgKF8sIGNvbnRleHQpIHtcbiAgICB0aGlzLiNzdWNjZXNzZnVsID0gZmFsc2VcbiAgICB0aGlzLiNjb250ZXh0ID0gY29udGV4dFxuICB9XG5cbiAgb25SZXF1ZXN0VXBncmFkZSAoY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KSB7XG4gICAgdGhpcy4jaGFuZGxlci5vblJlcXVlc3RVcGdyYWRlPy4oY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KVxuICB9XG5cbiAgb25SZXNwb25zZVN0YXJ0IChcbiAgICBjb250cm9sbGVyLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgaGVhZGVycyxcbiAgICBzdGF0dXNNZXNzYWdlXG4gICkge1xuICAgIGFzc2VydCh0aGlzLiNjYWxsYmFjayAhPSBudWxsKVxuXG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTEuaHRtbCNuYW1lLWhhbmRsaW5nLWEtdmFsaWRhdGlvbi1yZXNwb1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNTg2MSNzZWN0aW9uLTRcbiAgICB0aGlzLiNzdWNjZXNzZnVsID0gc3RhdHVzQ29kZSA9PT0gMzA0IHx8XG4gICAgICAodGhpcy4jYWxsb3dFcnJvclN0YXR1c0NvZGVzICYmIHN0YXR1c0NvZGUgPj0gNTAwICYmIHN0YXR1c0NvZGUgPD0gNTA0KVxuICAgIHRoaXMuI2NhbGxiYWNrKHRoaXMuI3N1Y2Nlc3NmdWwsIHRoaXMuI2NvbnRleHQpXG4gICAgdGhpcy4jY2FsbGJhY2sgPSBudWxsXG5cbiAgICBpZiAodGhpcy4jc3VjY2Vzc2Z1bCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICB0aGlzLiNoYW5kbGVyLm9uUmVxdWVzdFN0YXJ0Py4oY29udHJvbGxlciwgdGhpcy4jY29udGV4dClcbiAgICB0aGlzLiNoYW5kbGVyLm9uUmVzcG9uc2VTdGFydD8uKFxuICAgICAgY29udHJvbGxlcixcbiAgICAgIHN0YXR1c0NvZGUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc3RhdHVzTWVzc2FnZVxuICAgIClcbiAgfVxuXG4gIG9uUmVzcG9uc2VEYXRhIChjb250cm9sbGVyLCBjaHVuaykge1xuICAgIGlmICh0aGlzLiNzdWNjZXNzZnVsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vblJlc3BvbnNlRGF0YT8uKGNvbnRyb2xsZXIsIGNodW5rKVxuICB9XG5cbiAgb25SZXNwb25zZUVuZCAoY29udHJvbGxlciwgdHJhaWxlcnMpIHtcbiAgICBpZiAodGhpcy4jc3VjY2Vzc2Z1bCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy4jaGFuZGxlci5vblJlc3BvbnNlRW5kPy4oY29udHJvbGxlciwgdHJhaWxlcnMpXG4gIH1cblxuICBvblJlc3BvbnNlRXJyb3IgKGNvbnRyb2xsZXIsIGVycikge1xuICAgIGlmICh0aGlzLiNzdWNjZXNzZnVsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy4jY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuI2NhbGxiYWNrKGZhbHNlKVxuICAgICAgdGhpcy4jY2FsbGJhY2sgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLiNoYW5kbGVyLm9uUmVzcG9uc2VFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jaGFuZGxlci5vblJlc3BvbnNlRXJyb3IoY29udHJvbGxlciwgZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYWNoZVJldmFsaWRhdGlvbkhhbmRsZXJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/cache-revalidation-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/decorator-handler.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/handler/decorator-handler.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst WrapHandler = __webpack_require__(/*! ./wrap-handler */ \"(rsc)/./node_modules/undici/lib/handler/wrap-handler.js\")\n\n/**\n * @deprecated\n */\nmodule.exports = class DecoratorHandler {\n  #handler\n  #onCompleteCalled = false\n  #onErrorCalled = false\n  #onResponseStartCalled = false\n\n  constructor (handler) {\n    if (typeof handler !== 'object' || handler === null) {\n      throw new TypeError('handler must be an object')\n    }\n    this.#handler = WrapHandler.wrap(handler)\n  }\n\n  onRequestStart (...args) {\n    this.#handler.onRequestStart?.(...args)\n  }\n\n  onRequestUpgrade (...args) {\n    assert(!this.#onCompleteCalled)\n    assert(!this.#onErrorCalled)\n\n    return this.#handler.onRequestUpgrade?.(...args)\n  }\n\n  onResponseStart (...args) {\n    assert(!this.#onCompleteCalled)\n    assert(!this.#onErrorCalled)\n    assert(!this.#onResponseStartCalled)\n\n    this.#onResponseStartCalled = true\n\n    return this.#handler.onResponseStart?.(...args)\n  }\n\n  onResponseData (...args) {\n    assert(!this.#onCompleteCalled)\n    assert(!this.#onErrorCalled)\n\n    return this.#handler.onResponseData?.(...args)\n  }\n\n  onResponseEnd (...args) {\n    assert(!this.#onCompleteCalled)\n    assert(!this.#onErrorCalled)\n\n    this.#onCompleteCalled = true\n    return this.#handler.onResponseEnd?.(...args)\n  }\n\n  onResponseError (...args) {\n    this.#onErrorCalled = true\n    return this.#handler.onResponseError?.(...args)\n  }\n\n  /**\n   * @deprecated\n   */\n  onBodySent () {}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL2RlY29yYXRvci1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBZ0I7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL2RlY29yYXRvci1oYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCBXcmFwSGFuZGxlciA9IHJlcXVpcmUoJy4vd3JhcC1oYW5kbGVyJylcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIERlY29yYXRvckhhbmRsZXIge1xuICAjaGFuZGxlclxuICAjb25Db21wbGV0ZUNhbGxlZCA9IGZhbHNlXG4gICNvbkVycm9yQ2FsbGVkID0gZmFsc2VcbiAgI29uUmVzcG9uc2VTdGFydENhbGxlZCA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3IgKGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdvYmplY3QnIHx8IGhhbmRsZXIgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hhbmRsZXIgbXVzdCBiZSBhbiBvYmplY3QnKVxuICAgIH1cbiAgICB0aGlzLiNoYW5kbGVyID0gV3JhcEhhbmRsZXIud3JhcChoYW5kbGVyKVxuICB9XG5cbiAgb25SZXF1ZXN0U3RhcnQgKC4uLmFyZ3MpIHtcbiAgICB0aGlzLiNoYW5kbGVyLm9uUmVxdWVzdFN0YXJ0Py4oLi4uYXJncylcbiAgfVxuXG4gIG9uUmVxdWVzdFVwZ3JhZGUgKC4uLmFyZ3MpIHtcbiAgICBhc3NlcnQoIXRoaXMuI29uQ29tcGxldGVDYWxsZWQpXG4gICAgYXNzZXJ0KCF0aGlzLiNvbkVycm9yQ2FsbGVkKVxuXG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25SZXF1ZXN0VXBncmFkZT8uKC4uLmFyZ3MpXG4gIH1cblxuICBvblJlc3BvbnNlU3RhcnQgKC4uLmFyZ3MpIHtcbiAgICBhc3NlcnQoIXRoaXMuI29uQ29tcGxldGVDYWxsZWQpXG4gICAgYXNzZXJ0KCF0aGlzLiNvbkVycm9yQ2FsbGVkKVxuICAgIGFzc2VydCghdGhpcy4jb25SZXNwb25zZVN0YXJ0Q2FsbGVkKVxuXG4gICAgdGhpcy4jb25SZXNwb25zZVN0YXJ0Q2FsbGVkID0gdHJ1ZVxuXG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25SZXNwb25zZVN0YXJ0Py4oLi4uYXJncylcbiAgfVxuXG4gIG9uUmVzcG9uc2VEYXRhICguLi5hcmdzKSB7XG4gICAgYXNzZXJ0KCF0aGlzLiNvbkNvbXBsZXRlQ2FsbGVkKVxuICAgIGFzc2VydCghdGhpcy4jb25FcnJvckNhbGxlZClcblxuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uUmVzcG9uc2VEYXRhPy4oLi4uYXJncylcbiAgfVxuXG4gIG9uUmVzcG9uc2VFbmQgKC4uLmFyZ3MpIHtcbiAgICBhc3NlcnQoIXRoaXMuI29uQ29tcGxldGVDYWxsZWQpXG4gICAgYXNzZXJ0KCF0aGlzLiNvbkVycm9yQ2FsbGVkKVxuXG4gICAgdGhpcy4jb25Db21wbGV0ZUNhbGxlZCA9IHRydWVcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vblJlc3BvbnNlRW5kPy4oLi4uYXJncylcbiAgfVxuXG4gIG9uUmVzcG9uc2VFcnJvciAoLi4uYXJncykge1xuICAgIHRoaXMuI29uRXJyb3JDYWxsZWQgPSB0cnVlXG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25SZXNwb25zZUVycm9yPy4oLi4uYXJncylcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgb25Cb2R5U2VudCAoKSB7fVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/decorator-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/redirect-handler.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/handler/redirect-handler.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst EE = __webpack_require__(/*! node:events */ \"node:events\")\n\nconst redirectableStatusCodes = [300, 301, 302, 303, 307, 308]\n\nconst kBody = Symbol('body')\n\nconst noop = () => {}\n\nclass BodyAsyncIterable {\n  constructor (body) {\n    this[kBody] = body\n    this[kBodyUsed] = false\n  }\n\n  async * [Symbol.asyncIterator] () {\n    assert(!this[kBodyUsed], 'disturbed')\n    this[kBodyUsed] = true\n    yield * this[kBody]\n  }\n}\n\nclass RedirectHandler {\n  static buildDispatch (dispatcher, maxRedirections) {\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    const dispatch = dispatcher.dispatch.bind(dispatcher)\n    return (opts, originalHandler) => dispatch(opts, new RedirectHandler(dispatch, maxRedirections, opts, originalHandler))\n  }\n\n  constructor (dispatch, maxRedirections, opts, handler) {\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    this.dispatch = dispatch\n    this.location = null\n    this.opts = { ...opts, maxRedirections: 0 } // opts must be a copy\n    this.maxRedirections = maxRedirections\n    this.handler = handler\n    this.history = []\n\n    if (util.isStream(this.opts.body)) {\n      // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n      // so that it can be dispatched again?\n      // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n      if (util.bodyLength(this.opts.body) === 0) {\n        this.opts.body\n          .on('data', function () {\n            assert(false)\n          })\n      }\n\n      if (typeof this.opts.body.readableDidRead !== 'boolean') {\n        this.opts.body[kBodyUsed] = false\n        EE.prototype.on.call(this.opts.body, 'data', function () {\n          this[kBodyUsed] = true\n        })\n      }\n    } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {\n      // TODO (fix): We can't access ReadableStream internal state\n      // to determine whether or not it has been disturbed. This is just\n      // a workaround.\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    } else if (\n      this.opts.body &&\n      typeof this.opts.body !== 'string' &&\n      !ArrayBuffer.isView(this.opts.body) &&\n      util.isIterable(this.opts.body) &&\n      !util.isFormDataLike(this.opts.body)\n    ) {\n      // TODO: Should we allow re-using iterable if !this.opts.idempotent\n      // or through some other flag?\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    }\n  }\n\n  onRequestStart (controller, context) {\n    this.handler.onRequestStart?.(controller, { ...context, history: this.history })\n  }\n\n  onRequestUpgrade (controller, statusCode, headers, socket) {\n    this.handler.onRequestUpgrade?.(controller, statusCode, headers, socket)\n  }\n\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {\n      throw new Error('max redirects')\n    }\n\n    // https://tools.ietf.org/html/rfc7231#section-6.4.2\n    // https://fetch.spec.whatwg.org/#http-redirect-fetch\n    // In case of HTTP 301 or 302 with POST, change the method to GET\n    if ((statusCode === 301 || statusCode === 302) && this.opts.method === 'POST') {\n      this.opts.method = 'GET'\n      if (util.isStream(this.opts.body)) {\n        util.destroy(this.opts.body.on('error', noop))\n      }\n      this.opts.body = null\n    }\n\n    // https://tools.ietf.org/html/rfc7231#section-6.4.4\n    // In case of HTTP 303, always replace method to be either HEAD or GET\n    if (statusCode === 303 && this.opts.method !== 'HEAD') {\n      this.opts.method = 'GET'\n      if (util.isStream(this.opts.body)) {\n        util.destroy(this.opts.body.on('error', noop))\n      }\n      this.opts.body = null\n    }\n\n    this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) || redirectableStatusCodes.indexOf(statusCode) === -1\n      ? null\n      : headers.location\n\n    if (this.opts.origin) {\n      this.history.push(new URL(this.opts.path, this.opts.origin))\n    }\n\n    if (!this.location) {\n      this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage)\n      return\n    }\n\n    const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)))\n    const path = search ? `${pathname}${search}` : pathname\n\n    // Remove headers referring to the original URL.\n    // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.\n    // https://tools.ietf.org/html/rfc7231#section-6.4\n    this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin)\n    this.opts.path = path\n    this.opts.origin = origin\n    this.opts.maxRedirections = 0\n    this.opts.query = null\n  }\n\n  onResponseData (controller, chunk) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response bodies.\n\n        Redirection is used to serve the requested resource from another URL, so it assumes that\n        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.\n\n        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually\n        (which means it's optional and not mandated) contain just an hyperlink to the value of\n        the Location response header, so the body can be ignored safely.\n\n        For status 300, which is \"Multiple Choices\", the spec mentions both generating a Location\n        response header AND a response body with the other possible location to follow.\n        Since the spec explicitly chooses not to specify a format for such body and leave it to\n        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.\n      */\n    } else {\n      this.handler.onResponseData?.(controller, chunk)\n    }\n  }\n\n  onResponseEnd (controller, trailers) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections\n        and neither are useful if present.\n\n        See comment on onData method above for more detailed information.\n      */\n      this.dispatch(this.opts, this)\n    } else {\n      this.handler.onResponseEnd(controller, trailers)\n    }\n  }\n\n  onResponseError (controller, error) {\n    this.handler.onResponseError?.(controller, error)\n  }\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4.4\nfunction shouldRemoveHeader (header, removeContent, unknownOrigin) {\n  if (header.length === 4) {\n    return util.headerNameToString(header) === 'host'\n  }\n  if (removeContent && util.headerNameToString(header).startsWith('content-')) {\n    return true\n  }\n  if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {\n    const name = util.headerNameToString(header)\n    return name === 'authorization' || name === 'cookie' || name === 'proxy-authorization'\n  }\n  return false\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4\nfunction cleanRequestHeaders (headers, removeContent, unknownOrigin) {\n  const ret = []\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n        ret.push(headers[i], headers[i + 1])\n      }\n    }\n  } else if (headers && typeof headers === 'object') {\n    const entries = typeof headers[Symbol.iterator] === 'function' ? headers : Object.entries(headers)\n    for (const [key, value] of entries) {\n      if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n        ret.push(key, value)\n      }\n    }\n  } else {\n    assert(headers == null, 'headers must be an object or an array')\n  }\n  return ret\n}\n\nmodule.exports = RedirectHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3JlZGlyZWN0LWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsd0VBQWlCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQ3pELFdBQVcsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFaEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxtQ0FBbUM7QUFDbkY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksMkJBQTJCO0FBQ3ZDLDZCQUE2QixTQUFTLEVBQUUsT0FBTzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaGFuZGxlci9yZWRpcmVjdC1oYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsga0JvZHlVc2VkIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgRUUgPSByZXF1aXJlKCdub2RlOmV2ZW50cycpXG5cbmNvbnN0IHJlZGlyZWN0YWJsZVN0YXR1c0NvZGVzID0gWzMwMCwgMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbmNvbnN0IGtCb2R5ID0gU3ltYm9sKCdib2R5JylcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9XG5cbmNsYXNzIEJvZHlBc3luY0l0ZXJhYmxlIHtcbiAgY29uc3RydWN0b3IgKGJvZHkpIHtcbiAgICB0aGlzW2tCb2R5XSA9IGJvZHlcbiAgICB0aGlzW2tCb2R5VXNlZF0gPSBmYWxzZVxuICB9XG5cbiAgYXN5bmMgKiBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdICgpIHtcbiAgICBhc3NlcnQoIXRoaXNba0JvZHlVc2VkXSwgJ2Rpc3R1cmJlZCcpXG4gICAgdGhpc1trQm9keVVzZWRdID0gdHJ1ZVxuICAgIHlpZWxkICogdGhpc1trQm9keV1cbiAgfVxufVxuXG5jbGFzcyBSZWRpcmVjdEhhbmRsZXIge1xuICBzdGF0aWMgYnVpbGREaXNwYXRjaCAoZGlzcGF0Y2hlciwgbWF4UmVkaXJlY3Rpb25zKSB7XG4gICAgaWYgKG1heFJlZGlyZWN0aW9ucyAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZWRpcmVjdGlvbnMpIHx8IG1heFJlZGlyZWN0aW9ucyA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFJlZGlyZWN0aW9ucyBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGRpc3BhdGNoZXIuZGlzcGF0Y2guYmluZChkaXNwYXRjaGVyKVxuICAgIHJldHVybiAob3B0cywgb3JpZ2luYWxIYW5kbGVyKSA9PiBkaXNwYXRjaChvcHRzLCBuZXcgUmVkaXJlY3RIYW5kbGVyKGRpc3BhdGNoLCBtYXhSZWRpcmVjdGlvbnMsIG9wdHMsIG9yaWdpbmFsSGFuZGxlcikpXG4gIH1cblxuICBjb25zdHJ1Y3RvciAoZGlzcGF0Y2gsIG1heFJlZGlyZWN0aW9ucywgb3B0cywgaGFuZGxlcikge1xuICAgIGlmIChtYXhSZWRpcmVjdGlvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4UmVkaXJlY3Rpb25zKSB8fCBtYXhSZWRpcmVjdGlvbnMgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZWRpcmVjdGlvbnMgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpXG4gICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaCA9IGRpc3BhdGNoXG4gICAgdGhpcy5sb2NhdGlvbiA9IG51bGxcbiAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIG1heFJlZGlyZWN0aW9uczogMCB9IC8vIG9wdHMgbXVzdCBiZSBhIGNvcHlcbiAgICB0aGlzLm1heFJlZGlyZWN0aW9ucyA9IG1heFJlZGlyZWN0aW9uc1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXJcbiAgICB0aGlzLmhpc3RvcnkgPSBbXVxuXG4gICAgaWYgKHV0aWwuaXNTdHJlYW0odGhpcy5vcHRzLmJvZHkpKSB7XG4gICAgICAvLyBUT0RPIChmaXgpOiBQcm92aWRlIHNvbWUgd2F5IGZvciB0aGUgdXNlciB0byBjYWNoZSB0aGUgZmlsZSB0byBlLmcuIC90bXBcbiAgICAgIC8vIHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYWdhaW4/XG4gICAgICAvLyBUT0RPIChmaXgpOiBEbyB3ZSBuZWVkIDEwMC1leHBlY3Qgc3VwcG9ydCB0byBwcm92aWRlIGEgd2F5IHRvIGRvIHRoaXMgcHJvcGVybHk/XG4gICAgICBpZiAodXRpbC5ib2R5TGVuZ3RoKHRoaXMub3B0cy5ib2R5KSA9PT0gMCkge1xuICAgICAgICB0aGlzLm9wdHMuYm9keVxuICAgICAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSlcbiAgICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5ib2R5LnJlYWRhYmxlRGlkUmVhZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMub3B0cy5ib2R5W2tCb2R5VXNlZF0gPSBmYWxzZVxuICAgICAgICBFRS5wcm90b3R5cGUub24uY2FsbCh0aGlzLm9wdHMuYm9keSwgJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpc1trQm9keVVzZWRdID0gdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLmJvZHkgJiYgdHlwZW9mIHRoaXMub3B0cy5ib2R5LnBpcGVUbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVE9ETyAoZml4KTogV2UgY2FuJ3QgYWNjZXNzIFJlYWRhYmxlU3RyZWFtIGludGVybmFsIHN0YXRlXG4gICAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgaXQgaGFzIGJlZW4gZGlzdHVyYmVkLiBUaGlzIGlzIGp1c3RcbiAgICAgIC8vIGEgd29ya2Fyb3VuZC5cbiAgICAgIHRoaXMub3B0cy5ib2R5ID0gbmV3IEJvZHlBc3luY0l0ZXJhYmxlKHRoaXMub3B0cy5ib2R5KVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLm9wdHMuYm9keSAmJlxuICAgICAgdHlwZW9mIHRoaXMub3B0cy5ib2R5ICE9PSAnc3RyaW5nJyAmJlxuICAgICAgIUFycmF5QnVmZmVyLmlzVmlldyh0aGlzLm9wdHMuYm9keSkgJiZcbiAgICAgIHV0aWwuaXNJdGVyYWJsZSh0aGlzLm9wdHMuYm9keSkgJiZcbiAgICAgICF1dGlsLmlzRm9ybURhdGFMaWtlKHRoaXMub3B0cy5ib2R5KVxuICAgICkge1xuICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIGFsbG93IHJlLXVzaW5nIGl0ZXJhYmxlIGlmICF0aGlzLm9wdHMuaWRlbXBvdGVudFxuICAgICAgLy8gb3IgdGhyb3VnaCBzb21lIG90aGVyIGZsYWc/XG4gICAgICB0aGlzLm9wdHMuYm9keSA9IG5ldyBCb2R5QXN5bmNJdGVyYWJsZSh0aGlzLm9wdHMuYm9keSlcbiAgICB9XG4gIH1cblxuICBvblJlcXVlc3RTdGFydCAoY29udHJvbGxlciwgY29udGV4dCkge1xuICAgIHRoaXMuaGFuZGxlci5vblJlcXVlc3RTdGFydD8uKGNvbnRyb2xsZXIsIHsgLi4uY29udGV4dCwgaGlzdG9yeTogdGhpcy5oaXN0b3J5IH0pXG4gIH1cblxuICBvblJlcXVlc3RVcGdyYWRlIChjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICB0aGlzLmhhbmRsZXIub25SZXF1ZXN0VXBncmFkZT8uKGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldClcbiAgfVxuXG4gIG9uUmVzcG9uc2VTdGFydCAoY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzTWVzc2FnZSkge1xuICAgIGlmICh0aGlzLm9wdHMudGhyb3dPbk1heFJlZGlyZWN0ICYmIHRoaXMuaGlzdG9yeS5sZW5ndGggPj0gdGhpcy5tYXhSZWRpcmVjdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWF4IHJlZGlyZWN0cycpXG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjQuMlxuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXJlZGlyZWN0LWZldGNoXG4gICAgLy8gSW4gY2FzZSBvZiBIVFRQIDMwMSBvciAzMDIgd2l0aCBQT1NULCBjaGFuZ2UgdGhlIG1ldGhvZCB0byBHRVRcbiAgICBpZiAoKHN0YXR1c0NvZGUgPT09IDMwMSB8fCBzdGF0dXNDb2RlID09PSAzMDIpICYmIHRoaXMub3B0cy5tZXRob2QgPT09ICdQT1NUJykge1xuICAgICAgdGhpcy5vcHRzLm1ldGhvZCA9ICdHRVQnXG4gICAgICBpZiAodXRpbC5pc1N0cmVhbSh0aGlzLm9wdHMuYm9keSkpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KHRoaXMub3B0cy5ib2R5Lm9uKCdlcnJvcicsIG5vb3ApKVxuICAgICAgfVxuICAgICAgdGhpcy5vcHRzLmJvZHkgPSBudWxsXG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjQuNFxuICAgIC8vIEluIGNhc2Ugb2YgSFRUUCAzMDMsIGFsd2F5cyByZXBsYWNlIG1ldGhvZCB0byBiZSBlaXRoZXIgSEVBRCBvciBHRVRcbiAgICBpZiAoc3RhdHVzQ29kZSA9PT0gMzAzICYmIHRoaXMub3B0cy5tZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgdGhpcy5vcHRzLm1ldGhvZCA9ICdHRVQnXG4gICAgICBpZiAodXRpbC5pc1N0cmVhbSh0aGlzLm9wdHMuYm9keSkpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KHRoaXMub3B0cy5ib2R5Lm9uKCdlcnJvcicsIG5vb3ApKVxuICAgICAgfVxuICAgICAgdGhpcy5vcHRzLmJvZHkgPSBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5sb2NhdGlvbiA9IHRoaXMuaGlzdG9yeS5sZW5ndGggPj0gdGhpcy5tYXhSZWRpcmVjdGlvbnMgfHwgdXRpbC5pc0Rpc3R1cmJlZCh0aGlzLm9wdHMuYm9keSkgfHwgcmVkaXJlY3RhYmxlU3RhdHVzQ29kZXMuaW5kZXhPZihzdGF0dXNDb2RlKSA9PT0gLTFcbiAgICAgID8gbnVsbFxuICAgICAgOiBoZWFkZXJzLmxvY2F0aW9uXG5cbiAgICBpZiAodGhpcy5vcHRzLm9yaWdpbikge1xuICAgICAgdGhpcy5oaXN0b3J5LnB1c2gobmV3IFVSTCh0aGlzLm9wdHMucGF0aCwgdGhpcy5vcHRzLm9yaWdpbikpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmxvY2F0aW9uKSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25SZXNwb25zZVN0YXJ0Py4oY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzTWVzc2FnZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHsgb3JpZ2luLCBwYXRobmFtZSwgc2VhcmNoIH0gPSB1dGlsLnBhcnNlVVJMKG5ldyBVUkwodGhpcy5sb2NhdGlvbiwgdGhpcy5vcHRzLm9yaWdpbiAmJiBuZXcgVVJMKHRoaXMub3B0cy5wYXRoLCB0aGlzLm9wdHMub3JpZ2luKSkpXG4gICAgY29uc3QgcGF0aCA9IHNlYXJjaCA/IGAke3BhdGhuYW1lfSR7c2VhcmNofWAgOiBwYXRobmFtZVxuXG4gICAgLy8gUmVtb3ZlIGhlYWRlcnMgcmVmZXJyaW5nIHRvIHRoZSBvcmlnaW5hbCBVUkwuXG4gICAgLy8gQnkgZGVmYXVsdCBpdCBpcyBIb3N0IG9ubHksIHVubGVzcyBpdCdzIGEgMzAzIChzZWUgYmVsb3cpLCB3aGljaCByZW1vdmVzIGFsc28gYWxsIENvbnRlbnQtKiBoZWFkZXJzLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40XG4gICAgdGhpcy5vcHRzLmhlYWRlcnMgPSBjbGVhblJlcXVlc3RIZWFkZXJzKHRoaXMub3B0cy5oZWFkZXJzLCBzdGF0dXNDb2RlID09PSAzMDMsIHRoaXMub3B0cy5vcmlnaW4gIT09IG9yaWdpbilcbiAgICB0aGlzLm9wdHMucGF0aCA9IHBhdGhcbiAgICB0aGlzLm9wdHMub3JpZ2luID0gb3JpZ2luXG4gICAgdGhpcy5vcHRzLm1heFJlZGlyZWN0aW9ucyA9IDBcbiAgICB0aGlzLm9wdHMucXVlcnkgPSBudWxsXG4gIH1cblxuICBvblJlc3BvbnNlRGF0YSAoY29udHJvbGxlciwgY2h1bmspIHtcbiAgICBpZiAodGhpcy5sb2NhdGlvbikge1xuICAgICAgLypcbiAgICAgICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjRcblxuICAgICAgICBUTERSOiB1bmRpY2kgYWx3YXlzIGlnbm9yZXMgM3h4IHJlc3BvbnNlIGJvZGllcy5cblxuICAgICAgICBSZWRpcmVjdGlvbiBpcyB1c2VkIHRvIHNlcnZlIHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UgZnJvbSBhbm90aGVyIFVSTCwgc28gaXQgYXNzdW1lcyB0aGF0XG4gICAgICAgIG5vIGJvZHkgaXMgZ2VuZXJhdGVkIChhbmQgdGh1cyBjYW4gYmUgaWdub3JlZCkuIEV2ZW4gdGhvdWdoIGdlbmVyYXRpbmcgYSBib2R5IGlzIG5vdCBwcm9oaWJpdGVkLlxuXG4gICAgICAgIEZvciBzdGF0dXMgMzAxLCAzMDIsIDMwMywgMzA3IGFuZCAzMDggKHRoZSBsYXR0ZXIgZnJvbSBSRkMgNzIzOCksIHRoZSBzcGVjcyBtZW50aW9uIHRoYXQgdGhlIGJvZHkgdXN1YWxseVxuICAgICAgICAod2hpY2ggbWVhbnMgaXQncyBvcHRpb25hbCBhbmQgbm90IG1hbmRhdGVkKSBjb250YWluIGp1c3QgYW4gaHlwZXJsaW5rIHRvIHRoZSB2YWx1ZSBvZlxuICAgICAgICB0aGUgTG9jYXRpb24gcmVzcG9uc2UgaGVhZGVyLCBzbyB0aGUgYm9keSBjYW4gYmUgaWdub3JlZCBzYWZlbHkuXG5cbiAgICAgICAgRm9yIHN0YXR1cyAzMDAsIHdoaWNoIGlzIFwiTXVsdGlwbGUgQ2hvaWNlc1wiLCB0aGUgc3BlYyBtZW50aW9ucyBib3RoIGdlbmVyYXRpbmcgYSBMb2NhdGlvblxuICAgICAgICByZXNwb25zZSBoZWFkZXIgQU5EIGEgcmVzcG9uc2UgYm9keSB3aXRoIHRoZSBvdGhlciBwb3NzaWJsZSBsb2NhdGlvbiB0byBmb2xsb3cuXG4gICAgICAgIFNpbmNlIHRoZSBzcGVjIGV4cGxpY2l0bHkgY2hvb3NlcyBub3QgdG8gc3BlY2lmeSBhIGZvcm1hdCBmb3Igc3VjaCBib2R5IGFuZCBsZWF2ZSBpdCB0b1xuICAgICAgICBzZXJ2ZXJzIGFuZCBicm93c2VycyBpbXBsZW1lbnRvcnMsIHdlIGlnbm9yZSB0aGUgYm9keSBhcyB0aGVyZSBpcyBubyBzcGVjaWZpZWQgd2F5IHRvIGV2ZW50dWFsbHkgcGFyc2UgaXQuXG4gICAgICAqL1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25SZXNwb25zZURhdGE/Lihjb250cm9sbGVyLCBjaHVuaylcbiAgICB9XG4gIH1cblxuICBvblJlc3BvbnNlRW5kIChjb250cm9sbGVyLCB0cmFpbGVycykge1xuICAgIGlmICh0aGlzLmxvY2F0aW9uKSB7XG4gICAgICAvKlxuICAgICAgICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNFxuXG4gICAgICAgIFRMRFI6IHVuZGljaSBhbHdheXMgaWdub3JlcyAzeHggcmVzcG9uc2UgdHJhaWxlcnMgYXMgdGhleSBhcmUgbm90IGV4cGVjdGVkIGluIGNhc2Ugb2YgcmVkaXJlY3Rpb25zXG4gICAgICAgIGFuZCBuZWl0aGVyIGFyZSB1c2VmdWwgaWYgcHJlc2VudC5cblxuICAgICAgICBTZWUgY29tbWVudCBvbiBvbkRhdGEgbWV0aG9kIGFib3ZlIGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uLlxuICAgICAgKi9cbiAgICAgIHRoaXMuZGlzcGF0Y2godGhpcy5vcHRzLCB0aGlzKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25SZXNwb25zZUVuZChjb250cm9sbGVyLCB0cmFpbGVycylcbiAgICB9XG4gIH1cblxuICBvblJlc3BvbnNlRXJyb3IgKGNvbnRyb2xsZXIsIGVycm9yKSB7XG4gICAgdGhpcy5oYW5kbGVyLm9uUmVzcG9uc2VFcnJvcj8uKGNvbnRyb2xsZXIsIGVycm9yKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40LjRcbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUhlYWRlciAoaGVhZGVyLCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSB7XG4gIGlmIChoZWFkZXIubGVuZ3RoID09PSA0KSB7XG4gICAgcmV0dXJuIHV0aWwuaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcikgPT09ICdob3N0J1xuICB9XG4gIGlmIChyZW1vdmVDb250ZW50ICYmIHV0aWwuaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcikuc3RhcnRzV2l0aCgnY29udGVudC0nKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKHVua25vd25PcmlnaW4gJiYgKGhlYWRlci5sZW5ndGggPT09IDEzIHx8IGhlYWRlci5sZW5ndGggPT09IDYgfHwgaGVhZGVyLmxlbmd0aCA9PT0gMTkpKSB7XG4gICAgY29uc3QgbmFtZSA9IHV0aWwuaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcilcbiAgICByZXR1cm4gbmFtZSA9PT0gJ2F1dGhvcml6YXRpb24nIHx8IG5hbWUgPT09ICdjb29raWUnIHx8IG5hbWUgPT09ICdwcm94eS1hdXRob3JpemF0aW9uJ1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNFxuZnVuY3Rpb24gY2xlYW5SZXF1ZXN0SGVhZGVycyAoaGVhZGVycywgcmVtb3ZlQ29udGVudCwgdW5rbm93bk9yaWdpbikge1xuICBjb25zdCByZXQgPSBbXVxuICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKCFzaG91bGRSZW1vdmVIZWFkZXIoaGVhZGVyc1tpXSwgcmVtb3ZlQ29udGVudCwgdW5rbm93bk9yaWdpbikpIHtcbiAgICAgICAgcmV0LnB1c2goaGVhZGVyc1tpXSwgaGVhZGVyc1tpICsgMV0pXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGhlYWRlcnMgJiYgdHlwZW9mIGhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgZW50cmllcyA9IHR5cGVvZiBoZWFkZXJzW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicgPyBoZWFkZXJzIDogT2JqZWN0LmVudHJpZXMoaGVhZGVycylcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICBpZiAoIXNob3VsZFJlbW92ZUhlYWRlcihrZXksIHJlbW92ZUNvbnRlbnQsIHVua25vd25PcmlnaW4pKSB7XG4gICAgICAgIHJldC5wdXNoKGtleSwgdmFsdWUpXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChoZWFkZXJzID09IG51bGwsICdoZWFkZXJzIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFuIGFycmF5JylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVkaXJlY3RIYW5kbGVyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/redirect-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/retry-handler.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/handler/retry-handler.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\nconst { kRetryHandlerDefaultRetry } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { RequestRetryError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst WrapHandler = __webpack_require__(/*! ./wrap-handler */ \"(rsc)/./node_modules/undici/lib/handler/wrap-handler.js\")\nconst {\n  isDisturbed,\n  parseRangeHeader,\n  wrapRequestBody\n} = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nfunction calculateRetryAfterHeader (retryAfter) {\n  const retryTime = new Date(retryAfter).getTime()\n  return isNaN(retryTime) ? 0 : retryTime - Date.now()\n}\n\nclass RetryHandler {\n  constructor (opts, { dispatch, handler }) {\n    const { retryOptions, ...dispatchOpts } = opts\n    const {\n      // Retry scoped\n      retry: retryFn,\n      maxRetries,\n      maxTimeout,\n      minTimeout,\n      timeoutFactor,\n      // Response scoped\n      methods,\n      errorCodes,\n      retryAfter,\n      statusCodes,\n      throwOnError\n    } = retryOptions ?? {}\n\n    this.error = null\n    this.dispatch = dispatch\n    this.handler = WrapHandler.wrap(handler)\n    this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) }\n    this.retryOpts = {\n      throwOnError: throwOnError ?? true,\n      retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],\n      retryAfter: retryAfter ?? true,\n      maxTimeout: maxTimeout ?? 30 * 1000, // 30s,\n      minTimeout: minTimeout ?? 500, // .5s\n      timeoutFactor: timeoutFactor ?? 2,\n      maxRetries: maxRetries ?? 5,\n      // What errors we should retry\n      methods: methods ?? ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE'],\n      // Indicates which errors to retry\n      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],\n      // List of errors to retry\n      errorCodes: errorCodes ?? [\n        'ECONNRESET',\n        'ECONNREFUSED',\n        'ENOTFOUND',\n        'ENETDOWN',\n        'ENETUNREACH',\n        'EHOSTDOWN',\n        'EHOSTUNREACH',\n        'EPIPE',\n        'UND_ERR_SOCKET'\n      ]\n    }\n\n    this.retryCount = 0\n    this.retryCountCheckpoint = 0\n    this.headersSent = false\n    this.start = 0\n    this.end = null\n    this.etag = null\n  }\n\n  onResponseStartWithRetry (controller, statusCode, headers, statusMessage, err) {\n    if (this.retryOpts.throwOnError) {\n      // Preserve old behavior for status codes that are not eligible for retry\n      if (this.retryOpts.statusCodes.includes(statusCode) === false) {\n        this.headersSent = true\n        this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage)\n      } else {\n        this.error = err\n      }\n\n      return\n    }\n\n    if (isDisturbed(this.opts.body)) {\n      this.headersSent = true\n      this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage)\n      return\n    }\n\n    function shouldRetry (passedErr) {\n      if (passedErr) {\n        this.headersSent = true\n\n        this.headersSent = true\n        this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage)\n        controller.resume()\n        return\n      }\n\n      this.error = err\n      controller.resume()\n    }\n\n    controller.pause()\n    this.retryOpts.retry(\n      err,\n      {\n        state: { counter: this.retryCount },\n        opts: { retryOptions: this.retryOpts, ...this.opts }\n      },\n      shouldRetry.bind(this)\n    )\n  }\n\n  onRequestStart (controller, context) {\n    if (!this.headersSent) {\n      this.handler.onRequestStart?.(controller, context)\n    }\n  }\n\n  onRequestUpgrade (controller, statusCode, headers, socket) {\n    this.handler.onRequestUpgrade?.(controller, statusCode, headers, socket)\n  }\n\n  static [kRetryHandlerDefaultRetry] (err, { state, opts }, cb) {\n    const { statusCode, code, headers } = err\n    const { method, retryOptions } = opts\n    const {\n      maxRetries,\n      minTimeout,\n      maxTimeout,\n      timeoutFactor,\n      statusCodes,\n      errorCodes,\n      methods\n    } = retryOptions\n    const { counter } = state\n\n    // Any code that is not a Undici's originated and allowed to retry\n    if (code && code !== 'UND_ERR_REQ_RETRY' && !errorCodes.includes(code)) {\n      cb(err)\n      return\n    }\n\n    // If a set of method are provided and the current method is not in the list\n    if (Array.isArray(methods) && !methods.includes(method)) {\n      cb(err)\n      return\n    }\n\n    // If a set of status code are provided and the current status code is not in the list\n    if (\n      statusCode != null &&\n      Array.isArray(statusCodes) &&\n      !statusCodes.includes(statusCode)\n    ) {\n      cb(err)\n      return\n    }\n\n    // If we reached the max number of retries\n    if (counter > maxRetries) {\n      cb(err)\n      return\n    }\n\n    let retryAfterHeader = headers?.['retry-after']\n    if (retryAfterHeader) {\n      retryAfterHeader = Number(retryAfterHeader)\n      retryAfterHeader = Number.isNaN(retryAfterHeader)\n        ? calculateRetryAfterHeader(headers['retry-after'])\n        : retryAfterHeader * 1e3 // Retry-After is in seconds\n    }\n\n    const retryTimeout =\n      retryAfterHeader > 0\n        ? Math.min(retryAfterHeader, maxTimeout)\n        : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout)\n\n    setTimeout(() => cb(null), retryTimeout)\n  }\n\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    this.error = null\n    this.retryCount += 1\n\n    if (statusCode >= 300) {\n      const err = new RequestRetryError('Request failed', statusCode, {\n        headers,\n        data: {\n          count: this.retryCount\n        }\n      })\n\n      this.onResponseStartWithRetry(controller, statusCode, headers, statusMessage, err)\n      return\n    }\n\n    // Checkpoint for resume from where we left it\n    if (this.headersSent) {\n      // Only Partial Content 206 supposed to provide Content-Range,\n      // any other status code that partially consumed the payload\n      // should not be retried because it would result in downstream\n      // wrongly concatenate multiple responses.\n      if (statusCode !== 206 && (this.start > 0 || statusCode !== 200)) {\n        throw new RequestRetryError('server does not support the range header and the payload was partially consumed', statusCode, {\n          headers,\n          data: { count: this.retryCount }\n        })\n      }\n\n      const contentRange = parseRangeHeader(headers['content-range'])\n      // If no content range\n      if (!contentRange) {\n        // We always throw here as we want to indicate that we entred unexpected path\n        throw new RequestRetryError('Content-Range mismatch', statusCode, {\n          headers,\n          data: { count: this.retryCount }\n        })\n      }\n\n      // Let's start with a weak etag check\n      if (this.etag != null && this.etag !== headers.etag) {\n        // We always throw here as we want to indicate that we entred unexpected path\n        throw new RequestRetryError('ETag mismatch', statusCode, {\n          headers,\n          data: { count: this.retryCount }\n        })\n      }\n\n      const { start, size, end = size ? size - 1 : null } = contentRange\n\n      assert(this.start === start, 'content-range mismatch')\n      assert(this.end == null || this.end === end, 'content-range mismatch')\n\n      return\n    }\n\n    if (this.end == null) {\n      if (statusCode === 206) {\n        // First time we receive 206\n        const range = parseRangeHeader(headers['content-range'])\n\n        if (range == null) {\n          this.headersSent = true\n          this.handler.onResponseStart?.(\n            controller,\n            statusCode,\n            headers,\n            statusMessage\n          )\n          return\n        }\n\n        const { start, size, end = size ? size - 1 : null } = range\n        assert(\n          start != null && Number.isFinite(start),\n          'content-range mismatch'\n        )\n        assert(end != null && Number.isFinite(end), 'invalid content-length')\n\n        this.start = start\n        this.end = end\n      }\n\n      // We make our best to checkpoint the body for further range headers\n      if (this.end == null) {\n        const contentLength = headers['content-length']\n        this.end = contentLength != null ? Number(contentLength) - 1 : null\n      }\n\n      assert(Number.isFinite(this.start))\n      assert(\n        this.end == null || Number.isFinite(this.end),\n        'invalid content-length'\n      )\n\n      this.resume = true\n      this.etag = headers.etag != null ? headers.etag : null\n\n      // Weak etags are not useful for comparison nor cache\n      // for instance not safe to assume if the response is byte-per-byte\n      // equal\n      if (\n        this.etag != null &&\n        this.etag[0] === 'W' &&\n        this.etag[1] === '/'\n      ) {\n        this.etag = null\n      }\n\n      this.headersSent = true\n      this.handler.onResponseStart?.(\n        controller,\n        statusCode,\n        headers,\n        statusMessage\n      )\n    } else {\n      throw new RequestRetryError('Request failed', statusCode, {\n        headers,\n        data: { count: this.retryCount }\n      })\n    }\n  }\n\n  onResponseData (controller, chunk) {\n    if (this.error) {\n      return\n    }\n\n    this.start += chunk.length\n\n    this.handler.onResponseData?.(controller, chunk)\n  }\n\n  onResponseEnd (controller, trailers) {\n    if (this.error && this.retryOpts.throwOnError) {\n      throw this.error\n    }\n\n    if (!this.error) {\n      this.retryCount = 0\n      return this.handler.onResponseEnd?.(controller, trailers)\n    }\n\n    this.retry(controller)\n  }\n\n  retry (controller) {\n    if (this.start !== 0) {\n      const headers = { range: `bytes=${this.start}-${this.end ?? ''}` }\n\n      // Weak etag check - weak etags will make comparison algorithms never match\n      if (this.etag != null) {\n        headers['if-match'] = this.etag\n      }\n\n      this.opts = {\n        ...this.opts,\n        headers: {\n          ...this.opts.headers,\n          ...headers\n        }\n      }\n    }\n\n    try {\n      this.retryCountCheckpoint = this.retryCount\n      this.dispatch(this.opts, this)\n    } catch (err) {\n      this.handler.onResponseError?.(controller, err)\n    }\n  }\n\n  onResponseError (controller, err) {\n    if (controller?.aborted || isDisturbed(this.opts.body)) {\n      this.handler.onResponseError?.(controller, err)\n      return\n    }\n\n    function shouldRetry (returnedErr) {\n      if (!returnedErr) {\n        this.retry(controller)\n        return\n      }\n\n      this.handler?.onResponseError?.(controller, returnedErr)\n    }\n\n    // We reconcile in case of a mix between network errors\n    // and server error response\n    if (this.retryCount - this.retryCountCheckpoint > 0) {\n      // We count the difference between the last checkpoint and the current retry count\n      this.retryCount =\n        this.retryCountCheckpoint +\n        (this.retryCount - this.retryCountCheckpoint)\n    } else {\n      this.retryCount += 1\n    }\n\n    this.retryOpts.retry(\n      err,\n      {\n        state: { counter: this.retryCount },\n        opts: { retryOptions: this.retryOpts, ...this.opts }\n      },\n      shouldRetry.bind(this)\n    )\n  }\n}\n\nmodule.exports = RetryHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3JldHJ5LWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7O0FBRXBDLFFBQVEsNEJBQTRCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDL0QsUUFBUSxvQkFBb0IsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN0RCxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0MsZ0JBQWdCO0FBQ2hCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLGFBQWE7QUFDMUQsWUFBWSw0QkFBNEI7QUFDeEMsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixZQUFZLFVBQVU7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixTQUFTO0FBQ1Q7O0FBRUEsY0FBYyw0Q0FBNEM7O0FBRTFEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsNENBQTRDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCLFdBQVcsR0FBRyxlQUFlOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDLGdCQUFnQjtBQUNoQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaGFuZGxlci9yZXRyeS1oYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuXG5jb25zdCB7IGtSZXRyeUhhbmRsZXJEZWZhdWx0UmV0cnkgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IFJlcXVlc3RSZXRyeUVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBXcmFwSGFuZGxlciA9IHJlcXVpcmUoJy4vd3JhcC1oYW5kbGVyJylcbmNvbnN0IHtcbiAgaXNEaXN0dXJiZWQsXG4gIHBhcnNlUmFuZ2VIZWFkZXIsXG4gIHdyYXBSZXF1ZXN0Qm9keVxufSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJldHJ5QWZ0ZXJIZWFkZXIgKHJldHJ5QWZ0ZXIpIHtcbiAgY29uc3QgcmV0cnlUaW1lID0gbmV3IERhdGUocmV0cnlBZnRlcikuZ2V0VGltZSgpXG4gIHJldHVybiBpc05hTihyZXRyeVRpbWUpID8gMCA6IHJldHJ5VGltZSAtIERhdGUubm93KClcbn1cblxuY2xhc3MgUmV0cnlIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIHsgZGlzcGF0Y2gsIGhhbmRsZXIgfSkge1xuICAgIGNvbnN0IHsgcmV0cnlPcHRpb25zLCAuLi5kaXNwYXRjaE9wdHMgfSA9IG9wdHNcbiAgICBjb25zdCB7XG4gICAgICAvLyBSZXRyeSBzY29wZWRcbiAgICAgIHJldHJ5OiByZXRyeUZuLFxuICAgICAgbWF4UmV0cmllcyxcbiAgICAgIG1heFRpbWVvdXQsXG4gICAgICBtaW5UaW1lb3V0LFxuICAgICAgdGltZW91dEZhY3RvcixcbiAgICAgIC8vIFJlc3BvbnNlIHNjb3BlZFxuICAgICAgbWV0aG9kcyxcbiAgICAgIGVycm9yQ29kZXMsXG4gICAgICByZXRyeUFmdGVyLFxuICAgICAgc3RhdHVzQ29kZXMsXG4gICAgICB0aHJvd09uRXJyb3JcbiAgICB9ID0gcmV0cnlPcHRpb25zID8/IHt9XG5cbiAgICB0aGlzLmVycm9yID0gbnVsbFxuICAgIHRoaXMuZGlzcGF0Y2ggPSBkaXNwYXRjaFxuICAgIHRoaXMuaGFuZGxlciA9IFdyYXBIYW5kbGVyLndyYXAoaGFuZGxlcilcbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRpc3BhdGNoT3B0cywgYm9keTogd3JhcFJlcXVlc3RCb2R5KG9wdHMuYm9keSkgfVxuICAgIHRoaXMucmV0cnlPcHRzID0ge1xuICAgICAgdGhyb3dPbkVycm9yOiB0aHJvd09uRXJyb3IgPz8gdHJ1ZSxcbiAgICAgIHJldHJ5OiByZXRyeUZuID8/IFJldHJ5SGFuZGxlcltrUmV0cnlIYW5kbGVyRGVmYXVsdFJldHJ5XSxcbiAgICAgIHJldHJ5QWZ0ZXI6IHJldHJ5QWZ0ZXIgPz8gdHJ1ZSxcbiAgICAgIG1heFRpbWVvdXQ6IG1heFRpbWVvdXQgPz8gMzAgKiAxMDAwLCAvLyAzMHMsXG4gICAgICBtaW5UaW1lb3V0OiBtaW5UaW1lb3V0ID8/IDUwMCwgLy8gLjVzXG4gICAgICB0aW1lb3V0RmFjdG9yOiB0aW1lb3V0RmFjdG9yID8/IDIsXG4gICAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzID8/IDUsXG4gICAgICAvLyBXaGF0IGVycm9ycyB3ZSBzaG91bGQgcmV0cnlcbiAgICAgIG1ldGhvZHM6IG1ldGhvZHMgPz8gWydHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BVVCcsICdERUxFVEUnLCAnVFJBQ0UnXSxcbiAgICAgIC8vIEluZGljYXRlcyB3aGljaCBlcnJvcnMgdG8gcmV0cnlcbiAgICAgIHN0YXR1c0NvZGVzOiBzdGF0dXNDb2RlcyA/PyBbNTAwLCA1MDIsIDUwMywgNTA0LCA0MjldLFxuICAgICAgLy8gTGlzdCBvZiBlcnJvcnMgdG8gcmV0cnlcbiAgICAgIGVycm9yQ29kZXM6IGVycm9yQ29kZXMgPz8gW1xuICAgICAgICAnRUNPTk5SRVNFVCcsXG4gICAgICAgICdFQ09OTlJFRlVTRUQnLFxuICAgICAgICAnRU5PVEZPVU5EJyxcbiAgICAgICAgJ0VORVRET1dOJyxcbiAgICAgICAgJ0VORVRVTlJFQUNIJyxcbiAgICAgICAgJ0VIT1NURE9XTicsXG4gICAgICAgICdFSE9TVFVOUkVBQ0gnLFxuICAgICAgICAnRVBJUEUnLFxuICAgICAgICAnVU5EX0VSUl9TT0NLRVQnXG4gICAgICBdXG4gICAgfVxuXG4gICAgdGhpcy5yZXRyeUNvdW50ID0gMFxuICAgIHRoaXMucmV0cnlDb3VudENoZWNrcG9pbnQgPSAwXG4gICAgdGhpcy5oZWFkZXJzU2VudCA9IGZhbHNlXG4gICAgdGhpcy5zdGFydCA9IDBcbiAgICB0aGlzLmVuZCA9IG51bGxcbiAgICB0aGlzLmV0YWcgPSBudWxsXG4gIH1cblxuICBvblJlc3BvbnNlU3RhcnRXaXRoUmV0cnkgKGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c01lc3NhZ2UsIGVycikge1xuICAgIGlmICh0aGlzLnJldHJ5T3B0cy50aHJvd09uRXJyb3IpIHtcbiAgICAgIC8vIFByZXNlcnZlIG9sZCBiZWhhdmlvciBmb3Igc3RhdHVzIGNvZGVzIHRoYXQgYXJlIG5vdCBlbGlnaWJsZSBmb3IgcmV0cnlcbiAgICAgIGlmICh0aGlzLnJldHJ5T3B0cy5zdGF0dXNDb2Rlcy5pbmNsdWRlcyhzdGF0dXNDb2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzU2VudCA9IHRydWVcbiAgICAgICAgdGhpcy5oYW5kbGVyLm9uUmVzcG9uc2VTdGFydD8uKGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c01lc3NhZ2UpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyXG4gICAgICB9XG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc0Rpc3R1cmJlZCh0aGlzLm9wdHMuYm9keSkpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1NlbnQgPSB0cnVlXG4gICAgICB0aGlzLmhhbmRsZXIub25SZXNwb25zZVN0YXJ0Py4oY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzTWVzc2FnZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3VsZFJldHJ5IChwYXNzZWRFcnIpIHtcbiAgICAgIGlmIChwYXNzZWRFcnIpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzU2VudCA9IHRydWVcblxuICAgICAgICB0aGlzLmhlYWRlcnNTZW50ID0gdHJ1ZVxuICAgICAgICB0aGlzLmhhbmRsZXIub25SZXNwb25zZVN0YXJ0Py4oY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzTWVzc2FnZSlcbiAgICAgICAgY29udHJvbGxlci5yZXN1bWUoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5lcnJvciA9IGVyclxuICAgICAgY29udHJvbGxlci5yZXN1bWUoKVxuICAgIH1cblxuICAgIGNvbnRyb2xsZXIucGF1c2UoKVxuICAgIHRoaXMucmV0cnlPcHRzLnJldHJ5KFxuICAgICAgZXJyLFxuICAgICAge1xuICAgICAgICBzdGF0ZTogeyBjb3VudGVyOiB0aGlzLnJldHJ5Q291bnQgfSxcbiAgICAgICAgb3B0czogeyByZXRyeU9wdGlvbnM6IHRoaXMucmV0cnlPcHRzLCAuLi50aGlzLm9wdHMgfVxuICAgICAgfSxcbiAgICAgIHNob3VsZFJldHJ5LmJpbmQodGhpcylcbiAgICApXG4gIH1cblxuICBvblJlcXVlc3RTdGFydCAoY29udHJvbGxlciwgY29udGV4dCkge1xuICAgIGlmICghdGhpcy5oZWFkZXJzU2VudCkge1xuICAgICAgdGhpcy5oYW5kbGVyLm9uUmVxdWVzdFN0YXJ0Py4oY29udHJvbGxlciwgY29udGV4dClcbiAgICB9XG4gIH1cblxuICBvblJlcXVlc3RVcGdyYWRlIChjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICB0aGlzLmhhbmRsZXIub25SZXF1ZXN0VXBncmFkZT8uKGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldClcbiAgfVxuXG4gIHN0YXRpYyBba1JldHJ5SGFuZGxlckRlZmF1bHRSZXRyeV0gKGVyciwgeyBzdGF0ZSwgb3B0cyB9LCBjYikge1xuICAgIGNvbnN0IHsgc3RhdHVzQ29kZSwgY29kZSwgaGVhZGVycyB9ID0gZXJyXG4gICAgY29uc3QgeyBtZXRob2QsIHJldHJ5T3B0aW9ucyB9ID0gb3B0c1xuICAgIGNvbnN0IHtcbiAgICAgIG1heFJldHJpZXMsXG4gICAgICBtaW5UaW1lb3V0LFxuICAgICAgbWF4VGltZW91dCxcbiAgICAgIHRpbWVvdXRGYWN0b3IsXG4gICAgICBzdGF0dXNDb2RlcyxcbiAgICAgIGVycm9yQ29kZXMsXG4gICAgICBtZXRob2RzXG4gICAgfSA9IHJldHJ5T3B0aW9uc1xuICAgIGNvbnN0IHsgY291bnRlciB9ID0gc3RhdGVcblxuICAgIC8vIEFueSBjb2RlIHRoYXQgaXMgbm90IGEgVW5kaWNpJ3Mgb3JpZ2luYXRlZCBhbmQgYWxsb3dlZCB0byByZXRyeVxuICAgIGlmIChjb2RlICYmIGNvZGUgIT09ICdVTkRfRVJSX1JFUV9SRVRSWScgJiYgIWVycm9yQ29kZXMuaW5jbHVkZXMoY29kZSkpIHtcbiAgICAgIGNiKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIGEgc2V0IG9mIG1ldGhvZCBhcmUgcHJvdmlkZWQgYW5kIHRoZSBjdXJyZW50IG1ldGhvZCBpcyBub3QgaW4gdGhlIGxpc3RcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtZXRob2RzKSAmJiAhbWV0aG9kcy5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICBjYihlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiBhIHNldCBvZiBzdGF0dXMgY29kZSBhcmUgcHJvdmlkZWQgYW5kIHRoZSBjdXJyZW50IHN0YXR1cyBjb2RlIGlzIG5vdCBpbiB0aGUgbGlzdFxuICAgIGlmIChcbiAgICAgIHN0YXR1c0NvZGUgIT0gbnVsbCAmJlxuICAgICAgQXJyYXkuaXNBcnJheShzdGF0dXNDb2RlcykgJiZcbiAgICAgICFzdGF0dXNDb2Rlcy5pbmNsdWRlcyhzdGF0dXNDb2RlKVxuICAgICkge1xuICAgICAgY2IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgd2UgcmVhY2hlZCB0aGUgbWF4IG51bWJlciBvZiByZXRyaWVzXG4gICAgaWYgKGNvdW50ZXIgPiBtYXhSZXRyaWVzKSB7XG4gICAgICBjYihlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgcmV0cnlBZnRlckhlYWRlciA9IGhlYWRlcnM/LlsncmV0cnktYWZ0ZXInXVxuICAgIGlmIChyZXRyeUFmdGVySGVhZGVyKSB7XG4gICAgICByZXRyeUFmdGVySGVhZGVyID0gTnVtYmVyKHJldHJ5QWZ0ZXJIZWFkZXIpXG4gICAgICByZXRyeUFmdGVySGVhZGVyID0gTnVtYmVyLmlzTmFOKHJldHJ5QWZ0ZXJIZWFkZXIpXG4gICAgICAgID8gY2FsY3VsYXRlUmV0cnlBZnRlckhlYWRlcihoZWFkZXJzWydyZXRyeS1hZnRlciddKVxuICAgICAgICA6IHJldHJ5QWZ0ZXJIZWFkZXIgKiAxZTMgLy8gUmV0cnktQWZ0ZXIgaXMgaW4gc2Vjb25kc1xuICAgIH1cblxuICAgIGNvbnN0IHJldHJ5VGltZW91dCA9XG4gICAgICByZXRyeUFmdGVySGVhZGVyID4gMFxuICAgICAgICA/IE1hdGgubWluKHJldHJ5QWZ0ZXJIZWFkZXIsIG1heFRpbWVvdXQpXG4gICAgICAgIDogTWF0aC5taW4obWluVGltZW91dCAqIHRpbWVvdXRGYWN0b3IgKiogKGNvdW50ZXIgLSAxKSwgbWF4VGltZW91dClcblxuICAgIHNldFRpbWVvdXQoKCkgPT4gY2IobnVsbCksIHJldHJ5VGltZW91dClcbiAgfVxuXG4gIG9uUmVzcG9uc2VTdGFydCAoY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzTWVzc2FnZSkge1xuICAgIHRoaXMuZXJyb3IgPSBudWxsXG4gICAgdGhpcy5yZXRyeUNvdW50ICs9IDFcblxuICAgIGlmIChzdGF0dXNDb2RlID49IDMwMCkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IFJlcXVlc3RSZXRyeUVycm9yKCdSZXF1ZXN0IGZhaWxlZCcsIHN0YXR1c0NvZGUsIHtcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGNvdW50OiB0aGlzLnJldHJ5Q291bnRcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vblJlc3BvbnNlU3RhcnRXaXRoUmV0cnkoY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzTWVzc2FnZSwgZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gQ2hlY2twb2ludCBmb3IgcmVzdW1lIGZyb20gd2hlcmUgd2UgbGVmdCBpdFxuICAgIGlmICh0aGlzLmhlYWRlcnNTZW50KSB7XG4gICAgICAvLyBPbmx5IFBhcnRpYWwgQ29udGVudCAyMDYgc3VwcG9zZWQgdG8gcHJvdmlkZSBDb250ZW50LVJhbmdlLFxuICAgICAgLy8gYW55IG90aGVyIHN0YXR1cyBjb2RlIHRoYXQgcGFydGlhbGx5IGNvbnN1bWVkIHRoZSBwYXlsb2FkXG4gICAgICAvLyBzaG91bGQgbm90IGJlIHJldHJpZWQgYmVjYXVzZSBpdCB3b3VsZCByZXN1bHQgaW4gZG93bnN0cmVhbVxuICAgICAgLy8gd3JvbmdseSBjb25jYXRlbmF0ZSBtdWx0aXBsZSByZXNwb25zZXMuXG4gICAgICBpZiAoc3RhdHVzQ29kZSAhPT0gMjA2ICYmICh0aGlzLnN0YXJ0ID4gMCB8fCBzdGF0dXNDb2RlICE9PSAyMDApKSB7XG4gICAgICAgIHRocm93IG5ldyBSZXF1ZXN0UmV0cnlFcnJvcignc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgdGhlIHJhbmdlIGhlYWRlciBhbmQgdGhlIHBheWxvYWQgd2FzIHBhcnRpYWxseSBjb25zdW1lZCcsIHN0YXR1c0NvZGUsIHtcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGRhdGE6IHsgY291bnQ6IHRoaXMucmV0cnlDb3VudCB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbnRlbnRSYW5nZSA9IHBhcnNlUmFuZ2VIZWFkZXIoaGVhZGVyc1snY29udGVudC1yYW5nZSddKVxuICAgICAgLy8gSWYgbm8gY29udGVudCByYW5nZVxuICAgICAgaWYgKCFjb250ZW50UmFuZ2UpIHtcbiAgICAgICAgLy8gV2UgYWx3YXlzIHRocm93IGhlcmUgYXMgd2Ugd2FudCB0byBpbmRpY2F0ZSB0aGF0IHdlIGVudHJlZCB1bmV4cGVjdGVkIHBhdGhcbiAgICAgICAgdGhyb3cgbmV3IFJlcXVlc3RSZXRyeUVycm9yKCdDb250ZW50LVJhbmdlIG1pc21hdGNoJywgc3RhdHVzQ29kZSwge1xuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgZGF0YTogeyBjb3VudDogdGhpcy5yZXRyeUNvdW50IH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gTGV0J3Mgc3RhcnQgd2l0aCBhIHdlYWsgZXRhZyBjaGVja1xuICAgICAgaWYgKHRoaXMuZXRhZyAhPSBudWxsICYmIHRoaXMuZXRhZyAhPT0gaGVhZGVycy5ldGFnKSB7XG4gICAgICAgIC8vIFdlIGFsd2F5cyB0aHJvdyBoZXJlIGFzIHdlIHdhbnQgdG8gaW5kaWNhdGUgdGhhdCB3ZSBlbnRyZWQgdW5leHBlY3RlZCBwYXRoXG4gICAgICAgIHRocm93IG5ldyBSZXF1ZXN0UmV0cnlFcnJvcignRVRhZyBtaXNtYXRjaCcsIHN0YXR1c0NvZGUsIHtcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGRhdGE6IHsgY291bnQ6IHRoaXMucmV0cnlDb3VudCB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgc3RhcnQsIHNpemUsIGVuZCA9IHNpemUgPyBzaXplIC0gMSA6IG51bGwgfSA9IGNvbnRlbnRSYW5nZVxuXG4gICAgICBhc3NlcnQodGhpcy5zdGFydCA9PT0gc3RhcnQsICdjb250ZW50LXJhbmdlIG1pc21hdGNoJylcbiAgICAgIGFzc2VydCh0aGlzLmVuZCA9PSBudWxsIHx8IHRoaXMuZW5kID09PSBlbmQsICdjb250ZW50LXJhbmdlIG1pc21hdGNoJylcblxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW5kID09IG51bGwpIHtcbiAgICAgIGlmIChzdGF0dXNDb2RlID09PSAyMDYpIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSB3ZSByZWNlaXZlIDIwNlxuICAgICAgICBjb25zdCByYW5nZSA9IHBhcnNlUmFuZ2VIZWFkZXIoaGVhZGVyc1snY29udGVudC1yYW5nZSddKVxuXG4gICAgICAgIGlmIChyYW5nZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzU2VudCA9IHRydWVcbiAgICAgICAgICB0aGlzLmhhbmRsZXIub25SZXNwb25zZVN0YXJ0Py4oXG4gICAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlXG4gICAgICAgICAgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBzdGFydCwgc2l6ZSwgZW5kID0gc2l6ZSA/IHNpemUgLSAxIDogbnVsbCB9ID0gcmFuZ2VcbiAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgIHN0YXJ0ICE9IG51bGwgJiYgTnVtYmVyLmlzRmluaXRlKHN0YXJ0KSxcbiAgICAgICAgICAnY29udGVudC1yYW5nZSBtaXNtYXRjaCdcbiAgICAgICAgKVxuICAgICAgICBhc3NlcnQoZW5kICE9IG51bGwgJiYgTnVtYmVyLmlzRmluaXRlKGVuZCksICdpbnZhbGlkIGNvbnRlbnQtbGVuZ3RoJylcblxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnRcbiAgICAgICAgdGhpcy5lbmQgPSBlbmRcbiAgICAgIH1cblxuICAgICAgLy8gV2UgbWFrZSBvdXIgYmVzdCB0byBjaGVja3BvaW50IHRoZSBib2R5IGZvciBmdXJ0aGVyIHJhbmdlIGhlYWRlcnNcbiAgICAgIGlmICh0aGlzLmVuZCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBoZWFkZXJzWydjb250ZW50LWxlbmd0aCddXG4gICAgICAgIHRoaXMuZW5kID0gY29udGVudExlbmd0aCAhPSBudWxsID8gTnVtYmVyKGNvbnRlbnRMZW5ndGgpIC0gMSA6IG51bGxcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh0aGlzLnN0YXJ0KSlcbiAgICAgIGFzc2VydChcbiAgICAgICAgdGhpcy5lbmQgPT0gbnVsbCB8fCBOdW1iZXIuaXNGaW5pdGUodGhpcy5lbmQpLFxuICAgICAgICAnaW52YWxpZCBjb250ZW50LWxlbmd0aCdcbiAgICAgIClcblxuICAgICAgdGhpcy5yZXN1bWUgPSB0cnVlXG4gICAgICB0aGlzLmV0YWcgPSBoZWFkZXJzLmV0YWcgIT0gbnVsbCA/IGhlYWRlcnMuZXRhZyA6IG51bGxcblxuICAgICAgLy8gV2VhayBldGFncyBhcmUgbm90IHVzZWZ1bCBmb3IgY29tcGFyaXNvbiBub3IgY2FjaGVcbiAgICAgIC8vIGZvciBpbnN0YW5jZSBub3Qgc2FmZSB0byBhc3N1bWUgaWYgdGhlIHJlc3BvbnNlIGlzIGJ5dGUtcGVyLWJ5dGVcbiAgICAgIC8vIGVxdWFsXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuZXRhZyAhPSBudWxsICYmXG4gICAgICAgIHRoaXMuZXRhZ1swXSA9PT0gJ1cnICYmXG4gICAgICAgIHRoaXMuZXRhZ1sxXSA9PT0gJy8nXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5ldGFnID0gbnVsbFxuICAgICAgfVxuXG4gICAgICB0aGlzLmhlYWRlcnNTZW50ID0gdHJ1ZVxuICAgICAgdGhpcy5oYW5kbGVyLm9uUmVzcG9uc2VTdGFydD8uKFxuICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBzdGF0dXNNZXNzYWdlXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0UmV0cnlFcnJvcignUmVxdWVzdCBmYWlsZWQnLCBzdGF0dXNDb2RlLCB7XG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGRhdGE6IHsgY291bnQ6IHRoaXMucmV0cnlDb3VudCB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIG9uUmVzcG9uc2VEYXRhIChjb250cm9sbGVyLCBjaHVuaykge1xuICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnN0YXJ0ICs9IGNodW5rLmxlbmd0aFxuXG4gICAgdGhpcy5oYW5kbGVyLm9uUmVzcG9uc2VEYXRhPy4oY29udHJvbGxlciwgY2h1bmspXG4gIH1cblxuICBvblJlc3BvbnNlRW5kIChjb250cm9sbGVyLCB0cmFpbGVycykge1xuICAgIGlmICh0aGlzLmVycm9yICYmIHRoaXMucmV0cnlPcHRzLnRocm93T25FcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5lcnJvclxuICAgIH1cblxuICAgIGlmICghdGhpcy5lcnJvcikge1xuICAgICAgdGhpcy5yZXRyeUNvdW50ID0gMFxuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vblJlc3BvbnNlRW5kPy4oY29udHJvbGxlciwgdHJhaWxlcnMpXG4gICAgfVxuXG4gICAgdGhpcy5yZXRyeShjb250cm9sbGVyKVxuICB9XG5cbiAgcmV0cnkgKGNvbnRyb2xsZXIpIHtcbiAgICBpZiAodGhpcy5zdGFydCAhPT0gMCkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHsgcmFuZ2U6IGBieXRlcz0ke3RoaXMuc3RhcnR9LSR7dGhpcy5lbmQgPz8gJyd9YCB9XG5cbiAgICAgIC8vIFdlYWsgZXRhZyBjaGVjayAtIHdlYWsgZXRhZ3Mgd2lsbCBtYWtlIGNvbXBhcmlzb24gYWxnb3JpdGhtcyBuZXZlciBtYXRjaFxuICAgICAgaWYgKHRoaXMuZXRhZyAhPSBudWxsKSB7XG4gICAgICAgIGhlYWRlcnNbJ2lmLW1hdGNoJ10gPSB0aGlzLmV0YWdcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRzID0ge1xuICAgICAgICAuLi50aGlzLm9wdHMsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi50aGlzLm9wdHMuaGVhZGVycyxcbiAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5yZXRyeUNvdW50Q2hlY2twb2ludCA9IHRoaXMucmV0cnlDb3VudFxuICAgICAgdGhpcy5kaXNwYXRjaCh0aGlzLm9wdHMsIHRoaXMpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25SZXNwb25zZUVycm9yPy4oY29udHJvbGxlciwgZXJyKVxuICAgIH1cbiAgfVxuXG4gIG9uUmVzcG9uc2VFcnJvciAoY29udHJvbGxlciwgZXJyKSB7XG4gICAgaWYgKGNvbnRyb2xsZXI/LmFib3J0ZWQgfHwgaXNEaXN0dXJiZWQodGhpcy5vcHRzLmJvZHkpKSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25SZXNwb25zZUVycm9yPy4oY29udHJvbGxlciwgZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvdWxkUmV0cnkgKHJldHVybmVkRXJyKSB7XG4gICAgICBpZiAoIXJldHVybmVkRXJyKSB7XG4gICAgICAgIHRoaXMucmV0cnkoY29udHJvbGxlcilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGFuZGxlcj8ub25SZXNwb25zZUVycm9yPy4oY29udHJvbGxlciwgcmV0dXJuZWRFcnIpXG4gICAgfVxuXG4gICAgLy8gV2UgcmVjb25jaWxlIGluIGNhc2Ugb2YgYSBtaXggYmV0d2VlbiBuZXR3b3JrIGVycm9yc1xuICAgIC8vIGFuZCBzZXJ2ZXIgZXJyb3IgcmVzcG9uc2VcbiAgICBpZiAodGhpcy5yZXRyeUNvdW50IC0gdGhpcy5yZXRyeUNvdW50Q2hlY2twb2ludCA+IDApIHtcbiAgICAgIC8vIFdlIGNvdW50IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGxhc3QgY2hlY2twb2ludCBhbmQgdGhlIGN1cnJlbnQgcmV0cnkgY291bnRcbiAgICAgIHRoaXMucmV0cnlDb3VudCA9XG4gICAgICAgIHRoaXMucmV0cnlDb3VudENoZWNrcG9pbnQgK1xuICAgICAgICAodGhpcy5yZXRyeUNvdW50IC0gdGhpcy5yZXRyeUNvdW50Q2hlY2twb2ludClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXRyeUNvdW50ICs9IDFcbiAgICB9XG5cbiAgICB0aGlzLnJldHJ5T3B0cy5yZXRyeShcbiAgICAgIGVycixcbiAgICAgIHtcbiAgICAgICAgc3RhdGU6IHsgY291bnRlcjogdGhpcy5yZXRyeUNvdW50IH0sXG4gICAgICAgIG9wdHM6IHsgcmV0cnlPcHRpb25zOiB0aGlzLnJldHJ5T3B0cywgLi4udGhpcy5vcHRzIH1cbiAgICAgIH0sXG4gICAgICBzaG91bGRSZXRyeS5iaW5kKHRoaXMpXG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmV0cnlIYW5kbGVyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/retry-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/unwrap-handler.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/handler/unwrap-handler.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { parseHeaders } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nconst kResume = Symbol('resume')\n\nclass UnwrapController {\n  #paused = false\n  #reason = null\n  #aborted = false\n  #abort\n\n  [kResume] = null\n\n  constructor (abort) {\n    this.#abort = abort\n  }\n\n  pause () {\n    this.#paused = true\n  }\n\n  resume () {\n    if (this.#paused) {\n      this.#paused = false\n      this[kResume]?.()\n    }\n  }\n\n  abort (reason) {\n    if (!this.#aborted) {\n      this.#aborted = true\n      this.#reason = reason\n      this.#abort(reason)\n    }\n  }\n\n  get aborted () {\n    return this.#aborted\n  }\n\n  get reason () {\n    return this.#reason\n  }\n\n  get paused () {\n    return this.#paused\n  }\n}\n\nmodule.exports = class UnwrapHandler {\n  #handler\n  #controller\n\n  constructor (handler) {\n    this.#handler = handler\n  }\n\n  static unwrap (handler) {\n    // TODO (fix): More checks...\n    return !handler.onRequestStart ? handler : new UnwrapHandler(handler)\n  }\n\n  onConnect (abort, context) {\n    this.#controller = new UnwrapController(abort)\n    this.#handler.onRequestStart?.(this.#controller, context)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    this.#handler.onRequestUpgrade?.(this.#controller, statusCode, parseHeaders(rawHeaders), socket)\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    this.#controller[kResume] = resume\n    this.#handler.onResponseStart?.(this.#controller, statusCode, parseHeaders(rawHeaders), statusMessage)\n    return !this.#controller.paused\n  }\n\n  onData (data) {\n    this.#handler.onResponseData?.(this.#controller, data)\n    return !this.#controller.paused\n  }\n\n  onComplete (rawTrailers) {\n    this.#handler.onResponseEnd?.(this.#controller, parseHeaders(rawTrailers))\n  }\n\n  onError (err) {\n    if (!this.#handler.onResponseError) {\n      throw new InvalidArgumentError('invalid onError method')\n    }\n\n    this.#handler.onResponseError?.(this.#controller, err)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3Vud3JhcC1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsa0VBQWM7QUFDL0MsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjs7QUFFekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3Vud3JhcC1oYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHBhcnNlSGVhZGVycyB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuY29uc3Qga1Jlc3VtZSA9IFN5bWJvbCgncmVzdW1lJylcblxuY2xhc3MgVW53cmFwQ29udHJvbGxlciB7XG4gICNwYXVzZWQgPSBmYWxzZVxuICAjcmVhc29uID0gbnVsbFxuICAjYWJvcnRlZCA9IGZhbHNlXG4gICNhYm9ydFxuXG4gIFtrUmVzdW1lXSA9IG51bGxcblxuICBjb25zdHJ1Y3RvciAoYWJvcnQpIHtcbiAgICB0aGlzLiNhYm9ydCA9IGFib3J0XG4gIH1cblxuICBwYXVzZSAoKSB7XG4gICAgdGhpcy4jcGF1c2VkID0gdHJ1ZVxuICB9XG5cbiAgcmVzdW1lICgpIHtcbiAgICBpZiAodGhpcy4jcGF1c2VkKSB7XG4gICAgICB0aGlzLiNwYXVzZWQgPSBmYWxzZVxuICAgICAgdGhpc1trUmVzdW1lXT8uKClcbiAgICB9XG4gIH1cblxuICBhYm9ydCAocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLiNhYm9ydGVkKSB7XG4gICAgICB0aGlzLiNhYm9ydGVkID0gdHJ1ZVxuICAgICAgdGhpcy4jcmVhc29uID0gcmVhc29uXG4gICAgICB0aGlzLiNhYm9ydChyZWFzb24pXG4gICAgfVxuICB9XG5cbiAgZ2V0IGFib3J0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLiNhYm9ydGVkXG4gIH1cblxuICBnZXQgcmVhc29uICgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhc29uXG4gIH1cblxuICBnZXQgcGF1c2VkICgpIHtcbiAgICByZXR1cm4gdGhpcy4jcGF1c2VkXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBVbndyYXBIYW5kbGVyIHtcbiAgI2hhbmRsZXJcbiAgI2NvbnRyb2xsZXJcblxuICBjb25zdHJ1Y3RvciAoaGFuZGxlcikge1xuICAgIHRoaXMuI2hhbmRsZXIgPSBoYW5kbGVyXG4gIH1cblxuICBzdGF0aWMgdW53cmFwIChoYW5kbGVyKSB7XG4gICAgLy8gVE9ETyAoZml4KTogTW9yZSBjaGVja3MuLi5cbiAgICByZXR1cm4gIWhhbmRsZXIub25SZXF1ZXN0U3RhcnQgPyBoYW5kbGVyIDogbmV3IFVud3JhcEhhbmRsZXIoaGFuZGxlcilcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICB0aGlzLiNjb250cm9sbGVyID0gbmV3IFVud3JhcENvbnRyb2xsZXIoYWJvcnQpXG4gICAgdGhpcy4jaGFuZGxlci5vblJlcXVlc3RTdGFydD8uKHRoaXMuI2NvbnRyb2xsZXIsIGNvbnRleHQpXG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHNvY2tldCkge1xuICAgIHRoaXMuI2hhbmRsZXIub25SZXF1ZXN0VXBncmFkZT8uKHRoaXMuI2NvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSwgc29ja2V0KVxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICB0aGlzLiNjb250cm9sbGVyW2tSZXN1bWVdID0gcmVzdW1lXG4gICAgdGhpcy4jaGFuZGxlci5vblJlc3BvbnNlU3RhcnQ/Lih0aGlzLiNjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBwYXJzZUhlYWRlcnMocmF3SGVhZGVycyksIHN0YXR1c01lc3NhZ2UpXG4gICAgcmV0dXJuICF0aGlzLiNjb250cm9sbGVyLnBhdXNlZFxuICB9XG5cbiAgb25EYXRhIChkYXRhKSB7XG4gICAgdGhpcy4jaGFuZGxlci5vblJlc3BvbnNlRGF0YT8uKHRoaXMuI2NvbnRyb2xsZXIsIGRhdGEpXG4gICAgcmV0dXJuICF0aGlzLiNjb250cm9sbGVyLnBhdXNlZFxuICB9XG5cbiAgb25Db21wbGV0ZSAocmF3VHJhaWxlcnMpIHtcbiAgICB0aGlzLiNoYW5kbGVyLm9uUmVzcG9uc2VFbmQ/Lih0aGlzLiNjb250cm9sbGVyLCBwYXJzZUhlYWRlcnMocmF3VHJhaWxlcnMpKVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgaWYgKCF0aGlzLiNoYW5kbGVyLm9uUmVzcG9uc2VFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRXJyb3IgbWV0aG9kJylcbiAgICB9XG5cbiAgICB0aGlzLiNoYW5kbGVyLm9uUmVzcG9uc2VFcnJvcj8uKHRoaXMuI2NvbnRyb2xsZXIsIGVycilcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/unwrap-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/wrap-handler.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/handler/wrap-handler.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nmodule.exports = class WrapHandler {\n  #handler\n\n  constructor (handler) {\n    this.#handler = handler\n  }\n\n  static wrap (handler) {\n    // TODO (fix): More checks...\n    return handler.onRequestStart ? handler : new WrapHandler(handler)\n  }\n\n  // Unwrap Interface\n\n  onConnect (abort, context) {\n    return this.#handler.onConnect?.(abort, context)\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    return this.#handler.onHeaders?.(statusCode, rawHeaders, resume, statusMessage)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    return this.#handler.onUpgrade?.(statusCode, rawHeaders, socket)\n  }\n\n  onData (data) {\n    return this.#handler.onData?.(data)\n  }\n\n  onComplete (trailers) {\n    return this.#handler.onComplete?.(trailers)\n  }\n\n  onError (err) {\n    if (!this.#handler.onError) {\n      throw err\n    }\n\n    return this.#handler.onError?.(err)\n  }\n\n  // Wrap Interface\n\n  onRequestStart (controller, context) {\n    this.#handler.onConnect?.((reason) => controller.abort(reason), context)\n  }\n\n  onRequestUpgrade (controller, statusCode, headers, socket) {\n    const rawHeaders = []\n    for (const [key, val] of Object.entries(headers)) {\n      rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map(v => Buffer.from(v)) : Buffer.from(val))\n    }\n\n    this.#handler.onUpgrade?.(statusCode, rawHeaders, socket)\n  }\n\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    const rawHeaders = []\n    for (const [key, val] of Object.entries(headers)) {\n      rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map(v => Buffer.from(v)) : Buffer.from(val))\n    }\n\n    if (this.#handler.onHeaders?.(statusCode, rawHeaders, () => controller.resume(), statusMessage) === false) {\n      controller.pause()\n    }\n  }\n\n  onResponseData (controller, data) {\n    if (this.#handler.onData?.(data) === false) {\n      controller.pause()\n    }\n  }\n\n  onResponseEnd (controller, trailers) {\n    const rawTrailers = []\n    for (const [key, val] of Object.entries(trailers)) {\n      rawTrailers.push(Buffer.from(key), Array.isArray(val) ? val.map(v => Buffer.from(v)) : Buffer.from(val))\n    }\n\n    this.#handler.onComplete?.(rawTrailers)\n  }\n\n  onResponseError (controller, err) {\n    if (!this.#handler.onError) {\n      throw new InvalidArgumentError('invalid onError method')\n    }\n\n    this.#handler.onError?.(err)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3dyYXAtaGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUV6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3dyYXAtaGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFdyYXBIYW5kbGVyIHtcbiAgI2hhbmRsZXJcblxuICBjb25zdHJ1Y3RvciAoaGFuZGxlcikge1xuICAgIHRoaXMuI2hhbmRsZXIgPSBoYW5kbGVyXG4gIH1cblxuICBzdGF0aWMgd3JhcCAoaGFuZGxlcikge1xuICAgIC8vIFRPRE8gKGZpeCk6IE1vcmUgY2hlY2tzLi4uXG4gICAgcmV0dXJuIGhhbmRsZXIub25SZXF1ZXN0U3RhcnQgPyBoYW5kbGVyIDogbmV3IFdyYXBIYW5kbGVyKGhhbmRsZXIpXG4gIH1cblxuICAvLyBVbndyYXAgSW50ZXJmYWNlXG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uQ29ubmVjdD8uKGFib3J0LCBjb250ZXh0KVxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vbkhlYWRlcnM/LihzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUsIHN0YXR1c01lc3NhZ2UpXG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHNvY2tldCkge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uVXBncmFkZT8uKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHNvY2tldClcbiAgfVxuXG4gIG9uRGF0YSAoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uRGF0YT8uKGRhdGEpXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uQ29tcGxldGU/Lih0cmFpbGVycylcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGlmICghdGhpcy4jaGFuZGxlci5vbkVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vbkVycm9yPy4oZXJyKVxuICB9XG5cbiAgLy8gV3JhcCBJbnRlcmZhY2VcblxuICBvblJlcXVlc3RTdGFydCAoY29udHJvbGxlciwgY29udGV4dCkge1xuICAgIHRoaXMuI2hhbmRsZXIub25Db25uZWN0Py4oKHJlYXNvbikgPT4gY29udHJvbGxlci5hYm9ydChyZWFzb24pLCBjb250ZXh0KVxuICB9XG5cbiAgb25SZXF1ZXN0VXBncmFkZSAoY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KSB7XG4gICAgY29uc3QgcmF3SGVhZGVycyA9IFtdXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgICByYXdIZWFkZXJzLnB1c2goQnVmZmVyLmZyb20oa2V5KSwgQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsLm1hcCh2ID0+IEJ1ZmZlci5mcm9tKHYpKSA6IEJ1ZmZlci5mcm9tKHZhbCkpXG4gICAgfVxuXG4gICAgdGhpcy4jaGFuZGxlci5vblVwZ3JhZGU/LihzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCBzb2NrZXQpXG4gIH1cblxuICBvblJlc3BvbnNlU3RhcnQgKGNvbnRyb2xsZXIsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICBjb25zdCByYXdIZWFkZXJzID0gW11cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgIHJhd0hlYWRlcnMucHVzaChCdWZmZXIuZnJvbShrZXkpLCBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwubWFwKHYgPT4gQnVmZmVyLmZyb20odikpIDogQnVmZmVyLmZyb20odmFsKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy4jaGFuZGxlci5vbkhlYWRlcnM/LihzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCAoKSA9PiBjb250cm9sbGVyLnJlc3VtZSgpLCBzdGF0dXNNZXNzYWdlKSA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnRyb2xsZXIucGF1c2UoKVxuICAgIH1cbiAgfVxuXG4gIG9uUmVzcG9uc2VEYXRhIChjb250cm9sbGVyLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuI2hhbmRsZXIub25EYXRhPy4oZGF0YSkgPT09IGZhbHNlKSB7XG4gICAgICBjb250cm9sbGVyLnBhdXNlKClcbiAgICB9XG4gIH1cblxuICBvblJlc3BvbnNlRW5kIChjb250cm9sbGVyLCB0cmFpbGVycykge1xuICAgIGNvbnN0IHJhd1RyYWlsZXJzID0gW11cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModHJhaWxlcnMpKSB7XG4gICAgICByYXdUcmFpbGVycy5wdXNoKEJ1ZmZlci5mcm9tKGtleSksIEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbC5tYXAodiA9PiBCdWZmZXIuZnJvbSh2KSkgOiBCdWZmZXIuZnJvbSh2YWwpKVxuICAgIH1cblxuICAgIHRoaXMuI2hhbmRsZXIub25Db21wbGV0ZT8uKHJhd1RyYWlsZXJzKVxuICB9XG5cbiAgb25SZXNwb25zZUVycm9yIChjb250cm9sbGVyLCBlcnIpIHtcbiAgICBpZiAoIXRoaXMuI2hhbmRsZXIub25FcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRXJyb3IgbWV0aG9kJylcbiAgICB9XG5cbiAgICB0aGlzLiNoYW5kbGVyLm9uRXJyb3I/LihlcnIpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/wrap-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/cache.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/cache.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { Readable } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst CacheHandler = __webpack_require__(/*! ../handler/cache-handler */ \"(rsc)/./node_modules/undici/lib/handler/cache-handler.js\")\nconst MemoryCacheStore = __webpack_require__(/*! ../cache/memory-cache-store */ \"(rsc)/./node_modules/undici/lib/cache/memory-cache-store.js\")\nconst CacheRevalidationHandler = __webpack_require__(/*! ../handler/cache-revalidation-handler */ \"(rsc)/./node_modules/undici/lib/handler/cache-revalidation-handler.js\")\nconst { assertCacheStore, assertCacheMethods, makeCacheKey, normaliseHeaders, parseCacheControlHeader } = __webpack_require__(/*! ../util/cache.js */ \"(rsc)/./node_modules/undici/lib/util/cache.js\")\nconst { AbortError } = __webpack_require__(/*! ../core/errors.js */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\n/**\n * @typedef {(options: import('../../types/dispatcher.d.ts').default.DispatchOptions, handler: import('../../types/dispatcher.d.ts').default.DispatchHandler) => void} DispatchFn\n */\n\n/**\n * @param {import('../../types/cache-interceptor.d.ts').default.GetResult} result\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives | undefined} cacheControlDirectives\n * @returns {boolean}\n */\nfunction needsRevalidation (result, cacheControlDirectives) {\n  if (cacheControlDirectives?.['no-cache']) {\n    // Always revalidate requests with the no-cache request directive\n    return true\n  }\n\n  if (result.cacheControlDirectives?.['no-cache'] && !Array.isArray(result.cacheControlDirectives['no-cache'])) {\n    // Always revalidate requests with unqualified no-cache response directive\n    return true\n  }\n\n  const now = Date.now()\n  if (now > result.staleAt) {\n    // Response is stale\n    if (cacheControlDirectives?.['max-stale']) {\n      // There's a threshold where we can serve stale responses, let's see if\n      //  we're in it\n      // https://www.rfc-editor.org/rfc/rfc9111.html#name-max-stale\n      const gracePeriod = result.staleAt + (cacheControlDirectives['max-stale'] * 1000)\n      return now > gracePeriod\n    }\n\n    return true\n  }\n\n  if (cacheControlDirectives?.['min-fresh']) {\n    // https://www.rfc-editor.org/rfc/rfc9111.html#section-5.2.1.3\n\n    // At this point, staleAt is always > now\n    const timeLeftTillStale = result.staleAt - now\n    const threshold = cacheControlDirectives['min-fresh'] * 1000\n\n    return timeLeftTillStale <= threshold\n  }\n\n  return false\n}\n\n/**\n * @param {DispatchFn} dispatch\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions} globalOpts\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} cacheKey\n * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler\n * @param {import('../../types/dispatcher.d.ts').default.RequestOptions} opts\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives | undefined} reqCacheControl\n */\nfunction handleUncachedResponse (\n  dispatch,\n  globalOpts,\n  cacheKey,\n  handler,\n  opts,\n  reqCacheControl\n) {\n  if (reqCacheControl?.['only-if-cached']) {\n    let aborted = false\n    try {\n      if (typeof handler.onConnect === 'function') {\n        handler.onConnect(() => {\n          aborted = true\n        })\n\n        if (aborted) {\n          return\n        }\n      }\n\n      if (typeof handler.onHeaders === 'function') {\n        handler.onHeaders(504, [], () => {}, 'Gateway Timeout')\n        if (aborted) {\n          return\n        }\n      }\n\n      if (typeof handler.onComplete === 'function') {\n        handler.onComplete([])\n      }\n    } catch (err) {\n      if (typeof handler.onError === 'function') {\n        handler.onError(err)\n      }\n    }\n\n    return true\n  }\n\n  return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler))\n}\n\n/**\n * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler\n * @param {import('../../types/dispatcher.d.ts').default.RequestOptions} opts\n * @param {import('../../types/cache-interceptor.d.ts').default.GetResult} result\n * @param {number} age\n * @param {any} context\n * @param {boolean} isStale\n */\nfunction sendCachedValue (handler, opts, result, age, context, isStale) {\n  // TODO (perf): Readable.from path can be optimized...\n  const stream = util.isStream(result.body)\n    ? result.body\n    : Readable.from(result.body ?? [])\n\n  assert(!stream.destroyed, 'stream should not be destroyed')\n  assert(!stream.readableDidRead, 'stream should not be readableDidRead')\n\n  const controller = {\n    resume () {\n      stream.resume()\n    },\n    pause () {\n      stream.pause()\n    },\n    get paused () {\n      return stream.isPaused()\n    },\n    get aborted () {\n      return stream.destroyed\n    },\n    get reason () {\n      return stream.errored\n    },\n    abort (reason) {\n      stream.destroy(reason ?? new AbortError())\n    }\n  }\n\n  stream\n    .on('error', function (err) {\n      if (!this.readableEnded) {\n        if (typeof handler.onResponseError === 'function') {\n          handler.onResponseError(controller, err)\n        } else {\n          throw err\n        }\n      }\n    })\n    .on('close', function () {\n      if (!this.errored) {\n        handler.onResponseEnd?.(controller, {})\n      }\n    })\n\n  handler.onRequestStart?.(controller, context)\n\n  if (stream.destroyed) {\n    return\n  }\n\n  // Add the age header\n  // https://www.rfc-editor.org/rfc/rfc9111.html#name-age\n  const headers = { ...result.headers, age: String(age) }\n\n  if (isStale) {\n    // Add warning header\n    //  https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Warning\n    headers.warning = '110 - \"response is stale\"'\n  }\n\n  handler.onResponseStart?.(controller, result.statusCode, headers, result.statusMessage)\n\n  if (opts.method === 'HEAD') {\n    stream.destroy()\n  } else {\n    stream.on('data', function (chunk) {\n      handler.onResponseData?.(controller, chunk)\n    })\n  }\n}\n\n/**\n * @param {DispatchFn} dispatch\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions} globalOpts\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} cacheKey\n * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler\n * @param {import('../../types/dispatcher.d.ts').default.RequestOptions} opts\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives | undefined} reqCacheControl\n * @param {import('../../types/cache-interceptor.d.ts').default.GetResult | undefined} result\n */\nfunction handleResult (\n  dispatch,\n  globalOpts,\n  cacheKey,\n  handler,\n  opts,\n  reqCacheControl,\n  result\n) {\n  if (!result) {\n    return handleUncachedResponse(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl)\n  }\n\n  const now = Date.now()\n  if (now > result.deleteAt) {\n    // Response is expired, cache store shouldn't have given this to us\n    return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler))\n  }\n\n  const age = Math.round((now - result.cachedAt) / 1000)\n  if (reqCacheControl?.['max-age'] && age >= reqCacheControl['max-age']) {\n    // Response is considered expired for this specific request\n    //  https://www.rfc-editor.org/rfc/rfc9111.html#section-5.2.1.1\n    return dispatch(opts, handler)\n  }\n\n  // Check if the response is stale\n  if (needsRevalidation(result, reqCacheControl)) {\n    if (util.isStream(opts.body) && util.bodyLength(opts.body) !== 0) {\n      // If body is a stream we can't revalidate...\n      // TODO (fix): This could be less strict...\n      return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler))\n    }\n\n    let withinStaleIfErrorThreshold = false\n    const staleIfErrorExpiry = result.cacheControlDirectives['stale-if-error'] ?? reqCacheControl?.['stale-if-error']\n    if (staleIfErrorExpiry) {\n      withinStaleIfErrorThreshold = now < (result.staleAt + (staleIfErrorExpiry * 1000))\n    }\n\n    let headers = {\n      ...opts.headers,\n      'if-modified-since': new Date(result.cachedAt).toUTCString()\n    }\n\n    if (result.etag) {\n      headers['if-none-match'] = result.etag\n    }\n\n    if (result.vary) {\n      headers = {\n        ...headers,\n        ...result.vary\n      }\n    }\n\n    // We need to revalidate the response\n    return dispatch(\n      {\n        ...opts,\n        headers\n      },\n      new CacheRevalidationHandler(\n        (success, context) => {\n          if (success) {\n            sendCachedValue(handler, opts, result, age, context, true)\n          } else if (util.isStream(result.body)) {\n            result.body.on('error', () => {}).destroy()\n          }\n        },\n        new CacheHandler(globalOpts, cacheKey, handler),\n        withinStaleIfErrorThreshold\n      )\n    )\n  }\n\n  // Dump request body.\n  if (util.isStream(opts.body)) {\n    opts.body.on('error', () => {}).destroy()\n  }\n\n  sendCachedValue(handler, opts, result, age, null, false)\n}\n\n/**\n * @param {import('../../types/cache-interceptor.d.ts').default.CacheOptions} [opts]\n * @returns {import('../../types/dispatcher.d.ts').default.DispatcherComposeInterceptor}\n */\nmodule.exports = (opts = {}) => {\n  const {\n    store = new MemoryCacheStore(),\n    methods = ['GET'],\n    cacheByDefault = undefined,\n    type = 'shared'\n  } = opts\n\n  if (typeof opts !== 'object' || opts === null) {\n    throw new TypeError(`expected type of opts to be an Object, got ${opts === null ? 'null' : typeof opts}`)\n  }\n\n  assertCacheStore(store, 'opts.store')\n  assertCacheMethods(methods, 'opts.methods')\n\n  if (typeof cacheByDefault !== 'undefined' && typeof cacheByDefault !== 'number') {\n    throw new TypeError(`exepcted opts.cacheByDefault to be number or undefined, got ${typeof cacheByDefault}`)\n  }\n\n  if (typeof type !== 'undefined' && type !== 'shared' && type !== 'private') {\n    throw new TypeError(`exepcted opts.type to be shared, private, or undefined, got ${typeof type}`)\n  }\n\n  const globalOpts = {\n    store,\n    methods,\n    cacheByDefault,\n    type\n  }\n\n  const safeMethodsToNotCache = util.safeHTTPMethods.filter(method => methods.includes(method) === false)\n\n  return dispatch => {\n    return (opts, handler) => {\n      if (!opts.origin || safeMethodsToNotCache.includes(opts.method)) {\n        // Not a method we want to cache or we don't have the origin, skip\n        return dispatch(opts, handler)\n      }\n\n      opts = {\n        ...opts,\n        headers: normaliseHeaders(opts)\n      }\n\n      const reqCacheControl = opts.headers?.['cache-control']\n        ? parseCacheControlHeader(opts.headers['cache-control'])\n        : undefined\n\n      if (reqCacheControl?.['no-store']) {\n        return dispatch(opts, handler)\n      }\n\n      /**\n       * @type {import('../../types/cache-interceptor.d.ts').default.CacheKey}\n       */\n      const cacheKey = makeCacheKey(opts)\n      const result = store.get(cacheKey)\n\n      if (result && typeof result.then === 'function') {\n        result.then(result => {\n          handleResult(dispatch,\n            globalOpts,\n            cacheKey,\n            handler,\n            opts,\n            reqCacheControl,\n            result\n          )\n        })\n      } else {\n        handleResult(\n          dispatch,\n          globalOpts,\n          cacheKey,\n          handler,\n          opts,\n          reqCacheControl,\n          result\n        )\n      }\n\n      return true\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMscUJBQXFCLG1CQUFPLENBQUMsMEZBQTBCO0FBQ3ZELHlCQUF5QixtQkFBTyxDQUFDLGdHQUE2QjtBQUM5RCxpQ0FBaUMsbUJBQU8sQ0FBQyxvSEFBdUM7QUFDaEYsUUFBUSxnR0FBZ0csRUFBRSxtQkFBTyxDQUFDLHVFQUFrQjtBQUNwSSxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLHlFQUFtQjs7QUFFbEQ7QUFDQSxhQUFhLDBKQUEwSjtBQUN2Szs7QUFFQTtBQUNBLFdBQVcsZ0VBQWdFO0FBQzNFLFdBQVcseUZBQXlGO0FBQ3BHLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVywwRUFBMEU7QUFDckYsV0FBVywrREFBK0Q7QUFDMUUsV0FBVywrREFBK0Q7QUFDMUUsV0FBVyw4REFBOEQ7QUFDekUsV0FBVyx5RkFBeUY7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVywrREFBK0Q7QUFDMUUsV0FBVyw4REFBOEQ7QUFDekUsV0FBVyxnRUFBZ0U7QUFDM0UsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVywwRUFBMEU7QUFDckYsV0FBVywrREFBK0Q7QUFDMUUsV0FBVywrREFBK0Q7QUFDMUUsV0FBVyw4REFBOEQ7QUFDekUsV0FBVyx5RkFBeUY7QUFDcEcsV0FBVyw0RUFBNEU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNENBQTRDO0FBQzVDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtRUFBbUU7QUFDOUUsYUFBYTtBQUNiO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0Esc0VBQXNFLHFDQUFxQztBQUMzRzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUZBQXVGLHNCQUFzQjtBQUM3Rzs7QUFFQTtBQUNBLHVGQUF1RixZQUFZO0FBQ25HOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2ludGVyY2VwdG9yL2NhY2hlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IFJlYWRhYmxlIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IENhY2hlSGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvY2FjaGUtaGFuZGxlcicpXG5jb25zdCBNZW1vcnlDYWNoZVN0b3JlID0gcmVxdWlyZSgnLi4vY2FjaGUvbWVtb3J5LWNhY2hlLXN0b3JlJylcbmNvbnN0IENhY2hlUmV2YWxpZGF0aW9uSGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvY2FjaGUtcmV2YWxpZGF0aW9uLWhhbmRsZXInKVxuY29uc3QgeyBhc3NlcnRDYWNoZVN0b3JlLCBhc3NlcnRDYWNoZU1ldGhvZHMsIG1ha2VDYWNoZUtleSwgbm9ybWFsaXNlSGVhZGVycywgcGFyc2VDYWNoZUNvbnRyb2xIZWFkZXIgfSA9IHJlcXVpcmUoJy4uL3V0aWwvY2FjaGUuanMnKVxuY29uc3QgeyBBYm9ydEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycy5qcycpXG5cbi8qKlxuICogQHR5cGVkZWYgeyhvcHRpb25zOiBpbXBvcnQoJy4uLy4uL3R5cGVzL2Rpc3BhdGNoZXIuZC50cycpLmRlZmF1bHQuRGlzcGF0Y2hPcHRpb25zLCBoYW5kbGVyOiBpbXBvcnQoJy4uLy4uL3R5cGVzL2Rpc3BhdGNoZXIuZC50cycpLmRlZmF1bHQuRGlzcGF0Y2hIYW5kbGVyKSA9PiB2b2lkfSBEaXNwYXRjaEZuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuR2V0UmVzdWx0fSByZXN1bHRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZUNvbnRyb2xEaXJlY3RpdmVzIHwgdW5kZWZpbmVkfSBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gbmVlZHNSZXZhbGlkYXRpb24gKHJlc3VsdCwgY2FjaGVDb250cm9sRGlyZWN0aXZlcykge1xuICBpZiAoY2FjaGVDb250cm9sRGlyZWN0aXZlcz8uWyduby1jYWNoZSddKSB7XG4gICAgLy8gQWx3YXlzIHJldmFsaWRhdGUgcmVxdWVzdHMgd2l0aCB0aGUgbm8tY2FjaGUgcmVxdWVzdCBkaXJlY3RpdmVcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHJlc3VsdC5jYWNoZUNvbnRyb2xEaXJlY3RpdmVzPy5bJ25vLWNhY2hlJ10gJiYgIUFycmF5LmlzQXJyYXkocmVzdWx0LmNhY2hlQ29udHJvbERpcmVjdGl2ZXNbJ25vLWNhY2hlJ10pKSB7XG4gICAgLy8gQWx3YXlzIHJldmFsaWRhdGUgcmVxdWVzdHMgd2l0aCB1bnF1YWxpZmllZCBuby1jYWNoZSByZXNwb25zZSBkaXJlY3RpdmVcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICBpZiAobm93ID4gcmVzdWx0LnN0YWxlQXQpIHtcbiAgICAvLyBSZXNwb25zZSBpcyBzdGFsZVxuICAgIGlmIChjYWNoZUNvbnRyb2xEaXJlY3RpdmVzPy5bJ21heC1zdGFsZSddKSB7XG4gICAgICAvLyBUaGVyZSdzIGEgdGhyZXNob2xkIHdoZXJlIHdlIGNhbiBzZXJ2ZSBzdGFsZSByZXNwb25zZXMsIGxldCdzIHNlZSBpZlxuICAgICAgLy8gIHdlJ3JlIGluIGl0XG4gICAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMS5odG1sI25hbWUtbWF4LXN0YWxlXG4gICAgICBjb25zdCBncmFjZVBlcmlvZCA9IHJlc3VsdC5zdGFsZUF0ICsgKGNhY2hlQ29udHJvbERpcmVjdGl2ZXNbJ21heC1zdGFsZSddICogMTAwMClcbiAgICAgIHJldHVybiBub3cgPiBncmFjZVBlcmlvZFxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoY2FjaGVDb250cm9sRGlyZWN0aXZlcz8uWydtaW4tZnJlc2gnXSkge1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MTExLmh0bWwjc2VjdGlvbi01LjIuMS4zXG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCBzdGFsZUF0IGlzIGFsd2F5cyA+IG5vd1xuICAgIGNvbnN0IHRpbWVMZWZ0VGlsbFN0YWxlID0gcmVzdWx0LnN0YWxlQXQgLSBub3dcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBjYWNoZUNvbnRyb2xEaXJlY3RpdmVzWydtaW4tZnJlc2gnXSAqIDEwMDBcblxuICAgIHJldHVybiB0aW1lTGVmdFRpbGxTdGFsZSA8PSB0aHJlc2hvbGRcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGlzcGF0Y2hGbn0gZGlzcGF0Y2hcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZUhhbmRsZXJPcHRpb25zfSBnbG9iYWxPcHRzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVLZXl9IGNhY2hlS2V5XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvZGlzcGF0Y2hlci5kLnRzJykuZGVmYXVsdC5EaXNwYXRjaEhhbmRsZXJ9IGhhbmRsZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9kaXNwYXRjaGVyLmQudHMnKS5kZWZhdWx0LlJlcXVlc3RPcHRpb25zfSBvcHRzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVDb250cm9sRGlyZWN0aXZlcyB8IHVuZGVmaW5lZH0gcmVxQ2FjaGVDb250cm9sXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVVuY2FjaGVkUmVzcG9uc2UgKFxuICBkaXNwYXRjaCxcbiAgZ2xvYmFsT3B0cyxcbiAgY2FjaGVLZXksXG4gIGhhbmRsZXIsXG4gIG9wdHMsXG4gIHJlcUNhY2hlQ29udHJvbFxuKSB7XG4gIGlmIChyZXFDYWNoZUNvbnRyb2w/Llsnb25seS1pZi1jYWNoZWQnXSkge1xuICAgIGxldCBhYm9ydGVkID0gZmFsc2VcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uQ29ubmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoYW5kbGVyLm9uQ29ubmVjdCgoKSA9PiB7XG4gICAgICAgICAgYWJvcnRlZCA9IHRydWVcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkhlYWRlcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaGFuZGxlci5vbkhlYWRlcnMoNTA0LCBbXSwgKCkgPT4ge30sICdHYXRld2F5IFRpbWVvdXQnKVxuICAgICAgICBpZiAoYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGhhbmRsZXIub25Db21wbGV0ZShbXSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGhhbmRsZXIub25FcnJvcihlcnIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaChvcHRzLCBuZXcgQ2FjaGVIYW5kbGVyKGdsb2JhbE9wdHMsIGNhY2hlS2V5LCBoYW5kbGVyKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvZGlzcGF0Y2hlci5kLnRzJykuZGVmYXVsdC5EaXNwYXRjaEhhbmRsZXJ9IGhhbmRsZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9kaXNwYXRjaGVyLmQudHMnKS5kZWZhdWx0LlJlcXVlc3RPcHRpb25zfSBvcHRzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuR2V0UmVzdWx0fSByZXN1bHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBhZ2VcbiAqIEBwYXJhbSB7YW55fSBjb250ZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RhbGVcbiAqL1xuZnVuY3Rpb24gc2VuZENhY2hlZFZhbHVlIChoYW5kbGVyLCBvcHRzLCByZXN1bHQsIGFnZSwgY29udGV4dCwgaXNTdGFsZSkge1xuICAvLyBUT0RPIChwZXJmKTogUmVhZGFibGUuZnJvbSBwYXRoIGNhbiBiZSBvcHRpbWl6ZWQuLi5cbiAgY29uc3Qgc3RyZWFtID0gdXRpbC5pc1N0cmVhbShyZXN1bHQuYm9keSlcbiAgICA/IHJlc3VsdC5ib2R5XG4gICAgOiBSZWFkYWJsZS5mcm9tKHJlc3VsdC5ib2R5ID8/IFtdKVxuXG4gIGFzc2VydCghc3RyZWFtLmRlc3Ryb3llZCwgJ3N0cmVhbSBzaG91bGQgbm90IGJlIGRlc3Ryb3llZCcpXG4gIGFzc2VydCghc3RyZWFtLnJlYWRhYmxlRGlkUmVhZCwgJ3N0cmVhbSBzaG91bGQgbm90IGJlIHJlYWRhYmxlRGlkUmVhZCcpXG5cbiAgY29uc3QgY29udHJvbGxlciA9IHtcbiAgICByZXN1bWUgKCkge1xuICAgICAgc3RyZWFtLnJlc3VtZSgpXG4gICAgfSxcbiAgICBwYXVzZSAoKSB7XG4gICAgICBzdHJlYW0ucGF1c2UoKVxuICAgIH0sXG4gICAgZ2V0IHBhdXNlZCAoKSB7XG4gICAgICByZXR1cm4gc3RyZWFtLmlzUGF1c2VkKClcbiAgICB9LFxuICAgIGdldCBhYm9ydGVkICgpIHtcbiAgICAgIHJldHVybiBzdHJlYW0uZGVzdHJveWVkXG4gICAgfSxcbiAgICBnZXQgcmVhc29uICgpIHtcbiAgICAgIHJldHVybiBzdHJlYW0uZXJyb3JlZFxuICAgIH0sXG4gICAgYWJvcnQgKHJlYXNvbikge1xuICAgICAgc3RyZWFtLmRlc3Ryb3kocmVhc29uID8/IG5ldyBBYm9ydEVycm9yKCkpXG4gICAgfVxuICB9XG5cbiAgc3RyZWFtXG4gICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghdGhpcy5yZWFkYWJsZUVuZGVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vblJlc3BvbnNlRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBoYW5kbGVyLm9uUmVzcG9uc2VFcnJvcihjb250cm9sbGVyLCBlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuZXJyb3JlZCkge1xuICAgICAgICBoYW5kbGVyLm9uUmVzcG9uc2VFbmQ/Lihjb250cm9sbGVyLCB7fSlcbiAgICAgIH1cbiAgICB9KVxuXG4gIGhhbmRsZXIub25SZXF1ZXN0U3RhcnQ/Lihjb250cm9sbGVyLCBjb250ZXh0KVxuXG4gIGlmIChzdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBBZGQgdGhlIGFnZSBoZWFkZXJcbiAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTEuaHRtbCNuYW1lLWFnZVxuICBjb25zdCBoZWFkZXJzID0geyAuLi5yZXN1bHQuaGVhZGVycywgYWdlOiBTdHJpbmcoYWdlKSB9XG5cbiAgaWYgKGlzU3RhbGUpIHtcbiAgICAvLyBBZGQgd2FybmluZyBoZWFkZXJcbiAgICAvLyAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1dhcm5pbmdcbiAgICBoZWFkZXJzLndhcm5pbmcgPSAnMTEwIC0gXCJyZXNwb25zZSBpcyBzdGFsZVwiJ1xuICB9XG5cbiAgaGFuZGxlci5vblJlc3BvbnNlU3RhcnQ/Lihjb250cm9sbGVyLCByZXN1bHQuc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdWx0LnN0YXR1c01lc3NhZ2UpXG5cbiAgaWYgKG9wdHMubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICBzdHJlYW0uZGVzdHJveSgpXG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBoYW5kbGVyLm9uUmVzcG9uc2VEYXRhPy4oY29udHJvbGxlciwgY2h1bmspXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGlzcGF0Y2hGbn0gZGlzcGF0Y2hcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZUhhbmRsZXJPcHRpb25zfSBnbG9iYWxPcHRzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVLZXl9IGNhY2hlS2V5XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvZGlzcGF0Y2hlci5kLnRzJykuZGVmYXVsdC5EaXNwYXRjaEhhbmRsZXJ9IGhhbmRsZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9kaXNwYXRjaGVyLmQudHMnKS5kZWZhdWx0LlJlcXVlc3RPcHRpb25zfSBvcHRzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVDb250cm9sRGlyZWN0aXZlcyB8IHVuZGVmaW5lZH0gcmVxQ2FjaGVDb250cm9sXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuR2V0UmVzdWx0IHwgdW5kZWZpbmVkfSByZXN1bHRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlUmVzdWx0IChcbiAgZGlzcGF0Y2gsXG4gIGdsb2JhbE9wdHMsXG4gIGNhY2hlS2V5LFxuICBoYW5kbGVyLFxuICBvcHRzLFxuICByZXFDYWNoZUNvbnRyb2wsXG4gIHJlc3VsdFxuKSB7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmV0dXJuIGhhbmRsZVVuY2FjaGVkUmVzcG9uc2UoZGlzcGF0Y2gsIGdsb2JhbE9wdHMsIGNhY2hlS2V5LCBoYW5kbGVyLCBvcHRzLCByZXFDYWNoZUNvbnRyb2wpXG4gIH1cblxuICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gIGlmIChub3cgPiByZXN1bHQuZGVsZXRlQXQpIHtcbiAgICAvLyBSZXNwb25zZSBpcyBleHBpcmVkLCBjYWNoZSBzdG9yZSBzaG91bGRuJ3QgaGF2ZSBnaXZlbiB0aGlzIHRvIHVzXG4gICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIG5ldyBDYWNoZUhhbmRsZXIoZ2xvYmFsT3B0cywgY2FjaGVLZXksIGhhbmRsZXIpKVxuICB9XG5cbiAgY29uc3QgYWdlID0gTWF0aC5yb3VuZCgobm93IC0gcmVzdWx0LmNhY2hlZEF0KSAvIDEwMDApXG4gIGlmIChyZXFDYWNoZUNvbnRyb2w/LlsnbWF4LWFnZSddICYmIGFnZSA+PSByZXFDYWNoZUNvbnRyb2xbJ21heC1hZ2UnXSkge1xuICAgIC8vIFJlc3BvbnNlIGlzIGNvbnNpZGVyZWQgZXhwaXJlZCBmb3IgdGhpcyBzcGVjaWZpYyByZXF1ZXN0XG4gICAgLy8gIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MTExLmh0bWwjc2VjdGlvbi01LjIuMS4xXG4gICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGUgcmVzcG9uc2UgaXMgc3RhbGVcbiAgaWYgKG5lZWRzUmV2YWxpZGF0aW9uKHJlc3VsdCwgcmVxQ2FjaGVDb250cm9sKSkge1xuICAgIGlmICh1dGlsLmlzU3RyZWFtKG9wdHMuYm9keSkgJiYgdXRpbC5ib2R5TGVuZ3RoKG9wdHMuYm9keSkgIT09IDApIHtcbiAgICAgIC8vIElmIGJvZHkgaXMgYSBzdHJlYW0gd2UgY2FuJ3QgcmV2YWxpZGF0ZS4uLlxuICAgICAgLy8gVE9ETyAoZml4KTogVGhpcyBjb3VsZCBiZSBsZXNzIHN0cmljdC4uLlxuICAgICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIG5ldyBDYWNoZUhhbmRsZXIoZ2xvYmFsT3B0cywgY2FjaGVLZXksIGhhbmRsZXIpKVxuICAgIH1cblxuICAgIGxldCB3aXRoaW5TdGFsZUlmRXJyb3JUaHJlc2hvbGQgPSBmYWxzZVxuICAgIGNvbnN0IHN0YWxlSWZFcnJvckV4cGlyeSA9IHJlc3VsdC5jYWNoZUNvbnRyb2xEaXJlY3RpdmVzWydzdGFsZS1pZi1lcnJvciddID8/IHJlcUNhY2hlQ29udHJvbD8uWydzdGFsZS1pZi1lcnJvciddXG4gICAgaWYgKHN0YWxlSWZFcnJvckV4cGlyeSkge1xuICAgICAgd2l0aGluU3RhbGVJZkVycm9yVGhyZXNob2xkID0gbm93IDwgKHJlc3VsdC5zdGFsZUF0ICsgKHN0YWxlSWZFcnJvckV4cGlyeSAqIDEwMDApKVxuICAgIH1cblxuICAgIGxldCBoZWFkZXJzID0ge1xuICAgICAgLi4ub3B0cy5oZWFkZXJzLFxuICAgICAgJ2lmLW1vZGlmaWVkLXNpbmNlJzogbmV3IERhdGUocmVzdWx0LmNhY2hlZEF0KS50b1VUQ1N0cmluZygpXG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5ldGFnKSB7XG4gICAgICBoZWFkZXJzWydpZi1ub25lLW1hdGNoJ10gPSByZXN1bHQuZXRhZ1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQudmFyeSkge1xuICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgLi4ucmVzdWx0LnZhcnlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSBuZWVkIHRvIHJldmFsaWRhdGUgdGhlIHJlc3BvbnNlXG4gICAgcmV0dXJuIGRpc3BhdGNoKFxuICAgICAge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9LFxuICAgICAgbmV3IENhY2hlUmV2YWxpZGF0aW9uSGFuZGxlcihcbiAgICAgICAgKHN1Y2Nlc3MsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgc2VuZENhY2hlZFZhbHVlKGhhbmRsZXIsIG9wdHMsIHJlc3VsdCwgYWdlLCBjb250ZXh0LCB0cnVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAodXRpbC5pc1N0cmVhbShyZXN1bHQuYm9keSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ib2R5Lm9uKCdlcnJvcicsICgpID0+IHt9KS5kZXN0cm95KClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5ldyBDYWNoZUhhbmRsZXIoZ2xvYmFsT3B0cywgY2FjaGVLZXksIGhhbmRsZXIpLFxuICAgICAgICB3aXRoaW5TdGFsZUlmRXJyb3JUaHJlc2hvbGRcbiAgICAgIClcbiAgICApXG4gIH1cblxuICAvLyBEdW1wIHJlcXVlc3QgYm9keS5cbiAgaWYgKHV0aWwuaXNTdHJlYW0ob3B0cy5ib2R5KSkge1xuICAgIG9wdHMuYm9keS5vbignZXJyb3InLCAoKSA9PiB7fSkuZGVzdHJveSgpXG4gIH1cblxuICBzZW5kQ2FjaGVkVmFsdWUoaGFuZGxlciwgb3B0cywgcmVzdWx0LCBhZ2UsIG51bGwsIGZhbHNlKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZS1pbnRlcmNlcHRvci5kLnRzJykuZGVmYXVsdC5DYWNoZU9wdGlvbnN9IFtvcHRzXVxuICogQHJldHVybnMge2ltcG9ydCgnLi4vLi4vdHlwZXMvZGlzcGF0Y2hlci5kLnRzJykuZGVmYXVsdC5EaXNwYXRjaGVyQ29tcG9zZUludGVyY2VwdG9yfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChvcHRzID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIHN0b3JlID0gbmV3IE1lbW9yeUNhY2hlU3RvcmUoKSxcbiAgICBtZXRob2RzID0gWydHRVQnXSxcbiAgICBjYWNoZUJ5RGVmYXVsdCA9IHVuZGVmaW5lZCxcbiAgICB0eXBlID0gJ3NoYXJlZCdcbiAgfSA9IG9wdHNcblxuICBpZiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8IG9wdHMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCB0eXBlIG9mIG9wdHMgdG8gYmUgYW4gT2JqZWN0LCBnb3QgJHtvcHRzID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIG9wdHN9YClcbiAgfVxuXG4gIGFzc2VydENhY2hlU3RvcmUoc3RvcmUsICdvcHRzLnN0b3JlJylcbiAgYXNzZXJ0Q2FjaGVNZXRob2RzKG1ldGhvZHMsICdvcHRzLm1ldGhvZHMnKVxuXG4gIGlmICh0eXBlb2YgY2FjaGVCeURlZmF1bHQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjYWNoZUJ5RGVmYXVsdCAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleGVwY3RlZCBvcHRzLmNhY2hlQnlEZWZhdWx0IHRvIGJlIG51bWJlciBvciB1bmRlZmluZWQsIGdvdCAke3R5cGVvZiBjYWNoZUJ5RGVmYXVsdH1gKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlICE9PSAnc2hhcmVkJyAmJiB0eXBlICE9PSAncHJpdmF0ZScpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleGVwY3RlZCBvcHRzLnR5cGUgdG8gYmUgc2hhcmVkLCBwcml2YXRlLCBvciB1bmRlZmluZWQsIGdvdCAke3R5cGVvZiB0eXBlfWApXG4gIH1cblxuICBjb25zdCBnbG9iYWxPcHRzID0ge1xuICAgIHN0b3JlLFxuICAgIG1ldGhvZHMsXG4gICAgY2FjaGVCeURlZmF1bHQsXG4gICAgdHlwZVxuICB9XG5cbiAgY29uc3Qgc2FmZU1ldGhvZHNUb05vdENhY2hlID0gdXRpbC5zYWZlSFRUUE1ldGhvZHMuZmlsdGVyKG1ldGhvZCA9PiBtZXRob2RzLmluY2x1ZGVzKG1ldGhvZCkgPT09IGZhbHNlKVxuXG4gIHJldHVybiBkaXNwYXRjaCA9PiB7XG4gICAgcmV0dXJuIChvcHRzLCBoYW5kbGVyKSA9PiB7XG4gICAgICBpZiAoIW9wdHMub3JpZ2luIHx8IHNhZmVNZXRob2RzVG9Ob3RDYWNoZS5pbmNsdWRlcyhvcHRzLm1ldGhvZCkpIHtcbiAgICAgICAgLy8gTm90IGEgbWV0aG9kIHdlIHdhbnQgdG8gY2FjaGUgb3Igd2UgZG9uJ3QgaGF2ZSB0aGUgb3JpZ2luLCBza2lwXG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICBvcHRzID0ge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBoZWFkZXJzOiBub3JtYWxpc2VIZWFkZXJzKG9wdHMpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcUNhY2hlQ29udHJvbCA9IG9wdHMuaGVhZGVycz8uWydjYWNoZS1jb250cm9sJ11cbiAgICAgICAgPyBwYXJzZUNhY2hlQ29udHJvbEhlYWRlcihvcHRzLmhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSlcbiAgICAgICAgOiB1bmRlZmluZWRcblxuICAgICAgaWYgKHJlcUNhY2hlQ29udHJvbD8uWyduby1zdG9yZSddKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlS2V5fVxuICAgICAgICovXG4gICAgICBjb25zdCBjYWNoZUtleSA9IG1ha2VDYWNoZUtleShvcHRzKVxuICAgICAgY29uc3QgcmVzdWx0ID0gc3RvcmUuZ2V0KGNhY2hlS2V5KVxuXG4gICAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXN1bHQudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgIGhhbmRsZVJlc3VsdChkaXNwYXRjaCxcbiAgICAgICAgICAgIGdsb2JhbE9wdHMsXG4gICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgcmVxQ2FjaGVDb250cm9sLFxuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlUmVzdWx0KFxuICAgICAgICAgIGRpc3BhdGNoLFxuICAgICAgICAgIGdsb2JhbE9wdHMsXG4gICAgICAgICAgY2FjaGVLZXksXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICBvcHRzLFxuICAgICAgICAgIHJlcUNhY2hlQ29udHJvbCxcbiAgICAgICAgICByZXN1bHRcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/dns.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/dns.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { isIP } = __webpack_require__(/*! node:net */ \"node:net\")\nconst { lookup } = __webpack_require__(/*! node:dns */ \"node:dns\")\nconst DecoratorHandler = __webpack_require__(/*! ../handler/decorator-handler */ \"(rsc)/./node_modules/undici/lib/handler/decorator-handler.js\")\nconst { InvalidArgumentError, InformationalError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst maxInt = Math.pow(2, 31) - 1\n\nclass DNSInstance {\n  #maxTTL = 0\n  #maxItems = 0\n  #records = new Map()\n  dualStack = true\n  affinity = null\n  lookup = null\n  pick = null\n\n  constructor (opts) {\n    this.#maxTTL = opts.maxTTL\n    this.#maxItems = opts.maxItems\n    this.dualStack = opts.dualStack\n    this.affinity = opts.affinity\n    this.lookup = opts.lookup ?? this.#defaultLookup\n    this.pick = opts.pick ?? this.#defaultPick\n  }\n\n  get full () {\n    return this.#records.size === this.#maxItems\n  }\n\n  runLookup (origin, opts, cb) {\n    const ips = this.#records.get(origin.hostname)\n\n    // If full, we just return the origin\n    if (ips == null && this.full) {\n      cb(null, origin)\n      return\n    }\n\n    const newOpts = {\n      affinity: this.affinity,\n      dualStack: this.dualStack,\n      lookup: this.lookup,\n      pick: this.pick,\n      ...opts.dns,\n      maxTTL: this.#maxTTL,\n      maxItems: this.#maxItems\n    }\n\n    // If no IPs we lookup\n    if (ips == null) {\n      this.lookup(origin, newOpts, (err, addresses) => {\n        if (err || addresses == null || addresses.length === 0) {\n          cb(err ?? new InformationalError('No DNS entries found'))\n          return\n        }\n\n        this.setRecords(origin, addresses)\n        const records = this.#records.get(origin.hostname)\n\n        const ip = this.pick(\n          origin,\n          records,\n          newOpts.affinity\n        )\n\n        let port\n        if (typeof ip.port === 'number') {\n          port = `:${ip.port}`\n        } else if (origin.port !== '') {\n          port = `:${origin.port}`\n        } else {\n          port = ''\n        }\n\n        cb(\n          null,\n          new URL(`${origin.protocol}//${\n            ip.family === 6 ? `[${ip.address}]` : ip.address\n          }${port}`)\n        )\n      })\n    } else {\n      // If there's IPs we pick\n      const ip = this.pick(\n        origin,\n        ips,\n        newOpts.affinity\n      )\n\n      // If no IPs we lookup - deleting old records\n      if (ip == null) {\n        this.#records.delete(origin.hostname)\n        this.runLookup(origin, opts, cb)\n        return\n      }\n\n      let port\n      if (typeof ip.port === 'number') {\n        port = `:${ip.port}`\n      } else if (origin.port !== '') {\n        port = `:${origin.port}`\n      } else {\n        port = ''\n      }\n\n      cb(\n        null,\n        new URL(`${origin.protocol}//${\n          ip.family === 6 ? `[${ip.address}]` : ip.address\n        }${port}`)\n      )\n    }\n  }\n\n  #defaultLookup (origin, opts, cb) {\n    lookup(\n      origin.hostname,\n      {\n        all: true,\n        family: this.dualStack === false ? this.affinity : 0,\n        order: 'ipv4first'\n      },\n      (err, addresses) => {\n        if (err) {\n          return cb(err)\n        }\n\n        const results = new Map()\n\n        for (const addr of addresses) {\n          // On linux we found duplicates, we attempt to remove them with\n          // the latest record\n          results.set(`${addr.address}:${addr.family}`, addr)\n        }\n\n        cb(null, results.values())\n      }\n    )\n  }\n\n  #defaultPick (origin, hostnameRecords, affinity) {\n    let ip = null\n    const { records, offset } = hostnameRecords\n\n    let family\n    if (this.dualStack) {\n      if (affinity == null) {\n        // Balance between ip families\n        if (offset == null || offset === maxInt) {\n          hostnameRecords.offset = 0\n          affinity = 4\n        } else {\n          hostnameRecords.offset++\n          affinity = (hostnameRecords.offset & 1) === 1 ? 6 : 4\n        }\n      }\n\n      if (records[affinity] != null && records[affinity].ips.length > 0) {\n        family = records[affinity]\n      } else {\n        family = records[affinity === 4 ? 6 : 4]\n      }\n    } else {\n      family = records[affinity]\n    }\n\n    // If no IPs we return null\n    if (family == null || family.ips.length === 0) {\n      return ip\n    }\n\n    if (family.offset == null || family.offset === maxInt) {\n      family.offset = 0\n    } else {\n      family.offset++\n    }\n\n    const position = family.offset % family.ips.length\n    ip = family.ips[position] ?? null\n\n    if (ip == null) {\n      return ip\n    }\n\n    if (Date.now() - ip.timestamp > ip.ttl) { // record TTL is already in ms\n      // We delete expired records\n      // It is possible that they have different TTL, so we manage them individually\n      family.ips.splice(position, 1)\n      return this.pick(origin, hostnameRecords, affinity)\n    }\n\n    return ip\n  }\n\n  pickFamily (origin, ipFamily) {\n    const records = this.#records.get(origin.hostname)?.records\n    if (!records) {\n      return null\n    }\n\n    const family = records[ipFamily]\n    if (!family) {\n      return null\n    }\n\n    if (family.offset == null || family.offset === maxInt) {\n      family.offset = 0\n    } else {\n      family.offset++\n    }\n\n    const position = family.offset % family.ips.length\n    const ip = family.ips[position] ?? null\n    if (ip == null) {\n      return ip\n    }\n\n    if (Date.now() - ip.timestamp > ip.ttl) { // record TTL is already in ms\n      // We delete expired records\n      // It is possible that they have different TTL, so we manage them individually\n      family.ips.splice(position, 1)\n    }\n\n    return ip\n  }\n\n  setRecords (origin, addresses) {\n    const timestamp = Date.now()\n    const records = { records: { 4: null, 6: null } }\n    for (const record of addresses) {\n      record.timestamp = timestamp\n      if (typeof record.ttl === 'number') {\n        // The record TTL is expected to be in ms\n        record.ttl = Math.min(record.ttl, this.#maxTTL)\n      } else {\n        record.ttl = this.#maxTTL\n      }\n\n      const familyRecords = records.records[record.family] ?? { ips: [] }\n\n      familyRecords.ips.push(record)\n      records.records[record.family] = familyRecords\n    }\n\n    this.#records.set(origin.hostname, records)\n  }\n\n  deleteRecords (origin) {\n    this.#records.delete(origin.hostname)\n  }\n\n  getHandler (meta, opts) {\n    return new DNSDispatchHandler(this, meta, opts)\n  }\n}\n\nclass DNSDispatchHandler extends DecoratorHandler {\n  #state = null\n  #opts = null\n  #dispatch = null\n  #origin = null\n  #controller = null\n  #newOrigin = null\n  #firstTry = true\n\n  constructor (state, { origin, handler, dispatch, newOrigin }, opts) {\n    super(handler)\n    this.#origin = origin\n    this.#newOrigin = newOrigin\n    this.#opts = { ...opts }\n    this.#state = state\n    this.#dispatch = dispatch\n  }\n\n  onResponseError (controller, err) {\n    switch (err.code) {\n      case 'ETIMEDOUT':\n      case 'ECONNREFUSED': {\n        if (this.#state.dualStack) {\n          if (!this.#firstTry) {\n            super.onResponseError(controller, err)\n            return\n          }\n          this.#firstTry = false\n\n          // Pick an ip address from the other family\n          const otherFamily = this.#newOrigin.hostname[0] === '[' ? 4 : 6\n          const ip = this.#state.pickFamily(this.#origin, otherFamily)\n          if (ip == null) {\n            super.onResponseError(controller, err)\n            return\n          }\n\n          let port\n          if (typeof ip.port === 'number') {\n            port = `:${ip.port}`\n          } else if (this.#origin.port !== '') {\n            port = `:${this.#origin.port}`\n          } else {\n            port = ''\n          }\n\n          const dispatchOpts = {\n            ...this.#opts,\n            origin: `${this.#origin.protocol}//${\n                ip.family === 6 ? `[${ip.address}]` : ip.address\n              }${port}`\n          }\n          this.#dispatch(dispatchOpts, this)\n          return\n        }\n\n        // if dual-stack disabled, we error out\n        super.onResponseError(controller, err)\n        break\n      }\n      case 'ENOTFOUND':\n        this.#state.deleteRecords(this.#origin)\n        super.onResponseError(controller, err)\n        break\n      default:\n        super.onResponseError(controller, err)\n        break\n    }\n  }\n}\n\nmodule.exports = interceptorOpts => {\n  if (\n    interceptorOpts?.maxTTL != null &&\n    (typeof interceptorOpts?.maxTTL !== 'number' || interceptorOpts?.maxTTL < 0)\n  ) {\n    throw new InvalidArgumentError('Invalid maxTTL. Must be a positive number')\n  }\n\n  if (\n    interceptorOpts?.maxItems != null &&\n    (typeof interceptorOpts?.maxItems !== 'number' ||\n      interceptorOpts?.maxItems < 1)\n  ) {\n    throw new InvalidArgumentError(\n      'Invalid maxItems. Must be a positive number and greater than zero'\n    )\n  }\n\n  if (\n    interceptorOpts?.affinity != null &&\n    interceptorOpts?.affinity !== 4 &&\n    interceptorOpts?.affinity !== 6\n  ) {\n    throw new InvalidArgumentError('Invalid affinity. Must be either 4 or 6')\n  }\n\n  if (\n    interceptorOpts?.dualStack != null &&\n    typeof interceptorOpts?.dualStack !== 'boolean'\n  ) {\n    throw new InvalidArgumentError('Invalid dualStack. Must be a boolean')\n  }\n\n  if (\n    interceptorOpts?.lookup != null &&\n    typeof interceptorOpts?.lookup !== 'function'\n  ) {\n    throw new InvalidArgumentError('Invalid lookup. Must be a function')\n  }\n\n  if (\n    interceptorOpts?.pick != null &&\n    typeof interceptorOpts?.pick !== 'function'\n  ) {\n    throw new InvalidArgumentError('Invalid pick. Must be a function')\n  }\n\n  const dualStack = interceptorOpts?.dualStack ?? true\n  let affinity\n  if (dualStack) {\n    affinity = interceptorOpts?.affinity ?? null\n  } else {\n    affinity = interceptorOpts?.affinity ?? 4\n  }\n\n  const opts = {\n    maxTTL: interceptorOpts?.maxTTL ?? 10e3, // Expressed in ms\n    lookup: interceptorOpts?.lookup ?? null,\n    pick: interceptorOpts?.pick ?? null,\n    dualStack,\n    affinity,\n    maxItems: interceptorOpts?.maxItems ?? Infinity\n  }\n\n  const instance = new DNSInstance(opts)\n\n  return dispatch => {\n    return function dnsInterceptor (origDispatchOpts, handler) {\n      const origin =\n        origDispatchOpts.origin.constructor === URL\n          ? origDispatchOpts.origin\n          : new URL(origDispatchOpts.origin)\n\n      if (isIP(origin.hostname) !== 0) {\n        return dispatch(origDispatchOpts, handler)\n      }\n\n      instance.runLookup(origin, origDispatchOpts, (err, newOrigin) => {\n        if (err) {\n          return handler.onResponseError(null, err)\n        }\n\n        const dispatchOpts = {\n          ...origDispatchOpts,\n          servername: origin.hostname, // For SNI on TLS\n          origin: newOrigin.origin,\n          headers: {\n            host: origin.host,\n            ...origDispatchOpts.headers\n          }\n        }\n\n        dispatch(\n          dispatchOpts,\n          instance.getHandler(\n            { origin, dispatch, handler, newOrigin },\n            origDispatchOpts\n          )\n        )\n      })\n\n      return true\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9kbnMuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLDBCQUFVO0FBQ25DLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEJBQVU7QUFDckMseUJBQXlCLG1CQUFPLENBQUMsa0dBQThCO0FBQy9ELFFBQVEsMkNBQTJDLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDN0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0IsVUFBVTtBQUNWLHFCQUFxQixZQUFZO0FBQ2pDLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDLGtDQUFrQyxXQUFXO0FBQzdDLFdBQVcsRUFBRSxLQUFLO0FBQ2xCO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixRQUFRO0FBQ1IsbUJBQW1CLFlBQVk7QUFDL0IsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkMsZ0NBQWdDLFdBQVc7QUFDM0MsU0FBUyxFQUFFLEtBQUs7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhLEdBQUcsWUFBWTtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixzQ0FBc0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0IsWUFBWTtBQUNaLHVCQUF1QixrQkFBa0I7QUFDekMsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0Msc0NBQXNDLFdBQVc7QUFDakQsZUFBZSxFQUFFLEtBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0NBQXNDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaW50ZXJjZXB0b3IvZG5zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgeyBpc0lQIH0gPSByZXF1aXJlKCdub2RlOm5ldCcpXG5jb25zdCB7IGxvb2t1cCB9ID0gcmVxdWlyZSgnbm9kZTpkbnMnKVxuY29uc3QgRGVjb3JhdG9ySGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvZGVjb3JhdG9yLWhhbmRsZXInKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgSW5mb3JtYXRpb25hbEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBtYXhJbnQgPSBNYXRoLnBvdygyLCAzMSkgLSAxXG5cbmNsYXNzIEROU0luc3RhbmNlIHtcbiAgI21heFRUTCA9IDBcbiAgI21heEl0ZW1zID0gMFxuICAjcmVjb3JkcyA9IG5ldyBNYXAoKVxuICBkdWFsU3RhY2sgPSB0cnVlXG4gIGFmZmluaXR5ID0gbnVsbFxuICBsb29rdXAgPSBudWxsXG4gIHBpY2sgPSBudWxsXG5cbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICB0aGlzLiNtYXhUVEwgPSBvcHRzLm1heFRUTFxuICAgIHRoaXMuI21heEl0ZW1zID0gb3B0cy5tYXhJdGVtc1xuICAgIHRoaXMuZHVhbFN0YWNrID0gb3B0cy5kdWFsU3RhY2tcbiAgICB0aGlzLmFmZmluaXR5ID0gb3B0cy5hZmZpbml0eVxuICAgIHRoaXMubG9va3VwID0gb3B0cy5sb29rdXAgPz8gdGhpcy4jZGVmYXVsdExvb2t1cFxuICAgIHRoaXMucGljayA9IG9wdHMucGljayA/PyB0aGlzLiNkZWZhdWx0UGlja1xuICB9XG5cbiAgZ2V0IGZ1bGwgKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWNvcmRzLnNpemUgPT09IHRoaXMuI21heEl0ZW1zXG4gIH1cblxuICBydW5Mb29rdXAgKG9yaWdpbiwgb3B0cywgY2IpIHtcbiAgICBjb25zdCBpcHMgPSB0aGlzLiNyZWNvcmRzLmdldChvcmlnaW4uaG9zdG5hbWUpXG5cbiAgICAvLyBJZiBmdWxsLCB3ZSBqdXN0IHJldHVybiB0aGUgb3JpZ2luXG4gICAgaWYgKGlwcyA9PSBudWxsICYmIHRoaXMuZnVsbCkge1xuICAgICAgY2IobnVsbCwgb3JpZ2luKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgbmV3T3B0cyA9IHtcbiAgICAgIGFmZmluaXR5OiB0aGlzLmFmZmluaXR5LFxuICAgICAgZHVhbFN0YWNrOiB0aGlzLmR1YWxTdGFjayxcbiAgICAgIGxvb2t1cDogdGhpcy5sb29rdXAsXG4gICAgICBwaWNrOiB0aGlzLnBpY2ssXG4gICAgICAuLi5vcHRzLmRucyxcbiAgICAgIG1heFRUTDogdGhpcy4jbWF4VFRMLFxuICAgICAgbWF4SXRlbXM6IHRoaXMuI21heEl0ZW1zXG4gICAgfVxuXG4gICAgLy8gSWYgbm8gSVBzIHdlIGxvb2t1cFxuICAgIGlmIChpcHMgPT0gbnVsbCkge1xuICAgICAgdGhpcy5sb29rdXAob3JpZ2luLCBuZXdPcHRzLCAoZXJyLCBhZGRyZXNzZXMpID0+IHtcbiAgICAgICAgaWYgKGVyciB8fCBhZGRyZXNzZXMgPT0gbnVsbCB8fCBhZGRyZXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY2IoZXJyID8/IG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ05vIEROUyBlbnRyaWVzIGZvdW5kJykpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFJlY29yZHMob3JpZ2luLCBhZGRyZXNzZXMpXG4gICAgICAgIGNvbnN0IHJlY29yZHMgPSB0aGlzLiNyZWNvcmRzLmdldChvcmlnaW4uaG9zdG5hbWUpXG5cbiAgICAgICAgY29uc3QgaXAgPSB0aGlzLnBpY2soXG4gICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgIHJlY29yZHMsXG4gICAgICAgICAgbmV3T3B0cy5hZmZpbml0eVxuICAgICAgICApXG5cbiAgICAgICAgbGV0IHBvcnRcbiAgICAgICAgaWYgKHR5cGVvZiBpcC5wb3J0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHBvcnQgPSBgOiR7aXAucG9ydH1gXG4gICAgICAgIH0gZWxzZSBpZiAob3JpZ2luLnBvcnQgIT09ICcnKSB7XG4gICAgICAgICAgcG9ydCA9IGA6JHtvcmlnaW4ucG9ydH1gXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9ydCA9ICcnXG4gICAgICAgIH1cblxuICAgICAgICBjYihcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG5ldyBVUkwoYCR7b3JpZ2luLnByb3RvY29sfS8vJHtcbiAgICAgICAgICAgIGlwLmZhbWlseSA9PT0gNiA/IGBbJHtpcC5hZGRyZXNzfV1gIDogaXAuYWRkcmVzc1xuICAgICAgICAgIH0ke3BvcnR9YClcbiAgICAgICAgKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlcmUncyBJUHMgd2UgcGlja1xuICAgICAgY29uc3QgaXAgPSB0aGlzLnBpY2soXG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgaXBzLFxuICAgICAgICBuZXdPcHRzLmFmZmluaXR5XG4gICAgICApXG5cbiAgICAgIC8vIElmIG5vIElQcyB3ZSBsb29rdXAgLSBkZWxldGluZyBvbGQgcmVjb3Jkc1xuICAgICAgaWYgKGlwID09IG51bGwpIHtcbiAgICAgICAgdGhpcy4jcmVjb3Jkcy5kZWxldGUob3JpZ2luLmhvc3RuYW1lKVxuICAgICAgICB0aGlzLnJ1bkxvb2t1cChvcmlnaW4sIG9wdHMsIGNiKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgbGV0IHBvcnRcbiAgICAgIGlmICh0eXBlb2YgaXAucG9ydCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcG9ydCA9IGA6JHtpcC5wb3J0fWBcbiAgICAgIH0gZWxzZSBpZiAob3JpZ2luLnBvcnQgIT09ICcnKSB7XG4gICAgICAgIHBvcnQgPSBgOiR7b3JpZ2luLnBvcnR9YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9ydCA9ICcnXG4gICAgICB9XG5cbiAgICAgIGNiKFxuICAgICAgICBudWxsLFxuICAgICAgICBuZXcgVVJMKGAke29yaWdpbi5wcm90b2NvbH0vLyR7XG4gICAgICAgICAgaXAuZmFtaWx5ID09PSA2ID8gYFske2lwLmFkZHJlc3N9XWAgOiBpcC5hZGRyZXNzXG4gICAgICAgIH0ke3BvcnR9YClcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAjZGVmYXVsdExvb2t1cCAob3JpZ2luLCBvcHRzLCBjYikge1xuICAgIGxvb2t1cChcbiAgICAgIG9yaWdpbi5ob3N0bmFtZSxcbiAgICAgIHtcbiAgICAgICAgYWxsOiB0cnVlLFxuICAgICAgICBmYW1pbHk6IHRoaXMuZHVhbFN0YWNrID09PSBmYWxzZSA/IHRoaXMuYWZmaW5pdHkgOiAwLFxuICAgICAgICBvcmRlcjogJ2lwdjRmaXJzdCdcbiAgICAgIH0sXG4gICAgICAoZXJyLCBhZGRyZXNzZXMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHRzID0gbmV3IE1hcCgpXG5cbiAgICAgICAgZm9yIChjb25zdCBhZGRyIG9mIGFkZHJlc3Nlcykge1xuICAgICAgICAgIC8vIE9uIGxpbnV4IHdlIGZvdW5kIGR1cGxpY2F0ZXMsIHdlIGF0dGVtcHQgdG8gcmVtb3ZlIHRoZW0gd2l0aFxuICAgICAgICAgIC8vIHRoZSBsYXRlc3QgcmVjb3JkXG4gICAgICAgICAgcmVzdWx0cy5zZXQoYCR7YWRkci5hZGRyZXNzfToke2FkZHIuZmFtaWx5fWAsIGFkZHIpXG4gICAgICAgIH1cblxuICAgICAgICBjYihudWxsLCByZXN1bHRzLnZhbHVlcygpKVxuICAgICAgfVxuICAgIClcbiAgfVxuXG4gICNkZWZhdWx0UGljayAob3JpZ2luLCBob3N0bmFtZVJlY29yZHMsIGFmZmluaXR5KSB7XG4gICAgbGV0IGlwID0gbnVsbFxuICAgIGNvbnN0IHsgcmVjb3Jkcywgb2Zmc2V0IH0gPSBob3N0bmFtZVJlY29yZHNcblxuICAgIGxldCBmYW1pbHlcbiAgICBpZiAodGhpcy5kdWFsU3RhY2spIHtcbiAgICAgIGlmIChhZmZpbml0eSA9PSBudWxsKSB7XG4gICAgICAgIC8vIEJhbGFuY2UgYmV0d2VlbiBpcCBmYW1pbGllc1xuICAgICAgICBpZiAob2Zmc2V0ID09IG51bGwgfHwgb2Zmc2V0ID09PSBtYXhJbnQpIHtcbiAgICAgICAgICBob3N0bmFtZVJlY29yZHMub2Zmc2V0ID0gMFxuICAgICAgICAgIGFmZmluaXR5ID0gNFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhvc3RuYW1lUmVjb3Jkcy5vZmZzZXQrK1xuICAgICAgICAgIGFmZmluaXR5ID0gKGhvc3RuYW1lUmVjb3Jkcy5vZmZzZXQgJiAxKSA9PT0gMSA/IDYgOiA0XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZHNbYWZmaW5pdHldICE9IG51bGwgJiYgcmVjb3Jkc1thZmZpbml0eV0uaXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZmFtaWx5ID0gcmVjb3Jkc1thZmZpbml0eV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhbWlseSA9IHJlY29yZHNbYWZmaW5pdHkgPT09IDQgPyA2IDogNF1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZmFtaWx5ID0gcmVjb3Jkc1thZmZpbml0eV1cbiAgICB9XG5cbiAgICAvLyBJZiBubyBJUHMgd2UgcmV0dXJuIG51bGxcbiAgICBpZiAoZmFtaWx5ID09IG51bGwgfHwgZmFtaWx5Lmlwcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBpcFxuICAgIH1cblxuICAgIGlmIChmYW1pbHkub2Zmc2V0ID09IG51bGwgfHwgZmFtaWx5Lm9mZnNldCA9PT0gbWF4SW50KSB7XG4gICAgICBmYW1pbHkub2Zmc2V0ID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICBmYW1pbHkub2Zmc2V0KytcbiAgICB9XG5cbiAgICBjb25zdCBwb3NpdGlvbiA9IGZhbWlseS5vZmZzZXQgJSBmYW1pbHkuaXBzLmxlbmd0aFxuICAgIGlwID0gZmFtaWx5Lmlwc1twb3NpdGlvbl0gPz8gbnVsbFxuXG4gICAgaWYgKGlwID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpcFxuICAgIH1cblxuICAgIGlmIChEYXRlLm5vdygpIC0gaXAudGltZXN0YW1wID4gaXAudHRsKSB7IC8vIHJlY29yZCBUVEwgaXMgYWxyZWFkeSBpbiBtc1xuICAgICAgLy8gV2UgZGVsZXRlIGV4cGlyZWQgcmVjb3Jkc1xuICAgICAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCB0aGV5IGhhdmUgZGlmZmVyZW50IFRUTCwgc28gd2UgbWFuYWdlIHRoZW0gaW5kaXZpZHVhbGx5XG4gICAgICBmYW1pbHkuaXBzLnNwbGljZShwb3NpdGlvbiwgMSlcbiAgICAgIHJldHVybiB0aGlzLnBpY2sob3JpZ2luLCBob3N0bmFtZVJlY29yZHMsIGFmZmluaXR5KVxuICAgIH1cblxuICAgIHJldHVybiBpcFxuICB9XG5cbiAgcGlja0ZhbWlseSAob3JpZ2luLCBpcEZhbWlseSkge1xuICAgIGNvbnN0IHJlY29yZHMgPSB0aGlzLiNyZWNvcmRzLmdldChvcmlnaW4uaG9zdG5hbWUpPy5yZWNvcmRzXG4gICAgaWYgKCFyZWNvcmRzKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IGZhbWlseSA9IHJlY29yZHNbaXBGYW1pbHldXG4gICAgaWYgKCFmYW1pbHkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgaWYgKGZhbWlseS5vZmZzZXQgPT0gbnVsbCB8fCBmYW1pbHkub2Zmc2V0ID09PSBtYXhJbnQpIHtcbiAgICAgIGZhbWlseS5vZmZzZXQgPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIGZhbWlseS5vZmZzZXQrK1xuICAgIH1cblxuICAgIGNvbnN0IHBvc2l0aW9uID0gZmFtaWx5Lm9mZnNldCAlIGZhbWlseS5pcHMubGVuZ3RoXG4gICAgY29uc3QgaXAgPSBmYW1pbHkuaXBzW3Bvc2l0aW9uXSA/PyBudWxsXG4gICAgaWYgKGlwID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpcFxuICAgIH1cblxuICAgIGlmIChEYXRlLm5vdygpIC0gaXAudGltZXN0YW1wID4gaXAudHRsKSB7IC8vIHJlY29yZCBUVEwgaXMgYWxyZWFkeSBpbiBtc1xuICAgICAgLy8gV2UgZGVsZXRlIGV4cGlyZWQgcmVjb3Jkc1xuICAgICAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCB0aGV5IGhhdmUgZGlmZmVyZW50IFRUTCwgc28gd2UgbWFuYWdlIHRoZW0gaW5kaXZpZHVhbGx5XG4gICAgICBmYW1pbHkuaXBzLnNwbGljZShwb3NpdGlvbiwgMSlcbiAgICB9XG5cbiAgICByZXR1cm4gaXBcbiAgfVxuXG4gIHNldFJlY29yZHMgKG9yaWdpbiwgYWRkcmVzc2VzKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKVxuICAgIGNvbnN0IHJlY29yZHMgPSB7IHJlY29yZHM6IHsgNDogbnVsbCwgNjogbnVsbCB9IH1cbiAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiBhZGRyZXNzZXMpIHtcbiAgICAgIHJlY29yZC50aW1lc3RhbXAgPSB0aW1lc3RhbXBcbiAgICAgIGlmICh0eXBlb2YgcmVjb3JkLnR0bCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gVGhlIHJlY29yZCBUVEwgaXMgZXhwZWN0ZWQgdG8gYmUgaW4gbXNcbiAgICAgICAgcmVjb3JkLnR0bCA9IE1hdGgubWluKHJlY29yZC50dGwsIHRoaXMuI21heFRUTClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY29yZC50dGwgPSB0aGlzLiNtYXhUVExcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmFtaWx5UmVjb3JkcyA9IHJlY29yZHMucmVjb3Jkc1tyZWNvcmQuZmFtaWx5XSA/PyB7IGlwczogW10gfVxuXG4gICAgICBmYW1pbHlSZWNvcmRzLmlwcy5wdXNoKHJlY29yZClcbiAgICAgIHJlY29yZHMucmVjb3Jkc1tyZWNvcmQuZmFtaWx5XSA9IGZhbWlseVJlY29yZHNcbiAgICB9XG5cbiAgICB0aGlzLiNyZWNvcmRzLnNldChvcmlnaW4uaG9zdG5hbWUsIHJlY29yZHMpXG4gIH1cblxuICBkZWxldGVSZWNvcmRzIChvcmlnaW4pIHtcbiAgICB0aGlzLiNyZWNvcmRzLmRlbGV0ZShvcmlnaW4uaG9zdG5hbWUpXG4gIH1cblxuICBnZXRIYW5kbGVyIChtZXRhLCBvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBETlNEaXNwYXRjaEhhbmRsZXIodGhpcywgbWV0YSwgb3B0cylcbiAgfVxufVxuXG5jbGFzcyBETlNEaXNwYXRjaEhhbmRsZXIgZXh0ZW5kcyBEZWNvcmF0b3JIYW5kbGVyIHtcbiAgI3N0YXRlID0gbnVsbFxuICAjb3B0cyA9IG51bGxcbiAgI2Rpc3BhdGNoID0gbnVsbFxuICAjb3JpZ2luID0gbnVsbFxuICAjY29udHJvbGxlciA9IG51bGxcbiAgI25ld09yaWdpbiA9IG51bGxcbiAgI2ZpcnN0VHJ5ID0gdHJ1ZVxuXG4gIGNvbnN0cnVjdG9yIChzdGF0ZSwgeyBvcmlnaW4sIGhhbmRsZXIsIGRpc3BhdGNoLCBuZXdPcmlnaW4gfSwgb3B0cykge1xuICAgIHN1cGVyKGhhbmRsZXIpXG4gICAgdGhpcy4jb3JpZ2luID0gb3JpZ2luXG4gICAgdGhpcy4jbmV3T3JpZ2luID0gbmV3T3JpZ2luXG4gICAgdGhpcy4jb3B0cyA9IHsgLi4ub3B0cyB9XG4gICAgdGhpcy4jc3RhdGUgPSBzdGF0ZVxuICAgIHRoaXMuI2Rpc3BhdGNoID0gZGlzcGF0Y2hcbiAgfVxuXG4gIG9uUmVzcG9uc2VFcnJvciAoY29udHJvbGxlciwgZXJyKSB7XG4gICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgY2FzZSAnRVRJTUVET1VUJzpcbiAgICAgIGNhc2UgJ0VDT05OUkVGVVNFRCc6IHtcbiAgICAgICAgaWYgKHRoaXMuI3N0YXRlLmR1YWxTdGFjaykge1xuICAgICAgICAgIGlmICghdGhpcy4jZmlyc3RUcnkpIHtcbiAgICAgICAgICAgIHN1cGVyLm9uUmVzcG9uc2VFcnJvcihjb250cm9sbGVyLCBlcnIpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy4jZmlyc3RUcnkgPSBmYWxzZVxuXG4gICAgICAgICAgLy8gUGljayBhbiBpcCBhZGRyZXNzIGZyb20gdGhlIG90aGVyIGZhbWlseVxuICAgICAgICAgIGNvbnN0IG90aGVyRmFtaWx5ID0gdGhpcy4jbmV3T3JpZ2luLmhvc3RuYW1lWzBdID09PSAnWycgPyA0IDogNlxuICAgICAgICAgIGNvbnN0IGlwID0gdGhpcy4jc3RhdGUucGlja0ZhbWlseSh0aGlzLiNvcmlnaW4sIG90aGVyRmFtaWx5KVxuICAgICAgICAgIGlmIChpcCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdXBlci5vblJlc3BvbnNlRXJyb3IoY29udHJvbGxlciwgZXJyKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHBvcnRcbiAgICAgICAgICBpZiAodHlwZW9mIGlwLnBvcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBwb3J0ID0gYDoke2lwLnBvcnR9YFxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy4jb3JpZ2luLnBvcnQgIT09ICcnKSB7XG4gICAgICAgICAgICBwb3J0ID0gYDoke3RoaXMuI29yaWdpbi5wb3J0fWBcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9ydCA9ICcnXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZGlzcGF0Y2hPcHRzID0ge1xuICAgICAgICAgICAgLi4udGhpcy4jb3B0cyxcbiAgICAgICAgICAgIG9yaWdpbjogYCR7dGhpcy4jb3JpZ2luLnByb3RvY29sfS8vJHtcbiAgICAgICAgICAgICAgICBpcC5mYW1pbHkgPT09IDYgPyBgWyR7aXAuYWRkcmVzc31dYCA6IGlwLmFkZHJlc3NcbiAgICAgICAgICAgICAgfSR7cG9ydH1gXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuI2Rpc3BhdGNoKGRpc3BhdGNoT3B0cywgdGhpcylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGR1YWwtc3RhY2sgZGlzYWJsZWQsIHdlIGVycm9yIG91dFxuICAgICAgICBzdXBlci5vblJlc3BvbnNlRXJyb3IoY29udHJvbGxlciwgZXJyKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnRU5PVEZPVU5EJzpcbiAgICAgICAgdGhpcy4jc3RhdGUuZGVsZXRlUmVjb3Jkcyh0aGlzLiNvcmlnaW4pXG4gICAgICAgIHN1cGVyLm9uUmVzcG9uc2VFcnJvcihjb250cm9sbGVyLCBlcnIpXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdXBlci5vblJlc3BvbnNlRXJyb3IoY29udHJvbGxlciwgZXJyKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVyY2VwdG9yT3B0cyA9PiB7XG4gIGlmIChcbiAgICBpbnRlcmNlcHRvck9wdHM/Lm1heFRUTCAhPSBudWxsICYmXG4gICAgKHR5cGVvZiBpbnRlcmNlcHRvck9wdHM/Lm1heFRUTCAhPT0gJ251bWJlcicgfHwgaW50ZXJjZXB0b3JPcHRzPy5tYXhUVEwgPCAwKVxuICApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgbWF4VFRMLiBNdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChcbiAgICBpbnRlcmNlcHRvck9wdHM/Lm1heEl0ZW1zICE9IG51bGwgJiZcbiAgICAodHlwZW9mIGludGVyY2VwdG9yT3B0cz8ubWF4SXRlbXMgIT09ICdudW1iZXInIHx8XG4gICAgICBpbnRlcmNlcHRvck9wdHM/Lm1heEl0ZW1zIDwgMSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgJ0ludmFsaWQgbWF4SXRlbXMuIE11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIgYW5kIGdyZWF0ZXIgdGhhbiB6ZXJvJ1xuICAgIClcbiAgfVxuXG4gIGlmIChcbiAgICBpbnRlcmNlcHRvck9wdHM/LmFmZmluaXR5ICE9IG51bGwgJiZcbiAgICBpbnRlcmNlcHRvck9wdHM/LmFmZmluaXR5ICE9PSA0ICYmXG4gICAgaW50ZXJjZXB0b3JPcHRzPy5hZmZpbml0eSAhPT0gNlxuICApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgYWZmaW5pdHkuIE11c3QgYmUgZWl0aGVyIDQgb3IgNicpXG4gIH1cblxuICBpZiAoXG4gICAgaW50ZXJjZXB0b3JPcHRzPy5kdWFsU3RhY2sgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiBpbnRlcmNlcHRvck9wdHM/LmR1YWxTdGFjayAhPT0gJ2Jvb2xlYW4nXG4gICkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBkdWFsU3RhY2suIE11c3QgYmUgYSBib29sZWFuJylcbiAgfVxuXG4gIGlmIChcbiAgICBpbnRlcmNlcHRvck9wdHM/Lmxvb2t1cCAhPSBudWxsICYmXG4gICAgdHlwZW9mIGludGVyY2VwdG9yT3B0cz8ubG9va3VwICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBsb29rdXAuIE11c3QgYmUgYSBmdW5jdGlvbicpXG4gIH1cblxuICBpZiAoXG4gICAgaW50ZXJjZXB0b3JPcHRzPy5waWNrICE9IG51bGwgJiZcbiAgICB0eXBlb2YgaW50ZXJjZXB0b3JPcHRzPy5waWNrICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBwaWNrLiBNdXN0IGJlIGEgZnVuY3Rpb24nKVxuICB9XG5cbiAgY29uc3QgZHVhbFN0YWNrID0gaW50ZXJjZXB0b3JPcHRzPy5kdWFsU3RhY2sgPz8gdHJ1ZVxuICBsZXQgYWZmaW5pdHlcbiAgaWYgKGR1YWxTdGFjaykge1xuICAgIGFmZmluaXR5ID0gaW50ZXJjZXB0b3JPcHRzPy5hZmZpbml0eSA/PyBudWxsXG4gIH0gZWxzZSB7XG4gICAgYWZmaW5pdHkgPSBpbnRlcmNlcHRvck9wdHM/LmFmZmluaXR5ID8/IDRcbiAgfVxuXG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgbWF4VFRMOiBpbnRlcmNlcHRvck9wdHM/Lm1heFRUTCA/PyAxMGUzLCAvLyBFeHByZXNzZWQgaW4gbXNcbiAgICBsb29rdXA6IGludGVyY2VwdG9yT3B0cz8ubG9va3VwID8/IG51bGwsXG4gICAgcGljazogaW50ZXJjZXB0b3JPcHRzPy5waWNrID8/IG51bGwsXG4gICAgZHVhbFN0YWNrLFxuICAgIGFmZmluaXR5LFxuICAgIG1heEl0ZW1zOiBpbnRlcmNlcHRvck9wdHM/Lm1heEl0ZW1zID8/IEluZmluaXR5XG4gIH1cblxuICBjb25zdCBpbnN0YW5jZSA9IG5ldyBETlNJbnN0YW5jZShvcHRzKVxuXG4gIHJldHVybiBkaXNwYXRjaCA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRuc0ludGVyY2VwdG9yIChvcmlnRGlzcGF0Y2hPcHRzLCBoYW5kbGVyKSB7XG4gICAgICBjb25zdCBvcmlnaW4gPVxuICAgICAgICBvcmlnRGlzcGF0Y2hPcHRzLm9yaWdpbi5jb25zdHJ1Y3RvciA9PT0gVVJMXG4gICAgICAgICAgPyBvcmlnRGlzcGF0Y2hPcHRzLm9yaWdpblxuICAgICAgICAgIDogbmV3IFVSTChvcmlnRGlzcGF0Y2hPcHRzLm9yaWdpbilcblxuICAgICAgaWYgKGlzSVAob3JpZ2luLmhvc3RuYW1lKSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2gob3JpZ0Rpc3BhdGNoT3B0cywgaGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2UucnVuTG9va3VwKG9yaWdpbiwgb3JpZ0Rpc3BhdGNoT3B0cywgKGVyciwgbmV3T3JpZ2luKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlci5vblJlc3BvbnNlRXJyb3IobnVsbCwgZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGlzcGF0Y2hPcHRzID0ge1xuICAgICAgICAgIC4uLm9yaWdEaXNwYXRjaE9wdHMsXG4gICAgICAgICAgc2VydmVybmFtZTogb3JpZ2luLmhvc3RuYW1lLCAvLyBGb3IgU05JIG9uIFRMU1xuICAgICAgICAgIG9yaWdpbjogbmV3T3JpZ2luLm9yaWdpbixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBob3N0OiBvcmlnaW4uaG9zdCxcbiAgICAgICAgICAgIC4uLm9yaWdEaXNwYXRjaE9wdHMuaGVhZGVyc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgIGRpc3BhdGNoT3B0cyxcbiAgICAgICAgICBpbnN0YW5jZS5nZXRIYW5kbGVyKFxuICAgICAgICAgICAgeyBvcmlnaW4sIGRpc3BhdGNoLCBoYW5kbGVyLCBuZXdPcmlnaW4gfSxcbiAgICAgICAgICAgIG9yaWdEaXNwYXRjaE9wdHNcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/dns.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/dump.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/dump.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst DecoratorHandler = __webpack_require__(/*! ../handler/decorator-handler */ \"(rsc)/./node_modules/undici/lib/handler/decorator-handler.js\")\n\nclass DumpHandler extends DecoratorHandler {\n  #maxSize = 1024 * 1024\n  #dumped = false\n  #size = 0\n  #controller = null\n  aborted = false\n  reason = false\n\n  constructor ({ maxSize, signal }, handler) {\n    if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {\n      throw new InvalidArgumentError('maxSize must be a number greater than 0')\n    }\n\n    super(handler)\n\n    this.#maxSize = maxSize ?? this.#maxSize\n    // this.#handler = handler\n  }\n\n  #abort (reason) {\n    this.aborted = true\n    this.reason = reason\n  }\n\n  onRequestStart (controller, context) {\n    controller.abort = this.#abort.bind(this)\n    this.#controller = controller\n\n    return super.onRequestStart(controller, context)\n  }\n\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    const contentLength = headers['content-length']\n\n    if (contentLength != null && contentLength > this.#maxSize) {\n      throw new RequestAbortedError(\n        `Response size (${contentLength}) larger than maxSize (${\n          this.#maxSize\n        })`\n      )\n    }\n\n    if (this.aborted === true) {\n      return true\n    }\n\n    return super.onResponseStart(controller, statusCode, headers, statusMessage)\n  }\n\n  onResponseError (controller, err) {\n    if (this.#dumped) {\n      return\n    }\n\n    err = this.#controller.reason ?? err\n\n    super.onResponseError(controller, err)\n  }\n\n  onResponseData (controller, chunk) {\n    this.#size = this.#size + chunk.length\n\n    if (this.#size >= this.#maxSize) {\n      this.#dumped = true\n\n      if (this.aborted === true) {\n        super.onResponseError(controller, this.reason)\n      } else {\n        super.onResponseEnd(controller, {})\n      }\n    }\n\n    return true\n  }\n\n  onResponseEnd (controller, trailers) {\n    if (this.#dumped) {\n      return\n    }\n\n    if (this.#controller.aborted === true) {\n      super.onResponseError(controller, this.reason)\n      return\n    }\n\n    super.onResponseEnd(controller, trailers)\n  }\n}\n\nfunction createDumpInterceptor (\n  { maxSize: defaultMaxSize } = {\n    maxSize: 1024 * 1024\n  }\n) {\n  return dispatch => {\n    return function Intercept (opts, handler) {\n      const { dumpMaxSize = defaultMaxSize } = opts\n\n      const dumpHandler = new DumpHandler({ maxSize: dumpMaxSize, signal: opts.signal }, handler)\n\n      return dispatch(opts, dumpHandler)\n    }\n  }\n}\n\nmodule.exports = createDumpInterceptor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9kdW1wLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsNENBQTRDLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDOUUseUJBQXlCLG1CQUFPLENBQUMsa0dBQThCOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSwwQkFBMEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0JBQStCOztBQUU3Qyw0Q0FBNEMsMkNBQTJDOztBQUV2RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9kdW1wLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBSZXF1ZXN0QWJvcnRlZEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBEZWNvcmF0b3JIYW5kbGVyID0gcmVxdWlyZSgnLi4vaGFuZGxlci9kZWNvcmF0b3ItaGFuZGxlcicpXG5cbmNsYXNzIER1bXBIYW5kbGVyIGV4dGVuZHMgRGVjb3JhdG9ySGFuZGxlciB7XG4gICNtYXhTaXplID0gMTAyNCAqIDEwMjRcbiAgI2R1bXBlZCA9IGZhbHNlXG4gICNzaXplID0gMFxuICAjY29udHJvbGxlciA9IG51bGxcbiAgYWJvcnRlZCA9IGZhbHNlXG4gIHJlYXNvbiA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3IgKHsgbWF4U2l6ZSwgc2lnbmFsIH0sIGhhbmRsZXIpIHtcbiAgICBpZiAobWF4U2l6ZSAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKG1heFNpemUpIHx8IG1heFNpemUgPCAxKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhTaXplIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAnKVxuICAgIH1cblxuICAgIHN1cGVyKGhhbmRsZXIpXG5cbiAgICB0aGlzLiNtYXhTaXplID0gbWF4U2l6ZSA/PyB0aGlzLiNtYXhTaXplXG4gICAgLy8gdGhpcy4jaGFuZGxlciA9IGhhbmRsZXJcbiAgfVxuXG4gICNhYm9ydCAocmVhc29uKSB7XG4gICAgdGhpcy5hYm9ydGVkID0gdHJ1ZVxuICAgIHRoaXMucmVhc29uID0gcmVhc29uXG4gIH1cblxuICBvblJlcXVlc3RTdGFydCAoY29udHJvbGxlciwgY29udGV4dCkge1xuICAgIGNvbnRyb2xsZXIuYWJvcnQgPSB0aGlzLiNhYm9ydC5iaW5kKHRoaXMpXG4gICAgdGhpcy4jY29udHJvbGxlciA9IGNvbnRyb2xsZXJcblxuICAgIHJldHVybiBzdXBlci5vblJlcXVlc3RTdGFydChjb250cm9sbGVyLCBjb250ZXh0KVxuICB9XG5cbiAgb25SZXNwb25zZVN0YXJ0IChjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IGhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ11cblxuICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwgJiYgY29udGVudExlbmd0aCA+IHRoaXMuI21heFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKFxuICAgICAgICBgUmVzcG9uc2Ugc2l6ZSAoJHtjb250ZW50TGVuZ3RofSkgbGFyZ2VyIHRoYW4gbWF4U2l6ZSAoJHtcbiAgICAgICAgICB0aGlzLiNtYXhTaXplXG4gICAgICAgIH0pYFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmFib3J0ZWQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLm9uUmVzcG9uc2VTdGFydChjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzdGF0dXNNZXNzYWdlKVxuICB9XG5cbiAgb25SZXNwb25zZUVycm9yIChjb250cm9sbGVyLCBlcnIpIHtcbiAgICBpZiAodGhpcy4jZHVtcGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBlcnIgPSB0aGlzLiNjb250cm9sbGVyLnJlYXNvbiA/PyBlcnJcblxuICAgIHN1cGVyLm9uUmVzcG9uc2VFcnJvcihjb250cm9sbGVyLCBlcnIpXG4gIH1cblxuICBvblJlc3BvbnNlRGF0YSAoY29udHJvbGxlciwgY2h1bmspIHtcbiAgICB0aGlzLiNzaXplID0gdGhpcy4jc2l6ZSArIGNodW5rLmxlbmd0aFxuXG4gICAgaWYgKHRoaXMuI3NpemUgPj0gdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgdGhpcy4jZHVtcGVkID0gdHJ1ZVxuXG4gICAgICBpZiAodGhpcy5hYm9ydGVkID09PSB0cnVlKSB7XG4gICAgICAgIHN1cGVyLm9uUmVzcG9uc2VFcnJvcihjb250cm9sbGVyLCB0aGlzLnJlYXNvbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyLm9uUmVzcG9uc2VFbmQoY29udHJvbGxlciwge30pXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIG9uUmVzcG9uc2VFbmQgKGNvbnRyb2xsZXIsIHRyYWlsZXJzKSB7XG4gICAgaWYgKHRoaXMuI2R1bXBlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuI2NvbnRyb2xsZXIuYWJvcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgc3VwZXIub25SZXNwb25zZUVycm9yKGNvbnRyb2xsZXIsIHRoaXMucmVhc29uKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc3VwZXIub25SZXNwb25zZUVuZChjb250cm9sbGVyLCB0cmFpbGVycylcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEdW1wSW50ZXJjZXB0b3IgKFxuICB7IG1heFNpemU6IGRlZmF1bHRNYXhTaXplIH0gPSB7XG4gICAgbWF4U2l6ZTogMTAyNCAqIDEwMjRcbiAgfVxuKSB7XG4gIHJldHVybiBkaXNwYXRjaCA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIEludGVyY2VwdCAob3B0cywgaGFuZGxlcikge1xuICAgICAgY29uc3QgeyBkdW1wTWF4U2l6ZSA9IGRlZmF1bHRNYXhTaXplIH0gPSBvcHRzXG5cbiAgICAgIGNvbnN0IGR1bXBIYW5kbGVyID0gbmV3IER1bXBIYW5kbGVyKHsgbWF4U2l6ZTogZHVtcE1heFNpemUsIHNpZ25hbDogb3B0cy5zaWduYWwgfSwgaGFuZGxlcilcblxuICAgICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIGR1bXBIYW5kbGVyKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUR1bXBJbnRlcmNlcHRvclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/dump.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/redirect.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/redirect.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst RedirectHandler = __webpack_require__(/*! ../handler/redirect-handler */ \"(rsc)/./node_modules/undici/lib/handler/redirect-handler.js\")\n\nfunction createRedirectInterceptor ({ maxRedirections: defaultMaxRedirections } = {}) {\n  return (dispatch) => {\n    return function Intercept (opts, handler) {\n      const { maxRedirections = defaultMaxRedirections, ...rest } = opts\n\n      if (maxRedirections == null || maxRedirections === 0) {\n        return dispatch(opts, handler)\n      }\n\n      const dispatchOpts = { ...rest, maxRedirections: 0 } // Stop sub dispatcher from also redirecting.\n      const redirectHandler = new RedirectHandler(dispatch, maxRedirections, dispatchOpts, handler)\n      return dispatch(dispatchOpts, redirectHandler)\n    }\n  }\n}\n\nmodule.exports = createRedirectInterceptor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWix3QkFBd0IsbUJBQU8sQ0FBQyxnR0FBNkI7O0FBRTdELHNDQUFzQywwQ0FBMEMsSUFBSTtBQUNwRjtBQUNBO0FBQ0EsY0FBYyxvREFBb0Q7O0FBRWxFO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaW50ZXJjZXB0b3IvcmVkaXJlY3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFJlZGlyZWN0SGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvcmVkaXJlY3QtaGFuZGxlcicpXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IgKHsgbWF4UmVkaXJlY3Rpb25zOiBkZWZhdWx0TWF4UmVkaXJlY3Rpb25zIH0gPSB7fSkge1xuICByZXR1cm4gKGRpc3BhdGNoKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIEludGVyY2VwdCAob3B0cywgaGFuZGxlcikge1xuICAgICAgY29uc3QgeyBtYXhSZWRpcmVjdGlvbnMgPSBkZWZhdWx0TWF4UmVkaXJlY3Rpb25zLCAuLi5yZXN0IH0gPSBvcHRzXG5cbiAgICAgIGlmIChtYXhSZWRpcmVjdGlvbnMgPT0gbnVsbCB8fCBtYXhSZWRpcmVjdGlvbnMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRpc3BhdGNoT3B0cyA9IHsgLi4ucmVzdCwgbWF4UmVkaXJlY3Rpb25zOiAwIH0gLy8gU3RvcCBzdWIgZGlzcGF0Y2hlciBmcm9tIGFsc28gcmVkaXJlY3RpbmcuXG4gICAgICBjb25zdCByZWRpcmVjdEhhbmRsZXIgPSBuZXcgUmVkaXJlY3RIYW5kbGVyKGRpc3BhdGNoLCBtYXhSZWRpcmVjdGlvbnMsIGRpc3BhdGNoT3B0cywgaGFuZGxlcilcbiAgICAgIHJldHVybiBkaXNwYXRjaChkaXNwYXRjaE9wdHMsIHJlZGlyZWN0SGFuZGxlcilcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/redirect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/response-error.js":
/*!***************************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/response-error.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// const { parseHeaders } = require('../core/util')\nconst DecoratorHandler = __webpack_require__(/*! ../handler/decorator-handler */ \"(rsc)/./node_modules/undici/lib/handler/decorator-handler.js\")\nconst { ResponseError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nclass ResponseErrorHandler extends DecoratorHandler {\n  #statusCode\n  #contentType\n  #decoder\n  #headers\n  #body\n\n  constructor (_opts, { handler }) {\n    super(handler)\n  }\n\n  #checkContentType (contentType) {\n    return (this.#contentType ?? '').indexOf(contentType) === 0\n  }\n\n  onRequestStart (controller, context) {\n    this.#statusCode = 0\n    this.#contentType = null\n    this.#decoder = null\n    this.#headers = null\n    this.#body = ''\n\n    return super.onRequestStart(controller, context)\n  }\n\n  onResponseStart (controller, statusCode, headers, statusMessage) {\n    this.#statusCode = statusCode\n    this.#headers = headers\n    this.#contentType = headers['content-type']\n\n    if (this.#statusCode < 400) {\n      return super.onResponseStart(controller, statusCode, headers, statusMessage)\n    }\n\n    if (this.#checkContentType('application/json') || this.#checkContentType('text/plain')) {\n      this.#decoder = new TextDecoder('utf-8')\n    }\n  }\n\n  onResponseData (controller, chunk) {\n    if (this.#statusCode < 400) {\n      return super.onResponseData(controller, chunk)\n    }\n\n    this.#body += this.#decoder?.decode(chunk, { stream: true }) ?? ''\n  }\n\n  onResponseEnd (controller, trailers) {\n    if (this.#statusCode >= 400) {\n      this.#body += this.#decoder?.decode(undefined, { stream: false }) ?? ''\n\n      if (this.#checkContentType('application/json')) {\n        try {\n          this.#body = JSON.parse(this.#body)\n        } catch {\n          // Do nothing...\n        }\n      }\n\n      let err\n      const stackTraceLimit = Error.stackTraceLimit\n      Error.stackTraceLimit = 0\n      try {\n        err = new ResponseError('Response Error', this.#statusCode, {\n          body: this.#body,\n          headers: this.#headers\n        })\n      } finally {\n        Error.stackTraceLimit = stackTraceLimit\n      }\n\n      super.onResponseError(controller, err)\n    } else {\n      super.onResponseEnd(controller, trailers)\n    }\n  }\n\n  onResponseError (controller, err) {\n    super.onResponseError(controller, err)\n  }\n}\n\nmodule.exports = () => {\n  return (dispatch) => {\n    return function Intercept (opts, handler) {\n      return dispatch(opts, new ResponseErrorHandler(opts, { handler }))\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZXNwb25zZS1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLGVBQWU7QUFDMUIseUJBQXlCLG1CQUFPLENBQUMsa0dBQThCO0FBQy9ELFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxlQUFlOztBQUV0RTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaW50ZXJjZXB0b3IvcmVzcG9uc2UtZXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIGNvbnN0IHsgcGFyc2VIZWFkZXJzIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgRGVjb3JhdG9ySGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvZGVjb3JhdG9yLWhhbmRsZXInKVxuY29uc3QgeyBSZXNwb25zZUVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbmNsYXNzIFJlc3BvbnNlRXJyb3JIYW5kbGVyIGV4dGVuZHMgRGVjb3JhdG9ySGFuZGxlciB7XG4gICNzdGF0dXNDb2RlXG4gICNjb250ZW50VHlwZVxuICAjZGVjb2RlclxuICAjaGVhZGVyc1xuICAjYm9keVxuXG4gIGNvbnN0cnVjdG9yIChfb3B0cywgeyBoYW5kbGVyIH0pIHtcbiAgICBzdXBlcihoYW5kbGVyKVxuICB9XG5cbiAgI2NoZWNrQ29udGVudFR5cGUgKGNvbnRlbnRUeXBlKSB7XG4gICAgcmV0dXJuICh0aGlzLiNjb250ZW50VHlwZSA/PyAnJykuaW5kZXhPZihjb250ZW50VHlwZSkgPT09IDBcbiAgfVxuXG4gIG9uUmVxdWVzdFN0YXJ0IChjb250cm9sbGVyLCBjb250ZXh0KSB7XG4gICAgdGhpcy4jc3RhdHVzQ29kZSA9IDBcbiAgICB0aGlzLiNjb250ZW50VHlwZSA9IG51bGxcbiAgICB0aGlzLiNkZWNvZGVyID0gbnVsbFxuICAgIHRoaXMuI2hlYWRlcnMgPSBudWxsXG4gICAgdGhpcy4jYm9keSA9ICcnXG5cbiAgICByZXR1cm4gc3VwZXIub25SZXF1ZXN0U3RhcnQoY29udHJvbGxlciwgY29udGV4dClcbiAgfVxuXG4gIG9uUmVzcG9uc2VTdGFydCAoY29udHJvbGxlciwgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzTWVzc2FnZSkge1xuICAgIHRoaXMuI3N0YXR1c0NvZGUgPSBzdGF0dXNDb2RlXG4gICAgdGhpcy4jaGVhZGVycyA9IGhlYWRlcnNcbiAgICB0aGlzLiNjb250ZW50VHlwZSA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG5cbiAgICBpZiAodGhpcy4jc3RhdHVzQ29kZSA8IDQwMCkge1xuICAgICAgcmV0dXJuIHN1cGVyLm9uUmVzcG9uc2VTdGFydChjb250cm9sbGVyLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzdGF0dXNNZXNzYWdlKVxuICAgIH1cblxuICAgIGlmICh0aGlzLiNjaGVja0NvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi9qc29uJykgfHwgdGhpcy4jY2hlY2tDb250ZW50VHlwZSgndGV4dC9wbGFpbicpKSB7XG4gICAgICB0aGlzLiNkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpXG4gICAgfVxuICB9XG5cbiAgb25SZXNwb25zZURhdGEgKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gICAgaWYgKHRoaXMuI3N0YXR1c0NvZGUgPCA0MDApIHtcbiAgICAgIHJldHVybiBzdXBlci5vblJlc3BvbnNlRGF0YShjb250cm9sbGVyLCBjaHVuaylcbiAgICB9XG5cbiAgICB0aGlzLiNib2R5ICs9IHRoaXMuI2RlY29kZXI/LmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSkgPz8gJydcbiAgfVxuXG4gIG9uUmVzcG9uc2VFbmQgKGNvbnRyb2xsZXIsIHRyYWlsZXJzKSB7XG4gICAgaWYgKHRoaXMuI3N0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICB0aGlzLiNib2R5ICs9IHRoaXMuI2RlY29kZXI/LmRlY29kZSh1bmRlZmluZWQsIHsgc3RyZWFtOiBmYWxzZSB9KSA/PyAnJ1xuXG4gICAgICBpZiAodGhpcy4jY2hlY2tDb250ZW50VHlwZSgnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy4jYm9keSA9IEpTT04ucGFyc2UodGhpcy4jYm9keSlcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8gRG8gbm90aGluZy4uLlxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBlcnJcbiAgICAgIGNvbnN0IHN0YWNrVHJhY2VMaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdFxuICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMFxuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyID0gbmV3IFJlc3BvbnNlRXJyb3IoJ1Jlc3BvbnNlIEVycm9yJywgdGhpcy4jc3RhdHVzQ29kZSwge1xuICAgICAgICAgIGJvZHk6IHRoaXMuI2JvZHksXG4gICAgICAgICAgaGVhZGVyczogdGhpcy4jaGVhZGVyc1xuICAgICAgICB9KVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gc3RhY2tUcmFjZUxpbWl0XG4gICAgICB9XG5cbiAgICAgIHN1cGVyLm9uUmVzcG9uc2VFcnJvcihjb250cm9sbGVyLCBlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLm9uUmVzcG9uc2VFbmQoY29udHJvbGxlciwgdHJhaWxlcnMpXG4gICAgfVxuICB9XG5cbiAgb25SZXNwb25zZUVycm9yIChjb250cm9sbGVyLCBlcnIpIHtcbiAgICBzdXBlci5vblJlc3BvbnNlRXJyb3IoY29udHJvbGxlciwgZXJyKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKCkgPT4ge1xuICByZXR1cm4gKGRpc3BhdGNoKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIEludGVyY2VwdCAob3B0cywgaGFuZGxlcikge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIG5ldyBSZXNwb25zZUVycm9ySGFuZGxlcihvcHRzLCB7IGhhbmRsZXIgfSkpXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/response-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/retry.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/retry.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst RetryHandler = __webpack_require__(/*! ../handler/retry-handler */ \"(rsc)/./node_modules/undici/lib/handler/retry-handler.js\")\n\nmodule.exports = globalOpts => {\n  return dispatch => {\n    return function retryInterceptor (opts, handler) {\n      return dispatch(\n        opts,\n        new RetryHandler(\n          { ...opts, retryOptions: { ...globalOpts, ...opts.retryOptions } },\n          {\n            handler,\n            dispatch\n          }\n        )\n      )\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZXRyeS5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaLHFCQUFxQixtQkFBTyxDQUFDLDBGQUEwQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUIsdUNBQXVDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZXRyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IFJldHJ5SGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvcmV0cnktaGFuZGxlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsT3B0cyA9PiB7XG4gIHJldHVybiBkaXNwYXRjaCA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJldHJ5SW50ZXJjZXB0b3IgKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaChcbiAgICAgICAgb3B0cyxcbiAgICAgICAgbmV3IFJldHJ5SGFuZGxlcihcbiAgICAgICAgICB7IC4uLm9wdHMsIHJldHJ5T3B0aW9uczogeyAuLi5nbG9iYWxPcHRzLCAuLi5vcHRzLnJldHJ5T3B0aW9ucyB9IH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgIGRpc3BhdGNoXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/retry.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/llhttp/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SPECIAL_HEADERS = exports.MINOR = exports.MAJOR = exports.HTAB_SP_VCHAR_OBS_TEXT = exports.QUOTED_STRING = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.HEX = exports.URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.STATUSES_HTTP = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.HEADER_STATE = exports.FINISH = exports.STATUSES = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/undici/lib/llhttp/utils.js\");\n// Emums\nexports.ERROR = {\n    OK: 0,\n    INTERNAL: 1,\n    STRICT: 2,\n    CR_EXPECTED: 25,\n    LF_EXPECTED: 3,\n    UNEXPECTED_CONTENT_LENGTH: 4,\n    UNEXPECTED_SPACE: 30,\n    CLOSED_CONNECTION: 5,\n    INVALID_METHOD: 6,\n    INVALID_URL: 7,\n    INVALID_CONSTANT: 8,\n    INVALID_VERSION: 9,\n    INVALID_HEADER_TOKEN: 10,\n    INVALID_CONTENT_LENGTH: 11,\n    INVALID_CHUNK_SIZE: 12,\n    INVALID_STATUS: 13,\n    INVALID_EOF_STATE: 14,\n    INVALID_TRANSFER_ENCODING: 15,\n    CB_MESSAGE_BEGIN: 16,\n    CB_HEADERS_COMPLETE: 17,\n    CB_MESSAGE_COMPLETE: 18,\n    CB_CHUNK_HEADER: 19,\n    CB_CHUNK_COMPLETE: 20,\n    PAUSED: 21,\n    PAUSED_UPGRADE: 22,\n    PAUSED_H2_UPGRADE: 23,\n    USER: 24,\n    CB_URL_COMPLETE: 26,\n    CB_STATUS_COMPLETE: 27,\n    CB_METHOD_COMPLETE: 32,\n    CB_VERSION_COMPLETE: 33,\n    CB_HEADER_FIELD_COMPLETE: 28,\n    CB_HEADER_VALUE_COMPLETE: 29,\n    CB_CHUNK_EXTENSION_NAME_COMPLETE: 34,\n    CB_CHUNK_EXTENSION_VALUE_COMPLETE: 35,\n    CB_RESET: 31,\n};\nexports.TYPE = {\n    BOTH: 0, // default\n    REQUEST: 1,\n    RESPONSE: 2,\n};\nexports.FLAGS = {\n    CONNECTION_KEEP_ALIVE: 1 << 0,\n    CONNECTION_CLOSE: 1 << 1,\n    CONNECTION_UPGRADE: 1 << 2,\n    CHUNKED: 1 << 3,\n    UPGRADE: 1 << 4,\n    CONTENT_LENGTH: 1 << 5,\n    SKIPBODY: 1 << 6,\n    TRAILING: 1 << 7,\n    // 1 << 8 is unused\n    TRANSFER_ENCODING: 1 << 9,\n};\nexports.LENIENT_FLAGS = {\n    HEADERS: 1 << 0,\n    CHUNKED_LENGTH: 1 << 1,\n    KEEP_ALIVE: 1 << 2,\n    TRANSFER_ENCODING: 1 << 3,\n    VERSION: 1 << 4,\n    DATA_AFTER_CLOSE: 1 << 5,\n    OPTIONAL_LF_AFTER_CR: 1 << 6,\n    OPTIONAL_CRLF_AFTER_CHUNK: 1 << 7,\n    OPTIONAL_CR_BEFORE_LF: 1 << 8,\n    SPACES_AFTER_CHUNK_SIZE: 1 << 9,\n};\nexports.METHODS = {\n    'DELETE': 0,\n    'GET': 1,\n    'HEAD': 2,\n    'POST': 3,\n    'PUT': 4,\n    /* pathological */\n    'CONNECT': 5,\n    'OPTIONS': 6,\n    'TRACE': 7,\n    /* WebDAV */\n    'COPY': 8,\n    'LOCK': 9,\n    'MKCOL': 10,\n    'MOVE': 11,\n    'PROPFIND': 12,\n    'PROPPATCH': 13,\n    'SEARCH': 14,\n    'UNLOCK': 15,\n    'BIND': 16,\n    'REBIND': 17,\n    'UNBIND': 18,\n    'ACL': 19,\n    /* subversion */\n    'REPORT': 20,\n    'MKACTIVITY': 21,\n    'CHECKOUT': 22,\n    'MERGE': 23,\n    /* upnp */\n    'M-SEARCH': 24,\n    'NOTIFY': 25,\n    'SUBSCRIBE': 26,\n    'UNSUBSCRIBE': 27,\n    /* RFC-5789 */\n    'PATCH': 28,\n    'PURGE': 29,\n    /* CalDAV */\n    'MKCALENDAR': 30,\n    /* RFC-2068, section 19.6.1.2 */\n    'LINK': 31,\n    'UNLINK': 32,\n    /* icecast */\n    'SOURCE': 33,\n    /* RFC-7540, section 11.6 */\n    'PRI': 34,\n    /* RFC-2326 RTSP */\n    'DESCRIBE': 35,\n    'ANNOUNCE': 36,\n    'SETUP': 37,\n    'PLAY': 38,\n    'PAUSE': 39,\n    'TEARDOWN': 40,\n    'GET_PARAMETER': 41,\n    'SET_PARAMETER': 42,\n    'REDIRECT': 43,\n    'RECORD': 44,\n    /* RAOP */\n    'FLUSH': 45,\n    /* DRAFT https://www.ietf.org/archive/id/draft-ietf-httpbis-safe-method-w-body-02.html */\n    'QUERY': 46,\n};\nexports.STATUSES = {\n    CONTINUE: 100,\n    SWITCHING_PROTOCOLS: 101,\n    PROCESSING: 102,\n    EARLY_HINTS: 103,\n    RESPONSE_IS_STALE: 110, // Unofficial\n    REVALIDATION_FAILED: 111, // Unofficial\n    DISCONNECTED_OPERATION: 112, // Unofficial\n    HEURISTIC_EXPIRATION: 113, // Unofficial\n    MISCELLANEOUS_WARNING: 199, // Unofficial\n    OK: 200,\n    CREATED: 201,\n    ACCEPTED: 202,\n    NON_AUTHORITATIVE_INFORMATION: 203,\n    NO_CONTENT: 204,\n    RESET_CONTENT: 205,\n    PARTIAL_CONTENT: 206,\n    MULTI_STATUS: 207,\n    ALREADY_REPORTED: 208,\n    TRANSFORMATION_APPLIED: 214, // Unofficial\n    IM_USED: 226,\n    MISCELLANEOUS_PERSISTENT_WARNING: 299, // Unofficial\n    MULTIPLE_CHOICES: 300,\n    MOVED_PERMANENTLY: 301,\n    FOUND: 302,\n    SEE_OTHER: 303,\n    NOT_MODIFIED: 304,\n    USE_PROXY: 305,\n    SWITCH_PROXY: 306, // No longer used\n    TEMPORARY_REDIRECT: 307,\n    PERMANENT_REDIRECT: 308,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    PAYMENT_REQUIRED: 402,\n    FORBIDDEN: 403,\n    NOT_FOUND: 404,\n    METHOD_NOT_ALLOWED: 405,\n    NOT_ACCEPTABLE: 406,\n    PROXY_AUTHENTICATION_REQUIRED: 407,\n    REQUEST_TIMEOUT: 408,\n    CONFLICT: 409,\n    GONE: 410,\n    LENGTH_REQUIRED: 411,\n    PRECONDITION_FAILED: 412,\n    PAYLOAD_TOO_LARGE: 413,\n    URI_TOO_LONG: 414,\n    UNSUPPORTED_MEDIA_TYPE: 415,\n    RANGE_NOT_SATISFIABLE: 416,\n    EXPECTATION_FAILED: 417,\n    IM_A_TEAPOT: 418,\n    PAGE_EXPIRED: 419, // Unofficial\n    ENHANCE_YOUR_CALM: 420, // Unofficial\n    MISDIRECTED_REQUEST: 421,\n    UNPROCESSABLE_ENTITY: 422,\n    LOCKED: 423,\n    FAILED_DEPENDENCY: 424,\n    TOO_EARLY: 425,\n    UPGRADE_REQUIRED: 426,\n    PRECONDITION_REQUIRED: 428,\n    TOO_MANY_REQUESTS: 429,\n    REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL: 430, // Unofficial\n    REQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n    LOGIN_TIMEOUT: 440, // Unofficial\n    NO_RESPONSE: 444, // Unofficial\n    RETRY_WITH: 449, // Unofficial\n    BLOCKED_BY_PARENTAL_CONTROL: 450, // Unofficial\n    UNAVAILABLE_FOR_LEGAL_REASONS: 451,\n    CLIENT_CLOSED_LOAD_BALANCED_REQUEST: 460, // Unofficial\n    INVALID_X_FORWARDED_FOR: 463, // Unofficial\n    REQUEST_HEADER_TOO_LARGE: 494, // Unofficial\n    SSL_CERTIFICATE_ERROR: 495, // Unofficial\n    SSL_CERTIFICATE_REQUIRED: 496, // Unofficial\n    HTTP_REQUEST_SENT_TO_HTTPS_PORT: 497, // Unofficial\n    INVALID_TOKEN: 498, // Unofficial\n    CLIENT_CLOSED_REQUEST: 499, // Unofficial\n    INTERNAL_SERVER_ERROR: 500,\n    NOT_IMPLEMENTED: 501,\n    BAD_GATEWAY: 502,\n    SERVICE_UNAVAILABLE: 503,\n    GATEWAY_TIMEOUT: 504,\n    HTTP_VERSION_NOT_SUPPORTED: 505,\n    VARIANT_ALSO_NEGOTIATES: 506,\n    INSUFFICIENT_STORAGE: 507,\n    LOOP_DETECTED: 508,\n    BANDWIDTH_LIMIT_EXCEEDED: 509,\n    NOT_EXTENDED: 510,\n    NETWORK_AUTHENTICATION_REQUIRED: 511,\n    WEB_SERVER_UNKNOWN_ERROR: 520, // Unofficial\n    WEB_SERVER_IS_DOWN: 521, // Unofficial\n    CONNECTION_TIMEOUT: 522, // Unofficial\n    ORIGIN_IS_UNREACHABLE: 523, // Unofficial\n    TIMEOUT_OCCURED: 524, // Unofficial\n    SSL_HANDSHAKE_FAILED: 525, // Unofficial\n    INVALID_SSL_CERTIFICATE: 526, // Unofficial\n    RAILGUN_ERROR: 527, // Unofficial\n    SITE_IS_OVERLOADED: 529, // Unofficial\n    SITE_IS_FROZEN: 530, // Unofficial\n    IDENTITY_PROVIDER_AUTHENTICATION_ERROR: 561, // Unofficial\n    NETWORK_READ_TIMEOUT: 598, // Unofficial\n    NETWORK_CONNECT_TIMEOUT: 599, // Unofficial\n};\nexports.FINISH = {\n    SAFE: 0,\n    SAFE_WITH_CB: 1,\n    UNSAFE: 2,\n};\nexports.HEADER_STATE = {\n    GENERAL: 0,\n    CONNECTION: 1,\n    CONTENT_LENGTH: 2,\n    TRANSFER_ENCODING: 3,\n    UPGRADE: 4,\n    CONNECTION_KEEP_ALIVE: 5,\n    CONNECTION_CLOSE: 6,\n    CONNECTION_UPGRADE: 7,\n    TRANSFER_ENCODING_CHUNKED: 8,\n};\n// C headers\nexports.METHODS_HTTP = [\n    exports.METHODS.DELETE,\n    exports.METHODS.GET,\n    exports.METHODS.HEAD,\n    exports.METHODS.POST,\n    exports.METHODS.PUT,\n    exports.METHODS.CONNECT,\n    exports.METHODS.OPTIONS,\n    exports.METHODS.TRACE,\n    exports.METHODS.COPY,\n    exports.METHODS.LOCK,\n    exports.METHODS.MKCOL,\n    exports.METHODS.MOVE,\n    exports.METHODS.PROPFIND,\n    exports.METHODS.PROPPATCH,\n    exports.METHODS.SEARCH,\n    exports.METHODS.UNLOCK,\n    exports.METHODS.BIND,\n    exports.METHODS.REBIND,\n    exports.METHODS.UNBIND,\n    exports.METHODS.ACL,\n    exports.METHODS.REPORT,\n    exports.METHODS.MKACTIVITY,\n    exports.METHODS.CHECKOUT,\n    exports.METHODS.MERGE,\n    exports.METHODS['M-SEARCH'],\n    exports.METHODS.NOTIFY,\n    exports.METHODS.SUBSCRIBE,\n    exports.METHODS.UNSUBSCRIBE,\n    exports.METHODS.PATCH,\n    exports.METHODS.PURGE,\n    exports.METHODS.MKCALENDAR,\n    exports.METHODS.LINK,\n    exports.METHODS.UNLINK,\n    exports.METHODS.PRI,\n    // TODO(indutny): should we allow it with HTTP?\n    exports.METHODS.SOURCE,\n    exports.METHODS.QUERY,\n];\nexports.METHODS_ICE = [\n    exports.METHODS.SOURCE,\n];\nexports.METHODS_RTSP = [\n    exports.METHODS.OPTIONS,\n    exports.METHODS.DESCRIBE,\n    exports.METHODS.ANNOUNCE,\n    exports.METHODS.SETUP,\n    exports.METHODS.PLAY,\n    exports.METHODS.PAUSE,\n    exports.METHODS.TEARDOWN,\n    exports.METHODS.GET_PARAMETER,\n    exports.METHODS.SET_PARAMETER,\n    exports.METHODS.REDIRECT,\n    exports.METHODS.RECORD,\n    exports.METHODS.FLUSH,\n    // For AirPlay\n    exports.METHODS.GET,\n    exports.METHODS.POST,\n];\nexports.METHOD_MAP = (0, utils_1.enumToMap)(exports.METHODS);\nexports.H_METHOD_MAP = Object.fromEntries(Object.entries(exports.METHODS).filter(([k]) => k.startsWith('H')));\nexports.STATUSES_HTTP = [\n    exports.STATUSES.CONTINUE,\n    exports.STATUSES.SWITCHING_PROTOCOLS,\n    exports.STATUSES.PROCESSING,\n    exports.STATUSES.EARLY_HINTS,\n    exports.STATUSES.RESPONSE_IS_STALE,\n    exports.STATUSES.REVALIDATION_FAILED,\n    exports.STATUSES.DISCONNECTED_OPERATION,\n    exports.STATUSES.HEURISTIC_EXPIRATION,\n    exports.STATUSES.MISCELLANEOUS_WARNING,\n    exports.STATUSES.OK,\n    exports.STATUSES.CREATED,\n    exports.STATUSES.ACCEPTED,\n    exports.STATUSES.NON_AUTHORITATIVE_INFORMATION,\n    exports.STATUSES.NO_CONTENT,\n    exports.STATUSES.RESET_CONTENT,\n    exports.STATUSES.PARTIAL_CONTENT,\n    exports.STATUSES.MULTI_STATUS,\n    exports.STATUSES.ALREADY_REPORTED,\n    exports.STATUSES.TRANSFORMATION_APPLIED,\n    exports.STATUSES.IM_USED,\n    exports.STATUSES.MISCELLANEOUS_PERSISTENT_WARNING,\n    exports.STATUSES.MULTIPLE_CHOICES,\n    exports.STATUSES.MOVED_PERMANENTLY,\n    exports.STATUSES.FOUND,\n    exports.STATUSES.SEE_OTHER,\n    exports.STATUSES.NOT_MODIFIED,\n    exports.STATUSES.USE_PROXY,\n    exports.STATUSES.SWITCH_PROXY,\n    exports.STATUSES.TEMPORARY_REDIRECT,\n    exports.STATUSES.PERMANENT_REDIRECT,\n    exports.STATUSES.BAD_REQUEST,\n    exports.STATUSES.UNAUTHORIZED,\n    exports.STATUSES.PAYMENT_REQUIRED,\n    exports.STATUSES.FORBIDDEN,\n    exports.STATUSES.NOT_FOUND,\n    exports.STATUSES.METHOD_NOT_ALLOWED,\n    exports.STATUSES.NOT_ACCEPTABLE,\n    exports.STATUSES.PROXY_AUTHENTICATION_REQUIRED,\n    exports.STATUSES.REQUEST_TIMEOUT,\n    exports.STATUSES.CONFLICT,\n    exports.STATUSES.GONE,\n    exports.STATUSES.LENGTH_REQUIRED,\n    exports.STATUSES.PRECONDITION_FAILED,\n    exports.STATUSES.PAYLOAD_TOO_LARGE,\n    exports.STATUSES.URI_TOO_LONG,\n    exports.STATUSES.UNSUPPORTED_MEDIA_TYPE,\n    exports.STATUSES.RANGE_NOT_SATISFIABLE,\n    exports.STATUSES.EXPECTATION_FAILED,\n    exports.STATUSES.IM_A_TEAPOT,\n    exports.STATUSES.PAGE_EXPIRED,\n    exports.STATUSES.ENHANCE_YOUR_CALM,\n    exports.STATUSES.MISDIRECTED_REQUEST,\n    exports.STATUSES.UNPROCESSABLE_ENTITY,\n    exports.STATUSES.LOCKED,\n    exports.STATUSES.FAILED_DEPENDENCY,\n    exports.STATUSES.TOO_EARLY,\n    exports.STATUSES.UPGRADE_REQUIRED,\n    exports.STATUSES.PRECONDITION_REQUIRED,\n    exports.STATUSES.TOO_MANY_REQUESTS,\n    exports.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL,\n    exports.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE,\n    exports.STATUSES.LOGIN_TIMEOUT,\n    exports.STATUSES.NO_RESPONSE,\n    exports.STATUSES.RETRY_WITH,\n    exports.STATUSES.BLOCKED_BY_PARENTAL_CONTROL,\n    exports.STATUSES.UNAVAILABLE_FOR_LEGAL_REASONS,\n    exports.STATUSES.CLIENT_CLOSED_LOAD_BALANCED_REQUEST,\n    exports.STATUSES.INVALID_X_FORWARDED_FOR,\n    exports.STATUSES.REQUEST_HEADER_TOO_LARGE,\n    exports.STATUSES.SSL_CERTIFICATE_ERROR,\n    exports.STATUSES.SSL_CERTIFICATE_REQUIRED,\n    exports.STATUSES.HTTP_REQUEST_SENT_TO_HTTPS_PORT,\n    exports.STATUSES.INVALID_TOKEN,\n    exports.STATUSES.CLIENT_CLOSED_REQUEST,\n    exports.STATUSES.INTERNAL_SERVER_ERROR,\n    exports.STATUSES.NOT_IMPLEMENTED,\n    exports.STATUSES.BAD_GATEWAY,\n    exports.STATUSES.SERVICE_UNAVAILABLE,\n    exports.STATUSES.GATEWAY_TIMEOUT,\n    exports.STATUSES.HTTP_VERSION_NOT_SUPPORTED,\n    exports.STATUSES.VARIANT_ALSO_NEGOTIATES,\n    exports.STATUSES.INSUFFICIENT_STORAGE,\n    exports.STATUSES.LOOP_DETECTED,\n    exports.STATUSES.BANDWIDTH_LIMIT_EXCEEDED,\n    exports.STATUSES.NOT_EXTENDED,\n    exports.STATUSES.NETWORK_AUTHENTICATION_REQUIRED,\n    exports.STATUSES.WEB_SERVER_UNKNOWN_ERROR,\n    exports.STATUSES.WEB_SERVER_IS_DOWN,\n    exports.STATUSES.CONNECTION_TIMEOUT,\n    exports.STATUSES.ORIGIN_IS_UNREACHABLE,\n    exports.STATUSES.TIMEOUT_OCCURED,\n    exports.STATUSES.SSL_HANDSHAKE_FAILED,\n    exports.STATUSES.INVALID_SSL_CERTIFICATE,\n    exports.STATUSES.RAILGUN_ERROR,\n    exports.STATUSES.SITE_IS_OVERLOADED,\n    exports.STATUSES.SITE_IS_FROZEN,\n    exports.STATUSES.IDENTITY_PROVIDER_AUTHENTICATION_ERROR,\n    exports.STATUSES.NETWORK_READ_TIMEOUT,\n    exports.STATUSES.NETWORK_CONNECT_TIMEOUT,\n];\nexports.ALPHA = [];\nfor (let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++) {\n    // Upper case\n    exports.ALPHA.push(String.fromCharCode(i));\n    // Lower case\n    exports.ALPHA.push(String.fromCharCode(i + 0x20));\n}\nexports.NUM_MAP = {\n    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,\n    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,\n};\nexports.HEX_MAP = {\n    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,\n    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,\n    A: 0XA, B: 0XB, C: 0XC, D: 0XD, E: 0XE, F: 0XF,\n    a: 0xa, b: 0xb, c: 0xc, d: 0xd, e: 0xe, f: 0xf,\n};\nexports.NUM = [\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n];\nexports.ALPHANUM = exports.ALPHA.concat(exports.NUM);\nexports.MARK = ['-', '_', '.', '!', '~', '*', '\\'', '(', ')'];\nexports.USERINFO_CHARS = exports.ALPHANUM\n    .concat(exports.MARK)\n    .concat(['%', ';', ':', '&', '=', '+', '$', ',']);\n// TODO(indutny): use RFC\nexports.URL_CHAR = [\n    '!', '\"', '$', '%', '&', '\\'',\n    '(', ')', '*', '+', ',', '-', '.', '/',\n    ':', ';', '<', '=', '>',\n    '@', '[', '\\\\', ']', '^', '_',\n    '`',\n    '{', '|', '}', '~',\n].concat(exports.ALPHANUM);\nexports.HEX = exports.NUM.concat(['a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F']);\n/* Tokens as defined by rfc 2616. Also lowercases them.\n *        token       = 1*<any CHAR except CTLs or separators>\n *     separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n *                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *                    | \"{\" | \"}\" | SP | HT\n */\nexports.TOKEN = [\n    '!', '#', '$', '%', '&', '\\'',\n    '*', '+', '-', '.',\n    '^', '_', '`',\n    '|', '~',\n].concat(exports.ALPHANUM);\n/*\n * Verify that a char is a valid visible (printable) US-ASCII\n * character or %x80-FF\n */\nexports.HEADER_CHARS = ['\\t'];\nfor (let i = 32; i <= 255; i++) {\n    if (i !== 127) {\n        exports.HEADER_CHARS.push(i);\n    }\n}\n// ',' = \\x44\nexports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);\nexports.QUOTED_STRING = ['\\t', ' '];\nfor (let i = 0x21; i <= 0xff; i++) {\n    if (i !== 0x22 && i !== 0x5c) { // All characters in ASCII except \\ and \"\n        exports.QUOTED_STRING.push(i);\n    }\n}\nexports.HTAB_SP_VCHAR_OBS_TEXT = ['\\t', ' '];\n// VCHAR: https://tools.ietf.org/html/rfc5234#appendix-B.1\nfor (let i = 0x21; i <= 0x7E; i++) {\n    exports.HTAB_SP_VCHAR_OBS_TEXT.push(i);\n}\n// OBS_TEXT: https://datatracker.ietf.org/doc/html/rfc9110#name-collected-abnf\nfor (let i = 0x80; i <= 0xff; i++) {\n    exports.HTAB_SP_VCHAR_OBS_TEXT.push(i);\n}\nexports.MAJOR = exports.NUM_MAP;\nexports.MINOR = exports.MAJOR;\nexports.SPECIAL_HEADERS = {\n    'connection': exports.HEADER_STATE.CONNECTION,\n    'content-length': exports.HEADER_STATE.CONTENT_LENGTH,\n    'proxy-connection': exports.HEADER_STATE.CONNECTION,\n    'transfer-encoding': exports.HEADER_STATE.TRANSFER_ENCODING,\n    'upgrade': exports.HEADER_STATE.UPGRADE,\n};\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsOEJBQThCLEdBQUcscUJBQXFCLEdBQUcsOEJBQThCLEdBQUcsb0JBQW9CLEdBQUcsYUFBYSxHQUFHLFdBQVcsR0FBRyxnQkFBZ0IsR0FBRyxzQkFBc0IsR0FBRyxZQUFZLEdBQUcsZ0JBQWdCLEdBQUcsV0FBVyxHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcsYUFBYSxHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcscUJBQXFCLEdBQUcsYUFBYSxHQUFHLFlBQVksR0FBRyxhQUFhO0FBQ2xuQixnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBUztBQUNqQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLHNCQUFzQjtBQUN0QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNLFVBQVU7QUFDaEI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIscUJBQXFCO0FBQ3JCLG1CQUFtQixXQUFXO0FBQzlCLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU1BFQ0lBTF9IRUFERVJTID0gZXhwb3J0cy5NSU5PUiA9IGV4cG9ydHMuTUFKT1IgPSBleHBvcnRzLkhUQUJfU1BfVkNIQVJfT0JTX1RFWFQgPSBleHBvcnRzLlFVT1RFRF9TVFJJTkcgPSBleHBvcnRzLkNPTk5FQ1RJT05fVE9LRU5fQ0hBUlMgPSBleHBvcnRzLkhFQURFUl9DSEFSUyA9IGV4cG9ydHMuVE9LRU4gPSBleHBvcnRzLkhFWCA9IGV4cG9ydHMuVVJMX0NIQVIgPSBleHBvcnRzLlVTRVJJTkZPX0NIQVJTID0gZXhwb3J0cy5NQVJLID0gZXhwb3J0cy5BTFBIQU5VTSA9IGV4cG9ydHMuTlVNID0gZXhwb3J0cy5IRVhfTUFQID0gZXhwb3J0cy5OVU1fTUFQID0gZXhwb3J0cy5BTFBIQSA9IGV4cG9ydHMuU1RBVFVTRVNfSFRUUCA9IGV4cG9ydHMuSF9NRVRIT0RfTUFQID0gZXhwb3J0cy5NRVRIT0RfTUFQID0gZXhwb3J0cy5NRVRIT0RTX1JUU1AgPSBleHBvcnRzLk1FVEhPRFNfSUNFID0gZXhwb3J0cy5NRVRIT0RTX0hUVFAgPSBleHBvcnRzLkhFQURFUl9TVEFURSA9IGV4cG9ydHMuRklOSVNIID0gZXhwb3J0cy5TVEFUVVNFUyA9IGV4cG9ydHMuTUVUSE9EUyA9IGV4cG9ydHMuTEVOSUVOVF9GTEFHUyA9IGV4cG9ydHMuRkxBR1MgPSBleHBvcnRzLlRZUEUgPSBleHBvcnRzLkVSUk9SID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLy8gRW11bXNcbmV4cG9ydHMuRVJST1IgPSB7XG4gICAgT0s6IDAsXG4gICAgSU5URVJOQUw6IDEsXG4gICAgU1RSSUNUOiAyLFxuICAgIENSX0VYUEVDVEVEOiAyNSxcbiAgICBMRl9FWFBFQ1RFRDogMyxcbiAgICBVTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIOiA0LFxuICAgIFVORVhQRUNURURfU1BBQ0U6IDMwLFxuICAgIENMT1NFRF9DT05ORUNUSU9OOiA1LFxuICAgIElOVkFMSURfTUVUSE9EOiA2LFxuICAgIElOVkFMSURfVVJMOiA3LFxuICAgIElOVkFMSURfQ09OU1RBTlQ6IDgsXG4gICAgSU5WQUxJRF9WRVJTSU9OOiA5LFxuICAgIElOVkFMSURfSEVBREVSX1RPS0VOOiAxMCxcbiAgICBJTlZBTElEX0NPTlRFTlRfTEVOR1RIOiAxMSxcbiAgICBJTlZBTElEX0NIVU5LX1NJWkU6IDEyLFxuICAgIElOVkFMSURfU1RBVFVTOiAxMyxcbiAgICBJTlZBTElEX0VPRl9TVEFURTogMTQsXG4gICAgSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORzogMTUsXG4gICAgQ0JfTUVTU0FHRV9CRUdJTjogMTYsXG4gICAgQ0JfSEVBREVSU19DT01QTEVURTogMTcsXG4gICAgQ0JfTUVTU0FHRV9DT01QTEVURTogMTgsXG4gICAgQ0JfQ0hVTktfSEVBREVSOiAxOSxcbiAgICBDQl9DSFVOS19DT01QTEVURTogMjAsXG4gICAgUEFVU0VEOiAyMSxcbiAgICBQQVVTRURfVVBHUkFERTogMjIsXG4gICAgUEFVU0VEX0gyX1VQR1JBREU6IDIzLFxuICAgIFVTRVI6IDI0LFxuICAgIENCX1VSTF9DT01QTEVURTogMjYsXG4gICAgQ0JfU1RBVFVTX0NPTVBMRVRFOiAyNyxcbiAgICBDQl9NRVRIT0RfQ09NUExFVEU6IDMyLFxuICAgIENCX1ZFUlNJT05fQ09NUExFVEU6IDMzLFxuICAgIENCX0hFQURFUl9GSUVMRF9DT01QTEVURTogMjgsXG4gICAgQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFOiAyOSxcbiAgICBDQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURTogMzQsXG4gICAgQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFOiAzNSxcbiAgICBDQl9SRVNFVDogMzEsXG59O1xuZXhwb3J0cy5UWVBFID0ge1xuICAgIEJPVEg6IDAsIC8vIGRlZmF1bHRcbiAgICBSRVFVRVNUOiAxLFxuICAgIFJFU1BPTlNFOiAyLFxufTtcbmV4cG9ydHMuRkxBR1MgPSB7XG4gICAgQ09OTkVDVElPTl9LRUVQX0FMSVZFOiAxIDw8IDAsXG4gICAgQ09OTkVDVElPTl9DTE9TRTogMSA8PCAxLFxuICAgIENPTk5FQ1RJT05fVVBHUkFERTogMSA8PCAyLFxuICAgIENIVU5LRUQ6IDEgPDwgMyxcbiAgICBVUEdSQURFOiAxIDw8IDQsXG4gICAgQ09OVEVOVF9MRU5HVEg6IDEgPDwgNSxcbiAgICBTS0lQQk9EWTogMSA8PCA2LFxuICAgIFRSQUlMSU5HOiAxIDw8IDcsXG4gICAgLy8gMSA8PCA4IGlzIHVudXNlZFxuICAgIFRSQU5TRkVSX0VOQ09ESU5HOiAxIDw8IDksXG59O1xuZXhwb3J0cy5MRU5JRU5UX0ZMQUdTID0ge1xuICAgIEhFQURFUlM6IDEgPDwgMCxcbiAgICBDSFVOS0VEX0xFTkdUSDogMSA8PCAxLFxuICAgIEtFRVBfQUxJVkU6IDEgPDwgMixcbiAgICBUUkFOU0ZFUl9FTkNPRElORzogMSA8PCAzLFxuICAgIFZFUlNJT046IDEgPDwgNCxcbiAgICBEQVRBX0FGVEVSX0NMT1NFOiAxIDw8IDUsXG4gICAgT1BUSU9OQUxfTEZfQUZURVJfQ1I6IDEgPDwgNixcbiAgICBPUFRJT05BTF9DUkxGX0FGVEVSX0NIVU5LOiAxIDw8IDcsXG4gICAgT1BUSU9OQUxfQ1JfQkVGT1JFX0xGOiAxIDw8IDgsXG4gICAgU1BBQ0VTX0FGVEVSX0NIVU5LX1NJWkU6IDEgPDwgOSxcbn07XG5leHBvcnRzLk1FVEhPRFMgPSB7XG4gICAgJ0RFTEVURSc6IDAsXG4gICAgJ0dFVCc6IDEsXG4gICAgJ0hFQUQnOiAyLFxuICAgICdQT1NUJzogMyxcbiAgICAnUFVUJzogNCxcbiAgICAvKiBwYXRob2xvZ2ljYWwgKi9cbiAgICAnQ09OTkVDVCc6IDUsXG4gICAgJ09QVElPTlMnOiA2LFxuICAgICdUUkFDRSc6IDcsXG4gICAgLyogV2ViREFWICovXG4gICAgJ0NPUFknOiA4LFxuICAgICdMT0NLJzogOSxcbiAgICAnTUtDT0wnOiAxMCxcbiAgICAnTU9WRSc6IDExLFxuICAgICdQUk9QRklORCc6IDEyLFxuICAgICdQUk9QUEFUQ0gnOiAxMyxcbiAgICAnU0VBUkNIJzogMTQsXG4gICAgJ1VOTE9DSyc6IDE1LFxuICAgICdCSU5EJzogMTYsXG4gICAgJ1JFQklORCc6IDE3LFxuICAgICdVTkJJTkQnOiAxOCxcbiAgICAnQUNMJzogMTksXG4gICAgLyogc3VidmVyc2lvbiAqL1xuICAgICdSRVBPUlQnOiAyMCxcbiAgICAnTUtBQ1RJVklUWSc6IDIxLFxuICAgICdDSEVDS09VVCc6IDIyLFxuICAgICdNRVJHRSc6IDIzLFxuICAgIC8qIHVwbnAgKi9cbiAgICAnTS1TRUFSQ0gnOiAyNCxcbiAgICAnTk9USUZZJzogMjUsXG4gICAgJ1NVQlNDUklCRSc6IDI2LFxuICAgICdVTlNVQlNDUklCRSc6IDI3LFxuICAgIC8qIFJGQy01Nzg5ICovXG4gICAgJ1BBVENIJzogMjgsXG4gICAgJ1BVUkdFJzogMjksXG4gICAgLyogQ2FsREFWICovXG4gICAgJ01LQ0FMRU5EQVInOiAzMCxcbiAgICAvKiBSRkMtMjA2OCwgc2VjdGlvbiAxOS42LjEuMiAqL1xuICAgICdMSU5LJzogMzEsXG4gICAgJ1VOTElOSyc6IDMyLFxuICAgIC8qIGljZWNhc3QgKi9cbiAgICAnU09VUkNFJzogMzMsXG4gICAgLyogUkZDLTc1NDAsIHNlY3Rpb24gMTEuNiAqL1xuICAgICdQUkknOiAzNCxcbiAgICAvKiBSRkMtMjMyNiBSVFNQICovXG4gICAgJ0RFU0NSSUJFJzogMzUsXG4gICAgJ0FOTk9VTkNFJzogMzYsXG4gICAgJ1NFVFVQJzogMzcsXG4gICAgJ1BMQVknOiAzOCxcbiAgICAnUEFVU0UnOiAzOSxcbiAgICAnVEVBUkRPV04nOiA0MCxcbiAgICAnR0VUX1BBUkFNRVRFUic6IDQxLFxuICAgICdTRVRfUEFSQU1FVEVSJzogNDIsXG4gICAgJ1JFRElSRUNUJzogNDMsXG4gICAgJ1JFQ09SRCc6IDQ0LFxuICAgIC8qIFJBT1AgKi9cbiAgICAnRkxVU0gnOiA0NSxcbiAgICAvKiBEUkFGVCBodHRwczovL3d3dy5pZXRmLm9yZy9hcmNoaXZlL2lkL2RyYWZ0LWlldGYtaHR0cGJpcy1zYWZlLW1ldGhvZC13LWJvZHktMDIuaHRtbCAqL1xuICAgICdRVUVSWSc6IDQ2LFxufTtcbmV4cG9ydHMuU1RBVFVTRVMgPSB7XG4gICAgQ09OVElOVUU6IDEwMCxcbiAgICBTV0lUQ0hJTkdfUFJPVE9DT0xTOiAxMDEsXG4gICAgUFJPQ0VTU0lORzogMTAyLFxuICAgIEVBUkxZX0hJTlRTOiAxMDMsXG4gICAgUkVTUE9OU0VfSVNfU1RBTEU6IDExMCwgLy8gVW5vZmZpY2lhbFxuICAgIFJFVkFMSURBVElPTl9GQUlMRUQ6IDExMSwgLy8gVW5vZmZpY2lhbFxuICAgIERJU0NPTk5FQ1RFRF9PUEVSQVRJT046IDExMiwgLy8gVW5vZmZpY2lhbFxuICAgIEhFVVJJU1RJQ19FWFBJUkFUSU9OOiAxMTMsIC8vIFVub2ZmaWNpYWxcbiAgICBNSVNDRUxMQU5FT1VTX1dBUk5JTkc6IDE5OSwgLy8gVW5vZmZpY2lhbFxuICAgIE9LOiAyMDAsXG4gICAgQ1JFQVRFRDogMjAxLFxuICAgIEFDQ0VQVEVEOiAyMDIsXG4gICAgTk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT046IDIwMyxcbiAgICBOT19DT05URU5UOiAyMDQsXG4gICAgUkVTRVRfQ09OVEVOVDogMjA1LFxuICAgIFBBUlRJQUxfQ09OVEVOVDogMjA2LFxuICAgIE1VTFRJX1NUQVRVUzogMjA3LFxuICAgIEFMUkVBRFlfUkVQT1JURUQ6IDIwOCxcbiAgICBUUkFOU0ZPUk1BVElPTl9BUFBMSUVEOiAyMTQsIC8vIFVub2ZmaWNpYWxcbiAgICBJTV9VU0VEOiAyMjYsXG4gICAgTUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkc6IDI5OSwgLy8gVW5vZmZpY2lhbFxuICAgIE1VTFRJUExFX0NIT0lDRVM6IDMwMCxcbiAgICBNT1ZFRF9QRVJNQU5FTlRMWTogMzAxLFxuICAgIEZPVU5EOiAzMDIsXG4gICAgU0VFX09USEVSOiAzMDMsXG4gICAgTk9UX01PRElGSUVEOiAzMDQsXG4gICAgVVNFX1BST1hZOiAzMDUsXG4gICAgU1dJVENIX1BST1hZOiAzMDYsIC8vIE5vIGxvbmdlciB1c2VkXG4gICAgVEVNUE9SQVJZX1JFRElSRUNUOiAzMDcsXG4gICAgUEVSTUFORU5UX1JFRElSRUNUOiAzMDgsXG4gICAgQkFEX1JFUVVFU1Q6IDQwMCxcbiAgICBVTkFVVEhPUklaRUQ6IDQwMSxcbiAgICBQQVlNRU5UX1JFUVVJUkVEOiA0MDIsXG4gICAgRk9SQklEREVOOiA0MDMsXG4gICAgTk9UX0ZPVU5EOiA0MDQsXG4gICAgTUVUSE9EX05PVF9BTExPV0VEOiA0MDUsXG4gICAgTk9UX0FDQ0VQVEFCTEU6IDQwNixcbiAgICBQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRDogNDA3LFxuICAgIFJFUVVFU1RfVElNRU9VVDogNDA4LFxuICAgIENPTkZMSUNUOiA0MDksXG4gICAgR09ORTogNDEwLFxuICAgIExFTkdUSF9SRVFVSVJFRDogNDExLFxuICAgIFBSRUNPTkRJVElPTl9GQUlMRUQ6IDQxMixcbiAgICBQQVlMT0FEX1RPT19MQVJHRTogNDEzLFxuICAgIFVSSV9UT09fTE9ORzogNDE0LFxuICAgIFVOU1VQUE9SVEVEX01FRElBX1RZUEU6IDQxNSxcbiAgICBSQU5HRV9OT1RfU0FUSVNGSUFCTEU6IDQxNixcbiAgICBFWFBFQ1RBVElPTl9GQUlMRUQ6IDQxNyxcbiAgICBJTV9BX1RFQVBPVDogNDE4LFxuICAgIFBBR0VfRVhQSVJFRDogNDE5LCAvLyBVbm9mZmljaWFsXG4gICAgRU5IQU5DRV9ZT1VSX0NBTE06IDQyMCwgLy8gVW5vZmZpY2lhbFxuICAgIE1JU0RJUkVDVEVEX1JFUVVFU1Q6IDQyMSxcbiAgICBVTlBST0NFU1NBQkxFX0VOVElUWTogNDIyLFxuICAgIExPQ0tFRDogNDIzLFxuICAgIEZBSUxFRF9ERVBFTkRFTkNZOiA0MjQsXG4gICAgVE9PX0VBUkxZOiA0MjUsXG4gICAgVVBHUkFERV9SRVFVSVJFRDogNDI2LFxuICAgIFBSRUNPTkRJVElPTl9SRVFVSVJFRDogNDI4LFxuICAgIFRPT19NQU5ZX1JFUVVFU1RTOiA0MjksXG4gICAgUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMOiA0MzAsIC8vIFVub2ZmaWNpYWxcbiAgICBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFOiA0MzEsXG4gICAgTE9HSU5fVElNRU9VVDogNDQwLCAvLyBVbm9mZmljaWFsXG4gICAgTk9fUkVTUE9OU0U6IDQ0NCwgLy8gVW5vZmZpY2lhbFxuICAgIFJFVFJZX1dJVEg6IDQ0OSwgLy8gVW5vZmZpY2lhbFxuICAgIEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTDogNDUwLCAvLyBVbm9mZmljaWFsXG4gICAgVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlM6IDQ1MSxcbiAgICBDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVDogNDYwLCAvLyBVbm9mZmljaWFsXG4gICAgSU5WQUxJRF9YX0ZPUldBUkRFRF9GT1I6IDQ2MywgLy8gVW5vZmZpY2lhbFxuICAgIFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRTogNDk0LCAvLyBVbm9mZmljaWFsXG4gICAgU1NMX0NFUlRJRklDQVRFX0VSUk9SOiA0OTUsIC8vIFVub2ZmaWNpYWxcbiAgICBTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQ6IDQ5NiwgLy8gVW5vZmZpY2lhbFxuICAgIEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQ6IDQ5NywgLy8gVW5vZmZpY2lhbFxuICAgIElOVkFMSURfVE9LRU46IDQ5OCwgLy8gVW5vZmZpY2lhbFxuICAgIENMSUVOVF9DTE9TRURfUkVRVUVTVDogNDk5LCAvLyBVbm9mZmljaWFsXG4gICAgSU5URVJOQUxfU0VSVkVSX0VSUk9SOiA1MDAsXG4gICAgTk9UX0lNUExFTUVOVEVEOiA1MDEsXG4gICAgQkFEX0dBVEVXQVk6IDUwMixcbiAgICBTRVJWSUNFX1VOQVZBSUxBQkxFOiA1MDMsXG4gICAgR0FURVdBWV9USU1FT1VUOiA1MDQsXG4gICAgSFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQ6IDUwNSxcbiAgICBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUzogNTA2LFxuICAgIElOU1VGRklDSUVOVF9TVE9SQUdFOiA1MDcsXG4gICAgTE9PUF9ERVRFQ1RFRDogNTA4LFxuICAgIEJBTkRXSURUSF9MSU1JVF9FWENFRURFRDogNTA5LFxuICAgIE5PVF9FWFRFTkRFRDogNTEwLFxuICAgIE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQ6IDUxMSxcbiAgICBXRUJfU0VSVkVSX1VOS05PV05fRVJST1I6IDUyMCwgLy8gVW5vZmZpY2lhbFxuICAgIFdFQl9TRVJWRVJfSVNfRE9XTjogNTIxLCAvLyBVbm9mZmljaWFsXG4gICAgQ09OTkVDVElPTl9USU1FT1VUOiA1MjIsIC8vIFVub2ZmaWNpYWxcbiAgICBPUklHSU5fSVNfVU5SRUFDSEFCTEU6IDUyMywgLy8gVW5vZmZpY2lhbFxuICAgIFRJTUVPVVRfT0NDVVJFRDogNTI0LCAvLyBVbm9mZmljaWFsXG4gICAgU1NMX0hBTkRTSEFLRV9GQUlMRUQ6IDUyNSwgLy8gVW5vZmZpY2lhbFxuICAgIElOVkFMSURfU1NMX0NFUlRJRklDQVRFOiA1MjYsIC8vIFVub2ZmaWNpYWxcbiAgICBSQUlMR1VOX0VSUk9SOiA1MjcsIC8vIFVub2ZmaWNpYWxcbiAgICBTSVRFX0lTX09WRVJMT0FERUQ6IDUyOSwgLy8gVW5vZmZpY2lhbFxuICAgIFNJVEVfSVNfRlJPWkVOOiA1MzAsIC8vIFVub2ZmaWNpYWxcbiAgICBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUjogNTYxLCAvLyBVbm9mZmljaWFsXG4gICAgTkVUV09SS19SRUFEX1RJTUVPVVQ6IDU5OCwgLy8gVW5vZmZpY2lhbFxuICAgIE5FVFdPUktfQ09OTkVDVF9USU1FT1VUOiA1OTksIC8vIFVub2ZmaWNpYWxcbn07XG5leHBvcnRzLkZJTklTSCA9IHtcbiAgICBTQUZFOiAwLFxuICAgIFNBRkVfV0lUSF9DQjogMSxcbiAgICBVTlNBRkU6IDIsXG59O1xuZXhwb3J0cy5IRUFERVJfU1RBVEUgPSB7XG4gICAgR0VORVJBTDogMCxcbiAgICBDT05ORUNUSU9OOiAxLFxuICAgIENPTlRFTlRfTEVOR1RIOiAyLFxuICAgIFRSQU5TRkVSX0VOQ09ESU5HOiAzLFxuICAgIFVQR1JBREU6IDQsXG4gICAgQ09OTkVDVElPTl9LRUVQX0FMSVZFOiA1LFxuICAgIENPTk5FQ1RJT05fQ0xPU0U6IDYsXG4gICAgQ09OTkVDVElPTl9VUEdSQURFOiA3LFxuICAgIFRSQU5TRkVSX0VOQ09ESU5HX0NIVU5LRUQ6IDgsXG59O1xuLy8gQyBoZWFkZXJzXG5leHBvcnRzLk1FVEhPRFNfSFRUUCA9IFtcbiAgICBleHBvcnRzLk1FVEhPRFMuREVMRVRFLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5HRVQsXG4gICAgZXhwb3J0cy5NRVRIT0RTLkhFQUQsXG4gICAgZXhwb3J0cy5NRVRIT0RTLlBPU1QsXG4gICAgZXhwb3J0cy5NRVRIT0RTLlBVVCxcbiAgICBleHBvcnRzLk1FVEhPRFMuQ09OTkVDVCxcbiAgICBleHBvcnRzLk1FVEhPRFMuT1BUSU9OUyxcbiAgICBleHBvcnRzLk1FVEhPRFMuVFJBQ0UsXG4gICAgZXhwb3J0cy5NRVRIT0RTLkNPUFksXG4gICAgZXhwb3J0cy5NRVRIT0RTLkxPQ0ssXG4gICAgZXhwb3J0cy5NRVRIT0RTLk1LQ09MLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5NT1ZFLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5QUk9QRklORCxcbiAgICBleHBvcnRzLk1FVEhPRFMuUFJPUFBBVENILFxuICAgIGV4cG9ydHMuTUVUSE9EUy5TRUFSQ0gsXG4gICAgZXhwb3J0cy5NRVRIT0RTLlVOTE9DSyxcbiAgICBleHBvcnRzLk1FVEhPRFMuQklORCxcbiAgICBleHBvcnRzLk1FVEhPRFMuUkVCSU5ELFxuICAgIGV4cG9ydHMuTUVUSE9EUy5VTkJJTkQsXG4gICAgZXhwb3J0cy5NRVRIT0RTLkFDTCxcbiAgICBleHBvcnRzLk1FVEhPRFMuUkVQT1JULFxuICAgIGV4cG9ydHMuTUVUSE9EUy5NS0FDVElWSVRZLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5DSEVDS09VVCxcbiAgICBleHBvcnRzLk1FVEhPRFMuTUVSR0UsXG4gICAgZXhwb3J0cy5NRVRIT0RTWydNLVNFQVJDSCddLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5OT1RJRlksXG4gICAgZXhwb3J0cy5NRVRIT0RTLlNVQlNDUklCRSxcbiAgICBleHBvcnRzLk1FVEhPRFMuVU5TVUJTQ1JJQkUsXG4gICAgZXhwb3J0cy5NRVRIT0RTLlBBVENILFxuICAgIGV4cG9ydHMuTUVUSE9EUy5QVVJHRSxcbiAgICBleHBvcnRzLk1FVEhPRFMuTUtDQUxFTkRBUixcbiAgICBleHBvcnRzLk1FVEhPRFMuTElOSyxcbiAgICBleHBvcnRzLk1FVEhPRFMuVU5MSU5LLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5QUkksXG4gICAgLy8gVE9ETyhpbmR1dG55KTogc2hvdWxkIHdlIGFsbG93IGl0IHdpdGggSFRUUD9cbiAgICBleHBvcnRzLk1FVEhPRFMuU09VUkNFLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5RVUVSWSxcbl07XG5leHBvcnRzLk1FVEhPRFNfSUNFID0gW1xuICAgIGV4cG9ydHMuTUVUSE9EUy5TT1VSQ0UsXG5dO1xuZXhwb3J0cy5NRVRIT0RTX1JUU1AgPSBbXG4gICAgZXhwb3J0cy5NRVRIT0RTLk9QVElPTlMsXG4gICAgZXhwb3J0cy5NRVRIT0RTLkRFU0NSSUJFLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5BTk5PVU5DRSxcbiAgICBleHBvcnRzLk1FVEhPRFMuU0VUVVAsXG4gICAgZXhwb3J0cy5NRVRIT0RTLlBMQVksXG4gICAgZXhwb3J0cy5NRVRIT0RTLlBBVVNFLFxuICAgIGV4cG9ydHMuTUVUSE9EUy5URUFSRE9XTixcbiAgICBleHBvcnRzLk1FVEhPRFMuR0VUX1BBUkFNRVRFUixcbiAgICBleHBvcnRzLk1FVEhPRFMuU0VUX1BBUkFNRVRFUixcbiAgICBleHBvcnRzLk1FVEhPRFMuUkVESVJFQ1QsXG4gICAgZXhwb3J0cy5NRVRIT0RTLlJFQ09SRCxcbiAgICBleHBvcnRzLk1FVEhPRFMuRkxVU0gsXG4gICAgLy8gRm9yIEFpclBsYXlcbiAgICBleHBvcnRzLk1FVEhPRFMuR0VULFxuICAgIGV4cG9ydHMuTUVUSE9EUy5QT1NULFxuXTtcbmV4cG9ydHMuTUVUSE9EX01BUCA9ICgwLCB1dGlsc18xLmVudW1Ub01hcCkoZXhwb3J0cy5NRVRIT0RTKTtcbmV4cG9ydHMuSF9NRVRIT0RfTUFQID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGV4cG9ydHMuTUVUSE9EUykuZmlsdGVyKChba10pID0+IGsuc3RhcnRzV2l0aCgnSCcpKSk7XG5leHBvcnRzLlNUQVRVU0VTX0hUVFAgPSBbXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5DT05USU5VRSxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlNXSVRDSElOR19QUk9UT0NPTFMsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5QUk9DRVNTSU5HLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuRUFSTFlfSElOVFMsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5SRVNQT05TRV9JU19TVEFMRSxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlJFVkFMSURBVElPTl9GQUlMRUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5ESVNDT05ORUNURURfT1BFUkFUSU9OLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuSEVVUklTVElDX0VYUElSQVRJT04sXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5NSVNDRUxMQU5FT1VTX1dBUk5JTkcsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5PSyxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkNSRUFURUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5BQ0NFUFRFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLk5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuTk9fQ09OVEVOVCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlJFU0VUX0NPTlRFTlQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5QQVJUSUFMX0NPTlRFTlQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5NVUxUSV9TVEFUVVMsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5BTFJFQURZX1JFUE9SVEVELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuVFJBTlNGT1JNQVRJT05fQVBQTElFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLklNX1VTRUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5NSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORyxcbiAgICBleHBvcnRzLlNUQVRVU0VTLk1VTFRJUExFX0NIT0lDRVMsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5NT1ZFRF9QRVJNQU5FTlRMWSxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkZPVU5ELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuU0VFX09USEVSLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuTk9UX01PRElGSUVELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuVVNFX1BST1hZLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuU1dJVENIX1BST1hZLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuVEVNUE9SQVJZX1JFRElSRUNULFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuUEVSTUFORU5UX1JFRElSRUNULFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuQkFEX1JFUVVFU1QsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5VTkFVVEhPUklaRUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5QQVlNRU5UX1JFUVVJUkVELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuRk9SQklEREVOLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuTk9UX0ZPVU5ELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuTUVUSE9EX05PVF9BTExPV0VELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuTk9UX0FDQ0VQVEFCTEUsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5QUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlJFUVVFU1RfVElNRU9VVCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkNPTkZMSUNULFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuR09ORSxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkxFTkdUSF9SRVFVSVJFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlBSRUNPTkRJVElPTl9GQUlMRUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5QQVlMT0FEX1RPT19MQVJHRSxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlVSSV9UT09fTE9ORyxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlVOU1VQUE9SVEVEX01FRElBX1RZUEUsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5SQU5HRV9OT1RfU0FUSVNGSUFCTEUsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5FWFBFQ1RBVElPTl9GQUlMRUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5JTV9BX1RFQVBPVCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlBBR0VfRVhQSVJFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkVOSEFOQ0VfWU9VUl9DQUxNLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuTUlTRElSRUNURURfUkVRVUVTVCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlVOUFJPQ0VTU0FCTEVfRU5USVRZLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuTE9DS0VELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuRkFJTEVEX0RFUEVOREVOQ1ksXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5UT09fRUFSTFksXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5VUEdSQURFX1JFUVVJUkVELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuUFJFQ09ORElUSU9OX1JFUVVJUkVELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuVE9PX01BTllfUkVRVUVTVFMsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5SRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5SRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuTE9HSU5fVElNRU9VVCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLk5PX1JFU1BPTlNFLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuUkVUUllfV0lUSCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5JTlZBTElEX1hfRk9SV0FSREVEX0ZPUixcbiAgICBleHBvcnRzLlNUQVRVU0VTLlJFUVVFU1RfSEVBREVSX1RPT19MQVJHRSxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlNTTF9DRVJUSUZJQ0FURV9FUlJPUixcbiAgICBleHBvcnRzLlNUQVRVU0VTLlNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5JTlZBTElEX1RPS0VOLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuQ0xJRU5UX0NMT1NFRF9SRVFVRVNULFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuSU5URVJOQUxfU0VSVkVSX0VSUk9SLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuTk9UX0lNUExFTUVOVEVELFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuQkFEX0dBVEVXQVksXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5TRVJWSUNFX1VOQVZBSUxBQkxFLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuR0FURVdBWV9USU1FT1VULFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuSFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5WQVJJQU5UX0FMU09fTkVHT1RJQVRFUyxcbiAgICBleHBvcnRzLlNUQVRVU0VTLklOU1VGRklDSUVOVF9TVE9SQUdFLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuTE9PUF9ERVRFQ1RFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLkJBTkRXSURUSF9MSU1JVF9FWENFRURFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLk5PVF9FWFRFTkRFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLk5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5XRUJfU0VSVkVSX1VOS05PV05fRVJST1IsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5XRUJfU0VSVkVSX0lTX0RPV04sXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5DT05ORUNUSU9OX1RJTUVPVVQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5PUklHSU5fSVNfVU5SRUFDSEFCTEUsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5USU1FT1VUX09DQ1VSRUQsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5TU0xfSEFORFNIQUtFX0ZBSUxFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLklOVkFMSURfU1NMX0NFUlRJRklDQVRFLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuUkFJTEdVTl9FUlJPUixcbiAgICBleHBvcnRzLlNUQVRVU0VTLlNJVEVfSVNfT1ZFUkxPQURFRCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLlNJVEVfSVNfRlJPWkVOLFxuICAgIGV4cG9ydHMuU1RBVFVTRVMuSURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IsXG4gICAgZXhwb3J0cy5TVEFUVVNFUy5ORVRXT1JLX1JFQURfVElNRU9VVCxcbiAgICBleHBvcnRzLlNUQVRVU0VTLk5FVFdPUktfQ09OTkVDVF9USU1FT1VULFxuXTtcbmV4cG9ydHMuQUxQSEEgPSBbXTtcbmZvciAobGV0IGkgPSAnQScuY2hhckNvZGVBdCgwKTsgaSA8PSAnWicuY2hhckNvZGVBdCgwKTsgaSsrKSB7XG4gICAgLy8gVXBwZXIgY2FzZVxuICAgIGV4cG9ydHMuQUxQSEEucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpKTtcbiAgICAvLyBMb3dlciBjYXNlXG4gICAgZXhwb3J0cy5BTFBIQS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaSArIDB4MjApKTtcbn1cbmV4cG9ydHMuTlVNX01BUCA9IHtcbiAgICAwOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LFxuICAgIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksXG59O1xuZXhwb3J0cy5IRVhfTUFQID0ge1xuICAgIDA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsXG4gICAgNTogNSwgNjogNiwgNzogNywgODogOCwgOTogOSxcbiAgICBBOiAwWEEsIEI6IDBYQiwgQzogMFhDLCBEOiAwWEQsIEU6IDBYRSwgRjogMFhGLFxuICAgIGE6IDB4YSwgYjogMHhiLCBjOiAweGMsIGQ6IDB4ZCwgZTogMHhlLCBmOiAweGYsXG59O1xuZXhwb3J0cy5OVU0gPSBbXG4gICAgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLFxuXTtcbmV4cG9ydHMuQUxQSEFOVU0gPSBleHBvcnRzLkFMUEhBLmNvbmNhdChleHBvcnRzLk5VTSk7XG5leHBvcnRzLk1BUksgPSBbJy0nLCAnXycsICcuJywgJyEnLCAnficsICcqJywgJ1xcJycsICcoJywgJyknXTtcbmV4cG9ydHMuVVNFUklORk9fQ0hBUlMgPSBleHBvcnRzLkFMUEhBTlVNXG4gICAgLmNvbmNhdChleHBvcnRzLk1BUkspXG4gICAgLmNvbmNhdChbJyUnLCAnOycsICc6JywgJyYnLCAnPScsICcrJywgJyQnLCAnLCddKTtcbi8vIFRPRE8oaW5kdXRueSk6IHVzZSBSRkNcbmV4cG9ydHMuVVJMX0NIQVIgPSBbXG4gICAgJyEnLCAnXCInLCAnJCcsICclJywgJyYnLCAnXFwnJyxcbiAgICAnKCcsICcpJywgJyonLCAnKycsICcsJywgJy0nLCAnLicsICcvJyxcbiAgICAnOicsICc7JywgJzwnLCAnPScsICc+JyxcbiAgICAnQCcsICdbJywgJ1xcXFwnLCAnXScsICdeJywgJ18nLFxuICAgICdgJyxcbiAgICAneycsICd8JywgJ30nLCAnficsXG5dLmNvbmNhdChleHBvcnRzLkFMUEhBTlVNKTtcbmV4cG9ydHMuSEVYID0gZXhwb3J0cy5OVU0uY29uY2F0KFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnXSk7XG4vKiBUb2tlbnMgYXMgZGVmaW5lZCBieSByZmMgMjYxNi4gQWxzbyBsb3dlcmNhc2VzIHRoZW0uXG4gKiAgICAgICAgdG9rZW4gICAgICAgPSAxKjxhbnkgQ0hBUiBleGNlcHQgQ1RMcyBvciBzZXBhcmF0b3JzPlxuICogICAgIHNlcGFyYXRvcnMgICAgID0gXCIoXCIgfCBcIilcIiB8IFwiPFwiIHwgXCI+XCIgfCBcIkBcIlxuICogICAgICAgICAgICAgICAgICAgIHwgXCIsXCIgfCBcIjtcIiB8IFwiOlwiIHwgXCJcXFwiIHwgPFwiPlxuICogICAgICAgICAgICAgICAgICAgIHwgXCIvXCIgfCBcIltcIiB8IFwiXVwiIHwgXCI/XCIgfCBcIj1cIlxuICogICAgICAgICAgICAgICAgICAgIHwgXCJ7XCIgfCBcIn1cIiB8IFNQIHwgSFRcbiAqL1xuZXhwb3J0cy5UT0tFTiA9IFtcbiAgICAnIScsICcjJywgJyQnLCAnJScsICcmJywgJ1xcJycsXG4gICAgJyonLCAnKycsICctJywgJy4nLFxuICAgICdeJywgJ18nLCAnYCcsXG4gICAgJ3wnLCAnficsXG5dLmNvbmNhdChleHBvcnRzLkFMUEhBTlVNKTtcbi8qXG4gKiBWZXJpZnkgdGhhdCBhIGNoYXIgaXMgYSB2YWxpZCB2aXNpYmxlIChwcmludGFibGUpIFVTLUFTQ0lJXG4gKiBjaGFyYWN0ZXIgb3IgJXg4MC1GRlxuICovXG5leHBvcnRzLkhFQURFUl9DSEFSUyA9IFsnXFx0J107XG5mb3IgKGxldCBpID0gMzI7IGkgPD0gMjU1OyBpKyspIHtcbiAgICBpZiAoaSAhPT0gMTI3KSB7XG4gICAgICAgIGV4cG9ydHMuSEVBREVSX0NIQVJTLnB1c2goaSk7XG4gICAgfVxufVxuLy8gJywnID0gXFx4NDRcbmV4cG9ydHMuQ09OTkVDVElPTl9UT0tFTl9DSEFSUyA9IGV4cG9ydHMuSEVBREVSX0NIQVJTLmZpbHRlcigoYykgPT4gYyAhPT0gNDQpO1xuZXhwb3J0cy5RVU9URURfU1RSSU5HID0gWydcXHQnLCAnICddO1xuZm9yIChsZXQgaSA9IDB4MjE7IGkgPD0gMHhmZjsgaSsrKSB7XG4gICAgaWYgKGkgIT09IDB4MjIgJiYgaSAhPT0gMHg1YykgeyAvLyBBbGwgY2hhcmFjdGVycyBpbiBBU0NJSSBleGNlcHQgXFwgYW5kIFwiXG4gICAgICAgIGV4cG9ydHMuUVVPVEVEX1NUUklORy5wdXNoKGkpO1xuICAgIH1cbn1cbmV4cG9ydHMuSFRBQl9TUF9WQ0hBUl9PQlNfVEVYVCA9IFsnXFx0JywgJyAnXTtcbi8vIFZDSEFSOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTIzNCNhcHBlbmRpeC1CLjFcbmZvciAobGV0IGkgPSAweDIxOyBpIDw9IDB4N0U7IGkrKykge1xuICAgIGV4cG9ydHMuSFRBQl9TUF9WQ0hBUl9PQlNfVEVYVC5wdXNoKGkpO1xufVxuLy8gT0JTX1RFWFQ6IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjOTExMCNuYW1lLWNvbGxlY3RlZC1hYm5mXG5mb3IgKGxldCBpID0gMHg4MDsgaSA8PSAweGZmOyBpKyspIHtcbiAgICBleHBvcnRzLkhUQUJfU1BfVkNIQVJfT0JTX1RFWFQucHVzaChpKTtcbn1cbmV4cG9ydHMuTUFKT1IgPSBleHBvcnRzLk5VTV9NQVA7XG5leHBvcnRzLk1JTk9SID0gZXhwb3J0cy5NQUpPUjtcbmV4cG9ydHMuU1BFQ0lBTF9IRUFERVJTID0ge1xuICAgICdjb25uZWN0aW9uJzogZXhwb3J0cy5IRUFERVJfU1RBVEUuQ09OTkVDVElPTixcbiAgICAnY29udGVudC1sZW5ndGgnOiBleHBvcnRzLkhFQURFUl9TVEFURS5DT05URU5UX0xFTkdUSCxcbiAgICAncHJveHktY29ubmVjdGlvbic6IGV4cG9ydHMuSEVBREVSX1NUQVRFLkNPTk5FQ1RJT04sXG4gICAgJ3RyYW5zZmVyLWVuY29kaW5nJzogZXhwb3J0cy5IRUFERVJfU1RBVEUuVFJBTlNGRVJfRU5DT0RJTkcsXG4gICAgJ3VwZ3JhZGUnOiBleHBvcnRzLkhFQURFUl9TVEFURS5VUEdSQURFLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/llhttp/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/llhttp/llhttp-wasm.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp-wasm.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nconst { Buffer } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\n\nconst wasmBase64 = 'AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzQzBQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEDAAADAAAABAUBcAESEgUDAQACBggBfwFBgNgECwfFBygGbWVtb3J5AgALX2luaXRpYWxpemUACBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQACRhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUANgxsbGh0dHBfYWxsb2MACwZtYWxsb2MAOAtsbGh0dHBfZnJlZQAMBGZyZWUADA9sbGh0dHBfZ2V0X3R5cGUADRVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADhVsbGh0dHBfZ2V0X2h0dHBfbWlub3IADxFsbGh0dHBfZ2V0X21ldGhvZAAQFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAERJsbGh0dHBfZ2V0X3VwZ3JhZGUAEgxsbGh0dHBfcmVzZXQAEw5sbGh0dHBfZXhlY3V0ZQAUFGxsaHR0cF9zZXR0aW5nc19pbml0ABUNbGxodHRwX2ZpbmlzaAAWDGxsaHR0cF9wYXVzZQAXDWxsaHR0cF9yZXN1bWUAGBtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGRBsbGh0dHBfZ2V0X2Vycm5vABoXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AGxdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAcFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB0RbGxodHRwX2Vycm5vX25hbWUAHhJsbGh0dHBfbWV0aG9kX25hbWUAHxJsbGh0dHBfc3RhdHVzX25hbWUAIBpsbGh0dHBf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a0E+aiECCyABIAI2AhwgAUIANwIQIAJBAnRBsNYAaiEAAkBBhNQAKAIAIgNBASACdCIHcUUEQCAAIAE2AgBBhNQAIAMgB3I2AgAgASAANgIYIAEgATYCCCABIAE2AgwMAQsgBEEZIAJBAXZrQQAgAkEfRxt0IQIgACgCACEAAkADQCAAIgMoAgRBeHEgBEYNASACQR12IQAgAkEBdCECIAMgAEEEcWpBEGoiBygCACIADQALIAcgATYCACABIAM2AhggASABNgIMIAEgATYCCAwBCyADKAIIIgAgATYCDCADIAE2AgggAUEANgIYIAEgAzYCDCABIAA2AggLQaDUAEGg1AAoAgBBAWsiAEF/IAAbNgIACwsHACAALQAoCwcAIAAtACoLBwAgAC0AKwsHACAALQApCwcAIAAvATQLBwAgAC0AMAtAAQR/IAAoAhghASAALwEuIQIgAC0AKCEDIAAoAjghBCAAEDcgACAENgI4IAAgAzoAKCAAIAI7AS4gACABNgIYC8X4AQIHfwN+IAEgAmohBAJAIAAiAygCDCIADQAgAygCBARAIAMgATYCBAsjAEEQayIJJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDtQBAAECAwQFBgcICQoLDA0ODxARFBUWFxgZGhscHR4fICEjJCUnKCmIA4cDhQOEA/wC9QLuAusC6ALmAuMC4ALfAt0C2wLWAtUC1ALTAtICygLJAsgCxwLGAsUCxALDAr0CvAK6ArkCuAK3ArYCtQK0ArICsQKsAqoCqAKnAqYCpQKkAqMCogKhAqACnwKbApoCmQKYApcCkAKIAoQCgwKCAvkB9gH1AfQB8wHyAfEB8AHvAe0B6wHoAeMB4QHgAd8B3gHdAdwB2wHaAdkB2AHX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QEBAQEBAQEBAQEBAAEALQQAhAiADQQA2AhwgA0G3CzYCECADQQI2AgwgAyABQQFqNgIUDIEDCyADQS9qIQIDQCABIARGBEBBISECDIIDCwJAAkACQCABLQAAIgBBCWsOGAIAKioBKioqKioqKioqKioqKioqKioqAigLIAFBAWohASADQS9qLQAAQQFxRQ0LDBkLIAFBAWohAQwYCyABQQFqIQEgAi0AAEECcQ0AC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAyAAwsgAUEBaiEBC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADQEM0QILIANCADcDIAw8CyAAQRVGBEAgA0EkNgIcIAMgATYCFCADQYYaNgIQIANBFTYCDEEAIQIM/QILQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDPwCCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDSsgA0EHNgIcIAMgATYCFCADIAA2AgwM+wILIAMtAC5BwABxRQ0BC0EAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAARQ0rIABBFUYEQCADQQo2AhwgAyABNgIUIANB8Rg2AhAgA0EVNgIMQQAhAgz6AgtBACECIANBADYCHCADIAE2AhQgA0GLDDYCECADQRM2AgwM+QILQQAhAiADQQA2AhwgAyABNgIUIANBsRQ2AhAgA0ECNgIMDPgCC0EAIQIgA0EANgIcIAMgATYCFCADQYwUNgIQIANBGTYCDAz3AgtBACECIANBADYCHCADIAE2AhQgA0HRHDYCECADQRk2AgwM9gILIABBFUYNPUEAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAz1AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQ0oIANBDTYCHCADIAE2AhQgAyAANgIMDPQCCyAAQRVGDTpBACECIANBADYCHCADIAE2AhQgA0GiDzYCECADQSI2AgwM8wILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDIiAEUEQCABQQFqIQEMKAsgA0EONgIcIAMgADYCDCADIAFBAWo2AhQM8gILIABBFUYNN0EAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAzxAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQRAIAFBAWohAQwnCyADQQ82AhwgAyAANgIMIAMgAUEBajYCFAzwAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM7wILIABBFUYNM0EAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzuAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMyIARQ0lIANBETYCHCADIAE2AhQgAyAANgIMDO0CCyAAQRVGDTBBACECIANBADYCHCADIAE2AhQgA0HODDYCECADQSM2AgwM7AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEMJQsgA0ESNgIcIAMgADYCDCADIAFBAWo2AhQM6wILIANBL2otAABBAXFFDQELQRUhAgzPAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM6AILIABBO0cNACABQQFqIQEMDAtBACECIANBADYCHCADIAE2AhQgA0GYFzYCECADQQI2AgwM5gILIABBFUYNKEEAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzlAgsgA0EUNgIcIAMgATYCFCADIAA2AgwM5AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEM3AILIANBFTYCHCADIAA2AgwgAyABQQFqNgIUDOMCCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNoCCyADQRc2AhwgAyAANgIMIAMgAUEBajYCFAziAgsgAEEVRg0jQQAhAiADQQA2AhwgAyABNgIUIANBzgw2AhAgA0EjNgIMDOECCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDB0LIANBGTYCHCADIAA2AgwgAyABQQFqNgIUDOACCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNYCCyADQRo2AhwgAyAANgIMIAMgAUEBajYCFAzfAgsgAEEVRg0fQQAhAiADQQA2AhwgAyABNgIUIANBog82AhAgA0EiNgIMDN4CCyADKAIEIQBBACEC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DLMCCyABIARGBEBB6QEhAgyzAgsgAS0AAEHIAEYNASADQQE6ACgLQbYBIQIMlwILQcoBIQIMlgILIAEgBEcEQCADQQw2AgggAyABNgIEQckBIQIMlgILQegBIQIMrwILIAEgBEYEQEHnASECDK8CCyABLQAAQcgARw0EIAFBAWohAUHIASECDJQCCyABIARGBEBB5gEhAgyuAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQcYBIQIMlAILIAFBAWohAUHHASECDJMCC0HlASECIAEgBEYNrAIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB99MAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMrQILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgBFBEBB1AEhAgyTAgsgA0HkATYCHCADIAE2AhQgAyAANgIMQQAhAgysAgtB4wEhAiABIARGDasCIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQfXTAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADKwCCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB0B42AhAgA0EINgIMDKkCC0HFASECDI4CCyADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDKcCC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ1lIABBFUcEQCADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgynAgsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDKYCC0HhASECIAQgASIARg2lAiAEIAFrIAMoAgAiAWohBSAAIAFrQQRqIQYCQANAIAAtAAAgAUHw0wBqLQAARw0BIAFBBEYNAyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBTYCAAymAgsgA0EANgIcIAMgADYCFCADQYQ3NgIQIANBCDYCDCADQQA2AgBBACECDKUCCyABIARHBEAgA0ENNgIIIAMgATYCBEHCASECDIsCC0HgASECDKQCCyADQQA2AgAgBkEBaiEBC0HDASECDIgCCyABIARGBEBB3wEhAgyiAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBwQEhAgyIAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYgCIANB3gE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAEgBEYEQEHdASECDKECCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYkCIANB3AE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILQcABIQIMhgILIAEgBEYEQEHbASECDKACC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDQIgA0HYATYCHCADIAE2AhQgAyAANgIMQQAhAgyiAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYsCIANB2QE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ2JAiADQdoBNgIcIAMgATYCFCADIAA2AgwMoAILQb8BIQIMhQILQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBnA02AhAgA0EhNgIMQQAhAgygAgtBvgEhAgyFAgsgA0HXATYCHCADIAE2AhQgA0HWGTYCECADQRU2AgxBACECDJ4CCyABIARGBEBB1wEhAgyeAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANB6xA2AhAgA0EJNgIMQQAhAgyeAgtBvQEhAgyDAgsgASAERgRAQdYBIQIM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LgsgAUEBaiEBQZcBIQIM2AELIAFBAWohAUEiDCsLIAEgBEYEQEGvASECDPEBCyABLQAAQdAARw0rIAFBAWohAUGWASECDNYBCyABIARGBEBBrgEhAgzwAQsCQAJAIAEtAABBxgBrDgsALCwsLCwsLCwsASwLIAFBAWohAUGUASECDNYBCyABQQFqIQFBlQEhAgzVAQtBrQEhAiABIARGDe4BIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazTAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO8BCyADQQA2AgAgBkEBaiEBQQ0MKAtBrAEhAiABIARGDe0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQeHTAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO4BCyADQQA2AgAgBkEBaiEBQQwMJwtBqwEhAiABIARGDewBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQarTAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO0BCyADQQA2AgAgBkEBaiEBQQMMJgtBqgEhAiABIARGDesBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQajTAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOwBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQakBIQIM6wELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBjwEhAgzRAQsgAUEBaiEBQZABIQIM0AELQagBIQIgASAERg3pASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm0wBqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzqAQsgA0EANgIAIAZBAWohAUEnDCMLQacBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk0wBqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEcDCILQaYBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGe0wBqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEGDCELQaUBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGZ0wBqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGkASECDOYBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQYQBIQIMzgELIAFBAWohAUGFASECDM0BCyABQQFqIQFBigEhAgzMAQsgAUEBaiEBQYsBIQIMywELQaMBIQIgASAERg3kASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGX0wBqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzlAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGiASECDOQBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGGASECDMoBCyABQQFqIQFBiQEhAgzJAQsgASAERgRAQaEBIQIM4wELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQYcBIQIMyQELIAFBAWohAUGIASECDMgBCyABIARGBEBBoAEhAgziAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GfASECIAEgBEYN4AEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBkdMAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4QELIANBADYCACAGQQFqIQFBHgwaC0GeASECIAEgBEYN3wEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBitMAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4AELIANBADYCACAGQQFqIQFBFQwZC0GdASECIAEgBEYN3gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBh9MAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3wELIANBADYCACAGQQFqIQFBFwwYC0GcASECIAEgBEYN3QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBgdMAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3gELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBmwEhAgzdAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYEBIQIMwwELIAFBAWohAUGCASECDMIBC0GaASECIAEgBEYN2wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5tMAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3AELIANBADYCACAGQQFqIQFBCQwVC0GZASECIAEgBEYN2gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5NMAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2wELIANBADYCACAGQQFqIQFBHwwUC0GYASECIAEgBEYN2QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB/tIAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2gELIANBADYCACAGQQFqIQFBAgwTC0GXASECIAEgBEYN2AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQfzSAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyABIARGBEBBlgEhAgzYAQtBASABLQAAQd8ARw0RGiABQQFqIQFB/QAhAgy9AQsgA0EANgIAIAZBAWohAUH+ACECDLwBC0GVASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBKQwPC0GUASECIAEgBEYN1AEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB+NIAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1QELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBkwEhAgzUAQsgAS0AAEHFAEcNDiABQQFqIQFB+gAhAgy5AQsgASAERgRAQZIBIQIM0wELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFB+AAhAgy5AQsgAUEBaiEBQfkAIQIMuAELQZEBIQIgASAERg3RASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHz0gBqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzSAQsgA0EANgIAIAZBAWohAUEjDAsLQZABIQIgASAERg3QASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHw0gBqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzRAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGPASECDNABCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQfMAIQIMtgELIAFBAWohAUH2ACECDLUBCyABIARGBEBBjgEhAgzPAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB9AAhAgy1AQsgAUEBaiEBQfUAIQIMtAELIAEgBEYEQEGNASECDM4BCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQYwBIQIgASAERg3MASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHs0gBqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzNAQsgA0EANgIAIAZBAWohAUEFDAYLQYsBIQIgASAERg3LASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHm0gBqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzMAQsgA0EANgIAIAZBAWohAUEWDAULQYoBIQIgASAERg3KASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzLAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGJASECDMoBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUHvACECDLABCyABQQFqIQFB8AAhAgyvAQtBiAEhAiABIARGDcgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQeDSAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMkBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGHASECDMcBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC0iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB6R42AhAgA0EGNgIMDMQBC0HuACECDKkBCyADQYYBNgIcIAMgATYCFCADIAA2AgxBACECDMIBC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgzBAQtB7QAhAgymAQsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDL8BCyABIARGBEBBhQEhAgy/AQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GGHjYCECADQQY2AgxBACECDL8BC0ECIQIMpAELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GEASECDL0BCyABIARGBEBBgwEhAgy9AQsCQCABLQAAQQlrDgRAAABAAAtB6wAhAgyiAQsgAy0AKUEFRgRAQewAIQIMogELQeoAIQIMoQELIAEgBEYEQEGCASECDLsBCyADQQ82AgggAyABNgIEDAoLIAEgBEYEQEGBASECDLoBCwJAIAEtAABBCWsOBD0AAD0AC0HpACECDJ8BCyABIARHBEAgA0EPNgIIIAMgATYCBEHnACECDJ8BC0GAASECDLgBCwJAIAEgBEcEQANAIAEtAABB4M4Aai0AACIAQQNHBEACQCAAQQFrDgI/AAQLQeYAIQIMoQELIAQgAUEBaiIBRw0AC0H+ACECDLkBC0H+ACECDLgBCyADQQA2AhwgAyABNgIUIANBxh82AhAgA0EHNgIMQQAhAgy3AQsgASAERgRAQf8AIQIMtwELAkACQAJAIAEtAABB4NAAai0AAEEBaw4DPAIAAQtB6AAhAgyeAQsgA0EANgIcIAMgATYCFCADQYYSNgIQIANBBzYCDEEAIQIMtwELQeAAIQIMnAELIAEgBEcEQCABQQFqIQFB5QAhAgycAQtB/QAhAgy1AQsgBCABIgBGBEBB/AAhAgy1AQsgAC0AACIBQS9GBEAgAEEBaiEBQeQAIQIMmwELIAFBCWsiAkEXSw0BIAAhAUEBIAJ0QZuAgARxDTcMAQsgBCABIgBGBEBB+wAhAgy0AQsgAC0AAEEvRw0AIABBAWohAQwDC0EAIQIgA0EANgIcIAMgADYCFCADQcYfNgIQIANBBzYCDAyyAQsCQAJAAkACQAJAA0AgAS0AAEHgzABqLQAAIgBBBUcEQAJAAkAgAEEBaw4IPQUGBwgABAEIC0HhACECDJ8BCyABQQFqIQFB4wAhAgyeAQsgBCABQQFqIgFHDQALQfoAIQIMtgELIAFBAWoMFAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgy0AQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyzAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyyAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMsQELIAEgBEYEQEH5ACECDLEBCwJAIAEtAABB4MwAai0AAEEBaw4INAQFBgAIAgMHCyABQQFqIQELQQMhAgyVAQsgAUEBagwNC0EAIQIgA0EANgIcIANBoxI2AhAgA0EHNgIMIAMgAUEBajYCFAytAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgysAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMqQELQeIAIQIMjgELIAEgBEYEQEH4ACECDKgBCyABQQFqDAILIAEgBEYEQEH3ACECDKcBCyABQQFqDAELIAEgBEYNASABQQFqCyEBQQQhAgyKAQtB9gAhAgyjAQsDQCABLQAAQeDKAGotAAAiAEECRwRAIABBAUcEQEHfACECDIsBCwwnCyAEIAFBAWoiAUcNAAtB9QAhAgyiAQsgASAERgRAQfQAIQIMogELAkAgAS0AAEEJaw43JQMGJQQGBgYGBgYGBgYGBgYGBgYGBgYFBgYCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAAYLIAFBAWoLIQFBBSECDIYBCyABQQFqDAYLIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMngELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMnQELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB8AA2AhwgAyABNgIUIAMgADYCDEEAIQIMnAELIANBADYCHCADIAE2AhQgA0G8EzYCECADQQc2AgxBACECDJsBCwJAAkACQAJAA0AgAS0AAEHgyABqLQAAIgBBBUcEQAJAIABBAWsOBiQDBAUGAAYLQd4AIQIMhgELIAQgAUEBaiIBRw0AC0HzACECDJ4BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQdsANgIcIAMgATYCFCADIAA2AgxBACECDJ0BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDJwBCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQfAANgIcIAMgATYCFCADIAA2AgxBACECDJsBCyADQQA2AhwgAyABNgIUIANB3Ag2AhAgA0EHNgIMQQAhAgyaAQsgASAERg0BIAFBAWoLIQFBBiECDH4LQfIAIQIMlwELAkACQAJAAkADQCABLQAAQeDGAGotAAAiAEEFRwRAIABBAWsOBB8CAwQFCyAEIAFBAWoiAUcNAAtB8QAhAgyaAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyZAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyYAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyXAQsgA0EANgIcIAMgATYCFCADQbQKNgIQIANBBzYCDEEAIQIMlgELQc4AIQIMewtB0AAhAgx6C0HdACECDHkLIAEgBEYEQEHwACECDJMBCwJAIAEtAABBCWsOBBYAABYACyABQQFqIQFB3AAhAgx4CyABIARGBEBB7wAhAgySAQsCQCABLQAAQQlrDgQVAAAVAAtBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUEQEHTASECDHgLIABBFUcEQCADQQA2AhwgAyABNgIUIANBwQ02AhAgA0EaNgIMQQAhAgySAQsgA0HuADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDJEBC0HtACECIAEgBEYNkAEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB18YAai0AAEcNBCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkQELIANBADYCACAGQQFqIQEgAy0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACECIANBADYCHCADIAE2AhQgA0HlCTYCECADQQg2AgwMkAELQewAIQIgASAERg2PASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHUxgBqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyQAQsgA0EANgIAIAZBAWohASADLQApQSFGDQMgA0EANgIcIAMgATYCFCADQYkKNgIQIANBCDYCDEEAIQIMjwELQesAIQIgASAERg2OASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHQxgBqLQAARw0CIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyPAQsgA0EANgIAIAZBAWohASADLQApIgBBI0kNAiAAQS5GDQIgA0EANgIcIAMgATYCFCADQcEJNgIQIANBCDYCDEEAIQIMjgELIANBADYCAAtBACECIANBADYCHCADIAE2AhQgA0GENzYCECADQQg2AgwMjAELQdgAIQIMcQsgASAERwRAIANBDTYCCCADIAE2AgRB1wAhAgxxC0HqACECDIoBCyABIARGBEBB6QAhAgyKAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1gAhAgxwCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdCADQegANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyABIARGBEBB5wAhAgyJAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ11IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMiQELQdUAIQIMbgsgASAERgRAQeUAIQIMiAELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDIoBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdyADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdSADQeQANgIcIAMgATYCFCADIAA2AgwMiAELQdMAIQIMbQsgAy0AKUEiRg2AAUHSACECDGwLQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALIABFBEBB1AAhAgxsCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQZwNNgIQIANBITYCDEEAIQIMhgELIANB4QA2AhwgAyABNgIUIANB1hk2AhAgA0EVNgIMQQAhAgyFAQsgASAERgRAQeAAIQIMhQELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HRACECDGwLIANBADYCHCADIAE2AhQgA0GIETYCECADQQk2AgxBACECDIUBCyADQQA2AhwgAyABNgIUIANBiBE2AhAgA0EJNgIMQQAhAgyEAQsgASAERgRAQd8AIQIMhAELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBiBE2AhAgA0ECNgIMQQAhAgyDAQsgASAERgRAQd0AIQIMgwELIAEtAAAiAkENRgRAIAFBAWohAUHPACECDGkLIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyCAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0G1LDYCECADQQc2AgwMgAELIAEgBEYEQEHbACECDIABCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc0AIQIMZAsgASAERgRAQdoAIQIMfgsgAS0AAEEJaw4EAAEBAAELQQAhAiADQQA2AhwgA0HsETYCECADQQc2AgwgAyABQQFqNgIUDHwLIANBgBI7ASpBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HZADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDHsLQcwAIQIMYAsgA0EANgIcIAMgATYCFCADQcENNgIQIANBGjYCDEEAIQIMeQsgASAERgRAQdkAIQIMeQsgAS0AAEEgRw06IAFBAWohASADLQAuQQFxDTogA0EANgIcIAMgATYCFCADQa0bNgIQIANBHjYCDEEAIQIMeAsgASAERgRAQdgAIQIMeAsCQAJAAkACQAJAIAEtAAAiAEEKaw4EAgMDAAELIAFBAWohAUErIQIMYQsgAEE6Rw0BIANBADYCHCADIAE2AhQgA0G5ETYCECADQQo2AgxBACECDHoLIAFBAWohASADQS9qLQAAQQFxRQ1tIAMtADJBgAFxRQRAIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsCQAJAIAAOFkpJSAEBAQEBAQEBAQEBAQEBAQEBAQABCyADQSk2AhwgAyABNgIUIANBshg2AhAgA0EVNgIMQQAhAgx7CyADQQA2AhwgAyABNgIUIANB3Qs2AhAgA0ERNgIMQQAhAgx6C0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAARQ1VIABBFUcNASADQQU2AhwgAyABNgIUIANBhho2AhAgA0EVNgIMQQAhAgx5C0HKACECDF4LQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDHcLIAMgAy8BMkGAAXI7ATIMOAsgASAERwRAIANBEDYCCCADIAE2AgRByQAhAgxcC0HXACECDHULIAEgBEYEQEHWACECDHULAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAPT09PT09PT09PT09AT09PQIDPQsgAUEBaiEBQcUAIQIMXQsgAUEBaiEBQcYAIQIMXAsgAUEBaiEBQccAIQIMWwsgAUEBaiEBQcgAIQIMWgtB1QAhAiAEIAEiAEYNcyAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcDQCABQcDGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQhBBCABQQVGDQoaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADHMLQdQAIQIgBCABIgBGDXIgBCABayADKAIAIgFqIQYgACABa0EPaiEHA0AgAUGwxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0HQQMgAUEPRg0JGiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxyC0HTACECIAQgASIARg1xIAQgAWsgAygCACIBaiEGIAAgAWtBDmohBwNAIAFBksYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNBiABQQ5GDQcgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMcQtB0gAhAiAEIAEiAEYNcCAEIAFrIAMoAgAiAWohBSAAIAFrQQFqIQYDQCABQZDGAGotAAAgAC0AACIHQSByIAcgB0HBAGtB/wFxQRpJG0H/AXFHDQUgAUEBRg0CIAFBAWohASAEIABBAWoiAEcNAAsgAyAFNgIADHALIAEgBEYEQEHRACECDHALAkACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcUHuAGsOBwA2NjY2NgE2CyABQQFqIQFBwgAhAgxWCyABQQFqIQFBwwAhAgxVCyADQQA2AgAgBkEBaiEBQcQAIQIMVAtB0AAhAiAEIAEiAEYNbSAEIAFrIAMoAgAiAWohBiAAIAFrQQlqIQcDQCABQYbGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQJBAiABQQlGDQQaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADG0LQc8AIQIgBCABIgBGDWwgBCABayADKAIAIgFqIQYgACABa0EFaiEHA0AgAUGAxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYNAiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxsCyAAIQEgA0EANgIADDALQQELOgAsIANBADYCACAHQQFqIQELQSwhAgxOCwJAA0AgAS0AAEGAxABqLQAAQQFHDQEgBCABQQFqIgFHDQALQc0AIQIMaAtBwQAhAgxNCyABIARGBEBBzAAhAgxnCyABLQAAQTpGBEAgAygCBCEAIANBADYCBCADIAAgARAvIgBFDTAgA0HLADYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxnCyADQQA2AhwgAyABNgIUIANBuRE2AhAgA0EKNgIMQQAhAgxmCwJAAkAgAy0ALEECaw4CAAEkCyADQTNqLQAAQQJxRQ0jIAMtAC5BAnENIyADQQA2AhwgAyABNgIUIANB1RM2AhAgA0ELNgIMQQAhAgxmCyADLQAyQSBxRQ0iIAMtAC5BAnENIiADQQA2AhwgAyABNgIUIANB7BI2AhAgA0EPNgIMQQAhAgxlC0EAIQACQCADKAI4IgJFDQAgAigCQCICRQ0AIAMgAhEAACEACyAARQRAQcAAIQIMSwsgAEEVRwRAIANBADYCHCADIAE2AhQgA0H4DjYCECADQRw2AgxBACECDGULIANBygA2AhwgAyABNgIUIANB8Bo2AhAgA0EVNgIMQQAhAgxkCyABIARHBEADQCABLQAAQfA/ai0AAEEBRw0XIAQgAUEBaiIBRw0AC0HEACECDGQLQcQAIQIMYwsgASAERwRAA0ACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcSIAQQlGDQAgAEEgRg0AAkACQAJAAkAgAEHjAGsOEwADAwMDAwMDAQMDAwMDAwMDAwIDCyABQQFqIQFBNSECDE4LIAFBAWohAUE2IQIMTQsgAUEBaiEBQTchAgxMCwwVCyAEIAFBAWoiAUcNAAtBPCECDGMLQTwhAgxiCyABIARGBEBByAAhAgxiCyADQRE2AgggAyABNgIEAkACQAJAAkACQCADLQAsQQFrDgQUAAECCQsgAy0AMkEgcQ0DQdEBIQIMSwsCQCADLwEyIgBBCHFFDQAgAy0AKEEBRw0AIAMtAC5BCHFFDQILIAMgAEH3+wNxQYAEcjsBMgwLCyADIAMvATJBEHI7ATIMBAsgA0EANgIEIAMgASABEDAiAARAIANBwQA2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMYwsgAUEBaiEBDFILIANBADYCHCADIAE2AhQgA0GjEzYCECADQQQ2AgxBACECDGELQccAIQIgASAERg1gIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEHwwwBqLQAAIAEtAABBIHJHDQEgAEEGRg1GIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADGELIANBADYCAAwFCwJAIAEgBEcEQANAIAEtAABB8MEAai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBxQAhAgxhC0HFACECDGALCyADQQA6ACwMAQtBCyECDEMLQT4hAgxCCwJAAkADQCABLQAAIgBBIEcEQAJAIABBCmsOBAMFBQMACyAAQSxGDQMMBAsgBCABQQFqIgFHDQALQcYAIQIMXQsgA0EIOgAsDA4LIAMtAChBAUcNAiADLQAuQQhxDQIgAygCBCEAIANBADYCBCADIAAgARAwIgAEQCADQcIANgIcIAMgADYCDCADIAFBAWo2AhRBACECDFwLIAFBAWohAQxKC0E6IQIMQAsCQANAIAEtAAAiAEEgRyAAQQlHcQ0BIAQgAUEBaiIBRw0AC0HDACECDFoLC0E7IQIMPgsCQAJAIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBAMEBAMECyAEIAFBAWoiAUcNAAtBPyECDFoLQT8hAgxZCyADIAMvATJBIHI7ATIMCgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFDUggA0E+NgIcIAMgATYCFCADIAA2AgxBACECDFcLAkAgASAERwRAA0AgAS0AAEHwwQBqLQAAIgBBAUcEQCAAQQJGDQMMDAsgBCABQQFqIgFHDQALQTchAgxYC0E3IQIMVwsgAUEBaiEBDAQLQTshAiAEIAEiAEYNVSAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcCQANAIAFBwMYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNASABQQVGBEBBByEBDDsLIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADFYLIANBADYCACAAIQEMBQtBOiECIAQgASIARg1UIAQgAWsgAygCACIBaiEGIAAgAWtBCGohBwJAA0AgAUHkP2otAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAUEIRgRAQQUhAQw6CyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxVCyADQQA2AgAgACEBDAQLQTkhAiAEIAEiAEYNUyAEIAFrIAMoAgAiAWohBiAAIAFrQQNqIQcCQANAIAFB4D9qLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBA0YEQEEGIQEMOQsgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMVAsgA0EANgIAIAAhAQwDCwJAA0AgAS0AACIAQSBHBEAgAEEKaw4EBwQEBwILIAQgAUEBaiIBRw0AC0E4IQIMUwsgAEEsRw0BIAFBAWohAEEBIQECQAJAAkACQAJAIAMtACxBBWsOBAMBAgQACyAAIQEMBAtBAiEBDAELQQQhAQsgA0EBOgAsIAMgAy8BMiABcjsBMiAAIQEMAQsgAyADLwEyQQhyOwEyIAAhAQtBPSECDDcLIANBADoALAtBOCECDDULIAEgBEYEQEE2IQIMTwsCQAJAAkACQAJAIAEtAABBCmsOBAACAgECCyADKAIEIQAgA0EANgIEIAMgACABEDAiAEUNAiADQTM2AhwgAyABNgIUIAMgADYCDEEAIQIMUgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFBEAgAUEBaiEBDAYLIANBMjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxRCyADLQAuQQFxBEBB0AEhAgw3CyADKAIEIQAgA0EANgIEIAMgACABEDAiAA0BDEMLQTMhAgw1CyADQTU2AhwgAyABNgIUIAMgADYCDEEAIQIMTgtBNCECDDMLIANBL2otAABBAXENACADQQA2AhwgAyABNgIUIANB8RU2AhAgA0EZNgIMQQAhAgxMC0EyIQIMMQsgASAERgRAQTIhAgxLCwJAIAEtAABBCkYEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQZgWNgIQIANBAzYCDEEAIQIMSwtBMSECDDALIAEgBEYEQEExIQIMSgsgAS0AACIAQQlHIABBIEdxDQEgAy0ALEEIRw0AIANBADoALAtBPCECDC4LQQEhAgJAAkACQAJAIAMtACxBBWsOBAMBAgAKCyADIAMvATJBCHI7ATIMCQtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgwGCyABIARGBEBBMCECDEcLIAEtAABBCkYEQCABQQFqIQEMAQsgAy0ALkEBcQ0AIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDEYLQS8hAgwrCyABQQFqIQFBMCECDCoLIAEgBEYEQEEvIQIMRAsgAS0AACIAQQlHIABBIEdxRQRAIAFBAWohASADLQAuQQFxDQEgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIMRAtBASECAkACQAJAAkACQAJAIAMtACxBAmsOBwUEBAMBAgAECyADIAMvATJBCHI7ATIMAwtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgtBLiECDCoLIANBADYCHCADIAE2AhQgA0GzEjYCECADQQs2AgxBACECDEMLQdIBIQIMKAsgASAERgRAQS4hAgxCCyADQQA2AgQgA0ERNgIIIAMgASABEDAiAA0BC0EtIQIMJgsgA0EtNgIcIAMgATYCFCADIAA2AgxBACECDD8LQQAhAAJAIAMoAjgiAkUNACACKAJEIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB2AA2AhwgAyABNgIUIANBnho2AhAgA0EVNgIMQQAhAgw+C0HLACECDCMLIANBADYCHCADIAE2AhQgA0GFDjYCECADQR02AgxBACECDDwLIAEgBEYEQEHOACECDDwLIAEtAAAiAEEgRg0CIABBOkYNAQsgA0EAOgAsQQkhAgwgCyADKAIEIQAgA0EANgIEIAMgACABEC8iAA0BDAILIAMtAC5BAXEEQEHPASECDB8LIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ0CIANBKjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgw4CyADQcsANgIcIAMgADYCDCADIAFBAWo2AhRBACECDDcLIAFBAWohAUE/IQIMHAsgAUEBaiEBDCkLIAEgBEYEQEErIQIMNQsCQCABLQAAQQpGBEAgAUEBaiEBDAELIAMtAC5BwABxRQ0GCyADLQAyQYABcQRAQQAhAAJAIAMoAjgiAkUNACACKAJUIgJFDQAgAyACEQAAIQALIABFDREgAEEVRgRAIANBBTYCHCADIAE2AhQgA0GGGjYCECADQRU2AgxBACECDDYLIANBADYCHCADIAE2AhQgA0HiDTYCECADQRQ2AgxBACECDDULIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsgAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIANBAToAMAsgAiACLwEAQcAAcjsBAAtBKiECDBcLIANBKTYCHCADIAE2AhQgA0GyGDYCECADQRU2AgxBACECDDALIANBADYCHCADIAE2AhQgA0HdCzYCECADQRE2AgxBACECDC8LIANBADYCHCADIAE2AhQgA0GdCzYCECADQQI2AgxBACECDC4LQQEhByADLwEyIgVBCHFFBEAgAykDIEIAUiEHCwJAIAMtADAEQEEBIQAgAy0AKUEFRg0BIAVBwABxRSAHcUUNAQsCQCADLQAoIgJBAkYEQEEBIQAgAy8BNCIGQeUARg0CQQAhACAFQcAAcQ0CIAZB5ABGDQIgBkHmAGtBAkkNAiAGQcwBRg0CIAZBsAJGDQIMAQtBACEAIAVBwABxDQELQQIhACAFQQhxDQAgBUGABHEEQAJAIAJBAUcNACADLQAuQQpxDQBBBSEADAILQQQhAAwBCyAFQSBxRQRAIAMQNUEAR0ECdCEADAELQQBBAyADKQMgUBshAAsCQCAAQQFrDgUAAQYHAgMLQQAhAgJAIAMoAjgiAEUNACAAKAIsIgBFDQAgAyAAEQAAIQILIAJFDSYgAkEVRgRAIANBAzYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDC4LQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDC0LQc4BIQIMEgtBACECIANBADYCHCADIAE2AhQgA0HkHzYCECADQQ82AgwMKwtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAA0BC0EOIQIMDwsgAEEVRgRAIANBAjYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDCkLQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDCgLQSkhAgwNCyADQQE6ADEMJAsgASAERwRAIANBCTYCCCADIAE2AgRBKCECDAwLQSYhAgwlCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMVARAQSUhAgwlCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDQAgA0EFNgIcIAMgATYCFCADIAA2AgwMJAtBDyECDAkLIAEgBEYEQEEjIQIMIwtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsONxcWAAECAwQFBgcUFBQUFBQUCAkKCwwNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQODxAREhMUC0ICIQoMFgtCAyEKDBULQgQhCgwUC0IFIQoMEwtCBiEKDBILQgchCgwRC0IIIQoMEAtCCSEKDA8LQgohCgwOC0ILIQoMDQtCDCEKDAwLQg0hCgwLC0IOIQoMCgtCDyEKDAkLQgohCgwIC0ILIQoMBwtCDCEKDAYLQg0hCgwFC0IOIQoMBAtCDyEKDAMLQQAhAiADQQA2AhwgAyABNgIUIANBzhQ2AhAgA0EMNgIMDCILIAEgBEYEQEEiIQIMIgtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQTBrDjcVFAABAgMEBQYHFhYWFhYWFggJCgsMDRYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWDg8QERITFgtCAiEKDBQLQgMhCgwTC0IEIQoMEgtCBSEKDBELQgYhCgwQC0IHIQoMDwtCCCEKDA4LQgkhCgwNC0IKIQoMDAtCCyEKDAsLQgwhCgwKC0INIQoMCQtCDiEKDAgLQg8hCgwHC0IKIQoMBgtCCyEKDAULQgwhCgwEC0INIQoMAwtCDiEKDAILQg8hCgwBC0IBIQoLIAFBAWohASADKQMgIgtC//////////8PWARAIAMgC0IEhiAKhDcDIAwCC0EAIQIgA0EANgIcIAMgATYCFCADQa0JNgIQIANBDDYCDAwfC0ElIQIMBAtBJiECDAMLIAMgAToALCADQQA2AgAgB0EBaiEBQQwhAgwCCyADQQA2AgAgBkEBaiEBQQohAgwBCyABQQFqIQFBCCECDAALAAtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMGAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMFwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMFgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMFQtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMFAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMEwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMEgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMEQtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMEAtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMDwtBACECIANBADYCHCADIAE2AhQgA0HIEjYCECADQQs2AgwMDgtBACECIANBADYCHCADIAE2AhQgA0GVCTYCECADQQs2AgwMDQtBACECIANBADYCHCADIAE2AhQgA0HpDzYCECADQQo2AgwMDAtBACECIANBADYCHCADIAE2AhQgA0GDEDYCECADQQo2AgwMCwtBACECIANBADYCHCADIAE2AhQgA0GmHDYCECADQQI2AgwMCgtBACECIANBADYCHCADIAE2AhQgA0HFFTYCECADQQI2AgwMCQtBACECIANBADYCHCADIAE2AhQgA0H/FzYCECADQQI2AgwMCAtBACECIANBADYCHCADIAE2AhQgA0HKFzYCECADQQI2AgwMBwsgA0ECNgIcIAMgATYCFCADQZQdNgIQIANBFjYCDEEAIQIMBgtB3gAhAiABIARGDQUgCUEIaiEHIAMoAgAhBQJAAkAgASAERwRAIAVBxsYAaiEIIAQgBWogAWshBiAFQX9zQQpqIgUgAWohAANAIAEtAAAgCC0AAEcEQEECIQgMAwsgBUUEQEEAIQggACEBDAMLIAVBAWshBSAIQQFqIQggBCABQQFqIgFHDQALIAYhBSAEIQELIAdBATYCACADIAU2AgAMAQsgA0EANgIAIAcgCDYCAAsgByABNgIEIAkoAgwhACAJKAIIDgMBBQIACwALIANBADYCHCADQa0dNgIQIANBFzYCDCADIABBAWo2AhRBACECDAMLIANBADYCHCADIAA2AhQgA0HCHTYCECADQQk2AgxBACECDAILIAEgBEYEQEEoIQIMAgsgA0EJNgIIIAMgATYCBEEnIQIMAQsgASAERgRAQQEhAgwBCwNAAkACQAJAIAEtAABBCmsOBAABAQABCyABQQFqIQEMAQsgAUEBaiEBIAMtAC5BIHENAEEAIQIgA0EANgIcIAMgATYCFCADQYwgNgIQIANBBTYCDAwCC0EBIQIgASAERw0ACwsgCUEQaiQAIAJFBEAgAygCDCEADAELIAMgAjYCHEEAIQAgAygCBCIBRQ0AIAMgASAEIAMoAggRAQAiAUUNACADIAQ2AhQgAyABNgIMIAEhAAsgAAu+AgECfyAAQQA6AAAgAEHcAGoiAUEBa0EAOgAAIABBADoAAiAAQQA6AAEgAUEDa0EAOgAAIAFBAmtBADoAACAAQQA6AAMgAUEEa0EAOgAAQQAgAGtBA3EiASAAaiIAQQA2AgBB3AAgAWtBfHEiAiAAaiIBQQRrQQA2AgACQCACQQlJDQAgAEEANgIIIABBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIAJBGUkNACAAQQA2AhggAEEANgIUIABBADYC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YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBFeHBlY3RlZCBMRiBhZnRlciBoZWFkZXJzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABUcmFuc2Zlci1FbmNvZGluZyBjYW4ndCBiZSBwcmVzZW50IHdpdGggQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBzaXplAEV4cGVjdGVkIExGIGFmdGVyIGNodW5rIHNpemUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBleHRlbnNpb24gdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIHF1b3RlZC1wYWlyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciByZXNwb25zZSBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIG5hbWUASW52YWxpZCBzdGF0dXMgY29kZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGRhdGEARXhwZWN0ZWQgTEYgYWZ0ZXIgY2h1bmsgZGF0YQBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AARGF0YSBhZnRlciBgQ29ubmVjdGlvbjogY2xvc2VgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBRVUVSWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAEV4cGVjdGVkIExGIGFmdGVyIENSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAUhUAABoVAAAPEgAA5BkAAJEVAAAJFAAALRkAAOQUAADpEQAAaRQAAKEUAAB2FQAAQxYAAF4SAACUFwAAFxYAAH0UAAB/FgAAQRcAALMTAADDFgAABBoAAL0YAADQGAAAoBMAANQZAACvFgAAaBYAAHAXAADZFgAA/BgAAP4RAABZFwAAlxYAABwXAAD2FgAAjRcAAAsSAAB/GwAALhEAALMQAABJEgAArRIAAPYYAABoEAAAYhUAABAVAABaFgAAShkAALUVAADBFQAAYBUAAFwZAABaGQAAUxkAABYVAACtEQAAQhAAALcQAABXGAAAvxUAAIkQAAAcGQAAGhkAALkVAABRGAAA3BMAAFsVAABZFQAA5hgAAGcVAAARGQAA7RgAAOcTAACuEAAAwhcAAAAUAACSEwAAhBMAAEASAAAmGQAArxUAAGIQAEHpOQsBAQBBgDoL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB6jsLBAEAAAIAQYE8C14DBAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAUAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEHqPQsEAQAAAgBBgT4LXgMAAwMDAwMAAAMDAAMDAAMDAwMDAwMDAwMABAAFAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAAMAQeA/Cw1sb3NlZWVwLWFsaXZlAEH5PwsBAQBBkMAAC+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnBAAsBAQBBkMIAC+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGhxAALXgEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAQYDGAAshZWN0aW9uZW50LWxlbmd0aG9ucm94eS1jb25uZWN0aW9uAEGwxgALK3JhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KU00NCg0KVFRQL0NFL1RTUC8AQenGAAsFAQIAAQMAQYDHAAtfBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQenIAAsFAQIAAQMAQYDJAAtfBAUFBgUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQenKAAsEAQAAAQBBgcsAC14CAgACAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAEHpzAALBQECAAEDAEGAzQALXwQFAAAFBQUFBQUFBQUFBQYFBQUFBQUFBQUFBQUABQAHCAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAUABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAAAAFAEHpzgALBQEBAAEBAEGAzwALAQEAQZrPAAtBAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQenQAAsFAQEAAQEAQYDRAAsBAQBBitEACwYCAAAAAAIAQaHRAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB4NIAC5oBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRVVFUllPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw=='\n\nlet wasmBuffer\n\nObject.defineProperty(module, 'exports', {\n  get: () => {\n    return wasmBuffer\n      ? wasmBuffer\n      : (wasmBuffer = Buffer.from(wasmBase64, 'base64'))\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwLXdhc20uanMiLCJtYXBwaW5ncyI6IjtBQUFZOztBQUVaLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7O0FBRXhDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL2xsaHR0cC13YXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKVxuXG5jb25zdCB3YXNtQmFzZTY0ID0gJ0FHRnpiUUVBQUFBQkp3ZGdBWDhCZjJBRGYzOS9BWDlnQW45L0FHQUJmd0JnQkg5L2YzOEJmMkFBQUdBRGYzOS9BQUxMQVFnRFpXNTJHSGRoYzIxZmIyNWZhR1ZoWkdWeWMxOWpiMjF3YkdWMFpRQUVBMlZ1ZGhWM1lYTnRYMjl1WDIxbGMzTmhaMlZmWW1WbmFXNEFBQU5sYm5ZTGQyRnpiVjl2Ymw5MWNtd0FBUU5sYm5ZT2QyRnpiVjl2Ymw5emRHRjBkWE1BQVFObGJuWVVkMkZ6YlY5dmJsOW9aV0ZrWlhKZlptbGxiR1FBQVFObGJuWVVkMkZ6YlY5dmJsOW9aV0ZrWlhKZmRtRnNkV1VBQVFObGJuWU1kMkZ6YlY5dmJsOWliMlI1QUFFRFpXNTJHSGRoYzIxZmIyNWZiV1Z6YzJGblpWOWpiMjF3YkdWMFpRQUFBelF6QlFZQUFBTUFBQUFBQUFBREFRTUFBd01EQUFBQ0FBQUFBQUlDQWdJQ0FnSUNBZ0lCQVFFQkFRRUJBUUVEQUFBREFBQUFCQVVCY0FFU0VnVURBUUFDQmdnQmZ3RkJnTmdFQ3dmRkJ5Z0diV1Z0YjNKNUFnQUxYMmx1YVhScFlXeHBlbVVBQ0JsZlgybHVaR2x5WldOMFgyWjFibU4wYVc5dVgzUmhZbXhsQVFBTGJHeG9kSFJ3WDJsdWFYUUFDUmhzYkdoMGRIQmZjMmh2ZFd4a1gydGxaWEJmWVd4cGRtVUFOZ3hzYkdoMGRIQmZZV3hzYjJNQUN3WnRZV3hzYjJNQU9BdHNiR2gwZEhCZlpuSmxaUUFNQkdaeVpXVUFEQTlzYkdoMGRIQmZaMlYwWDNSNWNHVUFEUlZzYkdoMGRIQmZaMlYwWDJoMGRIQmZiV0ZxYjNJQURoVnNiR2gwZEhCZloyVjBYMmgwZEhCZmJXbHViM0lBRHhGc2JHaDBkSEJmWjJWMFgyMWxkR2h2WkFBUUZteHNhSFIwY0Y5blpYUmZjM1JoZEhWelgyTnZaR1VBRVJKc2JHaDBkSEJmWjJWMFgzVndaM0poWkdVQUVneHNiR2gwZEhCZmNtVnpaWFFBRXc1c2JHaDBkSEJmWlhobFkzVjBaUUFVRkd4c2FIUjBjRjl6WlhSMGFXNW5jMTlwYm1sMEFCVU5iR3hvZEhSd1gyWnBibWx6YUFBV0RHeHNhSFIwY0Y5d1lYVnpaUUFYRFd4c2FIUjBjRjl5WlhOMWJXVUFHQnRzYkdoMGRIQmZjbVZ6ZFcxbFgyRm1kR1Z5WDNWd1ozSmhaR1VBR1JCc2JHaDBkSEJmWjJWMFgyVnljbTV2QUJvWGJHeG9kSFJ3WDJkbGRGOWxjbkp2Y2w5eVpXRnpiMjRBR3hkc2JHaDBkSEJmYzJWMFgyVnljbTl5WDNKbFlYTnZiZ0FjRkd4c2FIUjBjRjluWlhSZlpYSnliM0pmY0c5ekFCMFJiR3hvZEhSd1gyVnljbTV2WDI1aGJXVUFIaEpzYkdoMGRIQmZiV1YwYUc5a1gyNWhiV1VBSHhKc2JHaDBkSEJmYzNSaGRIVnpYMjVoYldVQUlCcHNiR2gwZEhCZmMyVjBYMnhsYm1sbGJuUmZhR1ZoWkdWeWN3QWhJV3hzYUhSMGNGOXpaWFJmYkdWdWFXVnVkRjlqYUhWdWEyVmtYMnhsYm1kMGFBQWlIV3hzYUhSMGNGOXpaWFJmYkdWdWFXVnVkRjlyWldWd1gyRnNhWFpsQUNNa2JHeG9kSFJ3WDNObGRGOXNaVzVwWlc1MFgzUnlZVzV6Wm1WeVgyVnVZMjlrYVc1bkFDUWFiR3hvZEhSd1gzTmxkRjlzWlc1cFpXNTBYM1psY25OcGIyNEFKU05zYkdoMGRIQmZjMlYwWDJ4bGJtbGxiblJmWkdGMFlWOWhablJsY2w5amJHOXpaUUFtSjJ4c2FIUjBjRjl6WlhSZmJHVnVhV1Z1ZEY5dmNIUnBiMjVoYkY5c1psOWhablJsY2w5amNnQW5MR3hzYUhSMGNGOXpaWFJmYkdWdWFXVnVkRjl2Y0hScGIyNWhiRjlqY214bVgyRm1kR1Z5WDJOb2RXNXJBQ2dvYkd4b2RIUndYM05sZEY5c1pXNXBaVzUwWDI5d2RHbHZibUZzWDJOeVgySmxabTl5WlY5c1pnQXBLbXhzYUhSMGNGOXpaWFJmYkdWdWFXVnVkRjl6Y0dGalpYTmZZV1owWlhKZlkyaDFibXRmYzJsNlpRQXFHR3hzYUhSMGNGOXRaWE56WVdkbFgyNWxaV1J6WDJWdlpnQTFDUmNCQUVFQkN4RUJBZ01FQlFvR0J6RXpNaTB1TENzdk1BcTh5d0l6RmdCQi9OTUFLQUlBQkVBQUMwSDgwd0JCQVRZQ0FBc1VBQ0FBRURjZ0FDQUNOZ0k0SUFBZ0FUb0FLQXNVQUNBQUlBQXZBVFFnQUMwQU1DQUFFRFlRQUFzZUFRRi9RY0FBRURraUFSQTNJQUZCZ0FnMkFqZ2dBU0FBT2dBb0lBRUxqd3dCQjM4Q1FDQUFSUTBBSUFCQkNHc2lBU0FBUVFScktBSUFJZ0JCZUhFaUJHb2hCUUpBSUFCQkFYRU5BQ0FBUVFOeFJRMEJJQUVnQVNnQ0FDSUFheUlCUVpEVUFDZ0NBRWtOQVNBQUlBUnFJUVFDUUFKQVFaVFVBQ2dDQUNBQlJ3UkFJQUJCL3dGTkJFQWdBRUVEZGlFRElBRW9BZ2dpQUNBQktBSU1JZ0pHQkVCQmdOUUFRWURVQUNnQ0FFRitJQU4zY1RZQ0FBd0ZDeUFDSUFBMkFnZ2dBQ0FDTmdJTURBUUxJQUVvQWhnaEJpQUJJQUVvQWd3aUFFY0VRQ0FBSUFFb0FnZ2lBallDQ0NBQ0lBQTJBZ3dNQXdzZ0FVRVVhaUlES0FJQUlnSkZCRUFnQVNnQ0VDSUNSUTBDSUFGQkVHb2hBd3NEUUNBRElRY2dBaUlBUVJScUlnTW9BZ0FpQWcwQUlBQkJFR29oQXlBQUtBSVFJZ0lOQUFzZ0IwRUFOZ0lBREFJTElBVW9BZ1FpQUVFRGNVRURSdzBDSUFVZ0FFRitjVFlDQkVHSTFBQWdCRFlDQUNBRklBUTJBZ0FnQVNBRVFRRnlOZ0lFREFNTFFRQWhBQXNnQmtVTkFBSkFJQUVvQWh3aUFrRUNkRUd3MWdCcUlnTW9BZ0FnQVVZRVFDQURJQUEyQWdBZ0FBMEJRWVRVQUVHRTFBQW9BZ0JCZmlBQ2QzRTJBZ0FNQWdzZ0JrRVFRUlFnQmlnQ0VDQUJSaHRxSUFBMkFnQWdBRVVOQVFzZ0FDQUdOZ0lZSUFFb0FoQWlBZ1JBSUFBZ0FqWUNFQ0FDSUFBMkFoZ0xJQUZCRkdvb0FnQWlBa1VOQUNBQVFSUnFJQUkyQWdBZ0FpQUFOZ0lZQ3lBQklBVlBEUUFnQlNnQ0JDSUFRUUZ4UlEwQUFrQUNRQUpBQWtBZ0FFRUNjVVVFUUVHWTFBQW9BZ0FnQlVZRVFFR1kxQUFnQVRZQ0FFR00xQUJCak5RQUtBSUFJQVJxSWdBMkFnQWdBU0FBUVFGeU5nSUVJQUZCbE5RQUtBSUFSdzBHUVlqVUFFRUFOZ0lBUVpUVUFFRUFOZ0lBREFZTFFaVFVBQ2dDQUNBRlJnUkFRWlRVQUNBQk5nSUFRWWpVQUVHSTFBQW9BZ0FnQkdvaUFEWUNBQ0FCSUFCQkFYSTJBZ1FnQUNBQmFpQUFOZ0lBREFZTElBQkJlSEVnQkdvaEJDQUFRZjhCVFFSQUlBQkJBM1loQXlBRktBSUlJZ0FnQlNnQ0RDSUNSZ1JBUVlEVUFFR0ExQUFvQWdCQmZpQURkM0UyQWdBTUJRc2dBaUFBTmdJSUlBQWdBallDREF3RUN5QUZLQUlZSVFZZ0JTQUZLQUlNSWdCSEJFQkJrTlFBS0FJQUdpQUFJQVVvQWdnaUFqWUNDQ0FDSUFBMkFnd01Bd3NnQlVFVWFpSURLQUlBSWdKRkJFQWdCU2dDRUNJQ1JRMENJQVZCRUdvaEF3c0RRQ0FESVFjZ0FpSUFRUlJxSWdNb0FnQWlBZzBBSUFCQkVHb2hBeUFBS0FJUUlnSU5BQXNnQjBFQU5nSUFEQUlMSUFVZ0FFRitjVFlDQkNBQklBUnFJQVEyQWdBZ0FTQUVRUUZ5TmdJRURBTUxRUUFoQUFzZ0JrVU5BQUpBSUFVb0Fod2lBa0VDZEVHdzFnQnFJZ01vQWdBZ0JVWUVRQ0FESUFBMkFnQWdBQTBCUVlUVUFFR0UxQUFvQWdCQmZpQUNkM0UyQWdBTUFnc2dCa0VRUVJRZ0JpZ0NFQ0FGUmh0cUlBQTJBZ0FnQUVVTkFRc2dBQ0FHTmdJWUlBVW9BaEFpQWdSQUlBQWdBallDRUNBQ0lBQTJBaGdMSUFWQkZHb29BZ0FpQWtVTkFDQUFRUlJxSUFJMkFnQWdBaUFBTmdJWUN5QUJJQVJxSUFRMkFnQWdBU0FFUVFGeU5nSUVJQUZCbE5RQUtBSUFSdzBBUVlqVUFDQUVOZ0lBREFFTElBUkIvd0ZOQkVBZ0JFRjRjVUdvMUFCcUlRQUNmMEdBMUFBb0FnQWlBa0VCSUFSQkEzWjBJZ054UlFSQVFZRFVBQ0FDSUFOeU5nSUFJQUFNQVFzZ0FDZ0NDQXNpQWlBQk5nSU1JQUFnQVRZQ0NDQUJJQUEyQWd3Z0FTQUNOZ0lJREFFTFFSOGhBaUFFUWYvLy93ZE5CRUFnQkVFbUlBUkJDSFpuSWdCcmRrRUJjU0FBUVFGMGEwRSthaUVDQ3lBQklBSTJBaHdnQVVJQU53SVFJQUpCQW5SQnNOWUFhaUVBQWtCQmhOUUFLQUlBSWdOQkFTQUNkQ0lIY1VVRVFDQUFJQUUyQWdCQmhOUUFJQU1nQjNJMkFnQWdBU0FBTmdJWUlBRWdBVFlDQ0NBQklBRTJBZ3dNQVFzZ0JFRVpJQUpCQVhaclFRQWdBa0VmUnh0MElRSWdBQ2dDQUNFQUFrQURRQ0FBSWdNb0FnUkJlSEVnQkVZTkFTQUNRUjEySVFBZ0FrRUJkQ0VDSUFNZ0FFRUVjV3BCRUdvaUJ5Z0NBQ0lBRFFBTElBY2dBVFlDQUNBQklBTTJBaGdnQVNBQk5nSU1JQUVnQVRZQ0NBd0JDeUFES0FJSUlnQWdBVFlDRENBRElBRTJBZ2dnQVVFQU5nSVlJQUVnQXpZQ0RDQUJJQUEyQWdnTFFhRFVBRUdnMUFBb0FnQkJBV3NpQUVGL0lBQWJOZ0lBQ3dzSEFDQUFMUUFvQ3djQUlBQXRBQ29MQndBZ0FDMEFLd3NIQUNBQUxRQXBDd2NBSUFBdkFUUUxCd0FnQUMwQU1BdEFBUVIvSUFBb0FoZ2hBU0FBTHdFdUlRSWdBQzBBS0NFRElBQW9BamdoQkNBQUVEY2dBQ0FFTmdJNElBQWdBem9BS0NBQUlBSTdBUzRnQUNBQk5nSVlDOFg0QVFJSGZ3TitJQUVnQW1vaEJBSkFJQUFpQXlnQ0RDSUFEUUFnQXlnQ0JBUkFJQU1nQVRZQ0JBc2pBRUVRYXlJSkpBQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFuOENRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQXlnQ0hDSUNRUUZyRHV3QjdnRUI2QUVDQXdRRkJnY0lDUW9MREEwT0R4QVJFdWNCRStZQkZCWGxBUllYNUFFWUdSb2JIQjBlSHlEdkFlMEJJZU1CSWlNa0pTWW5LQ2txSytJQkxDMHVMekF4TXVFQjRBRXpOTjhCM2dFMU5qYzRPVG83UEQwK1AwQkJRa05FUlVaSFNFbEtTMHhOVGsvcEFWQlJVbFBkQWR3QlZOc0JWZG9CVmxkWVdWcGJYRjFlWDJCaFltTmtaV1puYUdscWEyeHRibTl3Y1hKemRIVjJkM2g1ZW50OGZYNS9nQUdCQVlJQmd3R0VBWVVCaGdHSEFZZ0JpUUdLQVlzQmpBR05BWTRCandHUUFaRUJrZ0dUQVpRQmxRR1dBWmNCbUFHWkFab0Jtd0djQVowQm5nR2ZBYUFCb1FHaUFhTUJwQUdsQWFZQnB3R29BYWtCcWdHckFhd0JyUUd1QWE4QnNBR3hBYklCc3dHMEFiVUJ0Z0czQWJnQnVRRzZBYnNCdkFHOUFiNEJ2d0hBQWNFQndnSERBY1FCeFFIWkFkZ0J4Z0hYQWNjQjFnSElBY2tCeWdITEFjd0J6UUhPQWM4QjBBSFJBZElCMHdIVUFRRHFBUXRCQUF6VUFRdEJEZ3pUQVF0QkRRelNBUXRCRHd6UkFRdEJFQXpRQVF0QkVRelBBUXRCRWd6T0FRdEJFd3pOQVF0QkZBek1BUXRCRlF6TEFRdEJGZ3pLQVF0QkZ3ekpBUXRCR0F6SUFRdEJHUXpIQVF0QkdnekdBUXRCR3d6RkFRdEJIQXpFQVF0QkhRekRBUXRCSGd6Q0FRdEJId3pCQVF0QkNBekFBUXRCSUF5L0FRdEJJZ3krQVF0QklReTlBUXRCQnd5OEFRdEJJd3k3QVF0QkpBeTZBUXRCSlF5NUFRdEJKZ3k0QVF0Qkp3eTNBUXRCemdFTXRnRUxRU2dNdFFFTFFTa010QUVMUVNvTXN3RUxRU3NNc2dFTFFjOEJETEVCQzBFdERMQUJDMEV1REs4QkMwRXZESzRCQzBFd0RLMEJDMEV4REt3QkMwRXlES3NCQzBFekRLb0JDMEhRQVF5cEFRdEJOQXlvQVF0Qk9BeW5BUXRCREF5bUFRdEJOUXlsQVF0Qk5neWtBUXRCTnd5akFRdEJQUXlpQVF0Qk9ReWhBUXRCMFFFTW9BRUxRUXNNbndFTFFUNE1uZ0VMUVRvTW5RRUxRUW9NbkFFTFFUc01td0VMUVR3TW1nRUxRZElCREprQkMwSEFBQXlZQVF0QlB3eVhBUXRCd1FBTWxnRUxRUWtNbFFFTFFTd01sQUVMUWNJQURKTUJDMEhEQUF5U0FRdEJ4QUFNa1FFTFFjVUFESkFCQzBIR0FBeVBBUXRCeHdBTWpnRUxRY2dBREkwQkMwSEpBQXlNQVF0QnlnQU1pd0VMUWNzQURJb0JDMEhNQUF5SkFRdEJ6UUFNaUFFTFFjNEFESWNCQzBIUEFBeUdBUXRCMEFBTWhRRUxRZEVBRElRQkMwSFNBQXlEQVF0QjFBQU1nZ0VMUWRNQURJRUJDMEhWQUF5QUFRdEIxZ0FNZnd0QjF3QU1mZ3RCMkFBTWZRdEIyUUFNZkF0QjJnQU1ld3RCMndBTWVndEIwd0VNZVF0QjNBQU1lQXRCM1FBTWR3dEJCZ3gyQzBIZUFBeDFDMEVGREhRTFFkOEFESE1MUVFRTWNndEI0QUFNY1F0QjRRQU1jQXRCNGdBTWJ3dEI0d0FNYmd0QkF3eHRDMEhrQUF4c0MwSGxBQXhyQzBIbUFBeHFDMEhvQUF4cEMwSG5BQXhvQzBIcEFBeG5DMEhxQUF4bUMwSHJBQXhsQzBIc0FBeGtDMEVDREdNTFFlMEFER0lMUWU0QURHRUxRZThBREdBTFFmQUFERjhMUWZFQURGNExRZklBREYwTFFmTUFERndMUWZRQURGc0xRZlVBREZvTFFmWUFERmtMUWZjQURGZ0xRZmdBREZjTFFma0FERllMUWZvQURGVUxRZnNBREZRTFFmd0FERk1MUWYwQURGSUxRZjRBREZFTFFmOEFERkFMUVlBQkRFOExRWUVCREU0TFFZSUJERTBMUVlNQkRFd0xRWVFCREVzTFFZVUJERW9MUVlZQkRFa0xRWWNCREVnTFFZZ0JERWNMUVlrQkRFWUxRWW9CREVVTFFZc0JERVFMUVl3QkRFTUxRWTBCREVJTFFZNEJERUVMUVk4QkRFQUxRWkFCREQ4TFFaRUJERDRMUVpJQkREMExRWk1CRER3TFFaUUJERHNMUVpVQkREb0xRWllCRERrTFFaY0JERGdMUVpnQkREY0xRWmtCRERZTFFab0JERFVMUVpzQkREUUxRWndCRERNTFFaMEJERElMUVo0QkRERUxRWjhCRERBTFFhQUJEQzhMUWFFQkRDNExRYUlCREMwTFFhTUJEQ3dMUWFRQkRDc0xRYVVCRENvTFFhWUJEQ2tMUWFjQkRDZ0xRYWdCRENjTFFha0JEQ1lMUWFvQkRDVUxRYXNCRENRTFFhd0JEQ01MUWEwQkRDSUxRYTRCRENFTFFhOEJEQ0FMUWJBQkRCOExRYkVCREI0TFFiSUJEQjBMUWJNQkRCd0xRYlFCREJzTFFiVUJEQm9MUWJZQkRCa0xRYmNCREJnTFFiZ0JEQmNMUVFFTUZndEJ1UUVNRlF0QnVnRU1GQXRCdXdFTUV3dEJ2QUVNRWd0QnZRRU1FUXRCdmdFTUVBdEJ2d0VNRHd0QndBRU1EZ3RCd1FFTURRdEJ3Z0VNREF0Qnd3RU1Dd3RCeEFFTUNndEJ4UUVNQ1F0QnhnRU1DQXRCMUFFTUJ3dEJ4d0VNQmd0QnlBRU1CUXRCeVFFTUJBdEJ5Z0VNQXd0Qnl3RU1BZ3RCelFFTUFRdEJ6QUVMSVFJRFFBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFNQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBbjhDUUFKQUFrQUNRQUpBQWtBQ1FBSi9Ba0FDUUFKQUFuOENRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQU1DZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FDRHRRQkFBRUNBd1FGQmdjSUNRb0xEQTBPRHhBUkZCVVdGeGdaR2hzY0hSNGZJQ0VqSkNVbktDbUlBNGNEaFFPRUEvd0M5UUx1QXVzQzZBTG1BdU1DNEFMZkF0MEMyd0xXQXRVQzFBTFRBdElDeWdMSkFzZ0N4d0xHQXNVQ3hBTERBcjBDdkFLNkFya0N1QUszQXJZQ3RRSzBBcklDc1FLc0Fxb0NxQUtuQXFZQ3BRS2tBcU1Db2dLaEFxQUNud0tiQXBvQ21RS1lBcGNDa0FLSUFvUUNnd0tDQXZrQjlnSDFBZlFCOHdIeUFmRUI4QUh2QWUwQjZ3SG9BZU1CNFFIZ0FkOEIzZ0hkQWR3QjJ3SGFBZGtCMkFIWEFkWUIxUUhVQWRJQjBRSFFBYzhCemdITkFjd0J5d0hLQWNrQnlBSEhBY1lCeFFIRUFjTUJ3Z0hCQWNBQnZ3RytBYjBCdkFHN0Fib0J1UUc0QWJjQnRnRzFBYlFCc3dHeUFiRUJzQUd2QWE0QnJRR3NBYXNCcWdHcEFhZ0Jwd0dtQWFVQnBBR2pBYUlCb1FHZ0FaOEJuZ0dkQVp3Qm13R2FBWmNCbGdHUkFaQUJqd0dPQVkwQmpBR0xBWW9CaVFHSUFZVUJoQUdEQVg1OWZIdDZkM1oxTEZGU1UxUlZWZ3NnQVNBRVJ3MXpRZXdCSVFJTXFRTUxJQUVnQkVjTmtBRkIwUUVoQWd5b0F3c2dBU0FFUnczcEFVR0VBU0VDREtjREN5QUJJQVJIRGZRQlFmb0FJUUlNcGdNTElBRWdCRWNOZ2dKQjlRQWhBZ3lsQXdzZ0FTQUVSdzJKQWtIekFDRUNES1FEQ3lBQklBUkhEWXdDUWZFQUlRSU1vd01MSUFFZ0JFY05Ia0VlSVFJTW9nTUxJQUVnQkVjTkdVRVlJUUlNb1FNTElBRWdCRWNOdUFKQnpRQWhBZ3lnQXdzZ0FTQUVSdzNEQWtIR0FDRUNESjhEQ3lBQklBUkhEY1FDUWNNQUlRSU1uZ01MSUFFZ0JFY055Z0pCT0NFQ0RKMERDeUFETFFBd1FRRkdEWlVERFBJQ0MwRUFJUUFDUUFKQUFrQWdBeTBBS2tVTkFDQURMUUFyUlEwQUlBTXZBVElpQWtFQ2NVVU5BUXdDQ3lBREx3RXlJZ0pCQVhGRkRRRUxRUUVoQUNBRExRQW9RUUZHRFFBZ0F5OEJOQ0lHUWVRQWEwSGtBRWtOQUNBR1Fjd0JSZzBBSUFaQnNBSkdEUUFnQWtIQUFIRU5BRUVBSVFBZ0FrR0lCSEZCZ0FSR0RRQWdBa0VvY1VFQVJ5RUFDeUFEUVFBN0FUSWdBMEVBT2dBeEFrQWdBRVVFUUNBRFFRQTZBREVnQXkwQUxrRUVjUTBCREp3REN5QURRZ0EzQXlBTElBTkJBRG9BTVNBRFFRRTZBRFlNU1F0QkFDRUFBa0FnQXlnQ09DSUNSUTBBSUFJb0Fpd2lBa1VOQUNBRElBSVJBQUFoQUFzZ0FFVU5TU0FBUVJWSERXTWdBMEVFTmdJY0lBTWdBVFlDRkNBRFFiMGFOZ0lRSUFOQkZUWUNERUVBSVFJTW1nTUxJQUVnQkVZRVFFRUdJUUlNbWdNTElBRXRBQUJCQ2tZTkdRd0JDeUFCSUFSR0JFQkJCeUVDREprREN3SkFJQUV0QUFCQkNtc09CQUlCQVFBQkN5QUJRUUZxSVFGQkVDRUNEUDRDQ3lBRExRQXVRWUFCY1EwWVFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJxUjgyQWhBZ0EwRUNOZ0lNREpjREN5QUJRUUZxSVFFZ0EwRXZhaTBBQUVFQmNRMFhRUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5CaEI4MkFoQWdBMEVaTmdJTURKWURDeUFESUFNcEF5QWlEQ0FFSUFGcnJTSUtmU0lMUWdBZ0N5QU1XQnMzQXlBZ0NpQU1XZzBaUVFnaEFneVZBd3NnQVNBRVJ3UkFJQU5CQ1RZQ0NDQURJQUUyQWdSQkVpRUNEUHNDQzBFSklRSU1sQU1MSUFNcEF5QlFEWndDREVRTElBRWdCRVlFUUVFTElRSU1rd01MSUFFdEFBQkJDa2NORnlBQlFRRnFJUUVNR0FzZ0EwRXZhaTBBQUVFQmNVVU5HZ3duQzBFQUlRQUNRQ0FES0FJNElnSkZEUUFnQWlnQ1NDSUNSUTBBSUFNZ0FoRUFBQ0VBQ3lBQURSb01Rd3RCQUNFQUFrQWdBeWdDT0NJQ1JRMEFJQUlvQWtnaUFrVU5BQ0FESUFJUkFBQWhBQXNnQUEwYkRDVUxRUUFoQUFKQUlBTW9BamdpQWtVTkFDQUNLQUpJSWdKRkRRQWdBeUFDRVFBQUlRQUxJQUFOSEF3ekN5QURRUzlxTFFBQVFRRnhSUTBkRENNTFFRQWhBQUpBSUFNb0FqZ2lBa1VOQUNBQ0tBSk1JZ0pGRFFBZ0F5QUNFUUFBSVFBTElBQU5IUXhEQzBFQUlRQUNRQ0FES0FJNElnSkZEUUFnQWlnQ1RDSUNSUTBBSUFNZ0FoRUFBQ0VBQ3lBQURSNE1JUXNnQVNBRVJnUkFRUk1oQWd5TEF3c0NRQ0FCTFFBQUlnQkJDbXNPQkNBa0pBQWpDeUFCUVFGcUlRRU1JQXRCQUNFQUFrQWdBeWdDT0NJQ1JRMEFJQUlvQWt3aUFrVU5BQ0FESUFJUkFBQWhBQXNnQUEwakRFTUxJQUVnQkVZRVFFRVdJUUlNaVFNTElBRXRBQUJCOEQ5cUxRQUFRUUZIRFNRTTdRSUxBa0FEUUNBQkxRQUFRZUE1YWkwQUFDSUFRUUZIQkVBQ1FDQUFRUUpyRGdJREFDZ0xJQUZCQVdvaEFVRWZJUUlNOEFJTElBUWdBVUVCYWlJQlJ3MEFDMEVZSVFJTWlBTUxJQU1vQWdRaEFFRUFJUUlnQTBFQU5nSUVJQU1nQUNBQlFRRnFJZ0VRTXlJQURTSU1RZ3RCQUNFQUFrQWdBeWdDT0NJQ1JRMEFJQUlvQWt3aUFrVU5BQ0FESUFJUkFBQWhBQXNnQUEwa0RDc0xJQUVnQkVZRVFFRWNJUUlNaGdNTElBTkJDallDQ0NBRElBRTJBZ1JCQUNFQUFrQWdBeWdDT0NJQ1JRMEFJQUlvQWtnaUFrVU5BQ0FESUFJUkFBQWhBQXNnQUEwbVFTSWhBZ3pyQWdzZ0FTQUVSd1JBQTBBZ0FTMEFBRUhnTzJvdEFBQWlBRUVEUndSQUlBQkJBV3NPQlJrYkord0NKaWNMSUFRZ0FVRUJhaUlCUncwQUMwRWJJUUlNaFFNTFFSc2hBZ3lFQXdzRFFDQUJMUUFBUWVBOWFpMEFBQ0lBUVFOSEJFQWdBRUVCYXc0RkVCSW9GQ2NvQ3lBRUlBRkJBV29pQVVjTkFBdEJIaUVDRElNREN5QUJJQVJIQkVBZ0EwRUxOZ0lJSUFNZ0FUWUNCRUVISVFJTTZRSUxRUjhoQWd5Q0F3c2dBU0FFUmdSQVFTQWhBZ3lDQXdzQ1FDQUJMUUFBUVExckRoUXZRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUFMUVFBaEFpQURRUUEyQWh3Z0EwRzNDellDRUNBRFFRSTJBZ3dnQXlBQlFRRnFOZ0lVRElFREN5QURRUzlxSVFJRFFDQUJJQVJHQkVCQklTRUNESUlEQ3dKQUFrQUNRQ0FCTFFBQUlnQkJDV3NPR0FJQUtpb0JLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FBaWdMSUFGQkFXb2hBU0FEUVM5cUxRQUFRUUZ4UlEwTERCa0xJQUZCQVdvaEFRd1lDeUFCUVFGcUlRRWdBaTBBQUVFQ2NRMEFDMEVBSVFJZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWM0VU5nSVFJQU5CRERZQ0RBeUFBd3NnQVVFQmFpRUJDMEVBSVFBQ1FDQURLQUk0SWdKRkRRQWdBaWdDVkNJQ1JRMEFJQU1nQWhFQUFDRUFDeUFBRFFFTTBRSUxJQU5DQURjRElBdzhDeUFBUVJWR0JFQWdBMEVrTmdJY0lBTWdBVFlDRkNBRFFZWWFOZ0lRSUFOQkZUWUNERUVBSVFJTS9RSUxRUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5CNGcwMkFoQWdBMEVVTmdJTURQd0NDeUFES0FJRUlRQkJBQ0VDSUFOQkFEWUNCQ0FESUFBZ0FTQU1wMm9pQVJBeElnQkZEU3NnQTBFSE5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd3TSt3SUxJQU10QUM1QndBQnhSUTBCQzBFQUlRQUNRQ0FES0FJNElnSkZEUUFnQWlnQ1VDSUNSUTBBSUFNZ0FoRUFBQ0VBQ3lBQVJRMHJJQUJCRlVZRVFDQURRUW8yQWh3Z0F5QUJOZ0lVSUFOQjhSZzJBaEFnQTBFVk5nSU1RUUFoQWd6NkFndEJBQ0VDSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdMRERZQ0VDQURRUk0yQWd3TStRSUxRUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5Cc1JRMkFoQWdBMEVDTmdJTURQZ0NDMEVBSVFJZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUVl3VU5nSVFJQU5CR1RZQ0RBejNBZ3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBIUkhEWUNFQ0FEUVJrMkFnd005Z0lMSUFCQkZVWU5QVUVBSVFJZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWFJUE5nSVFJQU5CSWpZQ0RBejFBZ3NnQXlnQ0JDRUFRUUFoQWlBRFFRQTJBZ1FnQXlBQUlBRVFNaUlBUlEwb0lBTkJEVFlDSENBRElBRTJBaFFnQXlBQU5nSU1EUFFDQ3lBQVFSVkdEVHBCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBHaUR6WUNFQ0FEUVNJMkFnd004d0lMSUFNb0FnUWhBRUVBSVFJZ0EwRUFOZ0lFSUFNZ0FDQUJFRElpQUVVRVFDQUJRUUZxSVFFTUtBc2dBMEVPTmdJY0lBTWdBRFlDRENBRElBRkJBV28yQWhRTThnSUxJQUJCRlVZTk4wRUFJUUlnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRYUlQTmdJUUlBTkJJallDREF6eEFnc2dBeWdDQkNFQVFRQWhBaUFEUVFBMkFnUWdBeUFBSUFFUU1pSUFSUVJBSUFGQkFXb2hBUXduQ3lBRFFRODJBaHdnQXlBQU5nSU1JQU1nQVVFQmFqWUNGQXp3QWd0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSG9GallDRUNBRFFSazJBZ3dNN3dJTElBQkJGVVlOTTBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFjNE1OZ0lRSUFOQkl6WUNEQXp1QWdzZ0F5Z0NCQ0VBUVFBaEFpQURRUUEyQWdRZ0F5QUFJQUVRTXlJQVJRMGxJQU5CRVRZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNRE8wQ0N5QUFRUlZHRFRCQkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSE9ERFlDRUNBRFFTTTJBZ3dNN0FJTElBTW9BZ1FoQUVFQUlRSWdBMEVBTmdJRUlBTWdBQ0FCRURNaUFFVUVRQ0FCUVFGcUlRRU1KUXNnQTBFU05nSWNJQU1nQURZQ0RDQURJQUZCQVdvMkFoUU02d0lMSUFOQkwyb3RBQUJCQVhGRkRRRUxRUlVoQWd6UEFndEJBQ0VDSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEhvRmpZQ0VDQURRUmsyQWd3TTZBSUxJQUJCTzBjTkFDQUJRUUZxSVFFTURBdEJBQ0VDSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdZRnpZQ0VDQURRUUkyQWd3TTVnSUxJQUJCRlVZTktFRUFJUUlnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRYzRNTmdJUUlBTkJJellDREF6bEFnc2dBMEVVTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3dNNUFJTElBTW9BZ1FoQUVFQUlRSWdBMEVBTmdJRUlBTWdBQ0FCRURNaUFFVUVRQ0FCUVFGcUlRRU0zQUlMSUFOQkZUWUNIQ0FESUFBMkFnd2dBeUFCUVFGcU5nSVVET01DQ3lBREtBSUVJUUJCQUNFQ0lBTkJBRFlDQkNBRElBQWdBUkF6SWdCRkJFQWdBVUVCYWlFQkROb0NDeUFEUVJjMkFod2dBeUFBTmdJTUlBTWdBVUVCYWpZQ0ZBemlBZ3NnQUVFVlJnMGpRUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5Cemd3MkFoQWdBMEVqTmdJTURPRUNDeUFES0FJRUlRQkJBQ0VDSUFOQkFEWUNCQ0FESUFBZ0FSQXpJZ0JGQkVBZ0FVRUJhaUVCREIwTElBTkJHVFlDSENBRElBQTJBZ3dnQXlBQlFRRnFOZ0lVRE9BQ0N5QURLQUlFSVFCQkFDRUNJQU5CQURZQ0JDQURJQUFnQVJBeklnQkZCRUFnQVVFQmFpRUJETllDQ3lBRFFSbzJBaHdnQXlBQU5nSU1JQU1nQVVFQmFqWUNGQXpmQWdzZ0FFRVZSZzBmUVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQm9nODJBaEFnQTBFaU5nSU1ETjRDQ3lBREtBSUVJUUJCQUNFQ0lBTkJBRFlDQkNBRElBQWdBUkF5SWdCRkJFQWdBVUVCYWlFQkRCc0xJQU5CSERZQ0hDQURJQUEyQWd3Z0F5QUJRUUZxTmdJVUROMENDeUFES0FJRUlRQkJBQ0VDSUFOQkFEWUNCQ0FESUFBZ0FSQXlJZ0JGQkVBZ0FVRUJhaUVCRE5JQ0N5QURRUjAyQWh3Z0F5QUFOZ0lNSUFNZ0FVRUJhallDRkF6Y0Fnc2dBRUU3UncwQklBRkJBV29oQVF0QkpDRUNETUFDQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFjNFVOZ0lRSUFOQkREWUNEQXpaQWdzZ0FTQUVSd1JBQTBBZ0FTMEFBRUVnUnczeEFTQUVJQUZCQVdvaUFVY05BQXRCTENFQ0ROa0NDMEVzSVFJTTJBSUxJQUVnQkVZRVFFRTBJUUlNMkFJTEFrQUNRQU5BQWtBZ0FTMEFBRUVLYXc0RUFnQUFBd0FMSUFRZ0FVRUJhaUlCUncwQUMwRTBJUUlNMlFJTElBTW9BZ1FoQUNBRFFRQTJBZ1FnQXlBQUlBRVFNQ0lBUlEyTUFpQURRVEkyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTTJBSUxJQU1vQWdRaEFDQURRUUEyQWdRZ0F5QUFJQUVRTUNJQVJRUkFJQUZCQVdvaEFReU1BZ3NnQTBFeU5nSWNJQU1nQURZQ0RDQURJQUZCQVdvMkFoUkJBQ0VDRE5jQ0N5QUJJQVJIQkVBQ1FBTkFJQUV0QUFCQk1Hc2lBRUgvQVhGQkNrOEVRRUU1SVFJTXdBSUxJQU1wQXlBaUMwS1pzK2JNbWJQbXpCbFdEUUVnQXlBTFFncCtJZ28zQXlBZ0NpQUFyVUwvQVlNaUMwSi9oVllOQVNBRElBb2dDM3czQXlBZ0JDQUJRUUZxSWdGSERRQUxRY0FBSVFJTTJBSUxJQU1vQWdRaEFDQURRUUEyQWdRZ0F5QUFJQUZCQVdvaUFSQXdJZ0FORnd6SkFndEJ3QUFoQWd6V0Fnc2dBU0FFUmdSQVFja0FJUUlNMWdJTEFrQURRQUpBSUFFdEFBQkJDV3NPR0FBQ2p3S1BBcE1DandLUEFvOENqd0tQQW84Q2p3S1BBbzhDandLUEFvOENqd0tQQW84Q2p3S1BBbzhDQUk4Q0N5QUVJQUZCQVdvaUFVY05BQXRCeVFBaEFneldBZ3NnQVVFQmFpRUJJQU5CTDJvdEFBQkJBWEVOandJZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWVrUE5nSVFJQU5CQ2pZQ0RFRUFJUUlNMVFJTElBRWdCRWNFUUFOQUlBRXRBQUFpQUVFZ1J3UkFBa0FDUUFKQUlBQkJ5QUJyRGdzQUFjMEJ6UUhOQWMwQnpRSE5BYzBCelFFQ3pRRUxJQUZCQVdvaEFVSFpBQ0VDREw4Q0N5QUJRUUZxSVFGQjJnQWhBZ3krQWdzZ0FVRUJhaUVCUWRzQUlRSU12UUlMSUFRZ0FVRUJhaUlCUncwQUMwSHVBQ0VDRE5VQ0MwSHVBQ0VDRE5RQ0N5QURRUUk2QUNnTU1BdEJBQ0VDSUFOQkFEWUNIQ0FEUWJjTE5nSVFJQU5CQWpZQ0RDQURJQUZCQVdvMkFoUU0wZ0lMUVFBaEFneTNBZ3RCRFNFQ0RMWUNDMEVSSVFJTXRRSUxRUk1oQWd5MEFndEJGQ0VDRExNQ0MwRVdJUUlNc2dJTFFSY2hBZ3l4QWd0QkdDRUNETEFDQzBFWklRSU1yd0lMUVJvaEFneXVBZ3RCR3lFQ0RLMENDMEVjSVFJTXJBSUxRUjBoQWd5ckFndEJIaUVDREtvQ0MwRWdJUUlNcVFJTFFTRWhBZ3lvQWd0Qkl5RUNES2NDQzBFbklRSU1wZ0lMSUFOQlBUWUNIQ0FESUFFMkFoUWdBeUFBTmdJTVFRQWhBZ3kvQWdzZ0EwRWJOZ0ljSUFNZ0FUWUNGQ0FEUVk4Yk5nSVFJQU5CRlRZQ0RFRUFJUUlNdmdJTElBTkJJRFlDSENBRElBRTJBaFFnQTBHZUdUWUNFQ0FEUVJVMkFneEJBQ0VDREwwQ0N5QURRUk0yQWh3Z0F5QUJOZ0lVSUFOQm5oazJBaEFnQTBFVk5nSU1RUUFoQWd5OEFnc2dBMEVMTmdJY0lBTWdBVFlDRkNBRFFaNFpOZ0lRSUFOQkZUWUNERUVBSVFJTXV3SUxJQU5CRURZQ0hDQURJQUUyQWhRZ0EwR2VHVFlDRUNBRFFSVTJBZ3hCQUNFQ0RMb0NDeUFEUVNBMkFod2dBeUFCTmdJVUlBTkJqeHMyQWhBZ0EwRVZOZ0lNUVFBaEFneTVBZ3NnQTBFTE5nSWNJQU1nQVRZQ0ZDQURRWThiTmdJUUlBTkJGVFlDREVFQUlRSU11QUlMSUFOQkREWUNIQ0FESUFFMkFoUWdBMEdQR3pZQ0VDQURRUlUyQWd4QkFDRUNETGNDQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFhOE9OZ0lRSUFOQkVqWUNEQXkyQWdzQ1FBTkFBa0FnQVMwQUFFRUthdzRFQUFJQ0FBSUxJQVFnQVVFQmFpSUJSdzBBQzBIc0FTRUNETFlDQ3dKQUFrQWdBeTBBTmtFQlJ3MEFRUUFoQUFKQUlBTW9BamdpQWtVTkFDQUNLQUpZSWdKRkRRQWdBeUFDRVFBQUlRQUxJQUJGRFFBZ0FFRVZSdzBCSUFOQjZ3RTJBaHdnQXlBQk5nSVVJQU5CNGhnMkFoQWdBMEVWTmdJTVFRQWhBZ3kzQWd0QnpBRWhBZ3ljQWdzZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWZFTE5nSVFJQU5CSHpZQ0RFRUFJUUlNdFFJTEFrQUNRQ0FETFFBb1FRRnJEZ0lFQVFBTFFjc0JJUUlNbXdJTFFjUUJJUUlNbWdJTElBTkJBam9BTVVFQUlRQUNRQ0FES0FJNElnSkZEUUFnQWlnQ0FDSUNSUTBBSUFNZ0FoRUFBQ0VBQ3lBQVJRUkFRYzBCSVFJTW1nSUxJQUJCRlVjRVFDQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQnJBdzJBaEFnQTBFUU5nSU1RUUFoQWd5MEFnc2dBMEhxQVRZQ0hDQURJQUUyQWhRZ0EwR0hHVFlDRUNBRFFSVTJBZ3hCQUNFQ0RMTUNDeUFCSUFSR0JFQkI2UUVoQWd5ekFnc2dBUzBBQUVISUFFWU5BU0FEUVFFNkFDZ0xRYllCSVFJTWx3SUxRY29CSVFJTWxnSUxJQUVnQkVjRVFDQURRUXcyQWdnZ0F5QUJOZ0lFUWNrQklRSU1sZ0lMUWVnQklRSU1yd0lMSUFFZ0JFWUVRRUhuQVNFQ0RLOENDeUFCTFFBQVFjZ0FSdzBFSUFGQkFXb2hBVUhJQVNFQ0RKUUNDeUFCSUFSR0JFQkI1Z0VoQWd5dUFnc0NRQUpBSUFFdEFBQkJ4UUJyRGhBQUJRVUZCUVVGQlFVRkJRVUZCUVVCQlFzZ0FVRUJhaUVCUWNZQklRSU1sQUlMSUFGQkFXb2hBVUhIQVNFQ0RKTUNDMEhsQVNFQ0lBRWdCRVlOckFJZ0F5Z0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUNhaUVHQWtBRFFDQUJMUUFBSUFCQjk5TUFhaTBBQUVjTkF5QUFRUUpHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QURJQVUyQWdBTXJRSUxJQU1vQWdRaEFDQURRZ0EzQXdBZ0F5QUFJQVpCQVdvaUFSQXRJZ0JGQkVCQjFBRWhBZ3lUQWdzZ0EwSGtBVFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5c0FndEI0d0VoQWlBQklBUkdEYXNDSUFNb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFXb2hCZ0pBQTBBZ0FTMEFBQ0FBUWZYVEFHb3RBQUJIRFFJZ0FFRUJSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0F5QUZOZ0lBREt3Q0N5QURRWUVFT3dFb0lBTW9BZ1FoQUNBRFFnQTNBd0FnQXlBQUlBWkJBV29pQVJBdElnQU5Bd3dDQ3lBRFFRQTJBZ0FMUVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQjBCNDJBaEFnQTBFSU5nSU1ES2tDQzBIRkFTRUNESTRDQ3lBRFFlSUJOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFneEJBQ0VDREtjQ0MwRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NPQ0lDUlEwQUlBTWdBaEVBQUNFQUN5QUFSUTFsSUFCQkZVY0VRQ0FEUVFBMkFod2dBeUFCTmdJVUlBTkIxQTQyQWhBZ0EwRWdOZ0lNUVFBaEFneW5BZ3NnQTBHRkFUWUNIQ0FESUFFMkFoUWdBMEhYR2pZQ0VDQURRUlUyQWd4QkFDRUNES1lDQzBIaEFTRUNJQVFnQVNJQVJnMmxBaUFFSUFGcklBTW9BZ0FpQVdvaEJTQUFJQUZyUVFScUlRWUNRQU5BSUFBdEFBQWdBVUh3MHdCcUxRQUFSdzBCSUFGQkJFWU5BeUFCUVFGcUlRRWdCQ0FBUVFGcUlnQkhEUUFMSUFNZ0JUWUNBQXltQWdzZ0EwRUFOZ0ljSUFNZ0FEWUNGQ0FEUVlRM05nSVFJQU5CQ0RZQ0RDQURRUUEyQWdCQkFDRUNES1VDQ3lBQklBUkhCRUFnQTBFTk5nSUlJQU1nQVRZQ0JFSENBU0VDRElzQ0MwSGdBU0VDREtRQ0N5QURRUUEyQWdBZ0JrRUJhaUVCQzBIREFTRUNESWdDQ3lBQklBUkdCRUJCM3dFaEFneWlBZ3NnQVMwQUFFRXdheUlBUWY4QmNVRUtTUVJBSUFNZ0FEb0FLaUFCUVFGcUlRRkJ3UUVoQWd5SUFnc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkF1SWdCRkRZZ0NJQU5CM2dFMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1vUUlMSUFFZ0JFWUVRRUhkQVNFQ0RLRUNDd0pBSUFFdEFBQkJMa1lFUUNBQlFRRnFJUUVNQVFzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXVJZ0JGRFlrQ0lBTkIzQUUyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTW9RSUxRY0FCSVFJTWhnSUxJQUVnQkVZRVFFSGJBU0VDREtBQ0MwRUFJUUJCQVNFRlFRRWhCMEVBSVFJQ1FBSkFBa0FDUUFKQUFuOENRQUpBQWtBQ1FBSkFBa0FDUUNBQkxRQUFRVEJyRGdvS0NRQUJBZ01FQlFZSUN3dEJBZ3dHQzBFRERBVUxRUVFNQkF0QkJRd0RDMEVHREFJTFFRY01BUXRCQ0FzaEFrRUFJUVZCQUNFSERBSUxRUWtoQWtFQklRQkJBQ0VGUVFBaEJ3d0JDMEVBSVFWQkFTRUNDeUFESUFJNkFDc2dBVUVCYWlFQkFrQUNRQ0FETFFBdVFSQnhEUUFDUUFKQUFrQWdBeTBBS2c0REFRQUNCQXNnQjBVTkF3d0NDeUFBRFFFTUFnc2dCVVVOQVFzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXVJZ0JGRFFJZ0EwSFlBVFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5aUFnc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkF1SWdCRkRZc0NJQU5CMlFFMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1vUUlMSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUUxpSUFSUTJKQWlBRFFkb0JOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFnd01vQUlMUWI4QklRSU1oUUlMUVFBaEFBSkFJQU1vQWpnaUFrVU5BQ0FDS0FJOElnSkZEUUFnQXlBQ0VRQUFJUUFMQWtBZ0FBUkFJQUJCRlVZTkFTQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQm5BMDJBaEFnQTBFaE5nSU1RUUFoQWd5Z0FndEJ2Z0VoQWd5RkFnc2dBMEhYQVRZQ0hDQURJQUUyQWhRZ0EwSFdHVFlDRUNBRFFSVTJBZ3hCQUNFQ0RKNENDeUFCSUFSR0JFQkIxd0VoQWd5ZUFnc0NRQ0FCTFFBQVFTQkdCRUFnQTBFQU93RTBJQUZCQVdvaEFRd0JDeUFEUVFBMkFod2dBeUFCTmdJVUlBTkI2eEEyQWhBZ0EwRUpOZ0lNUVFBaEFneWVBZ3RCdlFFaEFneURBZ3NnQVNBRVJnUkFRZFlCSVFJTW5RSUxBa0FnQVMwQUFFRXdhMEgvQVhFaUFrRUtTUVJBSUFGQkFXb2hBUUpBSUFNdkFUUWlBRUdaTTBzTkFDQURJQUJCQ213aUFEc0JOQ0FBUWY3L0EzRWdBa0gvL3dOelN3MEFJQU1nQUNBQ2Fqc0JOQXdDQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFZQWROZ0lRSUFOQkRUWUNEQXllQWdzZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUVlBZE5nSVFJQU5CRFRZQ0RFRUFJUUlNblFJTFFid0JJUUlNZ2dJTElBRWdCRVlFUUVIVkFTRUNESndDQ3dKQUlBRXRBQUJCTUd0Qi93RnhJZ0pCQ2trRVFDQUJRUUZxSVFFQ1FDQURMd0UwSWdCQm1UTkxEUUFnQXlBQVFRcHNJZ0E3QVRRZ0FFSCsvd054SUFKQi8vOERjMHNOQUNBRElBQWdBbW83QVRRTUFndEJBQ0VDSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdBSFRZQ0VDQURRUTAyQWd3TW5RSUxJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR0FIVFlDRUNBRFFRMDJBZ3hCQUNFQ0RKd0NDMEc3QVNFQ0RJRUNDeUFCSUFSR0JFQkIxQUVoQWd5YkFnc0NRQ0FCTFFBQVFUQnJRZjhCY1NJQ1FRcEpCRUFnQVVFQmFpRUJBa0FnQXk4Qk5DSUFRWmt6U3cwQUlBTWdBRUVLYkNJQU93RTBJQUJCL3Y4RGNTQUNRZi8vQTNOTERRQWdBeUFBSUFKcU93RTBEQUlMUVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQmdCMDJBaEFnQTBFTk5nSU1ESndDQ3lBRFFRQTJBaHdnQXlBQk5nSVVJQU5CZ0IwMkFoQWdBMEVOTmdJTVFRQWhBZ3liQWd0QnVnRWhBZ3lBQWdzZ0FTQUVSZ1JBUWRNQklRSU1tZ0lMQWtBQ1FBSkFBa0FnQVMwQUFFRUthdzRYQWdNREFBTURBd01EQXdNREF3TURBd01EQXdNREF3RURDeUFCUVFGcURBVUxJQUZCQVdvaEFVRzVBU0VDRElFQ0N5QUJRUUZxSVFFZ0EwRXZhaTBBQUVFQmNRMElJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR0ZDellDRUNBRFFRMDJBZ3hCQUNFQ0RKb0NDeUFEUVFBMkFod2dBeUFCTmdJVUlBTkJoUXMyQWhBZ0EwRU5OZ0lNUVFBaEFneVpBZ3NnQVNBRVJ3UkFJQU5CRGpZQ0NDQURJQUUyQWdSQkFTRUNEUDhCQzBIU0FTRUNESmdDQ3dKQUFrQURRQUpBSUFFdEFBQkJDbXNPQkFJQUFBTUFDeUFFSUFGQkFXb2lBVWNOQUF0QjBRRWhBZ3laQWdzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXNJZ0JGQkVBZ0FVRUJhaUVCREFRTElBTkIwQUUyQWh3Z0F5QUFOZ0lNSUFNZ0FVRUJhallDRkVFQUlRSU1tQUlMSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUUxDSUFEUUVnQVVFQmFnc2hBVUczQVNFQ0RQd0JDeUFEUWM4Qk5nSWNJQU1nQURZQ0RDQURJQUZCQVdvMkFoUkJBQ0VDREpVQ0MwRzRBU0VDRFBvQkN5QURRUzlxTFFBQVFRRnhEUUVnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRYzhiTmdJUUlBTkJHVFlDREVFQUlRSU1rd0lMSUFFZ0JFWUVRRUhQQVNFQ0RKTUNDd0pBQWtBQ1FDQUJMUUFBUVFwckRnUUJBZ0lBQWdzZ0FVRUJhaUVCREFJTElBRkJBV29oQVF3QkN5QURMUUF1UWNBQWNVVU5BUXRCQUNFQUFrQWdBeWdDT0NJQ1JRMEFJQUlvQWpRaUFrVU5BQ0FESUFJUkFBQWhBQXNnQUVVTmxnRWdBRUVWUmdSQUlBTkIyUUEyQWh3Z0F5QUJOZ0lVSUFOQnZSazJBaEFnQTBFVk5nSU1RUUFoQWd5U0Fnc2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFmZ01OZ0lRSUFOQkd6WUNERUVBSVFJTWtRSUxJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSEhKellDRUNBRFFRSTJBZ3hCQUNFQ0RKQUNDeUFCSUFSSEJFQWdBMEVNTmdJSUlBTWdBVFlDQkVHMUFTRUNEUFlCQzBIT0FTRUNESThDQ3lBQklBUkdCRUJCelFFaEFneVBBZ3NDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUV0QUFCQndRQnJEaFVBQVFJRFdnUUZCbHBhV2djSUNRb0xEQTBPRHhCYUN5QUJRUUZxSVFGQjhRQWhBZ3lFQWdzZ0FVRUJhaUVCUWZJQUlRSU1nd0lMSUFGQkFXb2hBVUgzQUNFQ0RJSUNDeUFCUVFGcUlRRkIrd0FoQWd5QkFnc2dBVUVCYWlFQlFmd0FJUUlNZ0FJTElBRkJBV29oQVVIL0FDRUNEUDhCQ3lBQlFRRnFJUUZCZ0FFaEFneitBUXNnQVVFQmFpRUJRWU1CSVFJTS9RRUxJQUZCQVdvaEFVR01BU0VDRFB3QkN5QUJRUUZxSVFGQmpRRWhBZ3o3QVFzZ0FVRUJhaUVCUVk0QklRSU0rZ0VMSUFGQkFXb2hBVUdiQVNFQ0RQa0JDeUFCUVFGcUlRRkJuQUVoQWd6NEFRc2dBVUVCYWlFQlFhSUJJUUlNOXdFTElBRkJBV29oQVVHcUFTRUNEUFlCQ3lBQlFRRnFJUUZCclFFaEFnejFBUXNnQVVFQmFpRUJRYlFCSVFJTTlBRUxJQUVnQkVZRVFFSE1BU0VDREk0Q0N5QUJMUUFBUWM0QVJ3MUlJQUZCQVdvaEFVR3pBU0VDRFBNQkN5QUJJQVJHQkVCQnl3RWhBZ3lOQWdzQ1FBSkFBa0FnQVMwQUFFSENBR3NPRWdCS1NrcEtTa3BLU2tvQlNrcEtTa3BLQWtvTElBRkJBV29oQVVHdUFTRUNEUFFCQ3lBQlFRRnFJUUZCc1FFaEFnenpBUXNnQVVFQmFpRUJRYklCSVFJTThnRUxRY29CSVFJZ0FTQUVSZzJMQWlBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRZHFJUVlDUUFOQUlBRXRBQUFnQUVIbzB3QnFMUUFBUncxRklBQkJCMFlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF5TUFnc2dBMEVBTmdJQUlBWkJBV29oQVVFYkRFVUxJQUVnQkVZRVFFSEpBU0VDRElzQ0N3SkFBa0FnQVMwQUFFSEpBR3NPQndCSFIwZEhSd0ZIQ3lBQlFRRnFJUUZCcndFaEFnenhBUXNnQVVFQmFpRUJRYkFCSVFJTThBRUxRY2dCSVFJZ0FTQUVSZzJKQWlBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVIbTB3QnFMUUFBUncxRElBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF5S0Fnc2dBMEVBTmdJQUlBWkJBV29oQVVFUERFTUxRY2NCSVFJZ0FTQUVSZzJJQWlBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVIazB3QnFMUUFBUncxQ0lBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF5SkFnc2dBMEVBTmdJQUlBWkJBV29oQVVFZ0RFSUxRY1lCSVFJZ0FTQUVSZzJIQWlBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVIaDB3QnFMUUFBUncxQklBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF5SUFnc2dBMEVBTmdJQUlBWkJBV29oQVVFU0RFRUxJQUVnQkVZRVFFSEZBU0VDREljQ0N3SkFBa0FnQVMwQUFFSEZBR3NPRGdCRFEwTkRRME5EUTBORFEwTUJRd3NnQVVFQmFpRUJRYXNCSVFJTTdRRUxJQUZCQVdvaEFVR3NBU0VDRE93QkMwSEVBU0VDSUFFZ0JFWU5oUUlnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCM3RNQWFpMEFBRWNOUHlBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNaGdJTElBTkJBRFlDQUNBR1FRRnFJUUZCQnd3L0MwSERBU0VDSUFFZ0JFWU5oQUlnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRmFpRUdBa0FEUUNBQkxRQUFJQUJCMk5NQWFpMEFBRWNOUGlBQVFRVkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNaFFJTElBTkJBRFlDQUNBR1FRRnFJUUZCS0F3K0N5QUJJQVJHQkVCQndnRWhBZ3lFQWdzQ1FBSkFBa0FnQVMwQUFFSEZBR3NPRVFCQlFVRkJRVUZCUVVFQlFVRkJRVUVDUVFzZ0FVRUJhaUVCUWFjQklRSU02d0VMSUFGQkFXb2hBVUdvQVNFQ0RPb0JDeUFCUVFGcUlRRkJxUUVoQWd6cEFRdEJ3UUVoQWlBQklBUkdEWUlDSUFNb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkJtb2hCZ0pBQTBBZ0FTMEFBQ0FBUWRIVEFHb3RBQUJIRFR3Z0FFRUdSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0F5QUZOZ0lBRElNQ0N5QURRUUEyQWdBZ0JrRUJhaUVCUVJvTVBBdEJ3QUVoQWlBQklBUkdEWUVDSUFNb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ0pBQTBBZ0FTMEFBQ0FBUWMzVEFHb3RBQUJIRFRzZ0FFRURSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0F5QUZOZ0lBRElJQ0N5QURRUUEyQWdBZ0JrRUJhaUVCUVNFTU93c2dBU0FFUmdSQVFiOEJJUUlNZ1FJTEFrQUNRQ0FCTFFBQVFjRUFhdzRVQUQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFFFOUN5QUJRUUZxSVFGQm93RWhBZ3puQVFzZ0FVRUJhaUVCUWFZQklRSU01Z0VMSUFFZ0JFWUVRRUcrQVNFQ0RJQUNDd0pBQWtBZ0FTMEFBRUhWQUdzT0N3QThQRHc4UER3OFBEd0JQQXNnQVVFQmFpRUJRYVFCSVFJTTVnRUxJQUZCQVdvaEFVR2xBU0VDRE9VQkMwRzlBU0VDSUFFZ0JFWU4vZ0VnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFSWFpRUdBa0FEUUNBQkxRQUFJQUJCeE5NQWFpMEFBRWNOT0NBQVFRaEdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNL3dFTElBTkJBRFlDQUNBR1FRRnFJUUZCS2d3NEN5QUJJQVJHQkVCQnZBRWhBZ3orQVFzZ0FTMEFBRUhRQUVjTk9DQUJRUUZxSVFGQkpRdzNDMEc3QVNFQ0lBRWdCRVlOL0FFZ0F5Z0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUNhaUVHQWtBRFFDQUJMUUFBSUFCQndkTUFhaTBBQUVjTk5pQUFRUUpHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QURJQVUyQWdBTS9RRUxJQU5CQURZQ0FDQUdRUUZxSVFGQkRndzJDeUFCSUFSR0JFQkJ1Z0VoQWd6OEFRc2dBUzBBQUVIRkFFY05OaUFCUVFGcUlRRkJvUUVoQWd6aEFRc2dBU0FFUmdSQVFia0JJUUlNK3dFTEFrQUNRQUpBQWtBZ0FTMEFBRUhDQUdzT0R3QUJBams1T1RrNU9UazVPVGs1QXprTElBRkJBV29oQVVHZEFTRUNET01CQ3lBQlFRRnFJUUZCbmdFaEFnemlBUXNnQVVFQmFpRUJRWjhCSVFJTTRRRUxJQUZCQVdvaEFVR2dBU0VDRE9BQkMwRzRBU0VDSUFFZ0JFWU4rUUVnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCdnRNQWFpMEFBRWNOTXlBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNK2dFTElBTkJBRFlDQUNBR1FRRnFJUUZCRkF3ekMwRzNBU0VDSUFFZ0JFWU4rQUVnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRWFpRUdBa0FEUUNBQkxRQUFJQUJCdWRNQWFpMEFBRWNOTWlBQVFRUkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNK1FFTElBTkJBRFlDQUNBR1FRRnFJUUZCS3d3eUMwRzJBU0VDSUFFZ0JFWU45d0VnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCdHRNQWFpMEFBRWNOTVNBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNK0FFTElBTkJBRFlDQUNBR1FRRnFJUUZCTEF3eEMwRzFBU0VDSUFFZ0JFWU45Z0VnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCNGRNQWFpMEFBRWNOTUNBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNOXdFTElBTkJBRFlDQUNBR1FRRnFJUUZCRVF3d0MwRzBBU0VDSUFFZ0JFWU45UUVnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRGFpRUdBa0FEUUNBQkxRQUFJQUJCc3RNQWFpMEFBRWNOTHlBQVFRTkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNOWdFTElBTkJBRFlDQUNBR1FRRnFJUUZCTGd3dkN5QUJJQVJHQkVCQnN3RWhBZ3oxQVFzQ1FBSkFBa0FDUUFKQUlBRXRBQUJCd1FCckRoVUFORFEwTkRRME5EUTBOQUUwTkFJME5BTTBOQVEwQ3lBQlFRRnFJUUZCa1FFaEFnemVBUXNnQVVFQmFpRUJRWklCSVFJTTNRRUxJQUZCQVdvaEFVR1RBU0VDRE53QkN5QUJRUUZxSVFGQm1BRWhBZ3piQVFzZ0FVRUJhaUVCUVpvQklRSU0yZ0VMSUFFZ0JFWUVRRUd5QVNFQ0RQUUJDd0pBQWtBZ0FTMEFBRUhTQUdzT0F3QXdBVEFMSUFGQkFXb2hBVUdaQVNFQ0ROb0JDeUFCUVFGcUlRRkJCQXd0QzBHeEFTRUNJQUVnQkVZTjhnRWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJzTk1BYWkwQUFFY05MQ0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU04d0VMSUFOQkFEWUNBQ0FHUVFGcUlRRkJIUXdzQ3lBQklBUkdCRUJCc0FFaEFnenlBUXNDUUFKQUlBRXRBQUJCeVFCckRnY0JMaTR1TGk0QUxnc2dBVUVCYWlFQlFaY0JJUUlNMkFFTElBRkJBV29oQVVFaURDc0xJQUVnQkVZRVFFR3ZBU0VDRFBFQkN5QUJMUUFBUWRBQVJ3MHJJQUZCQVdvaEFVR1dBU0VDRE5ZQkN5QUJJQVJHQkVCQnJnRWhBZ3p3QVFzQ1FBSkFJQUV0QUFCQnhnQnJEZ3NBTEN3c0xDd3NMQ3dzQVN3TElBRkJBV29oQVVHVUFTRUNETllCQ3lBQlFRRnFJUUZCbFFFaEFnelZBUXRCclFFaEFpQUJJQVJHRGU0QklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBMm9oQmdKQUEwQWdBUzBBQUNBQVFhelRBR290QUFCSERTZ2dBRUVEUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURPOEJDeUFEUVFBMkFnQWdCa0VCYWlFQlFRME1LQXRCckFFaEFpQUJJQVJHRGUwQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBbW9oQmdKQUEwQWdBUzBBQUNBQVFlSFRBR290QUFCSERTY2dBRUVDUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURPNEJDeUFEUVFBMkFnQWdCa0VCYWlFQlFRd01Kd3RCcXdFaEFpQUJJQVJHRGV3QklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBV29oQmdKQUEwQWdBUzBBQUNBQVFhclRBR290QUFCSERTWWdBRUVCUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURPMEJDeUFEUVFBMkFnQWdCa0VCYWlFQlFRTU1KZ3RCcWdFaEFpQUJJQVJHRGVzQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBV29oQmdKQUEwQWdBUzBBQUNBQVFhalRBR290QUFCSERTVWdBRUVCUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURPd0JDeUFEUVFBMkFnQWdCa0VCYWlFQlFTWU1KUXNnQVNBRVJnUkFRYWtCSVFJTTZ3RUxBa0FDUUNBQkxRQUFRZFFBYXc0Q0FBRW5DeUFCUVFGcUlRRkJqd0VoQWd6UkFRc2dBVUVCYWlFQlFaQUJJUUlNMEFFTFFhZ0JJUUlnQVNBRVJnM3BBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUdtMHdCcUxRQUFSdzBqSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXpxQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVuRENNTFFhY0JJUUlnQVNBRVJnM29BU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUdrMHdCcUxRQUFSdzBpSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXpwQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVjRENJTFFhWUJJUUlnQVNBRVJnM25BU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWUNRQU5BSUFFdEFBQWdBRUdlMHdCcUxRQUFSdzBoSUFCQkJVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXpvQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVHRENFTFFhVUJJUUlnQVNBRVJnM21BU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFScUlRWUNRQU5BSUFFdEFBQWdBRUdaMHdCcUxRQUFSdzBnSUFCQkJFWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXpuQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVaRENBTElBRWdCRVlFUUVHa0FTRUNET1lCQ3dKQUFrQUNRQUpBSUFFdEFBQkJMV3NPSXdBa0pDUWtKQ1FrSkNRa0pDUWtKQ1FrSkNRa0pDUWtKQUVrSkNRa0pBSWtKQ1FESkFzZ0FVRUJhaUVCUVlRQklRSU16Z0VMSUFGQkFXb2hBVUdGQVNFQ0RNMEJDeUFCUVFGcUlRRkJpZ0VoQWd6TUFRc2dBVUVCYWlFQlFZc0JJUUlNeXdFTFFhTUJJUUlnQVNBRVJnM2tBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUdYMHdCcUxRQUFSdzBlSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXpsQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVMREI0TElBRWdCRVlFUUVHaUFTRUNET1FCQ3dKQUFrQWdBUzBBQUVIQkFHc09Bd0FnQVNBTElBRkJBV29oQVVHR0FTRUNETW9CQ3lBQlFRRnFJUUZCaVFFaEFnekpBUXNnQVNBRVJnUkFRYUVCSVFJTTR3RUxBa0FDUUNBQkxRQUFRY0VBYXc0UEFCOGZIeDhmSHg4Zkh4OGZIeDhCSHdzZ0FVRUJhaUVCUVljQklRSU15UUVMSUFGQkFXb2hBVUdJQVNFQ0RNZ0JDeUFCSUFSR0JFQkJvQUVoQWd6aUFRc2dBUzBBQUVITUFFY05IQ0FCUVFGcUlRRkJDZ3diQzBHZkFTRUNJQUVnQkVZTjRBRWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVGYWlFR0FrQURRQ0FCTFFBQUlBQkJrZE1BYWkwQUFFY05HaUFBUVFWR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU00UUVMSUFOQkFEWUNBQ0FHUVFGcUlRRkJIZ3dhQzBHZUFTRUNJQUVnQkVZTjN3RWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVHYWlFR0FrQURRQ0FCTFFBQUlBQkJpdE1BYWkwQUFFY05HU0FBUVFaR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU00QUVMSUFOQkFEWUNBQ0FHUVFGcUlRRkJGUXdaQzBHZEFTRUNJQUVnQkVZTjNnRWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVDYWlFR0FrQURRQ0FCTFFBQUlBQkJoOU1BYWkwQUFFY05HQ0FBUVFKR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU0zd0VMSUFOQkFEWUNBQ0FHUVFGcUlRRkJGd3dZQzBHY0FTRUNJQUVnQkVZTjNRRWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVGYWlFR0FrQURRQ0FCTFFBQUlBQkJnZE1BYWkwQUFFY05GeUFBUVFWR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU0zZ0VMSUFOQkFEWUNBQ0FHUVFGcUlRRkJHQXdYQ3lBQklBUkdCRUJCbXdFaEFnemRBUXNDUUFKQUlBRXRBQUJCeVFCckRnY0FHUmtaR1JrQkdRc2dBVUVCYWlFQlFZRUJJUUlNd3dFTElBRkJBV29oQVVHQ0FTRUNETUlCQzBHYUFTRUNJQUVnQkVZTjJ3RWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkI1dE1BYWkwQUFFY05GU0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU0zQUVMSUFOQkFEWUNBQ0FHUVFGcUlRRkJDUXdWQzBHWkFTRUNJQUVnQkVZTjJnRWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkI1Tk1BYWkwQUFFY05GQ0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU0yd0VMSUFOQkFEWUNBQ0FHUVFGcUlRRkJId3dVQzBHWUFTRUNJQUVnQkVZTjJRRWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVDYWlFR0FrQURRQ0FCTFFBQUlBQkIvdElBYWkwQUFFY05FeUFBUVFKR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU0yZ0VMSUFOQkFEWUNBQ0FHUVFGcUlRRkJBZ3dUQzBHWEFTRUNJQUVnQkVZTjJBRWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0EwQWdBUzBBQUNBQVFmelNBR290QUFCSERSRWdBRUVCUmcwQ0lBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQUROZ0JDeUFCSUFSR0JFQkJsZ0VoQWd6WUFRdEJBU0FCTFFBQVFkOEFSdzBSR2lBQlFRRnFJUUZCL1FBaEFneTlBUXNnQTBFQU5nSUFJQVpCQVdvaEFVSCtBQ0VDREx3QkMwR1ZBU0VDSUFFZ0JFWU4xUUVnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFSWFpRUdBa0FEUUNBQkxRQUFJQUJCeE5NQWFpMEFBRWNORHlBQVFRaEdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNMWdFTElBTkJBRFlDQUNBR1FRRnFJUUZCS1F3UEMwR1VBU0VDSUFFZ0JFWU4xQUVnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRGFpRUdBa0FEUUNBQkxRQUFJQUJCK05JQWFpMEFBRWNORGlBQVFRTkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNMVFFTElBTkJBRFlDQUNBR1FRRnFJUUZCTFF3T0N5QUJJQVJHQkVCQmt3RWhBZ3pVQVFzZ0FTMEFBRUhGQUVjTkRpQUJRUUZxSVFGQitnQWhBZ3k1QVFzZ0FTQUVSZ1JBUVpJQklRSU0wd0VMQWtBQ1FDQUJMUUFBUWN3QWF3NElBQThQRHc4UER3RVBDeUFCUVFGcUlRRkIrQUFoQWd5NUFRc2dBVUVCYWlFQlFma0FJUUlNdUFFTFFaRUJJUUlnQVNBRVJnM1JBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFScUlRWUNRQU5BSUFFdEFBQWdBRUh6MGdCcUxRQUFSdzBMSUFCQkJFWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXpTQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVqREFzTFFaQUJJUUlnQVNBRVJnM1FBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUh3MGdCcUxRQUFSdzBLSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXpSQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVBREFvTElBRWdCRVlFUUVHUEFTRUNETkFCQ3dKQUFrQWdBUzBBQUVISUFHc09DQUFNREF3TURBd0JEQXNnQVVFQmFpRUJRZk1BSVFJTXRnRUxJQUZCQVdvaEFVSDJBQ0VDRExVQkN5QUJJQVJHQkVCQmpnRWhBZ3pQQVFzQ1FBSkFJQUV0QUFCQnpnQnJEZ01BQ3dFTEN5QUJRUUZxSVFGQjlBQWhBZ3kxQVFzZ0FVRUJhaUVCUWZVQUlRSU10QUVMSUFFZ0JFWUVRRUdOQVNFQ0RNNEJDeUFCTFFBQVFka0FSdzBJSUFGQkFXb2hBVUVJREFjTFFZd0JJUUlnQVNBRVJnM01BU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFOcUlRWUNRQU5BSUFFdEFBQWdBRUhzMGdCcUxRQUFSdzBHSUFCQkEwWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXpOQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVGREFZTFFZc0JJUUlnQVNBRVJnM0xBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWUNRQU5BSUFFdEFBQWdBRUhtMGdCcUxRQUFSdzBGSUFCQkJVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXpNQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVXREFVTFFZb0JJUUlnQVNBRVJnM0tBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhoMHdCcUxRQUFSdzBFSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXpMQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUVRREFRTElBRWdCRVlFUUVHSkFTRUNETW9CQ3dKQUFrQWdBUzBBQUVIREFHc09EQUFHQmdZR0JnWUdCZ1lHQVFZTElBRkJBV29oQVVIdkFDRUNETEFCQ3lBQlFRRnFJUUZCOEFBaEFneXZBUXRCaUFFaEFpQUJJQVJHRGNnQklBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCV29oQmdKQUEwQWdBUzBBQUNBQVFlRFNBR290QUFCSERRSWdBRUVGUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURNa0JDeUFEUVFBMkFnQWdCa0VCYWlFQlFTUU1BZ3NnQTBFQU5nSUFEQUlMSUFFZ0JFWUVRRUdIQVNFQ0RNY0JDeUFCTFFBQVFjd0FSdzBCSUFGQkFXb2hBVUVUQ3pvQUtTQURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFQzBpQUEwQ0RBRUxRUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5CNlI0MkFoQWdBMEVHTmdJTURNUUJDMEh1QUNFQ0RLa0JDeUFEUVlZQk5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd4QkFDRUNETUlCQzBFQUlRQUNRQ0FES0FJNElnSkZEUUFnQWlnQ09DSUNSUTBBSUFNZ0FoRUFBQ0VBQ3lBQVJRMEFJQUJCRlVZTkFTQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQjFBNDJBaEFnQTBFZ05nSU1RUUFoQWd6QkFRdEI3UUFoQWd5bUFRc2dBMEdGQVRZQ0hDQURJQUUyQWhRZ0EwSFhHallDRUNBRFFSVTJBZ3hCQUNFQ0RMOEJDeUFCSUFSR0JFQkJoUUVoQWd5L0FRc0NRQ0FCTFFBQVFTQkdCRUFnQVVFQmFpRUJEQUVMSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdHSGpZQ0VDQURRUVkyQWd4QkFDRUNETDhCQzBFQ0lRSU1wQUVMQTBBZ0FTMEFBRUVnUncwQ0lBUWdBVUVCYWlJQlJ3MEFDMEdFQVNFQ0RMMEJDeUFCSUFSR0JFQkJnd0VoQWd5OUFRc0NRQ0FCTFFBQVFRbHJEZ1JBQUFCQUFBdEI2d0FoQWd5aUFRc2dBeTBBS1VFRlJnUkFRZXdBSVFJTW9nRUxRZW9BSVFJTW9RRUxJQUVnQkVZRVFFR0NBU0VDRExzQkN5QURRUTgyQWdnZ0F5QUJOZ0lFREFvTElBRWdCRVlFUUVHQkFTRUNETG9CQ3dKQUlBRXRBQUJCQ1dzT0JEMEFBRDBBQzBIcEFDRUNESjhCQ3lBQklBUkhCRUFnQTBFUE5nSUlJQU1nQVRZQ0JFSG5BQ0VDREo4QkMwR0FBU0VDRExnQkN3SkFJQUVnQkVjRVFBTkFJQUV0QUFCQjRNNEFhaTBBQUNJQVFRTkhCRUFDUUNBQVFRRnJEZ0kvQUFRTFFlWUFJUUlNb1FFTElBUWdBVUVCYWlJQlJ3MEFDMEgrQUNFQ0RMa0JDMEgrQUNFQ0RMZ0JDeUFEUVFBMkFod2dBeUFCTmdJVUlBTkJ4aDgyQWhBZ0EwRUhOZ0lNUVFBaEFneTNBUXNnQVNBRVJnUkFRZjhBSVFJTXR3RUxBa0FDUUFKQUlBRXRBQUJCNE5BQWFpMEFBRUVCYXc0RFBBSUFBUXRCNkFBaEFneWVBUXNnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRWVlTTmdJUUlBTkJCellDREVFQUlRSU10d0VMUWVBQUlRSU1uQUVMSUFFZ0JFY0VRQ0FCUVFGcUlRRkI1UUFoQWd5Y0FRdEIvUUFoQWd5MUFRc2dCQ0FCSWdCR0JFQkIvQUFoQWd5MUFRc2dBQzBBQUNJQlFTOUdCRUFnQUVFQmFpRUJRZVFBSVFJTW13RUxJQUZCQ1dzaUFrRVhTdzBCSUFBaEFVRUJJQUowUVp1QWdBUnhEVGNNQVFzZ0JDQUJJZ0JHQkVCQit3QWhBZ3kwQVFzZ0FDMEFBRUV2UncwQUlBQkJBV29oQVF3REMwRUFJUUlnQTBFQU5nSWNJQU1nQURZQ0ZDQURRY1lmTmdJUUlBTkJCellDREF5eUFRc0NRQUpBQWtBQ1FBSkFBMEFnQVMwQUFFSGd6QUJxTFFBQUlnQkJCVWNFUUFKQUFrQWdBRUVCYXc0SVBRVUdCd2dBQkFFSUMwSGhBQ0VDREo4QkN5QUJRUUZxSVFGQjR3QWhBZ3llQVFzZ0JDQUJRUUZxSWdGSERRQUxRZm9BSVFJTXRnRUxJQUZCQVdvTUZBc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkFySWdCRkRSNGdBMEhiQURZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNUVFBaEFneTBBUXNnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBcklnQkZEUjRnQTBIZEFEWUNIQ0FESUFFMkFoUWdBeUFBTmdJTVFRQWhBZ3l6QVFzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXJJZ0JGRFI0Z0EwSHdBRFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5eUFRc2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFjc1BOZ0lRSUFOQkJ6WUNERUVBSVFJTXNRRUxJQUVnQkVZRVFFSDVBQ0VDRExFQkN3SkFJQUV0QUFCQjRNd0FhaTBBQUVFQmF3NElOQVFGQmdBSUFnTUhDeUFCUVFGcUlRRUxRUU1oQWd5VkFRc2dBVUVCYWd3TkMwRUFJUUlnQTBFQU5nSWNJQU5Cb3hJMkFoQWdBMEVITmdJTUlBTWdBVUVCYWpZQ0ZBeXRBUXNnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBcklnQkZEUllnQTBIYkFEWUNIQ0FESUFFMkFoUWdBeUFBTmdJTVFRQWhBZ3lzQVFzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXJJZ0JGRFJZZ0EwSGRBRFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5ckFRc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkFySWdCRkRSWWdBMEh3QURZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNUVFBaEFneXFBUXNnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRY3NQTmdJUUlBTkJCellDREVFQUlRSU1xUUVMUWVJQUlRSU1qZ0VMSUFFZ0JFWUVRRUg0QUNFQ0RLZ0JDeUFCUVFGcURBSUxJQUVnQkVZRVFFSDNBQ0VDREtjQkN5QUJRUUZxREFFTElBRWdCRVlOQVNBQlFRRnFDeUVCUVFRaEFneUtBUXRCOWdBaEFneWpBUXNEUUNBQkxRQUFRZURLQUdvdEFBQWlBRUVDUndSQUlBQkJBVWNFUUVIZkFDRUNESXNCQ3d3bkN5QUVJQUZCQVdvaUFVY05BQXRCOVFBaEFneWlBUXNnQVNBRVJnUkFRZlFBSVFJTW9nRUxBa0FnQVMwQUFFRUphdzQzSlFNR0pRUUdCZ1lHQmdZR0JnWUdCZ1lHQmdZR0JnWUZCZ1lDQmdZR0JnWUdCZ1lHQmdZR0JnWUdCZ1lHQmdZR0JnWUdCZ1lHQUFZTElBRkJBV29MSVFGQkJTRUNESVlCQ3lBQlFRRnFEQVlMSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUUt5SUFSUTBJSUFOQjJ3QTJBaHdnQXlBQk5nSVVJQU1nQURZQ0RFRUFJUUlNbmdFTElBTW9BZ1FoQUNBRFFRQTJBZ1FnQXlBQUlBRVFLeUlBUlEwSUlBTkIzUUEyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTW5RRUxJQU1vQWdRaEFDQURRUUEyQWdRZ0F5QUFJQUVRS3lJQVJRMElJQU5COEFBMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1uQUVMSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEc4RXpZQ0VDQURRUWMyQWd4QkFDRUNESnNCQ3dKQUFrQUNRQUpBQTBBZ0FTMEFBRUhneUFCcUxRQUFJZ0JCQlVjRVFBSkFJQUJCQVdzT0JpUURCQVVHQUFZTFFkNEFJUUlNaGdFTElBUWdBVUVCYWlJQlJ3MEFDMEh6QUNFQ0RKNEJDeUFES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRUNzaUFFVU5CeUFEUWRzQU5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd4QkFDRUNESjBCQ3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQkVDc2lBRVVOQnlBRFFkMEFOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFneEJBQ0VDREp3QkN5QURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFQ3NpQUVVTkJ5QURRZkFBTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3hCQUNFQ0RKc0JDeUFEUVFBMkFod2dBeUFCTmdJVUlBTkIzQWcyQWhBZ0EwRUhOZ0lNUVFBaEFneWFBUXNnQVNBRVJnMEJJQUZCQVdvTElRRkJCaUVDREg0TFFmSUFJUUlNbHdFTEFrQUNRQUpBQWtBRFFDQUJMUUFBUWVER0FHb3RBQUFpQUVFRlJ3UkFJQUJCQVdzT0JCOENBd1FGQ3lBRUlBRkJBV29pQVVjTkFBdEI4UUFoQWd5YUFRc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkFySWdCRkRRTWdBMEhiQURZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNUVFBaEFneVpBUXNnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBcklnQkZEUU1nQTBIZEFEWUNIQ0FESUFFMkFoUWdBeUFBTmdJTVFRQWhBZ3lZQVFzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXJJZ0JGRFFNZ0EwSHdBRFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5WEFRc2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFiUUtOZ0lRSUFOQkJ6WUNERUVBSVFJTWxnRUxRYzRBSVFJTWV3dEIwQUFoQWd4NkMwSGRBQ0VDREhrTElBRWdCRVlFUUVId0FDRUNESk1CQ3dKQUlBRXRBQUJCQ1dzT0JCWUFBQllBQ3lBQlFRRnFJUUZCM0FBaEFneDRDeUFCSUFSR0JFQkI3d0FoQWd5U0FRc0NRQ0FCTFFBQVFRbHJEZ1FWQUFBVkFBdEJBQ0VBQWtBZ0F5Z0NPQ0lDUlEwQUlBSW9BakFpQWtVTkFDQURJQUlSQUFBaEFBc2dBRVVFUUVIVEFTRUNESGdMSUFCQkZVY0VRQ0FEUVFBMkFod2dBeUFCTmdJVUlBTkJ3UTAyQWhBZ0EwRWFOZ0lNUVFBaEFneVNBUXNnQTBIdUFEWUNIQ0FESUFFMkFoUWdBMEh3R1RZQ0VDQURRUlUyQWd4QkFDRUNESkVCQzBIdEFDRUNJQUVnQkVZTmtBRWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVEYWlFR0FrQURRQ0FCTFFBQUlBQkIxOFlBYWkwQUFFY05CQ0FBUVFOR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU1rUUVMSUFOQkFEWUNBQ0FHUVFGcUlRRWdBeTBBS1NJQVFTTnJRUXRKRFFRQ1FDQUFRUVpMRFFCQkFTQUFkRUhLQUhGRkRRQU1CUXRCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBIbENUWUNFQ0FEUVFnMkFnd01rQUVMUWV3QUlRSWdBU0FFUmcyUEFTQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFSFV4Z0JxTFFBQVJ3MERJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBeVFBUXNnQTBFQU5nSUFJQVpCQVdvaEFTQURMUUFwUVNGR0RRTWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFZa0tOZ0lRSUFOQkNEWUNERUVBSVFJTWp3RUxRZXNBSVFJZ0FTQUVSZzJPQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRTnFJUVlDUUFOQUlBRXRBQUFnQUVIUXhnQnFMUUFBUncwQ0lBQkJBMFlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF5UEFRc2dBMEVBTmdJQUlBWkJBV29oQVNBRExRQXBJZ0JCSTBrTkFpQUFRUzVHRFFJZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWNFSk5nSVFJQU5CQ0RZQ0RFRUFJUUlNamdFTElBTkJBRFlDQUF0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR0VOellDRUNBRFFRZzJBZ3dNakFFTFFkZ0FJUUlNY1FzZ0FTQUVSd1JBSUFOQkRUWUNDQ0FESUFFMkFnUkIxd0FoQWd4eEMwSHFBQ0VDRElvQkN5QUJJQVJHQkVCQjZRQWhBZ3lLQVFzZ0FTMEFBRUV3YXlJQVFmOEJjVUVLU1FSQUlBTWdBRG9BS2lBQlFRRnFJUUZCMWdBaEFneHdDeUFES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRUM0aUFFVU5kQ0FEUWVnQU5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd4QkFDRUNESWtCQ3lBQklBUkdCRUJCNXdBaEFneUpBUXNDUUNBQkxRQUFRUzVHQkVBZ0FVRUJhaUVCREFFTElBTW9BZ1FoQUNBRFFRQTJBZ1FnQXlBQUlBRVFMaUlBUlExMUlBTkI1Z0EyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTWlRRUxRZFVBSVFJTWJnc2dBU0FFUmdSQVFlVUFJUUlNaUFFTFFRQWhBRUVCSVFWQkFTRUhRUUFoQWdKQUFrQUNRQUpBQWtBQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBSUFFdEFBQkJNR3NPQ2dvSkFBRUNBd1FGQmdnTEMwRUNEQVlMUVFNTUJRdEJCQXdFQzBFRkRBTUxRUVlNQWd0QkJ3d0JDMEVJQ3lFQ1FRQWhCVUVBSVFjTUFndEJDU0VDUVFFaEFFRUFJUVZCQUNFSERBRUxRUUFoQlVFQklRSUxJQU1nQWpvQUt5QUJRUUZxSVFFQ1FBSkFJQU10QUM1QkVIRU5BQUpBQWtBQ1FDQURMUUFxRGdNQkFBSUVDeUFIUlEwRERBSUxJQUFOQVF3Q0N5QUZSUTBCQ3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQkVDNGlBRVVOQWlBRFFlSUFOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFneEJBQ0VDRElvQkN5QURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFQzRpQUVVTmR5QURRZU1BTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3hCQUNFQ0RJa0JDeUFES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRUM0aUFFVU5kU0FEUWVRQU5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd3TWlBRUxRZE1BSVFJTWJRc2dBeTBBS1VFaVJnMkFBVUhTQUNFQ0RHd0xRUUFoQUFKQUlBTW9BamdpQWtVTkFDQUNLQUk4SWdKRkRRQWdBeUFDRVFBQUlRQUxJQUJGQkVCQjFBQWhBZ3hzQ3lBQVFSVkhCRUFnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRWndOTmdJUUlBTkJJVFlDREVFQUlRSU1oZ0VMSUFOQjRRQTJBaHdnQXlBQk5nSVVJQU5CMWhrMkFoQWdBMEVWTmdJTVFRQWhBZ3lGQVFzZ0FTQUVSZ1JBUWVBQUlRSU1oUUVMQWtBQ1FBSkFBa0FDUUNBQkxRQUFRUXByRGdRQkJBUUFCQXNnQVVFQmFpRUJEQUVMSUFGQkFXb2hBU0FEUVM5cUxRQUFRUUZ4UlEwQkMwSFJBQ0VDREd3TElBTkJBRFlDSENBRElBRTJBaFFnQTBHSUVUWUNFQ0FEUVFrMkFneEJBQ0VDRElVQkN5QURRUUEyQWh3Z0F5QUJOZ0lVSUFOQmlCRTJBaEFnQTBFSk5nSU1RUUFoQWd5RUFRc2dBU0FFUmdSQVFkOEFJUUlNaEFFTElBRXRBQUJCQ2tZRVFDQUJRUUZxSVFFTUNRc2dBeTBBTGtIQUFIRU5DQ0FEUVFBMkFod2dBeUFCTmdJVUlBTkJpQkUyQWhBZ0EwRUNOZ0lNUVFBaEFneURBUXNnQVNBRVJnUkFRZDBBSVFJTWd3RUxJQUV0QUFBaUFrRU5SZ1JBSUFGQkFXb2hBVUhQQUNFQ0RHa0xJQUVoQUNBQ1FRbHJEZ1FGQVFFRkFRc2dCQ0FCSWdCR0JFQkIzQUFoQWd5Q0FRc2dBQzBBQUVFS1J3MEFJQUJCQVdvTUFndEJBQ0VDSUFOQkFEWUNIQ0FESUFBMkFoUWdBMEcxTERZQ0VDQURRUWMyQWd3TWdBRUxJQUVnQkVZRVFFSGJBQ0VDRElBQkN3SkFJQUV0QUFCQkNXc09CQU1BQUFNQUN5QUJRUUZxQ3lFQlFjMEFJUUlNWkFzZ0FTQUVSZ1JBUWRvQUlRSU1mZ3NnQVMwQUFFRUphdzRFQUFFQkFBRUxRUUFoQWlBRFFRQTJBaHdnQTBIc0VUWUNFQ0FEUVFjMkFnd2dBeUFCUVFGcU5nSVVESHdMSUFOQmdCSTdBU3BCQUNFQUFrQWdBeWdDT0NJQ1JRMEFJQUlvQWpBaUFrVU5BQ0FESUFJUkFBQWhBQXNnQUVVTkFDQUFRUlZIRFFFZ0EwSFpBRFlDSENBRElBRTJBaFFnQTBId0dUWUNFQ0FEUVJVMkFneEJBQ0VDREhzTFFjd0FJUUlNWUFzZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWNFTk5nSVFJQU5CR2pZQ0RFRUFJUUlNZVFzZ0FTQUVSZ1JBUWRrQUlRSU1lUXNnQVMwQUFFRWdSdzA2SUFGQkFXb2hBU0FETFFBdVFRRnhEVG9nQTBFQU5nSWNJQU1nQVRZQ0ZDQURRYTBiTmdJUUlBTkJIallDREVFQUlRSU1lQXNnQVNBRVJnUkFRZGdBSVFJTWVBc0NRQUpBQWtBQ1FBSkFJQUV0QUFBaUFFRUthdzRFQWdNREFBRUxJQUZCQVdvaEFVRXJJUUlNWVFzZ0FFRTZSdzBCSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEc1RVRZQ0VDQURRUW8yQWd4QkFDRUNESG9MSUFGQkFXb2hBU0FEUVM5cUxRQUFRUUZ4UlExdElBTXRBREpCZ0FGeFJRUkFJQU5CTW1vaEFpQURFRFJCQUNFQUFrQWdBeWdDT0NJR1JRMEFJQVlvQWlRaUJrVU5BQ0FESUFZUkFBQWhBQXNDUUFKQUlBQU9Ga3BKU0FFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkN5QURRU2syQWh3Z0F5QUJOZ0lVSUFOQnNoZzJBaEFnQTBFVk5nSU1RUUFoQWd4N0N5QURRUUEyQWh3Z0F5QUJOZ0lVSUFOQjNRczJBaEFnQTBFUk5nSU1RUUFoQWd4NkMwRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NWQ0lDUlEwQUlBTWdBaEVBQUNFQUN5QUFSUTFWSUFCQkZVY05BU0FEUVFVMkFod2dBeUFCTmdJVUlBTkJoaG8yQWhBZ0EwRVZOZ0lNUVFBaEFneDVDMEhLQUNFQ0RGNExRUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5CNGcwMkFoQWdBMEVVTmdJTURIY0xJQU1nQXk4Qk1rR0FBWEk3QVRJTU9Bc2dBU0FFUndSQUlBTkJFRFlDQ0NBRElBRTJBZ1JCeVFBaEFneGNDMEhYQUNFQ0RIVUxJQUVnQkVZRVFFSFdBQ0VDREhVTEFrQUNRQUpBQWtBZ0FTMEFBQ0lBUVNCeUlBQWdBRUhCQUd0Qi93RnhRUnBKRzBIL0FYRkI0d0JyRGhNQVBUMDlQVDA5UFQwOVBUMDlBVDA5UFFJRFBRc2dBVUVCYWlFQlFjVUFJUUlNWFFzZ0FVRUJhaUVCUWNZQUlRSU1YQXNnQVVFQmFpRUJRY2NBSVFJTVd3c2dBVUVCYWlFQlFjZ0FJUUlNV2d0QjFRQWhBaUFFSUFFaUFFWU5jeUFFSUFGcklBTW9BZ0FpQVdvaEJpQUFJQUZyUVFWcUlRY0RRQ0FCUWNER0FHb3RBQUFnQUMwQUFDSUZRU0J5SUFVZ0JVSEJBR3RCL3dGeFFScEpHMEgvQVhGSERRaEJCQ0FCUVFWR0RRb2FJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQXlBR05nSUFESE1MUWRRQUlRSWdCQ0FCSWdCR0RYSWdCQ0FCYXlBREtBSUFJZ0ZxSVFZZ0FDQUJhMEVQYWlFSEEwQWdBVUd3eGdCcUxRQUFJQUF0QUFBaUJVRWdjaUFGSUFWQndRQnJRZjhCY1VFYVNSdEIvd0Z4UncwSFFRTWdBVUVQUmcwSkdpQUJRUUZxSVFFZ0JDQUFRUUZxSWdCSERRQUxJQU1nQmpZQ0FBeHlDMEhUQUNFQ0lBUWdBU0lBUmcxeElBUWdBV3NnQXlnQ0FDSUJhaUVHSUFBZ0FXdEJEbW9oQndOQUlBRkJrc1lBYWkwQUFDQUFMUUFBSWdWQklISWdCU0FGUWNFQWEwSC9BWEZCR2trYlFmOEJjVWNOQmlBQlFRNUdEUWNnQVVFQmFpRUJJQVFnQUVFQmFpSUFSdzBBQ3lBRElBWTJBZ0FNY1F0QjBnQWhBaUFFSUFFaUFFWU5jQ0FFSUFGcklBTW9BZ0FpQVdvaEJTQUFJQUZyUVFGcUlRWURRQ0FCUVpER0FHb3RBQUFnQUMwQUFDSUhRU0J5SUFjZ0IwSEJBR3RCL3dGeFFScEpHMEgvQVhGSERRVWdBVUVCUmcwQ0lBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBeUFGTmdJQURIQUxJQUVnQkVZRVFFSFJBQ0VDREhBTEFrQUNRQ0FCTFFBQUlnQkJJSElnQUNBQVFjRUFhMEgvQVhGQkdra2JRZjhCY1VIdUFHc09Cd0EyTmpZMk5nRTJDeUFCUVFGcUlRRkJ3Z0FoQWd4V0N5QUJRUUZxSVFGQnd3QWhBZ3hWQ3lBRFFRQTJBZ0FnQmtFQmFpRUJRY1FBSVFJTVZBdEIwQUFoQWlBRUlBRWlBRVlOYlNBRUlBRnJJQU1vQWdBaUFXb2hCaUFBSUFGclFRbHFJUWNEUUNBQlFZYkdBR290QUFBZ0FDMEFBQ0lGUVNCeUlBVWdCVUhCQUd0Qi93RnhRUnBKRzBIL0FYRkhEUUpCQWlBQlFRbEdEUVFhSUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0F5QUdOZ0lBREcwTFFjOEFJUUlnQkNBQklnQkdEV3dnQkNBQmF5QURLQUlBSWdGcUlRWWdBQ0FCYTBFRmFpRUhBMEFnQVVHQXhnQnFMUUFBSUFBdEFBQWlCVUVnY2lBRklBVkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFJ3MEJJQUZCQlVZTkFpQUJRUUZxSVFFZ0JDQUFRUUZxSWdCSERRQUxJQU1nQmpZQ0FBeHNDeUFBSVFFZ0EwRUFOZ0lBRERBTFFRRUxPZ0FzSUFOQkFEWUNBQ0FIUVFGcUlRRUxRU3doQWd4T0N3SkFBMEFnQVMwQUFFR0F4QUJxTFFBQVFRRkhEUUVnQkNBQlFRRnFJZ0ZIRFFBTFFjMEFJUUlNYUF0QndRQWhBZ3hOQ3lBQklBUkdCRUJCekFBaEFneG5DeUFCTFFBQVFUcEdCRUFnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBdklnQkZEVEFnQTBITEFEWUNIQ0FESUFBMkFnd2dBeUFCUVFGcU5nSVVRUUFoQWd4bkN5QURRUUEyQWh3Z0F5QUJOZ0lVSUFOQnVSRTJBaEFnQTBFS05nSU1RUUFoQWd4bUN3SkFBa0FnQXkwQUxFRUNhdzRDQUFFa0N5QURRVE5xTFFBQVFRSnhSUTBqSUFNdEFDNUJBbkVOSXlBRFFRQTJBaHdnQXlBQk5nSVVJQU5CMVJNMkFoQWdBMEVMTmdJTVFRQWhBZ3htQ3lBRExRQXlRU0J4UlEwaUlBTXRBQzVCQW5FTklpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQjdCSTJBaEFnQTBFUE5nSU1RUUFoQWd4bEMwRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NRQ0lDUlEwQUlBTWdBaEVBQUNFQUN5QUFSUVJBUWNBQUlRSU1Td3NnQUVFVlJ3UkFJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSDREallDRUNBRFFSdzJBZ3hCQUNFQ0RHVUxJQU5CeWdBMkFod2dBeUFCTmdJVUlBTkI4Qm8yQWhBZ0EwRVZOZ0lNUVFBaEFneGtDeUFCSUFSSEJFQURRQ0FCTFFBQVFmQS9haTBBQUVFQlJ3MFhJQVFnQVVFQmFpSUJSdzBBQzBIRUFDRUNER1FMUWNRQUlRSU1Zd3NnQVNBRVJ3UkFBMEFDUUNBQkxRQUFJZ0JCSUhJZ0FDQUFRY0VBYTBIL0FYRkJHa2tiUWY4QmNTSUFRUWxHRFFBZ0FFRWdSZzBBQWtBQ1FBSkFBa0FnQUVIakFHc09Fd0FEQXdNREF3TURBUU1EQXdNREF3TURBd0lEQ3lBQlFRRnFJUUZCTlNFQ0RFNExJQUZCQVdvaEFVRTJJUUlNVFFzZ0FVRUJhaUVCUVRjaEFneE1Dd3dWQ3lBRUlBRkJBV29pQVVjTkFBdEJQQ0VDREdNTFFUd2hBZ3hpQ3lBQklBUkdCRUJCeUFBaEFneGlDeUFEUVJFMkFnZ2dBeUFCTmdJRUFrQUNRQUpBQWtBQ1FDQURMUUFzUVFGckRnUVVBQUVDQ1FzZ0F5MEFNa0VnY1EwRFFkRUJJUUlNU3dzQ1FDQURMd0V5SWdCQkNIRkZEUUFnQXkwQUtFRUJSdzBBSUFNdEFDNUJDSEZGRFFJTElBTWdBRUgzK3dOeFFZQUVjanNCTWd3TEN5QURJQU12QVRKQkVISTdBVElNQkFzZ0EwRUFOZ0lFSUFNZ0FTQUJFREFpQUFSQUlBTkJ3UUEyQWh3Z0F5QUFOZ0lNSUFNZ0FVRUJhallDRkVFQUlRSU1Zd3NnQVVFQmFpRUJERklMSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdqRXpZQ0VDQURRUVEyQWd4QkFDRUNER0VMUWNjQUlRSWdBU0FFUmcxZ0lBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCbW9oQmdKQUEwQWdBRUh3d3dCcUxRQUFJQUV0QUFCQklISkhEUUVnQUVFR1JnMUdJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQXlBRk5nSUFER0VMSUFOQkFEWUNBQXdGQ3dKQUlBRWdCRWNFUUFOQUlBRXRBQUJCOE1FQWFpMEFBQ0lBUVFGSEJFQWdBRUVDUncwRElBRkJBV29oQVF3RkN5QUVJQUZCQVdvaUFVY05BQXRCeFFBaEFneGhDMEhGQUNFQ0RHQUxDeUFEUVFBNkFDd01BUXRCQ3lFQ0RFTUxRVDRoQWd4Q0N3SkFBa0FEUUNBQkxRQUFJZ0JCSUVjRVFBSkFJQUJCQ21zT0JBTUZCUU1BQ3lBQVFTeEdEUU1NQkFzZ0JDQUJRUUZxSWdGSERRQUxRY1lBSVFJTVhRc2dBMEVJT2dBc0RBNExJQU10QUNoQkFVY05BaUFETFFBdVFRaHhEUUlnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBd0lnQUVRQ0FEUWNJQU5nSWNJQU1nQURZQ0RDQURJQUZCQVdvMkFoUkJBQ0VDREZ3TElBRkJBV29oQVF4S0MwRTZJUUlNUUFzQ1FBTkFJQUV0QUFBaUFFRWdSeUFBUVFsSGNRMEJJQVFnQVVFQmFpSUJSdzBBQzBIREFDRUNERm9MQzBFN0lRSU1QZ3NDUUFKQUlBRWdCRWNFUUFOQUlBRXRBQUFpQUVFZ1J3UkFJQUJCQ21zT0JBTUVCQU1FQ3lBRUlBRkJBV29pQVVjTkFBdEJQeUVDREZvTFFUOGhBZ3haQ3lBRElBTXZBVEpCSUhJN0FUSU1DZ3NnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBd0lnQkZEVWdnQTBFK05nSWNJQU1nQVRZQ0ZDQURJQUEyQWd4QkFDRUNERmNMQWtBZ0FTQUVSd1JBQTBBZ0FTMEFBRUh3d1FCcUxRQUFJZ0JCQVVjRVFDQUFRUUpHRFFNTURBc2dCQ0FCUVFGcUlnRkhEUUFMUVRjaEFneFlDMEUzSVFJTVZ3c2dBVUVCYWlFQkRBUUxRVHNoQWlBRUlBRWlBRVlOVlNBRUlBRnJJQU1vQWdBaUFXb2hCaUFBSUFGclFRVnFJUWNDUUFOQUlBRkJ3TVlBYWkwQUFDQUFMUUFBSWdWQklISWdCU0FGUWNFQWEwSC9BWEZCR2trYlFmOEJjVWNOQVNBQlFRVkdCRUJCQnlFQkREc0xJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQXlBR05nSUFERllMSUFOQkFEWUNBQ0FBSVFFTUJRdEJPaUVDSUFRZ0FTSUFSZzFVSUFRZ0FXc2dBeWdDQUNJQmFpRUdJQUFnQVd0QkNHb2hCd0pBQTBBZ0FVSGtQMm90QUFBZ0FDMEFBQ0lGUVNCeUlBVWdCVUhCQUd0Qi93RnhRUnBKRzBIL0FYRkhEUUVnQVVFSVJnUkFRUVVoQVF3NkN5QUJRUUZxSVFFZ0JDQUFRUUZxSWdCSERRQUxJQU1nQmpZQ0FBeFZDeUFEUVFBMkFnQWdBQ0VCREFRTFFUa2hBaUFFSUFFaUFFWU5VeUFFSUFGcklBTW9BZ0FpQVdvaEJpQUFJQUZyUVFOcUlRY0NRQU5BSUFGQjREOXFMUUFBSUFBdEFBQWlCVUVnY2lBRklBVkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFJ3MEJJQUZCQTBZRVFFRUdJUUVNT1FzZ0FVRUJhaUVCSUFRZ0FFRUJhaUlBUncwQUN5QURJQVkyQWdBTVZBc2dBMEVBTmdJQUlBQWhBUXdEQ3dKQUEwQWdBUzBBQUNJQVFTQkhCRUFnQUVFS2F3NEVCd1FFQndJTElBUWdBVUVCYWlJQlJ3MEFDMEU0SVFJTVV3c2dBRUVzUncwQklBRkJBV29oQUVFQklRRUNRQUpBQWtBQ1FBSkFJQU10QUN4QkJXc09CQU1CQWdRQUN5QUFJUUVNQkF0QkFpRUJEQUVMUVFRaEFRc2dBMEVCT2dBc0lBTWdBeThCTWlBQmNqc0JNaUFBSVFFTUFRc2dBeUFETHdFeVFRaHlPd0V5SUFBaEFRdEJQU0VDRERjTElBTkJBRG9BTEF0Qk9DRUNERFVMSUFFZ0JFWUVRRUUySVFJTVR3c0NRQUpBQWtBQ1FBSkFJQUV0QUFCQkNtc09CQUFDQWdFQ0N5QURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFREFpQUVVTkFpQURRVE0yQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTVVnc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkF3SWdCRkJFQWdBVUVCYWlFQkRBWUxJQU5CTWpZQ0hDQURJQUEyQWd3Z0F5QUJRUUZxTmdJVVFRQWhBZ3hSQ3lBRExRQXVRUUZ4QkVCQjBBRWhBZ3czQ3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQkVEQWlBQTBCREVNTFFUTWhBZ3cxQ3lBRFFUVTJBaHdnQXlBQk5nSVVJQU1nQURZQ0RFRUFJUUlNVGd0Qk5DRUNERE1MSUFOQkwyb3RBQUJCQVhFTkFDQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQjhSVTJBaEFnQTBFWk5nSU1RUUFoQWd4TUMwRXlJUUlNTVFzZ0FTQUVSZ1JBUVRJaEFneExDd0pBSUFFdEFBQkJDa1lFUUNBQlFRRnFJUUVNQVFzZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUVpnV05nSVFJQU5CQXpZQ0RFRUFJUUlNU3d0Qk1TRUNEREFMSUFFZ0JFWUVRRUV4SVFJTVNnc2dBUzBBQUNJQVFRbEhJQUJCSUVkeERRRWdBeTBBTEVFSVJ3MEFJQU5CQURvQUxBdEJQQ0VDREM0TFFRRWhBZ0pBQWtBQ1FBSkFJQU10QUN4QkJXc09CQU1CQWdBS0N5QURJQU12QVRKQkNISTdBVElNQ1F0QkFpRUNEQUVMUVFRaEFnc2dBMEVCT2dBc0lBTWdBeThCTWlBQ2Nqc0JNZ3dHQ3lBQklBUkdCRUJCTUNFQ0RFY0xJQUV0QUFCQkNrWUVRQ0FCUVFGcUlRRU1BUXNnQXkwQUxrRUJjUTBBSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEhISnpZQ0VDQURRUUkyQWd4QkFDRUNERVlMUVM4aEFnd3JDeUFCUVFGcUlRRkJNQ0VDRENvTElBRWdCRVlFUUVFdklRSU1SQXNnQVMwQUFDSUFRUWxISUFCQklFZHhSUVJBSUFGQkFXb2hBU0FETFFBdVFRRnhEUUVnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRZWtQTmdJUUlBTkJDallDREVFQUlRSU1SQXRCQVNFQ0FrQUNRQUpBQWtBQ1FBSkFJQU10QUN4QkFtc09Cd1VFQkFNQkFnQUVDeUFESUFNdkFUSkJDSEk3QVRJTUF3dEJBaUVDREFFTFFRUWhBZ3NnQTBFQk9nQXNJQU1nQXk4Qk1pQUNjanNCTWd0QkxpRUNEQ29MSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEd6RWpZQ0VDQURRUXMyQWd4QkFDRUNERU1MUWRJQklRSU1LQXNnQVNBRVJnUkFRUzRoQWd4Q0N5QURRUUEyQWdRZ0EwRVJOZ0lJSUFNZ0FTQUJFREFpQUEwQkMwRXRJUUlNSmdzZ0EwRXROZ0ljSUFNZ0FUWUNGQ0FESUFBMkFneEJBQ0VDREQ4TFFRQWhBQUpBSUFNb0FqZ2lBa1VOQUNBQ0tBSkVJZ0pGRFFBZ0F5QUNFUUFBSVFBTElBQkZEUUFnQUVFVlJ3MEJJQU5CMkFBMkFod2dBeUFCTmdJVUlBTkJuaG8yQWhBZ0EwRVZOZ0lNUVFBaEFndytDMEhMQUNFQ0RDTUxJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR0ZEallDRUNBRFFSMDJBZ3hCQUNFQ0REd0xJQUVnQkVZRVFFSE9BQ0VDRER3TElBRXRBQUFpQUVFZ1JnMENJQUJCT2tZTkFRc2dBMEVBT2dBc1FRa2hBZ3dnQ3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQkVDOGlBQTBCREFJTElBTXRBQzVCQVhFRVFFSFBBU0VDREI4TElBTW9BZ1FoQUNBRFFRQTJBZ1FnQXlBQUlBRVFMeUlBUlEwQ0lBTkJLallDSENBRElBQTJBZ3dnQXlBQlFRRnFOZ0lVUVFBaEFndzRDeUFEUWNzQU5nSWNJQU1nQURZQ0RDQURJQUZCQVdvMkFoUkJBQ0VDRERjTElBRkJBV29oQVVFL0lRSU1IQXNnQVVFQmFpRUJEQ2tMSUFFZ0JFWUVRRUVySVFJTU5Rc0NRQ0FCTFFBQVFRcEdCRUFnQVVFQmFpRUJEQUVMSUFNdEFDNUJ3QUJ4UlEwR0N5QURMUUF5UVlBQmNRUkFRUUFoQUFKQUlBTW9BamdpQWtVTkFDQUNLQUpVSWdKRkRRQWdBeUFDRVFBQUlRQUxJQUJGRFJFZ0FFRVZSZ1JBSUFOQkJUWUNIQ0FESUFFMkFoUWdBMEdHR2pZQ0VDQURRUlUyQWd4QkFDRUNERFlMSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEhpRFRZQ0VDQURRUlEyQWd4QkFDRUNERFVMSUFOQk1tb2hBaUFERURSQkFDRUFBa0FnQXlnQ09DSUdSUTBBSUFZb0FpUWlCa1VOQUNBRElBWVJBQUFoQUFzZ0FBNFdBZ0VBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQXdRTElBTkJBVG9BTUFzZ0FpQUNMd0VBUWNBQWNqc0JBQXRCS2lFQ0RCY0xJQU5CS1RZQ0hDQURJQUUyQWhRZ0EwR3lHRFlDRUNBRFFSVTJBZ3hCQUNFQ0REQUxJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSGRDellDRUNBRFFSRTJBZ3hCQUNFQ0RDOExJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR2RDellDRUNBRFFRSTJBZ3hCQUNFQ0RDNExRUUVoQnlBREx3RXlJZ1ZCQ0hGRkJFQWdBeWtESUVJQVVpRUhDd0pBSUFNdEFEQUVRRUVCSVFBZ0F5MEFLVUVGUmcwQklBVkJ3QUJ4UlNBSGNVVU5BUXNDUUNBRExRQW9JZ0pCQWtZRVFFRUJJUUFnQXk4Qk5DSUdRZVVBUmcwQ1FRQWhBQ0FGUWNBQWNRMENJQVpCNUFCR0RRSWdCa0htQUd0QkFra05BaUFHUWN3QlJnMENJQVpCc0FKR0RRSU1BUXRCQUNFQUlBVkJ3QUJ4RFFFTFFRSWhBQ0FGUVFoeERRQWdCVUdBQkhFRVFBSkFJQUpCQVVjTkFDQURMUUF1UVFweERRQkJCU0VBREFJTFFRUWhBQXdCQ3lBRlFTQnhSUVJBSUFNUU5VRUFSMEVDZENFQURBRUxRUUJCQXlBREtRTWdVQnNoQUFzQ1FDQUFRUUZyRGdVQUFRWUhBZ01MUVFBaEFnSkFJQU1vQWpnaUFFVU5BQ0FBS0FJc0lnQkZEUUFnQXlBQUVRQUFJUUlMSUFKRkRTWWdBa0VWUmdSQUlBTkJBellDSENBRElBRTJBaFFnQTBHOUdqWUNFQ0FEUVJVMkFneEJBQ0VDREM0TFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJydzQyQWhBZ0EwRVNOZ0lNREMwTFFjNEJJUUlNRWd0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSGtIellDRUNBRFFRODJBZ3dNS3d0QkFDRUFBa0FnQXlnQ09DSUNSUTBBSUFJb0Fpd2lBa1VOQUNBRElBSVJBQUFoQUFzZ0FBMEJDMEVPSVFJTUR3c2dBRUVWUmdSQUlBTkJBallDSENBRElBRTJBaFFnQTBHOUdqWUNFQ0FEUVJVMkFneEJBQ0VDRENrTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJydzQyQWhBZ0EwRVNOZ0lNRENnTFFTa2hBZ3dOQ3lBRFFRRTZBREVNSkFzZ0FTQUVSd1JBSUFOQkNUWUNDQ0FESUFFMkFnUkJLQ0VDREF3TFFTWWhBZ3dsQ3lBRElBTXBBeUFpRENBRUlBRnJyU0lLZlNJTFFnQWdDeUFNV0JzM0F5QWdDaUFNVkFSQVFTVWhBZ3dsQ3lBREtBSUVJUUJCQUNFQ0lBTkJBRFlDQkNBRElBQWdBU0FNcDJvaUFSQXhJZ0JGRFFBZ0EwRUZOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFnd01KQXRCRHlFQ0RBa0xJQUVnQkVZRVFFRWpJUUlNSXd0Q0FDRUtBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBRXRBQUJCTUdzT054Y1dBQUVDQXdRRkJnY1VGQlFVRkJRVUNBa0tDd3dORkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFPRHhBUkVoTVVDMElDSVFvTUZndENBeUVLREJVTFFnUWhDZ3dVQzBJRklRb01Fd3RDQmlFS0RCSUxRZ2NoQ2d3UkMwSUlJUW9NRUF0Q0NTRUtEQThMUWdvaENnd09DMElMSVFvTURRdENEQ0VLREF3TFFnMGhDZ3dMQzBJT0lRb01DZ3RDRHlFS0RBa0xRZ29oQ2d3SUMwSUxJUW9NQnd0Q0RDRUtEQVlMUWcwaENnd0ZDMElPSVFvTUJBdENEeUVLREFNTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJ6aFEyQWhBZ0EwRU1OZ0lNRENJTElBRWdCRVlFUUVFaUlRSU1JZ3RDQUNFS0FrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FCTFFBQVFUQnJEamNWRkFBQkFnTUVCUVlIRmhZV0ZoWVdGZ2dKQ2dzTURSWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0RnOFFFUklURmd0Q0FpRUtEQlFMUWdNaENnd1RDMElFSVFvTUVndENCU0VLREJFTFFnWWhDZ3dRQzBJSElRb01Ed3RDQ0NFS0RBNExRZ2toQ2d3TkMwSUtJUW9NREF0Q0N5RUtEQXNMUWd3aENnd0tDMElOSVFvTUNRdENEaUVLREFnTFFnOGhDZ3dIQzBJS0lRb01CZ3RDQ3lFS0RBVUxRZ3doQ2d3RUMwSU5JUW9NQXd0Q0RpRUtEQUlMUWc4aENnd0JDMElCSVFvTElBRkJBV29oQVNBREtRTWdJZ3RDLy8vLy8vLy8vLzhQV0FSQUlBTWdDMElFaGlBS2hEY0RJQXdDQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFhMEpOZ0lRSUFOQkREWUNEQXdmQzBFbElRSU1CQXRCSmlFQ0RBTUxJQU1nQVRvQUxDQURRUUEyQWdBZ0IwRUJhaUVCUVF3aEFnd0NDeUFEUVFBMkFnQWdCa0VCYWlFQlFRb2hBZ3dCQ3lBQlFRRnFJUUZCQ0NFQ0RBQUxBQXRCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBIVkVEWUNFQ0FEUVFrMkFnd01HQXRCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBIWENqWUNFQ0FEUVFrMkFnd01Gd3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBHL0VEWUNFQ0FEUVFrMkFnd01GZ3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBHa0VUWUNFQ0FEUVFrMkFnd01GUXRCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBIVkVEWUNFQ0FEUVFrMkFnd01GQXRCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBIWENqWUNFQ0FEUVFrMkFnd01Fd3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBHL0VEWUNFQ0FEUVFrMkFnd01FZ3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBHa0VUWUNFQ0FEUVFrMkFnd01FUXRCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBHL0ZqWUNFQ0FEUVE4MkFnd01FQXRCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBHL0ZqWUNFQ0FEUVE4MkFnd01Ed3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBISUVqWUNFQ0FEUVFzMkFnd01EZ3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBHVkNUWUNFQ0FEUVFzMkFnd01EUXRCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBIcER6WUNFQ0FEUVFvMkFnd01EQXRCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBHREVEWUNFQ0FEUVFvMkFnd01Dd3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBHbUhEWUNFQ0FEUVFJMkFnd01DZ3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBIRkZUWUNFQ0FEUVFJMkFnd01DUXRCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBIL0Z6WUNFQ0FEUVFJMkFnd01DQXRCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBIS0Z6WUNFQ0FEUVFJMkFnd01Cd3NnQTBFQ05nSWNJQU1nQVRZQ0ZDQURRWlFkTmdJUUlBTkJGallDREVFQUlRSU1CZ3RCM2dBaEFpQUJJQVJHRFFVZ0NVRUlhaUVISUFNb0FnQWhCUUpBQWtBZ0FTQUVSd1JBSUFWQnhzWUFhaUVJSUFRZ0JXb2dBV3NoQmlBRlFYOXpRUXBxSWdVZ0FXb2hBQU5BSUFFdEFBQWdDQzBBQUVjRVFFRUNJUWdNQXdzZ0JVVUVRRUVBSVFnZ0FDRUJEQU1MSUFWQkFXc2hCU0FJUVFGcUlRZ2dCQ0FCUVFGcUlnRkhEUUFMSUFZaEJTQUVJUUVMSUFkQkFUWUNBQ0FESUFVMkFnQU1BUXNnQTBFQU5nSUFJQWNnQ0RZQ0FBc2dCeUFCTmdJRUlBa29BZ3doQUNBSktBSUlEZ01CQlFJQUN3QUxJQU5CQURZQ0hDQURRYTBkTmdJUUlBTkJGellDRENBRElBQkJBV28yQWhSQkFDRUNEQU1MSUFOQkFEWUNIQ0FESUFBMkFoUWdBMEhDSFRZQ0VDQURRUWsyQWd4QkFDRUNEQUlMSUFFZ0JFWUVRRUVvSVFJTUFnc2dBMEVKTmdJSUlBTWdBVFlDQkVFbklRSU1BUXNnQVNBRVJnUkFRUUVoQWd3QkN3TkFBa0FDUUFKQUlBRXRBQUJCQ21zT0JBQUJBUUFCQ3lBQlFRRnFJUUVNQVFzZ0FVRUJhaUVCSUFNdEFDNUJJSEVOQUVFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFZd2dOZ0lRSUFOQkJUWUNEQXdDQzBFQklRSWdBU0FFUncwQUN3c2dDVUVRYWlRQUlBSkZCRUFnQXlnQ0RDRUFEQUVMSUFNZ0FqWUNIRUVBSVFBZ0F5Z0NCQ0lCUlEwQUlBTWdBU0FFSUFNb0FnZ1JBUUFpQVVVTkFDQURJQVEyQWhRZ0F5QUJOZ0lNSUFFaEFBc2dBQXUrQWdFQ2Z5QUFRUUE2QUFBZ0FFSGNBR29pQVVFQmEwRUFPZ0FBSUFCQkFEb0FBaUFBUVFBNkFBRWdBVUVEYTBFQU9nQUFJQUZCQW10QkFEb0FBQ0FBUVFBNkFBTWdBVUVFYTBFQU9nQUFRUUFnQUd0QkEzRWlBU0FBYWlJQVFRQTJBZ0JCM0FBZ0FXdEJmSEVpQWlBQWFpSUJRUVJyUVFBMkFnQUNRQ0FDUVFsSkRRQWdBRUVBTmdJSUlBQkJBRFlDQkNBQlFRaHJRUUEyQWdBZ0FVRU1hMEVBTmdJQUlBSkJHVWtOQUNBQVFRQTJBaGdnQUVFQU5nSVVJQUJCQURZQ0VDQUFRUUEyQWd3Z0FVRVFhMEVBTmdJQUlBRkJGR3RCQURZQ0FDQUJRUmhyUVFBMkFnQWdBVUVjYTBFQU5nSUFJQUlnQUVFRWNVRVljaUlDYXlJQlFTQkpEUUFnQUNBQ2FpRUFBMEFnQUVJQU53TVlJQUJDQURjREVDQUFRZ0EzQXdnZ0FFSUFOd01BSUFCQklHb2hBQ0FCUVNCcklnRkJIMHNOQUFzTEMxWUJBWDhDUUNBQUtBSU1EUUFDUUFKQUFrQUNRQ0FBTFFBeERnTUJBQU1DQ3lBQUtBSTRJZ0ZGRFFBZ0FTZ0NMQ0lCUlEwQUlBQWdBUkVBQUNJQkRRTUxRUUFQQ3dBTElBQkIwQmcyQWhCQkRpRUJDeUFCQ3hvQUlBQW9BZ3hGQkVBZ0FFSEpIallDRUNBQVFSVTJBZ3dMQ3hRQUlBQW9BZ3hCRlVZRVFDQUFRUUEyQWd3TEN4UUFJQUFvQWd4QkZrWUVRQ0FBUVFBMkFnd0xDd2NBSUFBb0Fnd0xCd0FnQUNnQ0VBc0pBQ0FBSUFFMkFoQUxCd0FnQUNnQ0ZBc1hBQ0FBUVNSUEJFQUFDeUFBUVFKMFFaUTNhaWdDQUFzWEFDQUFRUzlQQkVBQUN5QUFRUUowUWFRNGFpZ0NBQXUvQ1FFQmYwSGZMQ0VCQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FFSGtBR3NPOUFOallnQUJZV0ZoWVdGaEFnTUVCV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdFR0J3Z0pDZ3NNRFE0UFlXRmhZV0VRWVdGaFlXRmhZV0ZoWVdFUllXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaEVoTVVGUllYR0JrYUcyRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRWNIUjRmSUNFaUl5UWxKaWNvS1NvckxDMHVMekF4TWpNME5UWmhOemc1T21GaFlXRmhZV0ZoTzJGaFlUeGhZV0ZoUFQ0L1lXRmhZV0ZoWVdGQVlXRkJZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoUWtORVJVWkhTRWxLUzB4TlRrOVFVVkpUWVdGaFlXRmhZV0ZVVlZaWFdGbGFXMkZjWFdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlWNWhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmZZR0VMUWRVckR3dEJneVVQQzBHL01BOExRZkkxRHd0QnRDZ1BDMEdmS0E4TFFZRXNEd3RCMWlvUEMwSDBNdzhMUWEwekR3dEJ5eWdQQzBIT0l3OExRY0FqRHd0QjJTTVBDMEhSSkE4TFFad3pEd3RCb2pZUEMwSDhNdzhMUWVBckR3dEI0U1VQQzBIdElBOExRY1F5RHd0QnFTY1BDMEc1Tmc4TFFiZ2dEd3RCcXlBUEMwR2pKQThMUWJZa0R3dEJnU01QQzBIaE1nOExRWjgwRHd0QnlDa1BDMEhBTWc4TFFlNHlEd3RCOEM4UEMwSEdOQThMUWRBaER3dEJtaVFQQzBIckx3OExRWVExRHd0Qnl6VVBDMEdXTVE4TFFjZ3JEd3RCMUM4UEMwR1RNQThMUWQ4MUR3dEJ0Q01QQzBHK05ROExRZElwRHd0QnN5SVBDMEhOSUE4TFFaczJEd3RCa0NFUEMwSC9JQThMUWEwMUR3dEJzRFFQQzBIeEpBOExRYWNxRHd0QjNUQVBDMEdMSWc4TFFjZ3ZEd3RCNnlvUEMwSDBLUThMUVk4bER3dEIzU0lQQzBIc0pnOExRZjB3RHd0QjFpWVBDMEdVTlE4TFFZMGpEd3RCdWlrUEMwSEhJZzhMUWZJbER3dEJ0ak1QQzBHaUlROExRZjh2RHd0QndDRVBDMEdCTXc4TFFja2xEd3RCcURFUEMwSEdNdzhMUWRNMkR3dEJ4allQQzBIa05BOExRWWdtRHd0QjdTY1BDMEg0SVE4TFFha3dEd3RCanpRUEMwR0dOZzhMUWFvdkR3dEJvU1lQQzBIc05nOExRWklwRHd0QnJ5WVBDMEdaSWc4TFFlQWhEd3NBQzBHMUpTRUJDeUFCQ3hjQUlBQWdBQzhCTGtIKy93TnhJQUZCQUVkeU93RXVDeG9BSUFBZ0FDOEJMa0g5L3dOeElBRkJBRWRCQVhSeU93RXVDeG9BSUFBZ0FDOEJMa0g3L3dOeElBRkJBRWRCQW5SeU93RXVDeG9BSUFBZ0FDOEJMa0gzL3dOeElBRkJBRWRCQTNSeU93RXVDeG9BSUFBZ0FDOEJMa0h2L3dOeElBRkJBRWRCQkhSeU93RXVDeG9BSUFBZ0FDOEJMa0hmL3dOeElBRkJBRWRCQlhSeU93RXVDeG9BSUFBZ0FDOEJMa0cvL3dOeElBRkJBRWRCQm5SeU93RXVDeG9BSUFBZ0FDOEJMa0gvL2dOeElBRkJBRWRCQjNSeU93RXVDeG9BSUFBZ0FDOEJMa0gvL1FOeElBRkJBRWRCQ0hSeU93RXVDeG9BSUFBZ0FDOEJMa0gvK3dOeElBRkJBRWRCQ1hSeU93RXVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDQkNJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQnpoRTJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDQ0NJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQjVBbzJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDRENJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQjVSMDJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDRUNJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQm5SQTJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDRkNJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQm9oNDJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDR0NJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQjdoUTJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDS0NJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQjlnZzJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDSENJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQjl4czJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDSUNJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQmxSVTJBaEJCR0NFRUN5QUVDemdBSUFBQ2Z5QUFMd0V5UVJSeFFSUkdCRUJCQVNBQUxRQW9RUUZHRFFFYUlBQXZBVFJCNVFCR0RBRUxJQUF0QUNsQkJVWUxPZ0F3QzFrQkFuOENRQ0FBTFFBb1FRRkdEUUFnQUM4Qk5DSUJRZVFBYTBIa0FFa05BQ0FCUWN3QlJnMEFJQUZCc0FKR0RRQWdBQzhCTWlJQVFjQUFjUTBBUVFFaEFpQUFRWWdFY1VHQUJFWU5BQ0FBUVNoeFJTRUNDeUFDQzR3QkFRSi9Ba0FDUUFKQUlBQXRBQ3BGRFFBZ0FDMEFLMFVOQUNBQUx3RXlJZ0ZCQW5GRkRRRU1BZ3NnQUM4Qk1pSUJRUUZ4UlEwQkMwRUJJUUlnQUMwQUtFRUJSZzBBSUFBdkFUUWlBRUhrQUd0QjVBQkpEUUFnQUVITUFVWU5BQ0FBUWJBQ1JnMEFJQUZCd0FCeERRQkJBQ0VDSUFGQmlBUnhRWUFFUmcwQUlBRkJLSEZCQUVjaEFnc2dBZ3RYQUNBQVFSaHFRZ0EzQXdBZ0FFSUFOd01BSUFCQk9HcENBRGNEQUNBQVFUQnFRZ0EzQXdBZ0FFRW9ha0lBTndNQUlBQkJJR3BDQURjREFDQUFRUkJxUWdBM0F3QWdBRUVJYWtJQU53TUFJQUJCN0FFMkFod0xCZ0FnQUJBNUM1b3RBUXQvSXdCQkVHc2lDaVFBUVpqVUFDZ0NBQ0lKUlFSQVFkalhBQ2dDQUNJRlJRUkFRZVRYQUVKL053SUFRZHpYQUVLQWdJU0FnSURBQURjQ0FFSFkxd0FnQ2tFSWFrRndjVUhZcXRXcUJYTWlCVFlDQUVIczF3QkJBRFlDQUVHODF3QkJBRFlDQUF0QndOY0FRWURZQkRZQ0FFR1ExQUJCZ05nRU5nSUFRYVRVQUNBRk5nSUFRYURVQUVGL05nSUFRY1RYQUVHQXFBTTJBZ0FEUUNBQlFielVBR29nQVVHdzFBQnFJZ0kyQWdBZ0FpQUJRYWpVQUdvaUF6WUNBQ0FCUWJUVUFHb2dBellDQUNBQlFjVFVBR29nQVVHNDFBQnFJZ00yQWdBZ0F5QUNOZ0lBSUFGQnpOUUFhaUFCUWNEVUFHb2lBallDQUNBQ0lBTTJBZ0FnQVVISTFBQnFJQUkyQWdBZ0FVRWdhaUlCUVlBQ1J3MEFDMEdNMkFSQndhY0ROZ0lBUVp6VUFFSG8xd0FvQWdBMkFnQkJqTlFBUWNDbkF6WUNBRUdZMUFCQmlOZ0VOZ0lBUWN6L0IwRTROZ0lBUVlqWUJDRUpDd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQkI3QUZOQkVCQmdOUUFLQUlBSWdaQkVDQUFRUk5xUVhCeElBQkJDMGtiSWdSQkEzWWlBSFlpQVVFRGNRUkFBa0FnQVVFQmNTQUFja0VCY3lJQ1FRTjBJZ0JCcU5RQWFpSUJJQUJCc05RQWFpZ0NBQ0lBS0FJSUlnTkdCRUJCZ05RQUlBWkJmaUFDZDNFMkFnQU1BUXNnQVNBRE5nSUlJQU1nQVRZQ0RBc2dBRUVJYWlFQklBQWdBa0VEZENJQ1FRTnlOZ0lFSUFBZ0Ftb2lBQ0FBS0FJRVFRRnlOZ0lFREJFTFFZalVBQ2dDQUNJSUlBUlBEUUVnQVFSQUFrQkJBaUFBZENJQ1FRQWdBbXR5SUFFZ0FIUnhhQ0lBUVFOMElnSkJxTlFBYWlJQklBSkJzTlFBYWlnQ0FDSUNLQUlJSWdOR0JFQkJnTlFBSUFaQmZpQUFkM0VpQmpZQ0FBd0JDeUFCSUFNMkFnZ2dBeUFCTmdJTUN5QUNJQVJCQTNJMkFnUWdBRUVEZENJQUlBUnJJUVVnQUNBQ2FpQUZOZ0lBSUFJZ0JHb2lCQ0FGUVFGeU5nSUVJQWdFUUNBSVFYaHhRYWpVQUdvaEFFR1UxQUFvQWdBaEF3Si9RUUVnQ0VFRGRuUWlBU0FHY1VVRVFFR0ExQUFnQVNBR2NqWUNBQ0FBREFFTElBQW9BZ2dMSWdFZ0F6WUNEQ0FBSUFNMkFnZ2dBeUFBTmdJTUlBTWdBVFlDQ0FzZ0FrRUlhaUVCUVpUVUFDQUVOZ0lBUVlqVUFDQUZOZ0lBREJFTFFZVFVBQ2dDQUNJTFJRMEJJQXRvUVFKMFFiRFdBR29vQWdBaUFDZ0NCRUY0Y1NBRWF5RUZJQUFoQWdOQUFrQWdBaWdDRUNJQlJRUkFJQUpCRkdvb0FnQWlBVVVOQVFzZ0FTZ0NCRUY0Y1NBRWF5SURJQVZKSVFJZ0F5QUZJQUliSVFVZ0FTQUFJQUliSVFBZ0FTRUNEQUVMQ3lBQUtBSVlJUWtnQUNnQ0RDSURJQUJIQkVCQmtOUUFLQUlBR2lBRElBQW9BZ2dpQVRZQ0NDQUJJQU0yQWd3TUVBc2dBRUVVYWlJQ0tBSUFJZ0ZGQkVBZ0FDZ0NFQ0lCUlEwRElBQkJFR29oQWdzRFFDQUNJUWNnQVNJRFFSUnFJZ0lvQWdBaUFRMEFJQU5CRUdvaEFpQURLQUlRSWdFTkFBc2dCMEVBTmdJQURBOExRWDhoQkNBQVFiOS9TdzBBSUFCQkUyb2lBVUZ3Y1NFRVFZVFVBQ2dDQUNJSVJRMEFRUUFnQkdzaEJRSkFBa0FDUUFKL1FRQWdCRUdBQWtrTkFCcEJIeUFFUWYvLy93ZExEUUFhSUFSQkppQUJRUWgyWnlJQWEzWkJBWEVnQUVFQmRHdEJQbW9MSWdaQkFuUkJzTllBYWlnQ0FDSUNSUVJBUVFBaEFVRUFJUU1NQVF0QkFDRUJJQVJCR1NBR1FRRjJhMEVBSUFaQkgwY2JkQ0VBUVFBaEF3TkFBa0FnQWlnQ0JFRjRjU0FFYXlJSElBVlBEUUFnQWlFRElBY2lCUTBBUVFBaEJTQUNJUUVNQXdzZ0FTQUNRUlJxS0FJQUlnY2dCeUFDSUFCQkhYWkJCSEZxUVJCcUtBSUFJZ0pHR3lBQklBY2JJUUVnQUVFQmRDRUFJQUlOQUFzTElBRWdBM0pGQkVCQkFDRURRUUlnQm5RaUFFRUFJQUJyY2lBSWNTSUFSUTBESUFCb1FRSjBRYkRXQUdvb0FnQWhBUXNnQVVVTkFRc0RRQ0FCS0FJRVFYaHhJQVJySWdJZ0JVa2hBQ0FDSUFVZ0FCc2hCU0FCSUFNZ0FCc2hBeUFCS0FJUUlnQUVmeUFBQlNBQlFSUnFLQUlBQ3lJQkRRQUxDeUFEUlEwQUlBVkJpTlFBS0FJQUlBUnJUdzBBSUFNb0FoZ2hCeUFESUFNb0Fnd2lBRWNFUUVHUTFBQW9BZ0FhSUFBZ0F5Z0NDQ0lCTmdJSUlBRWdBRFlDREF3T0N5QURRUlJxSWdJb0FnQWlBVVVFUUNBREtBSVFJZ0ZGRFFNZ0EwRVFhaUVDQ3dOQUlBSWhCaUFCSWdCQkZHb2lBaWdDQUNJQkRRQWdBRUVRYWlFQ0lBQW9BaEFpQVEwQUN5QUdRUUEyQWdBTURRdEJpTlFBS0FJQUlnTWdCRThFUUVHVTFBQW9BZ0FoQVFKQUlBTWdCR3NpQWtFUVR3UkFJQUVnQkdvaUFDQUNRUUZ5TmdJRUlBRWdBMm9nQWpZQ0FDQUJJQVJCQTNJMkFnUU1BUXNnQVNBRFFRTnlOZ0lFSUFFZ0Eyb2lBQ0FBS0FJRVFRRnlOZ0lFUVFBaEFFRUFJUUlMUVlqVUFDQUNOZ0lBUVpUVUFDQUFOZ0lBSUFGQkNHb2hBUXdQQzBHTTFBQW9BZ0FpQXlBRVN3UkFJQVFnQ1dvaUFDQURJQVJySWdGQkFYSTJBZ1JCbU5RQUlBQTJBZ0JCak5RQUlBRTJBZ0FnQ1NBRVFRTnlOZ0lFSUFsQkNHb2hBUXdQQzBFQUlRRWdCQUovUWRqWEFDZ0NBQVJBUWVEWEFDZ0NBQXdCQzBIazF3QkNmemNDQUVIYzF3QkNnSUNFZ0lDQXdBQTNBZ0JCMk5jQUlBcEJER3BCY0hGQjJLclZxZ1Z6TmdJQVFlelhBRUVBTmdJQVFielhBRUVBTmdJQVFZQ0FCQXNpQUNBRVFjY0FhaUlGYWlJR1FRQWdBR3NpQjNFaUFrOEVRRUh3MXdCQk1EWUNBQXdQQ3dKQVFialhBQ2dDQUNJQlJRMEFRYkRYQUNnQ0FDSUlJQUpxSVFBZ0FDQUJUU0FBSUFoTGNRMEFRUUFoQVVIdzF3QkJNRFlDQUF3UEMwRzgxd0F0QUFCQkJIRU5CQUpBQWtBZ0NRUkFRY0RYQUNFQkEwQWdBU2dDQUNJQUlBbE5CRUFnQUNBQktBSUVhaUFKU3cwREN5QUJLQUlJSWdFTkFBc0xRUUFRT2lJQVFYOUdEUVVnQWlFR1FkelhBQ2dDQUNJQlFRRnJJZ01nQUhFRVFDQUNJQUJySUFBZ0EycEJBQ0FCYTNGcUlRWUxJQVFnQms4TkJTQUdRZjcvLy84SFN3MEZRYmpYQUNnQ0FDSURCRUJCc05jQUtBSUFJZ2NnQm1vaEFTQUJJQWRORFFZZ0FTQURTdzBHQ3lBR0VEb2lBU0FBUncwQkRBY0xJQVlnQTJzZ0IzRWlCa0grLy8vL0Iwc05CQ0FHRURvaEFDQUFJQUVvQWdBZ0FTZ0NCR3BHRFFNZ0FDRUJDd0pBSUFZZ0JFSElBR3BQRFFBZ0FVRi9SZzBBUWVEWEFDZ0NBQ0lBSUFVZ0JtdHFRUUFnQUd0eElnQkIvdi8vL3dkTEJFQWdBU0VBREFjTElBQVFPa0YvUndSQUlBQWdCbW9oQmlBQklRQU1Cd3RCQUNBR2F4QTZHZ3dFQ3lBQklnQkJmMGNOQlF3REMwRUFJUU1NREF0QkFDRUFEQW9MSUFCQmYwY05BZ3RCdk5jQVFielhBQ2dDQUVFRWNqWUNBQXNnQWtIKy8vLy9CMHNOQVNBQ0VEb2hBRUVBRURvaEFTQUFRWDlHRFFFZ0FVRi9SZzBCSUFBZ0FVOE5BU0FCSUFCcklnWWdCRUU0YWswTkFRdEJzTmNBUWJEWEFDZ0NBQ0FHYWlJQk5nSUFRYlRYQUNnQ0FDQUJTUVJBUWJUWEFDQUJOZ0lBQ3dKQUFrQUNRRUdZMUFBb0FnQWlBZ1JBUWNEWEFDRUJBMEFnQUNBQktBSUFJZ01nQVNnQ0JDSUZha1lOQWlBQktBSUlJZ0VOQUFzTUFndEJrTlFBS0FJQUlnRkJBRWNnQUNBQlQzRkZCRUJCa05RQUlBQTJBZ0FMUVFBaEFVSEUxd0FnQmpZQ0FFSEExd0FnQURZQ0FFR2cxQUJCZnpZQ0FFR2sxQUJCMk5jQUtBSUFOZ0lBUWN6WEFFRUFOZ0lBQTBBZ0FVRzgxQUJxSUFGQnNOUUFhaUlDTmdJQUlBSWdBVUdvMUFCcUlnTTJBZ0FnQVVHMDFBQnFJQU0yQWdBZ0FVSEUxQUJxSUFGQnVOUUFhaUlETmdJQUlBTWdBallDQUNBQlFjelVBR29nQVVIQTFBQnFJZ0kyQWdBZ0FpQUROZ0lBSUFGQnlOUUFhaUFDTmdJQUlBRkJJR29pQVVHQUFrY05BQXRCZUNBQWEwRVBjU0lCSUFCcUlnSWdCa0U0YXlJRElBRnJJZ0ZCQVhJMkFnUkJuTlFBUWVqWEFDZ0NBRFlDQUVHTTFBQWdBVFlDQUVHWTFBQWdBallDQUNBQUlBTnFRVGcyQWdRTUFnc2dBQ0FDVFEwQUlBSWdBMGtOQUNBQktBSU1RUWh4RFFCQmVDQUNhMEVQY1NJQUlBSnFJZ05Cak5RQUtBSUFJQVpxSWdjZ0FHc2lBRUVCY2pZQ0JDQUJJQVVnQm1vMkFnUkJuTlFBUWVqWEFDZ0NBRFlDQUVHTTFBQWdBRFlDQUVHWTFBQWdBellDQUNBQ0lBZHFRVGcyQWdRTUFRc2dBRUdRMUFBb0FnQkpCRUJCa05RQUlBQTJBZ0FMSUFBZ0Jtb2hBMEhBMXdBaEFRSkFBa0FDUUFOQUlBTWdBU2dDQUVjRVFDQUJLQUlJSWdFTkFRd0NDd3NnQVMwQURFRUljVVVOQVF0QndOY0FJUUVEUUNBQktBSUFJZ01nQWswRVFDQURJQUVvQWdScUlnVWdBa3NOQXdzZ0FTZ0NDQ0VCREFBTEFBc2dBU0FBTmdJQUlBRWdBU2dDQkNBR2FqWUNCQ0FBUVhnZ0FHdEJEM0ZxSWdrZ0JFRURjallDQkNBRFFYZ2dBMnRCRDNGcUlnWWdCQ0FKYWlJRWF5RUJJQUlnQmtZRVFFR1kxQUFnQkRZQ0FFR00xQUJCak5RQUtBSUFJQUZxSWdBMkFnQWdCQ0FBUVFGeU5nSUVEQWdMUVpUVUFDZ0NBQ0FHUmdSQVFaVFVBQ0FFTmdJQVFZalVBRUdJMUFBb0FnQWdBV29pQURZQ0FDQUVJQUJCQVhJMkFnUWdBQ0FFYWlBQU5nSUFEQWdMSUFZb0FnUWlCVUVEY1VFQlJ3MEdJQVZCZUhFaENDQUZRZjhCVFFSQUlBVkJBM1loQXlBR0tBSUlJZ0FnQmlnQ0RDSUNSZ1JBUVlEVUFFR0ExQUFvQWdCQmZpQURkM0UyQWdBTUJ3c2dBaUFBTmdJSUlBQWdBallDREF3R0N5QUdLQUlZSVFjZ0JpQUdLQUlNSWdCSEJFQWdBQ0FHS0FJSUlnSTJBZ2dnQWlBQU5nSU1EQVVMSUFaQkZHb2lBaWdDQUNJRlJRUkFJQVlvQWhBaUJVVU5CQ0FHUVJCcUlRSUxBMEFnQWlFRElBVWlBRUVVYWlJQ0tBSUFJZ1VOQUNBQVFSQnFJUUlnQUNnQ0VDSUZEUUFMSUFOQkFEWUNBQXdFQzBGNElBQnJRUTl4SWdFZ0FHb2lCeUFHUVRocklnTWdBV3NpQVVFQmNqWUNCQ0FBSUFOcVFUZzJBZ1FnQWlBRlFUY2dCV3RCRDNGcVFUOXJJZ01nQXlBQ1FSQnFTUnNpQTBFak5nSUVRWnpVQUVIbzF3QW9BZ0EyQWdCQmpOUUFJQUUyQWdCQm1OUUFJQWMyQWdBZ0EwRVFha0hJMXdBcEFnQTNBZ0FnQTBIQTF3QXBBZ0EzQWdoQnlOY0FJQU5CQ0dvMkFnQkJ4TmNBSUFZMkFnQkJ3TmNBSUFBMkFnQkJ6TmNBUVFBMkFnQWdBMEVrYWlFQkEwQWdBVUVITmdJQUlBVWdBVUVFYWlJQlN3MEFDeUFDSUFOR0RRQWdBeUFES0FJRVFYNXhOZ0lFSUFNZ0F5QUNheUlGTmdJQUlBSWdCVUVCY2pZQ0JDQUZRZjhCVFFSQUlBVkJlSEZCcU5RQWFpRUFBbjlCZ05RQUtBSUFJZ0ZCQVNBRlFRTjJkQ0lEY1VVRVFFR0ExQUFnQVNBRGNqWUNBQ0FBREFFTElBQW9BZ2dMSWdFZ0FqWUNEQ0FBSUFJMkFnZ2dBaUFBTmdJTUlBSWdBVFlDQ0F3QkMwRWZJUUVnQlVILy8vOEhUUVJBSUFWQkppQUZRUWgyWnlJQWEzWkJBWEVnQUVFQmRHdEJQbW9oQVFzZ0FpQUJOZ0ljSUFKQ0FEY0NFQ0FCUVFKMFFiRFdBR29oQUVHRTFBQW9BZ0FpQTBFQklBRjBJZ1p4UlFSQUlBQWdBallDQUVHRTFBQWdBeUFHY2pZQ0FDQUNJQUEyQWhnZ0FpQUNOZ0lJSUFJZ0FqWUNEQXdCQ3lBRlFSa2dBVUVCZG10QkFDQUJRUjlIRzNRaEFTQUFLQUlBSVFNQ1FBTkFJQU1pQUNnQ0JFRjRjU0FGUmcwQklBRkJIWFloQXlBQlFRRjBJUUVnQUNBRFFRUnhha0VRYWlJR0tBSUFJZ01OQUFzZ0JpQUNOZ0lBSUFJZ0FEWUNHQ0FDSUFJMkFnd2dBaUFDTmdJSURBRUxJQUFvQWdnaUFTQUNOZ0lNSUFBZ0FqWUNDQ0FDUVFBMkFoZ2dBaUFBTmdJTUlBSWdBVFlDQ0F0QmpOUUFLQUlBSWdFZ0JFME5BRUdZMUFBb0FnQWlBQ0FFYWlJQ0lBRWdCR3NpQVVFQmNqWUNCRUdNMUFBZ0FUWUNBRUdZMUFBZ0FqWUNBQ0FBSUFSQkEzSTJBZ1FnQUVFSWFpRUJEQWdMUVFBaEFVSHcxd0JCTURZQ0FBd0hDMEVBSVFBTElBZEZEUUFDUUNBR0tBSWNJZ0pCQW5SQnNOWUFhaUlES0FJQUlBWkdCRUFnQXlBQU5nSUFJQUFOQVVHRTFBQkJoTlFBS0FJQVFYNGdBbmR4TmdJQURBSUxJQWRCRUVFVUlBY29BaEFnQmtZYmFpQUFOZ0lBSUFCRkRRRUxJQUFnQnpZQ0dDQUdLQUlRSWdJRVFDQUFJQUkyQWhBZ0FpQUFOZ0lZQ3lBR1FSUnFLQUlBSWdKRkRRQWdBRUVVYWlBQ05nSUFJQUlnQURZQ0dBc2dBU0FJYWlFQklBWWdDR29pQmlnQ0JDRUZDeUFHSUFWQmZuRTJBZ1FnQVNBRWFpQUJOZ0lBSUFRZ0FVRUJjallDQkNBQlFmOEJUUVJBSUFGQmVIRkJxTlFBYWlFQUFuOUJnTlFBS0FJQUlnSkJBU0FCUVFOMmRDSUJjVVVFUUVHQTFBQWdBU0FDY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJZ0VnQkRZQ0RDQUFJQVEyQWdnZ0JDQUFOZ0lNSUFRZ0FUWUNDQXdCQzBFZklRVWdBVUgvLy84SFRRUkFJQUZCSmlBQlFRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb2hCUXNnQkNBRk5nSWNJQVJDQURjQ0VDQUZRUUowUWJEV0FHb2hBRUdFMUFBb0FnQWlBa0VCSUFWMElnTnhSUVJBSUFBZ0JEWUNBRUdFMUFBZ0FpQURjallDQUNBRUlBQTJBaGdnQkNBRU5nSUlJQVFnQkRZQ0RBd0JDeUFCUVJrZ0JVRUJkbXRCQUNBRlFSOUhHM1FoQlNBQUtBSUFJUUFDUUFOQUlBQWlBaWdDQkVGNGNTQUJSZzBCSUFWQkhYWWhBQ0FGUVFGMElRVWdBaUFBUVFSeGFrRVFhaUlES0FJQUlnQU5BQXNnQXlBRU5nSUFJQVFnQWpZQ0dDQUVJQVEyQWd3Z0JDQUVOZ0lJREFFTElBSW9BZ2dpQUNBRU5nSU1JQUlnQkRZQ0NDQUVRUUEyQWhnZ0JDQUNOZ0lNSUFRZ0FEWUNDQXNnQ1VFSWFpRUJEQUlMQWtBZ0IwVU5BQUpBSUFNb0Fod2lBVUVDZEVHdzFnQnFJZ0lvQWdBZ0EwWUVRQ0FDSUFBMkFnQWdBQTBCUVlUVUFDQUlRWDRnQVhkeElnZzJBZ0FNQWdzZ0IwRVFRUlFnQnlnQ0VDQURSaHRxSUFBMkFnQWdBRVVOQVFzZ0FDQUhOZ0lZSUFNb0FoQWlBUVJBSUFBZ0FUWUNFQ0FCSUFBMkFoZ0xJQU5CRkdvb0FnQWlBVVVOQUNBQVFSUnFJQUUyQWdBZ0FTQUFOZ0lZQ3dKQUlBVkJEMDBFUUNBRElBUWdCV29pQUVFRGNqWUNCQ0FBSUFOcUlnQWdBQ2dDQkVFQmNqWUNCQXdCQ3lBRElBUnFJZ0lnQlVFQmNqWUNCQ0FESUFSQkEzSTJBZ1FnQWlBRmFpQUZOZ0lBSUFWQi93Rk5CRUFnQlVGNGNVR28xQUJxSVFBQ2YwR0ExQUFvQWdBaUFVRUJJQVZCQTNaMElnVnhSUVJBUVlEVUFDQUJJQVZ5TmdJQUlBQU1BUXNnQUNnQ0NBc2lBU0FDTmdJTUlBQWdBallDQ0NBQ0lBQTJBZ3dnQWlBQk5nSUlEQUVMUVI4aEFTQUZRZi8vL3dkTkJFQWdCVUVtSUFWQkNIWm5JZ0JyZGtFQmNTQUFRUUYwYTBFK2FpRUJDeUFDSUFFMkFod2dBa0lBTndJUUlBRkJBblJCc05ZQWFpRUFRUUVnQVhRaUJDQUljVVVFUUNBQUlBSTJBZ0JCaE5RQUlBUWdDSEkyQWdBZ0FpQUFOZ0lZSUFJZ0FqWUNDQ0FDSUFJMkFnd01BUXNnQlVFWklBRkJBWFpyUVFBZ0FVRWZSeHQwSVFFZ0FDZ0NBQ0VFQWtBRFFDQUVJZ0FvQWdSQmVIRWdCVVlOQVNBQlFSMTJJUVFnQVVFQmRDRUJJQUFnQkVFRWNXcEJFR29pQmlnQ0FDSUVEUUFMSUFZZ0FqWUNBQ0FDSUFBMkFoZ2dBaUFDTmdJTUlBSWdBallDQ0F3QkN5QUFLQUlJSWdFZ0FqWUNEQ0FBSUFJMkFnZ2dBa0VBTmdJWUlBSWdBRFlDRENBQ0lBRTJBZ2dMSUFOQkNHb2hBUXdCQ3dKQUlBbEZEUUFDUUNBQUtBSWNJZ0ZCQW5SQnNOWUFhaUlDS0FJQUlBQkdCRUFnQWlBRE5nSUFJQU1OQVVHRTFBQWdDMEYrSUFGM2NUWUNBQXdDQ3lBSlFSQkJGQ0FKS0FJUUlBQkdHMm9nQXpZQ0FDQURSUTBCQ3lBRElBazJBaGdnQUNnQ0VDSUJCRUFnQXlBQk5nSVFJQUVnQXpZQ0dBc2dBRUVVYWlnQ0FDSUJSUTBBSUFOQkZHb2dBVFlDQUNBQklBTTJBaGdMQWtBZ0JVRVBUUVJBSUFBZ0JDQUZhaUlCUVFOeU5nSUVJQUFnQVdvaUFTQUJLQUlFUVFGeU5nSUVEQUVMSUFBZ0JHb2lCeUFGUVFGeU5nSUVJQUFnQkVFRGNqWUNCQ0FGSUFkcUlBVTJBZ0FnQ0FSQUlBaEJlSEZCcU5RQWFpRUJRWlRVQUNnQ0FDRURBbjlCQVNBSVFRTjJkQ0lDSUFaeFJRUkFRWURVQUNBQ0lBWnlOZ0lBSUFFTUFRc2dBU2dDQ0FzaUFpQUROZ0lNSUFFZ0F6WUNDQ0FESUFFMkFnd2dBeUFDTmdJSUMwR1UxQUFnQnpZQ0FFR0kxQUFnQlRZQ0FBc2dBRUVJYWlFQkN5QUtRUkJxSkFBZ0FRdERBQ0FBUlFSQVB3QkJFSFFQQ3dKQUlBQkIvLzhEY1EwQUlBQkJBRWdOQUNBQVFSQjJRQUFpQUVGL1JnUkFRZkRYQUVFd05nSUFRWDhQQ3lBQVFSQjBEd3NBQ3d2YlFDSUFRWUFJQ3drQkFBQUFBZ0FBQUFNQVFaUUlDd1VFQUFBQUJRQkJwQWdMQ1FZQUFBQUhBQUFBQ0FCQjNBZ0xnakZKYm5aaGJHbGtJR05vWVhJZ2FXNGdkWEpzSUhGMVpYSjVBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZZbTlrZVFCRGIyNTBaVzUwTFV4bGJtZDBhQ0J2ZG1WeVpteHZkd0JEYUhWdWF5QnphWHBsSUc5MlpYSm1iRzkzQUVsdWRtRnNhV1FnYldWMGFHOWtJR1p2Y2lCSVZGUlFMM2d1ZUNCeVpYRjFaWE4wQUVsdWRtRnNhV1FnYldWMGFHOWtJR1p2Y2lCU1ZGTlFMM2d1ZUNCeVpYRjFaWE4wQUVWNGNHVmpkR1ZrSUZOUFZWSkRSU0J0WlhSb2IyUWdabTl5SUVsRFJTOTRMbmdnY21WeGRXVnpkQUJKYm5aaGJHbGtJR05vWVhJZ2FXNGdkWEpzSUdaeVlXZHRaVzUwSUhOMFlYSjBBRVY0Y0dWamRHVmtJR1J2ZEFCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDNOMFlYUjFjd0JKYm5aaGJHbGtJSEpsYzNCdmJuTmxJSE4wWVhSMWN3QkZlSEJsWTNSbFpDQk1SaUJoWm5SbGNpQm9aV0ZrWlhKekFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklHVjRkR1Z1YzJsdmJuTUFWWE5sY2lCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmNtVnpaWFJnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5amFIVnVhMTlvWldGa1pYSmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDl0WlhOellXZGxYMkpsWjJsdVlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZZMmgxYm10ZlpYaDBaVzV6YVc5dVgzWmhiSFZsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmMzUmhkSFZ6WDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmRtVnljMmx2Ymw5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgzVnliRjlqYjIxd2JHVjBaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDJOb2RXNXJYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYUdWaFpHVnlYM1poYkhWbFgyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZiV1Z6YzJGblpWOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMjFsZEdodlpGOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMmhsWVdSbGNsOW1hV1ZzWkY5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyTm9kVzVyWDJWNGRHVnVjMmx2Ymw5dVlXMWxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQlZibVY0Y0dWamRHVmtJR05vWVhJZ2FXNGdkWEpzSUhObGNuWmxjZ0JKYm5aaGJHbGtJR2hsWVdSbGNpQjJZV3gxWlNCamFHRnlBRWx1ZG1Gc2FXUWdhR1ZoWkdWeUlHWnBaV3hrSUdOb1lYSUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOTJaWEp6YVc5dUFFbHVkbUZzYVdRZ2JXbHViM0lnZG1WeWMybHZiZ0JKYm5aaGJHbGtJRzFoYW05eUlIWmxjbk5wYjI0QVJYaHdaV04wWldRZ2MzQmhZMlVnWVdaMFpYSWdkbVZ5YzJsdmJnQkZlSEJsWTNSbFpDQkRVa3hHSUdGbWRHVnlJSFpsY25OcGIyNEFTVzUyWVd4cFpDQklWRlJRSUhabGNuTnBiMjRBU1c1MllXeHBaQ0JvWldGa1pYSWdkRzlyWlc0QVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5MWNtd0FTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSnpJR2x1SUhWeWJBQlZibVY0Y0dWamRHVmtJSE4wWVhKMElHTm9ZWElnYVc0Z2RYSnNBRVJ2ZFdKc1pTQkFJR2x1SUhWeWJBQkZiWEIwZVNCRGIyNTBaVzUwTFV4bGJtZDBhQUJKYm5aaGJHbGtJR05vWVhKaFkzUmxjaUJwYmlCRGIyNTBaVzUwTFV4bGJtZDBhQUJVY21GdWMyWmxjaTFGYm1OdlpHbHVaeUJqWVc0bmRDQmlaU0J3Y21WelpXNTBJSGRwZEdnZ1EyOXVkR1Z1ZEMxTVpXNW5kR2dBUkhWd2JHbGpZWFJsSUVOdmJuUmxiblF0VEdWdVozUm9BRWx1ZG1Gc2FXUWdZMmhoY2lCcGJpQjFjbXdnY0dGMGFBQkRiMjUwWlc1MExVeGxibWQwYUNCallXNG5kQ0JpWlNCd2NtVnpaVzUwSUhkcGRHZ2dWSEpoYm5ObVpYSXRSVzVqYjJScGJtY0FUV2x6YzJsdVp5QmxlSEJsWTNSbFpDQkRVaUJoWm5SbGNpQmphSFZ1YXlCemFYcGxBRVY0Y0dWamRHVmtJRXhHSUdGbWRHVnlJR05vZFc1cklITnBlbVVBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1kyaDFibXNnYzJsNlpRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyaGxZV1JsY2w5MllXeDFaUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMk5vZFc1clgyVjRkR1Z1YzJsdmJsOTJZV3gxWlFCSmJuWmhiR2xrSUdOb1lYSmhZM1JsY2lCcGJpQmphSFZ1YXlCbGVIUmxibk5wYjI1eklIWmhiSFZsQUUxcGMzTnBibWNnWlhod1pXTjBaV1FnUTFJZ1lXWjBaWElnYUdWaFpHVnlJSFpoYkhWbEFFMXBjM05wYm1jZ1pYaHdaV04wWldRZ1RFWWdZV1owWlhJZ2FHVmhaR1Z5SUhaaGJIVmxBRWx1ZG1Gc2FXUWdZRlJ5WVc1elptVnlMVVZ1WTI5a2FXNW5ZQ0JvWldGa1pYSWdkbUZzZFdVQVRXbHpjMmx1WnlCbGVIQmxZM1JsWkNCRFVpQmhablJsY2lCamFIVnVheUJsZUhSbGJuTnBiMjRnZG1Gc2RXVUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjeUJ4ZFc5MFpTQjJZV3gxWlFCSmJuWmhiR2xrSUhGMWIzUmxaQzF3WVdseUlHbHVJR05vZFc1cklHVjRkR1Z1YzJsdmJuTWdjWFZ2ZEdWa0lIWmhiSFZsQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlHTm9kVzVySUdWNGRHVnVjMmx2Ym5NZ2NYVnZkR1ZrSUhaaGJIVmxBRkJoZFhObFpDQmllU0J2Ymw5b1pXRmtaWEp6WDJOdmJYQnNaWFJsQUVsdWRtRnNhV1FnUlU5R0lITjBZWFJsQUc5dVgzSmxjMlYwSUhCaGRYTmxBRzl1WDJOb2RXNXJYMmhsWVdSbGNpQndZWFZ6WlFCdmJsOXRaWE56WVdkbFgySmxaMmx1SUhCaGRYTmxBRzl1WDJOb2RXNXJYMlY0ZEdWdWMybHZibDkyWVd4MVpTQndZWFZ6WlFCdmJsOXpkR0YwZFhOZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmRtVnljMmx2Ymw5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5MWNteGZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZZMmgxYm10ZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmFHVmhaR1Z5WDNaaGJIVmxYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYMjFsYzNOaFoyVmZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZiV1YwYUc5a1gyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgyaGxZV1JsY2w5bWFXVnNaRjlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDlqYUhWdWExOWxlSFJsYm5OcGIyNWZibUZ0WlNCd1lYVnpaUUJWYm1WNGNHVmpkR1ZrSUhOd1lXTmxJR0ZtZEdWeUlITjBZWEowSUd4cGJtVUFUV2x6YzJsdVp5QmxlSEJsWTNSbFpDQkRVaUJoWm5SbGNpQnlaWE53YjI1elpTQnNhVzVsQUZOd1lXNGdZMkZzYkdKaFkyc2daWEp5YjNJZ2FXNGdiMjVmWTJoMWJtdGZaWGgwWlc1emFXOXVYMjVoYldVQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdZMmgxYm1zZ1pYaDBaVzV6YVc5dWN5QnVZVzFsQUUxcGMzTnBibWNnWlhod1pXTjBaV1FnUTFJZ1lXWjBaWElnWTJoMWJtc2daWGgwWlc1emFXOXVJRzVoYldVQVNXNTJZV3hwWkNCemRHRjBkWE1nWTI5a1pRQlFZWFZ6WlNCdmJpQkRUMDVPUlVOVUwxVndaM0poWkdVQVVHRjFjMlVnYjI0Z1VGSkpMMVZ3WjNKaFpHVUFSWGh3WldOMFpXUWdTRlJVVUM4eUlFTnZibTVsWTNScGIyNGdVSEpsWm1GalpRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyMWxkR2h2WkFCRmVIQmxZM1JsWkNCemNHRmpaU0JoWm5SbGNpQnRaWFJvYjJRQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5b1pXRmtaWEpmWm1sbGJHUUFVR0YxYzJWa0FFbHVkbUZzYVdRZ2QyOXlaQ0JsYm1OdmRXNTBaWEpsWkFCSmJuWmhiR2xrSUcxbGRHaHZaQ0JsYm1OdmRXNTBaWEpsWkFCTmFYTnphVzVuSUdWNGNHVmpkR1ZrSUVOU0lHRm1kR1Z5SUdOb2RXNXJJR1JoZEdFQVJYaHdaV04wWldRZ1RFWWdZV1owWlhJZ1kyaDFibXNnWkdGMFlRQlZibVY0Y0dWamRHVmtJR05vWVhJZ2FXNGdkWEpzSUhOamFHVnRZUUJTWlhGMVpYTjBJR2hoY3lCcGJuWmhiR2xrSUdCVWNtRnVjMlpsY2kxRmJtTnZaR2x1WjJBQVJHRjBZU0JoWm5SbGNpQmdRMjl1Ym1WamRHbHZiam9nWTJ4dmMyVmdBRk5YU1ZSRFNGOVFVazlZV1FCVlUwVmZVRkpQV0ZrQVRVdEJRMVJKVmtsVVdRQlZUbEJTVDBORlUxTkJRa3hGWDBWT1ZFbFVXUUJSVlVWU1dRQkRUMUJaQUUxUFZrVkVYMUJGVWsxQlRrVk9WRXhaQUZSUFQxOUZRVkpNV1FCT1QxUkpSbGtBUmtGSlRFVkVYMFJGVUVWT1JFVk9RMWtBUWtGRVgwZEJWRVZYUVZrQVVFeEJXUUJRVlZRQVEwaEZRMHRQVlZRQVIwRlVSVmRCV1Y5VVNVMUZUMVZVQUZKRlVWVkZVMVJmVkVsTlJVOVZWQUJPUlZSWFQxSkxYME5QVGs1RlExUmZWRWxOUlU5VlZBQkRUMDVPUlVOVVNVOU9YMVJKVFVWUFZWUUFURTlIU1U1ZlZFbE5SVTlWVkFCT1JWUlhUMUpMWDFKRlFVUmZWRWxOUlU5VlZBQlFUMU5VQUUxSlUwUkpVa1ZEVkVWRVgxSkZVVlZGVTFRQVEweEpSVTVVWDBOTVQxTkZSRjlTUlZGVlJWTlVBRU5NU1VWT1ZGOURURTlUUlVSZlRFOUJSRjlDUVV4QlRrTkZSRjlTUlZGVlJWTlVBRUpCUkY5U1JWRlZSVk5VQUVoVVZGQmZVa1ZSVlVWVFZGOVRSVTVVWDFSUFgwaFVWRkJUWDFCUFVsUUFVa1ZRVDFKVUFFbE5YMEZmVkVWQlVFOVVBRkpGVTBWVVgwTlBUbFJGVGxRQVRrOWZRMDlPVkVWT1ZBQlFRVkpVU1VGTVgwTlBUbFJGVGxRQVNGQkZYMGxPVmtGTVNVUmZRMDlPVTFSQlRsUUFTRkJGWDBOQ1gxSkZVMFZVQUVkRlZBQklVRVZmVTFSU1NVTlVBRU5QVGtaTVNVTlVBRlJGVFZCUFVrRlNXVjlTUlVSSlVrVkRWQUJRUlZKTlFVNUZUbFJmVWtWRVNWSkZRMVFBUTA5T1RrVkRWQUJOVlV4VVNWOVRWRUZVVlZNQVNGQkZYMGxPVmtGTVNVUmZVMVJCVkZWVEFGUlBUMTlOUVU1WlgxSkZVVlZGVTFSVEFFVkJVa3haWDBoSlRsUlRBRlZPUVZaQlNVeEJRa3hGWDBaUFVsOU1SVWRCVEY5U1JVRlRUMDVUQUU5UVZFbFBUbE1BVTFkSlZFTklTVTVIWDFCU1QxUlBRMDlNVXdCV1FWSkpRVTVVWDBGTVUwOWZUa1ZIVDFSSlFWUkZVd0JOVlV4VVNWQk1SVjlEU0U5SlEwVlRBRWxPVkVWU1RrRk1YMU5GVWxaRlVsOUZVbEpQVWdCWFJVSmZVMFZTVmtWU1gxVk9TMDVQVjA1ZlJWSlNUMUlBVWtGSlRFZFZUbDlGVWxKUFVnQkpSRVZPVkVsVVdWOVFVazlXU1VSRlVsOUJWVlJJUlU1VVNVTkJWRWxQVGw5RlVsSlBVZ0JUVTB4ZlEwVlNWRWxHU1VOQlZFVmZSVkpTVDFJQVNVNVdRVXhKUkY5WVgwWlBVbGRCVWtSRlJGOUdUMUlBVTBWVVgxQkJVa0ZOUlZSRlVnQkhSVlJmVUVGU1FVMUZWRVZTQUVoUVJWOVZVMFZTQUZORlJWOVBWRWhGVWdCSVVFVmZRMEpmUTBoVlRrdGZTRVZCUkVWU0FFVjRjR1ZqZEdWa0lFeEdJR0ZtZEdWeUlFTlNBRTFMUTBGTVJVNUVRVklBVTBWVVZWQUFWMFZDWDFORlVsWkZVbDlKVTE5RVQxZE9BRlJGUVZKRVQxZE9BRWhRUlY5RFRFOVRSVVJmUTA5T1RrVkRWRWxQVGdCSVJWVlNTVk5VU1VOZlJWaFFTVkpCVkVsUFRnQkVTVk5EVDA1T1JVTlVSVVJmVDFCRlVrRlVTVTlPQUU1UFRsOUJWVlJJVDFKSlZFRlVTVlpGWDBsT1JrOVNUVUZVU1U5T0FFaFFSVjlKVGxaQlRFbEVYMVpGVWxOSlQwNEFTRkJGWDBOQ1gwMUZVMU5CUjBWZlFrVkhTVTRBVTBsVVJWOUpVMTlHVWs5YVJVNEFTRkJGWDBsT1ZrRk1TVVJmU0VWQlJFVlNYMVJQUzBWT0FFbE9Wa0ZNU1VSZlZFOUxSVTRBUms5U1FrbEVSRVZPQUVWT1NFRk9RMFZmV1U5VlVsOURRVXhOQUVoUVJWOUpUbFpCVEVsRVgxVlNUQUJDVEU5RFMwVkVYMEpaWDFCQlVrVk9WRUZNWDBOUFRsUlNUMHdBVFV0RFQwd0FRVU5NQUVoUVJWOUpUbFJGVWs1QlRBQlNSVkZWUlZOVVgwaEZRVVJGVWw5R1NVVk1SRk5mVkU5UFgweEJVa2RGWDFWT1QwWkdTVU5KUVV3QVNGQkZYMDlMQUZWT1RFbE9Td0JWVGt4UFEwc0FVRkpKQUZKRlZGSlpYMWRKVkVnQVNGQkZYMGxPVmtGTVNVUmZRMDlPVkVWT1ZGOU1SVTVIVkVnQVNGQkZYMVZPUlZoUVJVTlVSVVJmUTA5T1ZFVk9WRjlNUlU1SFZFZ0FSa3hWVTBnQVVGSlBVRkJCVkVOSUFFMHRVMFZCVWtOSUFGVlNTVjlVVDA5ZlRFOU9Sd0JRVWs5RFJWTlRTVTVIQUUxSlUwTkZURXhCVGtWUFZWTmZVRVZTVTBsVFZFVk9WRjlYUVZKT1NVNUhBRTFKVTBORlRFeEJUa1ZQVlZOZlYwRlNUa2xPUndCSVVFVmZTVTVXUVV4SlJGOVVVa0ZPVTBaRlVsOUZUa05QUkVsT1J3QkZlSEJsWTNSbFpDQkRVa3hHQUVoUVJWOUpUbFpCVEVsRVgwTklWVTVMWDFOSldrVUFUVTlXUlFCRFQwNVVTVTVWUlFCSVVFVmZRMEpmVTFSQlZGVlRYME5QVFZCTVJWUkZBRWhRUlY5RFFsOUlSVUZFUlZKVFgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5V1JWSlRTVTlPWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlWVWt4ZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBOSVZVNUxYME5QVFZCTVJWUkZBRWhRUlY5RFFsOUlSVUZFUlZKZlZrRk1WVVZmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYME5JVlU1TFgwVllWRVZPVTBsUFRsOVdRVXhWUlY5RFQwMVFURVZVUlFCSVVFVmZRMEpmUTBoVlRrdGZSVmhVUlU1VFNVOU9YMDVCVFVWZlEwOU5VRXhGVkVVQVNGQkZYME5DWDAxRlUxTkJSMFZmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMDFGVkVoUFJGOURUMDFRVEVWVVJRQklVRVZmUTBKZlNFVkJSRVZTWDBaSlJVeEVYME5QVFZCTVJWUkZBRVJGVEVWVVJRQklVRVZmU1U1V1FVeEpSRjlGVDBaZlUxUkJWRVVBU1U1V1FVeEpSRjlUVTB4ZlEwVlNWRWxHU1VOQlZFVUFVRUZWVTBVQVRrOWZVa1ZUVUU5T1UwVUFWVTVUVlZCUVQxSlVSVVJmVFVWRVNVRmZWRmxRUlFCSFQwNUZBRTVQVkY5QlEwTkZVRlJCUWt4RkFGTkZVbFpKUTBWZlZVNUJWa0ZKVEVGQ1RFVUFVa0ZPUjBWZlRrOVVYMU5CVkVsVFJrbEJRa3hGQUU5U1NVZEpUbDlKVTE5VlRsSkZRVU5JUVVKTVJRQlNSVk5RVDA1VFJWOUpVMTlUVkVGTVJRQlFWVkpIUlFCTlJWSkhSUUJTUlZGVlJWTlVYMGhGUVVSRlVsOUdTVVZNUkZOZlZFOVBYMHhCVWtkRkFGSkZVVlZGVTFSZlNFVkJSRVZTWDFSUFQxOU1RVkpIUlFCUVFWbE1UMEZFWDFSUFQxOU1RVkpIUlFCSlRsTlZSa1pKUTBsRlRsUmZVMVJQVWtGSFJRQklVRVZmVUVGVlUwVkVYMVZRUjFKQlJFVUFTRkJGWDFCQlZWTkZSRjlJTWw5VlVFZFNRVVJGQUZOUFZWSkRSUUJCVGs1UFZVNURSUUJVVWtGRFJRQklVRVZmVlU1RldGQkZRMVJGUkY5VFVFRkRSUUJFUlZORFVrbENSUUJWVGxOVlFsTkRVa2xDUlFCU1JVTlBVa1FBU0ZCRlgwbE9Wa0ZNU1VSZlRVVlVTRTlFQUU1UFZGOUdUMVZPUkFCUVVrOVFSa2xPUkFCVlRrSkpUa1FBVWtWQ1NVNUVBRlZPUVZWVVNFOVNTVnBGUkFCTlJWUklUMFJmVGs5VVgwRk1URTlYUlVRQVNGUlVVRjlXUlZKVFNVOU9YMDVQVkY5VFZWQlFUMUpVUlVRQVFVeFNSVUZFV1Y5U1JWQlBVbFJGUkFCQlEwTkZVRlJGUkFCT1QxUmZTVTFRVEVWTlJVNVVSVVFBVEU5UFVGOUVSVlJGUTFSRlJBQklVRVZmUTFKZlJWaFFSVU5VUlVRQVNGQkZYMHhHWDBWWVVFVkRWRVZFQUVOU1JVRlVSVVFBU1UxZlZWTkZSQUJJVUVWZlVFRlZVMFZFQUZSSlRVVlBWVlJmVDBORFZWSkZSQUJRUVZsTlJVNVVYMUpGVVZWSlVrVkVBRkJTUlVOUFRrUkpWRWxQVGw5U1JWRlZTVkpGUkFCUVVrOVlXVjlCVlZSSVJVNVVTVU5CVkVsUFRsOVNSVkZWU1ZKRlJBQk9SVlJYVDFKTFgwRlZWRWhGVGxSSlEwRlVTVTlPWDFKRlVWVkpVa1ZFQUV4RlRrZFVTRjlTUlZGVlNWSkZSQUJUVTB4ZlEwVlNWRWxHU1VOQlZFVmZVa1ZSVlVsU1JVUUFWVkJIVWtGRVJWOVNSVkZWU1ZKRlJBQlFRVWRGWDBWWVVFbFNSVVFBVUZKRlEwOU9SRWxVU1U5T1gwWkJTVXhGUkFCRldGQkZRMVJCVkVsUFRsOUdRVWxNUlVRQVVrVldRVXhKUkVGVVNVOU9YMFpCU1V4RlJBQlRVMHhmU0VGT1JGTklRVXRGWDBaQlNVeEZSQUJNVDBOTFJVUUFWRkpCVGxOR1QxSk5RVlJKVDA1ZlFWQlFURWxGUkFCT1QxUmZUVTlFU1VaSlJVUUFUazlVWDBWWVZFVk9SRVZFQUVKQlRrUlhTVVJVU0Y5TVNVMUpWRjlGV0VORlJVUkZSQUJUU1ZSRlgwbFRYMDlXUlZKTVQwRkVSVVFBU0VWQlJBQkZlSEJsWTNSbFpDQklWRlJRTHdBQVVoVUFBQm9WQUFBUEVnQUE1QmtBQUpFVkFBQUpGQUFBTFJrQUFPUVVBQURwRVFBQWFSUUFBS0VVQUFCMkZRQUFReFlBQUY0U0FBQ1VGd0FBRnhZQUFIMFVBQUIvRmdBQVFSY0FBTE1UQUFEREZnQUFCQm9BQUwwWUFBRFFHQUFBb0JNQUFOUVpBQUN2RmdBQWFCWUFBSEFYQUFEWkZnQUEvQmdBQVA0UkFBQlpGd0FBbHhZQUFCd1hBQUQyRmdBQWpSY0FBQXNTQUFCL0d3QUFMaEVBQUxNUUFBQkpFZ0FBclJJQUFQWVlBQUJvRUFBQVloVUFBQkFWQUFCYUZnQUFTaGtBQUxVVkFBREJGUUFBWUJVQUFGd1pBQUJhR1FBQVV4a0FBQllWQUFDdEVRQUFRaEFBQUxjUUFBQlhHQUFBdnhVQUFJa1FBQUFjR1FBQUdoa0FBTGtWQUFCUkdBQUEzQk1BQUZzVkFBQlpGUUFBNWhnQUFHY1ZBQUFSR1FBQTdSZ0FBT2NUQUFDdUVBQUF3aGNBQUFBVUFBQ1NFd0FBaEJNQUFFQVNBQUFtR1FBQXJ4VUFBR0lRQUVIcE9Rc0JBUUJCZ0RvTDRBRUJBUUlCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFREFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQkI2anNMQkFFQUFBSUFRWUU4QzE0REJBTURBd01EQUFBREF3QURBd0FEQXdNREF3TURBd01EQUFVQUFBQUFBQU1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUF3QURBRUhxUFFzRUFRQUFBZ0JCZ1Q0TFhnTUFBd01EQXdNQUFBTURBQU1EQUFNREF3TURBd01EQXdNQUJBQUZBQUFBQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01BQUFBREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3QURBQU1BUWVBL0N3MXNiM05sWldWd0xXRnNhWFpsQUVINVB3c0JBUUJCa01BQUMrQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFRZm5CQUFzQkFRQkJrTUlBQytjQkFRRUJBUUVCQVFFQkFRRUJBZ0VCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFGamFIVnVhMlZrQUVHaHhBQUxYZ0VBQVFFQkFRRUFBQUVCQUFFQkFBRUJBUUVCQVFFQkFRRUFBQUFBQUFBQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFBQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQUFFQVFZREdBQXNoWldOMGFXOXVaVzUwTFd4bGJtZDBhRzl1Y205NGVTMWpiMjV1WldOMGFXOXVBRUd3eGdBTEszSmhibk5tWlhJdFpXNWpiMlJwYm1kd1ozSmhaR1VOQ2cwS1UwME5DZzBLVkZSUUwwTkZMMVJUVUM4QVFlbkdBQXNGQVFJQUFRTUFRWURIQUF0ZkJBVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVBUWVuSUFBc0ZBUUlBQVFNQVFZREpBQXRmQkFVRkJnVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUFRZW5LQUFzRUFRQUFBUUJCZ2NzQUMxNENBZ0FDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUVIcHpBQUxCUUVDQUFFREFFR0F6UUFMWHdRRkFBQUZCUVVGQlFVRkJRVUZCUVlGQlFVRkJRVUZCUVVGQlFVQUJRQUhDQVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUUFGQUFVQUJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVQUFBQUZBRUhwemdBTEJRRUJBQUVCQUVHQXp3QUxBUUVBUVpyUEFBdEJBZ0FBQUFBQUFBTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREFBQUFBQUFBQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01BUWVuUUFBc0ZBUUVBQVFFQVFZRFJBQXNCQVFCQml0RUFDd1lDQUFBQUFBSUFRYUhSQUFzNkF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUFBQUFBQUFEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd0JCNE5JQUM1b0JUazlWVGtORlJVTkxUMVZVVGtWRFZFVlVSVU5TU1VKRlRGVlRTRVZVUlVGRVUwVkJVa05JVWtkRlExUkpWa2xVV1V4RlRrUkJVbFpGVDFSSlJsbFFWRWxQVGxORFNGTkZRVmxUVkVGVVEwaEhSVlZGVWxsUFVrUkpVa1ZEVkU5U1ZGSkRTRkJCVWtGTlJWUkZVbFZTUTBWQ1UwTlNTVUpGUVZKRVQxZE9RVU5GU1U1RVRrdERTMVZDVTBOU1NVSkZTRlJVVUM5QlJGUlFMdz09J1xuXG5sZXQgd2FzbUJ1ZmZlclxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnZXhwb3J0cycsIHtcbiAgZ2V0OiAoKSA9PiB7XG4gICAgcmV0dXJuIHdhc21CdWZmZXJcbiAgICAgID8gd2FzbUJ1ZmZlclxuICAgICAgOiAod2FzbUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHdhc21CYXNlNjQsICdiYXNlNjQnKSlcbiAgfVxufSlcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nconst { Buffer } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\n\nconst wasmBase64 = 'AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzQzBQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEDAAADAAAABAUBcAESEgUDAQACBggBfwFBgNgECwfFBygGbWVtb3J5AgALX2luaXRpYWxpemUACBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQACRhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUANgxsbGh0dHBfYWxsb2MACwZtYWxsb2MAOAtsbGh0dHBfZnJlZQAMBGZyZWUADA9sbGh0dHBfZ2V0X3R5cGUADRVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADhVsbGh0dHBfZ2V0X2h0dHBfbWlub3IADxFsbGh0dHBfZ2V0X21ldGhvZAAQFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAERJsbGh0dHBfZ2V0X3VwZ3JhZGUAEgxsbGh0dHBfcmVzZXQAEw5sbGh0dHBfZXhlY3V0ZQAUFGxsaHR0cF9zZXR0aW5nc19pbml0ABUNbGxodHRwX2ZpbmlzaAAWDGxsaHR0cF9wYXVzZQAXDWxsaHR0cF9yZXN1bWUAGBtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGRBsbGh0dHBfZ2V0X2Vycm5vABoXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AGxdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAcFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB0RbGxodHRwX2Vycm5vX25hbWUAHhJsbGh0dHBfbWV0aG9kX25hbWUAHxJsbGh0dHBfc3RhdHVzX25hbWUAIBpsbGh0dHBf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a0E+aiECCyABIAI2AhwgAUIANwIQIAJBAnRBsNYAaiEAAkBBhNQAKAIAIgNBASACdCIHcUUEQCAAIAE2AgBBhNQAIAMgB3I2AgAgASAANgIYIAEgATYCCCABIAE2AgwMAQsgBEEZIAJBAXZrQQAgAkEfRxt0IQIgACgCACEAAkADQCAAIgMoAgRBeHEgBEYNASACQR12IQAgAkEBdCECIAMgAEEEcWpBEGoiBygCACIADQALIAcgATYCACABIAM2AhggASABNgIMIAEgATYCCAwBCyADKAIIIgAgATYCDCADIAE2AgggAUEANgIYIAEgAzYCDCABIAA2AggLQaDUAEGg1AAoAgBBAWsiAEF/IAAbNgIACwsHACAALQAoCwcAIAAtACoLBwAgAC0AKwsHACAALQApCwcAIAAvATQLBwAgAC0AMAtAAQR/IAAoAhghASAALwEuIQIgAC0AKCEDIAAoAjghBCAAEDcgACAENgI4IAAgAzoAKCAAIAI7AS4gACABNgIYC8X4AQIHfwN+IAEgAmohBAJAIAAiAygCDCIADQAgAygCBARAIAMgATYCBAsjAEEQayIJJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDtQBAAECAwQFBgcICQoLDA0ODxARFBUWFxgZGhscHR4fICEjJCUnKCmIA4cDhQOEA/wC9QLuAusC6ALmAuMC4ALfAt0C2wLWAtUC1ALTAtICygLJAsgCxwLGAsUCxALDAr0CvAK6ArkCuAK3ArYCtQK0ArICsQKsAqoCqAKnAqYCpQKkAqMCogKhAqACnwKbApoCmQKYApcCkAKIAoQCgwKCAvkB9gH1AfQB8wHyAfEB8AHvAe0B6wHoAeMB4QHgAd8B3gHdAdwB2wHaAdkB2AHX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QEBAQEBAQEBAQEBAAEALQQAhAiADQQA2AhwgA0G3CzYCECADQQI2AgwgAyABQQFqNgIUDIEDCyADQS9qIQIDQCABIARGBEBBISECDIIDCwJAAkACQCABLQAAIgBBCWsOGAIAKioBKioqKioqKioqKioqKioqKioqAigLIAFBAWohASADQS9qLQAAQQFxRQ0LDBkLIAFBAWohAQwYCyABQQFqIQEgAi0AAEECcQ0AC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAyAAwsgAUEBaiEBC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADQEM0QILIANCADcDIAw8CyAAQRVGBEAgA0EkNgIcIAMgATYCFCADQYYaNgIQIANBFTYCDEEAIQIM/QILQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDPwCCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDSsgA0EHNgIcIAMgATYCFCADIAA2AgwM+wILIAMtAC5BwABxRQ0BC0EAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAARQ0rIABBFUYEQCADQQo2AhwgAyABNgIUIANB8Rg2AhAgA0EVNgIMQQAhAgz6AgtBACECIANBADYCHCADIAE2AhQgA0GLDDYCECADQRM2AgwM+QILQQAhAiADQQA2AhwgAyABNgIUIANBsRQ2AhAgA0ECNgIMDPgCC0EAIQIgA0EANgIcIAMgATYCFCADQYwUNgIQIANBGTYCDAz3AgtBACECIANBADYCHCADIAE2AhQgA0HRHDYCECADQRk2AgwM9gILIABBFUYNPUEAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAz1AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQ0oIANBDTYCHCADIAE2AhQgAyAANgIMDPQCCyAAQRVGDTpBACECIANBADYCHCADIAE2AhQgA0GiDzYCECADQSI2AgwM8wILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDIiAEUEQCABQQFqIQEMKAsgA0EONgIcIAMgADYCDCADIAFBAWo2AhQM8gILIABBFUYNN0EAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAzxAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQRAIAFBAWohAQwnCyADQQ82AhwgAyAANgIMIAMgAUEBajYCFAzwAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM7wILIABBFUYNM0EAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzuAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMyIARQ0lIANBETYCHCADIAE2AhQgAyAANgIMDO0CCyAAQRVGDTBBACECIANBADYCHCADIAE2AhQgA0HODDYCECADQSM2AgwM7AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEMJQsgA0ESNgIcIAMgADYCDCADIAFBAWo2AhQM6wILIANBL2otAABBAXFFDQELQRUhAgzPAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM6AILIABBO0cNACABQQFqIQEMDAtBACECIANBADYCHCADIAE2AhQgA0GYFzYCECADQQI2AgwM5gILIABBFUYNKEEAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzlAgsgA0EUNgIcIAMgATYCFCADIAA2AgwM5AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEM3AILIANBFTYCHCADIAA2AgwgAyABQQFqNgIUDOMCCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNoCCyADQRc2AhwgAyAANgIMIAMgAUEBajYCFAziAgsgAEEVRg0jQQAhAiADQQA2AhwgAyABNgIUIANBzgw2AhAgA0EjNgIMDOECCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDB0LIANBGTYCHCADIAA2AgwgAyABQQFqNgIUDOACCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNYCCyADQRo2AhwgAyAANgIMIAMgAUEBajYCFAzfAgsgAEEVRg0fQQAhAiADQQA2AhwgAyABNgIUIANBog82AhAgA0EiNgIMDN4CCyADKAIEIQBBACEC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DLMCCyABIARGBEBB6QEhAgyzAgsgAS0AAEHIAEYNASADQQE6ACgLQbYBIQIMlwILQcoBIQIMlgILIAEgBEcEQCADQQw2AgggAyABNgIEQckBIQIMlgILQegBIQIMrwILIAEgBEYEQEHnASECDK8CCyABLQAAQcgARw0EIAFBAWohAUHIASECDJQCCyABIARGBEBB5gEhAgyuAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQcYBIQIMlAILIAFBAWohAUHHASECDJMCC0HlASECIAEgBEYNrAIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB99MAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMrQILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgBFBEBB1AEhAgyTAgsgA0HkATYCHCADIAE2AhQgAyAANgIMQQAhAgysAgtB4wEhAiABIARGDasCIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQfXTAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADKwCCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB0B42AhAgA0EINgIMDKkCC0HFASECDI4CCyADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDKcCC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ1lIABBFUcEQCADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgynAgsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDKYCC0HhASECIAQgASIARg2lAiAEIAFrIAMoAgAiAWohBSAAIAFrQQRqIQYCQANAIAAtAAAgAUHw0wBqLQAARw0BIAFBBEYNAyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBTYCAAymAgsgA0EANgIcIAMgADYCFCADQYQ3NgIQIANBCDYCDCADQQA2AgBBACECDKUCCyABIARHBEAgA0ENNgIIIAMgATYCBEHCASECDIsCC0HgASECDKQCCyADQQA2AgAgBkEBaiEBC0HDASECDIgCCyABIARGBEBB3wEhAgyiAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBwQEhAgyIAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYgCIANB3gE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAEgBEYEQEHdASECDKECCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYkCIANB3AE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILQcABIQIMhgILIAEgBEYEQEHbASECDKACC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDQIgA0HYATYCHCADIAE2AhQgAyAANgIMQQAhAgyiAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYsCIANB2QE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ2JAiADQdoBNgIcIAMgATYCFCADIAA2AgwMoAILQb8BIQIMhQILQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBnA02AhAgA0EhNgIMQQAhAgygAgtBvgEhAgyFAgsgA0HXATYCHCADIAE2AhQgA0HWGTYCECADQRU2AgxBACECDJ4CCyABIARGBEBB1wEhAgyeAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANB6xA2AhAgA0EJNgIMQQAhAgyeAgtBvQEhAgyDAgsgASAERgRAQdYBIQIM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LgsgAUEBaiEBQZcBIQIM2AELIAFBAWohAUEiDCsLIAEgBEYEQEGvASECDPEBCyABLQAAQdAARw0rIAFBAWohAUGWASECDNYBCyABIARGBEBBrgEhAgzwAQsCQAJAIAEtAABBxgBrDgsALCwsLCwsLCwsASwLIAFBAWohAUGUASECDNYBCyABQQFqIQFBlQEhAgzVAQtBrQEhAiABIARGDe4BIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazTAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO8BCyADQQA2AgAgBkEBaiEBQQ0MKAtBrAEhAiABIARGDe0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQeHTAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO4BCyADQQA2AgAgBkEBaiEBQQwMJwtBqwEhAiABIARGDewBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQarTAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO0BCyADQQA2AgAgBkEBaiEBQQMMJgtBqgEhAiABIARGDesBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQajTAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOwBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQakBIQIM6wELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBjwEhAgzRAQsgAUEBaiEBQZABIQIM0AELQagBIQIgASAERg3pASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm0wBqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzqAQsgA0EANgIAIAZBAWohAUEnDCMLQacBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk0wBqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEcDCILQaYBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGe0wBqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEGDCELQaUBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGZ0wBqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGkASECDOYBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQYQBIQIMzgELIAFBAWohAUGFASECDM0BCyABQQFqIQFBigEhAgzMAQsgAUEBaiEBQYsBIQIMywELQaMBIQIgASAERg3kASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGX0wBqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzlAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGiASECDOQBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGGASECDMoBCyABQQFqIQFBiQEhAgzJAQsgASAERgRAQaEBIQIM4wELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQYcBIQIMyQELIAFBAWohAUGIASECDMgBCyABIARGBEBBoAEhAgziAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GfASECIAEgBEYN4AEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBkdMAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4QELIANBADYCACAGQQFqIQFBHgwaC0GeASECIAEgBEYN3wEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBitMAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4AELIANBADYCACAGQQFqIQFBFQwZC0GdASECIAEgBEYN3gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBh9MAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3wELIANBADYCACAGQQFqIQFBFwwYC0GcASECIAEgBEYN3QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBgdMAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3gELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBmwEhAgzdAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYEBIQIMwwELIAFBAWohAUGCASECDMIBC0GaASECIAEgBEYN2wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5tMAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3AELIANBADYCACAGQQFqIQFBCQwVC0GZASECIAEgBEYN2gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5NMAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2wELIANBADYCACAGQQFqIQFBHwwUC0GYASECIAEgBEYN2QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB/tIAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2gELIANBADYCACAGQQFqIQFBAgwTC0GXASECIAEgBEYN2AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQfzSAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyABIARGBEBBlgEhAgzYAQtBASABLQAAQd8ARw0RGiABQQFqIQFB/QAhAgy9AQsgA0EANgIAIAZBAWohAUH+ACECDLwBC0GVASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBKQwPC0GUASECIAEgBEYN1AEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB+NIAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1QELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBkwEhAgzUAQsgAS0AAEHFAEcNDiABQQFqIQFB+gAhAgy5AQsgASAERgRAQZIBIQIM0wELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFB+AAhAgy5AQsgAUEBaiEBQfkAIQIMuAELQZEBIQIgASAERg3RASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHz0gBqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzSAQsgA0EANgIAIAZBAWohAUEjDAsLQZABIQIgASAERg3QASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHw0gBqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzRAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGPASECDNABCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQfMAIQIMtgELIAFBAWohAUH2ACECDLUBCyABIARGBEBBjgEhAgzPAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB9AAhAgy1AQsgAUEBaiEBQfUAIQIMtAELIAEgBEYEQEGNASECDM4BCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQYwBIQIgASAERg3MASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHs0gBqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzNAQsgA0EANgIAIAZBAWohAUEFDAYLQYsBIQIgASAERg3LASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHm0gBqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzMAQsgA0EANgIAIAZBAWohAUEWDAULQYoBIQIgASAERg3KASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzLAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGJASECDMoBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUHvACECDLABCyABQQFqIQFB8AAhAgyvAQtBiAEhAiABIARGDcgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQeDSAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMkBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGHASECDMcBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC0iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB6R42AhAgA0EGNgIMDMQBC0HuACECDKkBCyADQYYBNgIcIAMgATYCFCADIAA2AgxBACECDMIBC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgzBAQtB7QAhAgymAQsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDL8BCyABIARGBEBBhQEhAgy/AQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GGHjYCECADQQY2AgxBACECDL8BC0ECIQIMpAELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GEASECDL0BCyABIARGBEBBgwEhAgy9AQsCQCABLQAAQQlrDgRAAABAAAtB6wAhAgyiAQsgAy0AKUEFRgRAQewAIQIMogELQeoAIQIMoQELIAEgBEYEQEGCASECDLsBCyADQQ82AgggAyABNgIEDAoLIAEgBEYEQEGBASECDLoBCwJAIAEtAABBCWsOBD0AAD0AC0HpACECDJ8BCyABIARHBEAgA0EPNgIIIAMgATYCBEHnACECDJ8BC0GAASECDLgBCwJAIAEgBEcEQANAIAEtAABB4M4Aai0AACIAQQNHBEACQCAAQQFrDgI/AAQLQeYAIQIMoQELIAQgAUEBaiIBRw0AC0H+ACECDLkBC0H+ACECDLgBCyADQQA2AhwgAyABNgIUIANBxh82AhAgA0EHNgIMQQAhAgy3AQsgASAERgRAQf8AIQIMtwELAkACQAJAIAEtAABB4NAAai0AAEEBaw4DPAIAAQtB6AAhAgyeAQsgA0EANgIcIAMgATYCFCADQYYSNgIQIANBBzYCDEEAIQIMtwELQeAAIQIMnAELIAEgBEcEQCABQQFqIQFB5QAhAgycAQtB/QAhAgy1AQsgBCABIgBGBEBB/AAhAgy1AQsgAC0AACIBQS9GBEAgAEEBaiEBQeQAIQIMmwELIAFBCWsiAkEXSw0BIAAhAUEBIAJ0QZuAgARxDTcMAQsgBCABIgBGBEBB+wAhAgy0AQsgAC0AAEEvRw0AIABBAWohAQwDC0EAIQIgA0EANgIcIAMgADYCFCADQcYfNgIQIANBBzYCDAyyAQsCQAJAAkACQAJAA0AgAS0AAEHgzABqLQAAIgBBBUcEQAJAAkAgAEEBaw4IPQUGBwgABAEIC0HhACECDJ8BCyABQQFqIQFB4wAhAgyeAQsgBCABQQFqIgFHDQALQfoAIQIMtgELIAFBAWoMFAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgy0AQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyzAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyyAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMsQELIAEgBEYEQEH5ACECDLEBCwJAIAEtAABB4MwAai0AAEEBaw4INAQFBgAIAgMHCyABQQFqIQELQQMhAgyVAQsgAUEBagwNC0EAIQIgA0EANgIcIANBoxI2AhAgA0EHNgIMIAMgAUEBajYCFAytAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgysAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMqQELQeIAIQIMjgELIAEgBEYEQEH4ACECDKgBCyABQQFqDAILIAEgBEYEQEH3ACECDKcBCyABQQFqDAELIAEgBEYNASABQQFqCyEBQQQhAgyKAQtB9gAhAgyjAQsDQCABLQAAQeDKAGotAAAiAEECRwRAIABBAUcEQEHfACECDIsBCwwnCyAEIAFBAWoiAUcNAAtB9QAhAgyiAQsgASAERgRAQfQAIQIMogELAkAgAS0AAEEJaw43JQMGJQQGBgYGBgYGBgYGBgYGBgYGBgYFBgYCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAAYLIAFBAWoLIQFBBSECDIYBCyABQQFqDAYLIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMngELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMnQELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB8AA2AhwgAyABNgIUIAMgADYCDEEAIQIMnAELIANBADYCHCADIAE2AhQgA0G8EzYCECADQQc2AgxBACECDJsBCwJAAkACQAJAA0AgAS0AAEHgyABqLQAAIgBBBUcEQAJAIABBAWsOBiQDBAUGAAYLQd4AIQIMhgELIAQgAUEBaiIBRw0AC0HzACECDJ4BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQdsANgIcIAMgATYCFCADIAA2AgxBACECDJ0BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDJwBCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQfAANgIcIAMgATYCFCADIAA2AgxBACECDJsBCyADQQA2AhwgAyABNgIUIANB3Ag2AhAgA0EHNgIMQQAhAgyaAQsgASAERg0BIAFBAWoLIQFBBiECDH4LQfIAIQIMlwELAkACQAJAAkADQCABLQAAQeDGAGotAAAiAEEFRwRAIABBAWsOBB8CAwQFCyAEIAFBAWoiAUcNAAtB8QAhAgyaAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyZAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyYAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyXAQsgA0EANgIcIAMgATYCFCADQbQKNgIQIANBBzYCDEEAIQIMlgELQc4AIQIMewtB0AAhAgx6C0HdACECDHkLIAEgBEYEQEHwACECDJMBCwJAIAEtAABBCWsOBBYAABYACyABQQFqIQFB3AAhAgx4CyABIARGBEBB7wAhAgySAQsCQCABLQAAQQlrDgQVAAAVAAtBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUEQEHTASECDHgLIABBFUcEQCADQQA2AhwgAyABNgIUIANBwQ02AhAgA0EaNgIMQQAhAgySAQsgA0HuADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDJEBC0HtACECIAEgBEYNkAEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB18YAai0AAEcNBCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkQELIANBADYCACAGQQFqIQEgAy0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACECIANBADYCHCADIAE2AhQgA0HlCTYCECADQQg2AgwMkAELQewAIQIgASAERg2PASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHUxgBqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyQAQsgA0EANgIAIAZBAWohASADLQApQSFGDQMgA0EANgIcIAMgATYCFCADQYkKNgIQIANBCDYCDEEAIQIMjwELQesAIQIgASAERg2OASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHQxgBqLQAARw0CIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyPAQsgA0EANgIAIAZBAWohASADLQApIgBBI0kNAiAAQS5GDQIgA0EANgIcIAMgATYCFCADQcEJNgIQIANBCDYCDEEAIQIMjgELIANBADYCAAtBACECIANBADYCHCADIAE2AhQgA0GENzYCECADQQg2AgwMjAELQdgAIQIMcQsgASAERwRAIANBDTYCCCADIAE2AgRB1wAhAgxxC0HqACECDIoBCyABIARGBEBB6QAhAgyKAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1gAhAgxwCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdCADQegANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyABIARGBEBB5wAhAgyJAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ11IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMiQELQdUAIQIMbgsgASAERgRAQeUAIQIMiAELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDIoBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdyADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdSADQeQANgIcIAMgATYCFCADIAA2AgwMiAELQdMAIQIMbQsgAy0AKUEiRg2AAUHSACECDGwLQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALIABFBEBB1AAhAgxsCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQZwNNgIQIANBITYCDEEAIQIMhgELIANB4QA2AhwgAyABNgIUIANB1hk2AhAgA0EVNgIMQQAhAgyFAQsgASAERgRAQeAAIQIMhQELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HRACECDGwLIANBADYCHCADIAE2AhQgA0GIETYCECADQQk2AgxBACECDIUBCyADQQA2AhwgAyABNgIUIANBiBE2AhAgA0EJNgIMQQAhAgyEAQsgASAERgRAQd8AIQIMhAELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBiBE2AhAgA0ECNgIMQQAhAgyDAQsgASAERgRAQd0AIQIMgwELIAEtAAAiAkENRgRAIAFBAWohAUHPACECDGkLIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyCAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0G1LDYCECADQQc2AgwMgAELIAEgBEYEQEHbACECDIABCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc0AIQIMZAsgASAERgRAQdoAIQIMfgsgAS0AAEEJaw4EAAEBAAELQQAhAiADQQA2AhwgA0HsETYCECADQQc2AgwgAyABQQFqNgIUDHwLIANBgBI7ASpBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HZADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDHsLQcwAIQIMYAsgA0EANgIcIAMgATYCFCADQcENNgIQIANBGjYCDEEAIQIMeQsgASAERgRAQdkAIQIMeQsgAS0AAEEgRw06IAFBAWohASADLQAuQQFxDTogA0EANgIcIAMgATYCFCADQa0bNgIQIANBHjYCDEEAIQIMeAsgASAERgRAQdgAIQIMeAsCQAJAAkACQAJAIAEtAAAiAEEKaw4EAgMD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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQTBrDjcVFAABAgMEBQYHFhYWFhYWFggJCgsMDRYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWDg8QERITFgtCAiEKDBQLQgMhCgwTC0IEIQoMEgtCBSEKDBELQgYhCgwQC0IHIQoMDwtCCCEKDA4LQgkhCgwNC0IKIQoMDAtCCyEKDAsLQgwhCgwKC0INIQoMCQtCDiEKDAgLQg8hCgwHC0IKIQoMBgtCCyEKDAULQgwhCgwEC0INIQoMAwtCDiEKDAILQg8hCgwBC0IBIQoLIAFBAWohASADKQMgIgtC//////////8PWARAIAMgC0IEhiAKhDcDIAwCC0EAIQIgA0EANgIcIAMgATYCFCADQa0JNgIQIANBDDYCDAwfC0ElIQIMBAtBJiECDAMLIAMgAToALCADQQA2AgAgB0EBaiEBQQwhAgwCCyADQQA2AgAgBkEBaiEBQQohAgwBCyABQQFqIQFBCCECDAALAAtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMGAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMFwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMFgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMFQtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMFAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMEwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMEgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMEQtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMEAtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMDwtBACECIANBADYCHCADIAE2AhQgA0HIEjYCECADQQs2AgwMDgtBACECIANBADYCHCADIAE2AhQgA0GVCTYCECADQQs2AgwMDQtBACECIANBADYCHCADIAE2AhQgA0HpDzYCECADQQo2AgwMDAtBACECIANBADYCHCADIAE2AhQgA0GDEDYCECADQQo2AgwMCwtBACECIANBADYCHCADIAE2AhQgA0GmHDYCECADQQI2AgwMCgtBACECIANBADYCHCADIAE2AhQgA0HFFTYCECADQQI2AgwMCQtBACECIANBADYCHCADIAE2AhQgA0H/FzYCECADQQI2AgwMCAtBACECIANBADYCHCADIAE2AhQgA0HKFzYCECADQQI2AgwMBwsgA0ECNgIcIAMgATYCFCADQZQdNgIQIANBFjYCDEEAIQIMBgtB3gAhAiABIARGDQUgCUEIaiEHIAMoAgAhBQJAAkAgASAERwRAIAVBxsYAaiEIIAQgBWogAWshBiAFQX9zQQpqIgUgAWohAANAIAEtAAAgCC0AAEcEQEECIQgMAwsgBUUEQEEAIQggACEBDAMLIAVBAWshBSAIQQFqIQggBCABQQFqIgFHDQALIAYhBSAEIQELIAdBATYCACADIAU2AgAMAQsgA0EANgIAIAcgCDYCAAsgByABNgIEIAkoAgwhACAJKAIIDgMBBQIACwALIANBADYCHCADQa0dNgIQIANBFzYCDCADIABBAWo2AhRBACECDAMLIANBADYCHCADIAA2AhQgA0HCHTYCECADQQk2AgxBACECDAILIAEgBEYEQEEoIQIMAgsgA0EJNgIIIAMgATYCBEEnIQIMAQsgASAERgRAQQEhAgwBCwNAAkACQAJAIAEtAABBCmsOBAABAQABCyABQQFqIQEMAQsgAUEBaiEBIAMtAC5BIHENAEEAIQIgA0EANgIcIAMgATYCFCADQYwgNgIQIANBBTYCDAwCC0EBIQIgASAERw0ACwsgCUEQaiQAIAJFBEAgAygCDCEADAELIAMgAjYCHEEAIQAgAygCBCIBRQ0AIAMgASAEIAMoAggRAQAiAUUNACADIAQ2AhQgAyABNgIMIAEhAAsgAAu+AgECfyAAQQA6AAAgAEHcAGoiAUEBa0EAOgAAIABBADoAAiAAQQA6AAEgAUEDa0EAOgAAIAFBAmtBADoAACAAQQA6AAMgAUEEa0EAOgAAQQAgAGtBA3EiASAAaiIAQQA2AgBB3AAgAWtBfHEiAiAAaiIBQQRrQQA2AgACQCACQQlJDQAgAEEANgIIIABBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIAJBGUkNACAAQQA2AhggAEEANgIUIABBADYC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U3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMARXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVycwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgAVHJhbnNmZXItRW5jb2RpbmcgY2FuJ3QgYmUgcHJlc2VudCB3aXRoIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgc2l6ZQBFeHBlY3RlZCBMRiBhZnRlciBjaHVuayBzaXplAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGhlYWRlciB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBxdW90ZWQtcGFpciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgcmVzcG9uc2UgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGV4dGVuc2lvbiBuYW1lAEludmFsaWQgc3RhdHVzIGNvZGUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBkYXRhAEV4cGVjdGVkIExGIGFmdGVyIGNodW5rIGRhdGEAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAERhdGEgYWZ0ZXIgYENvbm5lY3Rpb246IGNsb3NlYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAUVVFUlkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBFeHBlY3RlZCBMRiBhZnRlciBDUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAFIVAAAaFQAADxIAAOQZAACRFQAACRQAAC0ZAADkFAAA6REAAGkUAAChFAAAdhUAAEMWAABeEgAAlBcAABcWAAB9FAAAfxYAAEEXAACzEwAAwxYAAAQaAAC9GAAA0BgAAKATAADUGQAArxYAAGgWAABwFwAA2RYAAPwYAAD+EQAAWRcAAJcWAAAcFwAA9hYAAI0XAAALEgAAfxsAAC4RAACzEAAASRIAAK0SAAD2GAAAaBAAAGIVAAAQFQAAWhYAAEoZAAC1FQAAwRUAAGAVAABcGQAAWhkAAFMZAAAWFQAArREAAEIQAAC3EAAAVxgAAL8VAACJEAAAHBkAABoZAAC5FQAAURgAANwTAABbFQAAWRUAAOYYAABnFQAAERkAAO0YAADnEwAArhAAAMIXAAAAFAAAkhMAAIQTAABAEgAAJhkAAK8VAABiEABB6TkLAQEAQYA6C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAwEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQeo7CwQBAAACAEGBPAteAwQDAwMDAwAAAwMAAwMAAwMDAwMDAwMDAwAFAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMAAwBB6j0LBAEAAAIAQYE+C14DAAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAQABQAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEHgPwsNbG9zZWVlcC1hbGl2ZQBB+T8LAQEAQZDAAAvgAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5wQALAQEAQZDCAAvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBocQAC14BAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGAxgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBsMYACytyYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNClNNDQoNClRUUC9DRS9UU1AvAEHpxgALBQECAAEDAEGAxwALXwQFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAEHpyAALBQECAAEDAEGAyQALXwQFBQYFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAEHpygALBAEAAAEAQYHLAAteAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgBB6cwACwUBAgABAwBBgM0AC18EBQAABQUFBQUFBQUFBQUGBQUFBQUFBQUFBQUFAAUABwgFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUABQAFAAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAAAABQBB6c4ACwUBAQABAQBBgM8ACwEBAEGazwALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEHp0AALBQEBAAEBAEGA0QALAQEAQYrRAAsGAgAAAAACAEGh0QALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQeDSAAuaAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VVRVJZT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8='\n\nlet wasmBuffer\n\nObject.defineProperty(module, 'exports', {\n  get: () => {\n    return wasmBuffer\n      ? wasmBuffer\n      : (wasmBuffer = Buffer.from(wasmBase64, 'base64'))\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwX3NpbWQtd2FzbS5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7O0FBRVosUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFeEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwX3NpbWQtd2FzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcblxuY29uc3Qgd2FzbUJhc2U2NCA9ICdBR0Z6YlFFQUFBQUJKd2RnQVg4QmYyQURmMzkvQVg5Z0FuOS9BR0FCZndCZ0JIOS9mMzhCZjJBQUFHQURmMzkvQUFMTEFRZ0RaVzUyR0hkaGMyMWZiMjVmYUdWaFpHVnljMTlqYjIxd2JHVjBaUUFFQTJWdWRoVjNZWE50WDI5dVgyMWxjM05oWjJWZlltVm5hVzRBQUFObGJuWUxkMkZ6YlY5dmJsOTFjbXdBQVFObGJuWU9kMkZ6YlY5dmJsOXpkR0YwZFhNQUFRTmxibllVZDJGemJWOXZibDlvWldGa1pYSmZabWxsYkdRQUFRTmxibllVZDJGemJWOXZibDlvWldGa1pYSmZkbUZzZFdVQUFRTmxibllNZDJGemJWOXZibDlpYjJSNUFBRURaVzUyR0hkaGMyMWZiMjVmYldWemMyRm5aVjlqYjIxd2JHVjBaUUFBQXpRekJRWUFBQU1BQUFBQUFBQURBUU1BQXdNREFBQUNBQUFBQUFJQ0FnSUNBZ0lDQWdJQkFRRUJBUUVCQVFFREFBQURBQUFBQkFVQmNBRVNFZ1VEQVFBQ0JnZ0Jmd0ZCZ05nRUN3ZkZCeWdHYldWdGIzSjVBZ0FMWDJsdWFYUnBZV3hwZW1VQUNCbGZYMmx1WkdseVpXTjBYMloxYm1OMGFXOXVYM1JoWW14bEFRQUxiR3hvZEhSd1gybHVhWFFBQ1Joc2JHaDBkSEJmYzJodmRXeGtYMnRsWlhCZllXeHBkbVVBTmd4c2JHaDBkSEJmWVd4c2IyTUFDd1p0WVd4c2IyTUFPQXRzYkdoMGRIQmZabkpsWlFBTUJHWnlaV1VBREE5c2JHaDBkSEJmWjJWMFgzUjVjR1VBRFJWc2JHaDBkSEJmWjJWMFgyaDBkSEJmYldGcWIzSUFEaFZzYkdoMGRIQmZaMlYwWDJoMGRIQmZiV2x1YjNJQUR4RnNiR2gwZEhCZloyVjBYMjFsZEdodlpBQVFGbXhzYUhSMGNGOW5aWFJmYzNSaGRIVnpYMk52WkdVQUVSSnNiR2gwZEhCZloyVjBYM1Z3WjNKaFpHVUFFZ3hzYkdoMGRIQmZjbVZ6WlhRQUV3NXNiR2gwZEhCZlpYaGxZM1YwWlFBVUZHeHNhSFIwY0Y5elpYUjBhVzVuYzE5cGJtbDBBQlVOYkd4b2RIUndYMlpwYm1semFBQVdER3hzYUhSMGNGOXdZWFZ6WlFBWERXeHNhSFIwY0Y5eVpYTjFiV1VBR0J0c2JHaDBkSEJmY21WemRXMWxYMkZtZEdWeVgzVndaM0poWkdVQUdSQnNiR2gwZEhCZloyVjBYMlZ5Y201dkFCb1hiR3hvZEhSd1gyZGxkRjlsY25KdmNsOXlaV0Z6YjI0QUd4ZHNiR2gwZEhCZmMyVjBYMlZ5Y205eVgzSmxZWE52YmdBY0ZHeHNhSFIwY0Y5blpYUmZaWEp5YjNKZmNHOXpBQjBSYkd4b2RIUndYMlZ5Y201dlgyNWhiV1VBSGhKc2JHaDBkSEJmYldWMGFHOWtYMjVoYldVQUh4SnNiR2gwZEhCZmMzUmhkSFZ6WDI1aGJXVUFJQnBzYkdoMGRIQmZjMlYwWDJ4bGJtbGxiblJmYUdWaFpHVnljd0FoSVd4c2FIUjBjRjl6WlhSZmJHVnVhV1Z1ZEY5amFIVnVhMlZrWDJ4bGJtZDBhQUFpSFd4c2FIUjBjRjl6WlhSZmJHVnVhV1Z1ZEY5clpXVndYMkZzYVhabEFDTWtiR3hvZEhSd1gzTmxkRjlzWlc1cFpXNTBYM1J5WVc1elptVnlYMlZ1WTI5a2FXNW5BQ1FhYkd4b2RIUndYM05sZEY5c1pXNXBaVzUwWDNabGNuTnBiMjRBSlNOc2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZlpHRjBZVjloWm5SbGNsOWpiRzl6WlFBbUoyeHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOXZjSFJwYjI1aGJGOXNabDloWm5SbGNsOWpjZ0FuTEd4c2FIUjBjRjl6WlhSZmJHVnVhV1Z1ZEY5dmNIUnBiMjVoYkY5amNteG1YMkZtZEdWeVgyTm9kVzVyQUNnb2JHeG9kSFJ3WDNObGRGOXNaVzVwWlc1MFgyOXdkR2x2Ym1Gc1gyTnlYMkpsWm05eVpWOXNaZ0FwS214c2FIUjBjRjl6WlhSZmJHVnVhV1Z1ZEY5emNHRmpaWE5mWVdaMFpYSmZZMmgxYm10ZmMybDZaUUFxR0d4c2FIUjBjRjl0WlhOellXZGxYMjVsWldSelgyVnZaZ0ExQ1JjQkFFRUJDeEVCQWdNRUJRb0dCekV6TWkwdUxDc3ZNQXJZeXdJekZnQkIvTk1BS0FJQUJFQUFDMEg4MHdCQkFUWUNBQXNVQUNBQUVEY2dBQ0FDTmdJNElBQWdBVG9BS0FzVUFDQUFJQUF2QVRRZ0FDMEFNQ0FBRURZUUFBc2VBUUYvUWNBQUVEa2lBUkEzSUFGQmdBZzJBamdnQVNBQU9nQW9JQUVMand3QkIzOENRQ0FBUlEwQUlBQkJDR3NpQVNBQVFRUnJLQUlBSWdCQmVIRWlCR29oQlFKQUlBQkJBWEVOQUNBQVFRTnhSUTBCSUFFZ0FTZ0NBQ0lBYXlJQlFaRFVBQ2dDQUVrTkFTQUFJQVJxSVFRQ1FBSkFRWlRVQUNnQ0FDQUJSd1JBSUFCQi93Rk5CRUFnQUVFRGRpRURJQUVvQWdnaUFDQUJLQUlNSWdKR0JFQkJnTlFBUVlEVUFDZ0NBRUYrSUFOM2NUWUNBQXdGQ3lBQ0lBQTJBZ2dnQUNBQ05nSU1EQVFMSUFFb0FoZ2hCaUFCSUFFb0Fnd2lBRWNFUUNBQUlBRW9BZ2dpQWpZQ0NDQUNJQUEyQWd3TUF3c2dBVUVVYWlJREtBSUFJZ0pGQkVBZ0FTZ0NFQ0lDUlEwQ0lBRkJFR29oQXdzRFFDQURJUWNnQWlJQVFSUnFJZ01vQWdBaUFnMEFJQUJCRUdvaEF5QUFLQUlRSWdJTkFBc2dCMEVBTmdJQURBSUxJQVVvQWdRaUFFRURjVUVEUncwQ0lBVWdBRUYrY1RZQ0JFR0kxQUFnQkRZQ0FDQUZJQVEyQWdBZ0FTQUVRUUZ5TmdJRURBTUxRUUFoQUFzZ0JrVU5BQUpBSUFFb0Fod2lBa0VDZEVHdzFnQnFJZ01vQWdBZ0FVWUVRQ0FESUFBMkFnQWdBQTBCUVlUVUFFR0UxQUFvQWdCQmZpQUNkM0UyQWdBTUFnc2dCa0VRUVJRZ0JpZ0NFQ0FCUmh0cUlBQTJBZ0FnQUVVTkFRc2dBQ0FHTmdJWUlBRW9BaEFpQWdSQUlBQWdBallDRUNBQ0lBQTJBaGdMSUFGQkZHb29BZ0FpQWtVTkFDQUFRUlJxSUFJMkFnQWdBaUFBTmdJWUN5QUJJQVZQRFFBZ0JTZ0NCQ0lBUVFGeFJRMEFBa0FDUUFKQUFrQWdBRUVDY1VVRVFFR1kxQUFvQWdBZ0JVWUVRRUdZMUFBZ0FUWUNBRUdNMUFCQmpOUUFLQUlBSUFScUlnQTJBZ0FnQVNBQVFRRnlOZ0lFSUFGQmxOUUFLQUlBUncwR1FZalVBRUVBTmdJQVFaVFVBRUVBTmdJQURBWUxRWlRVQUNnQ0FDQUZSZ1JBUVpUVUFDQUJOZ0lBUVlqVUFFR0kxQUFvQWdBZ0JHb2lBRFlDQUNBQklBQkJBWEkyQWdRZ0FDQUJhaUFBTmdJQURBWUxJQUJCZUhFZ0JHb2hCQ0FBUWY4QlRRUkFJQUJCQTNZaEF5QUZLQUlJSWdBZ0JTZ0NEQ0lDUmdSQVFZRFVBRUdBMUFBb0FnQkJmaUFEZDNFMkFnQU1CUXNnQWlBQU5nSUlJQUFnQWpZQ0RBd0VDeUFGS0FJWUlRWWdCU0FGS0FJTUlnQkhCRUJCa05RQUtBSUFHaUFBSUFVb0FnZ2lBallDQ0NBQ0lBQTJBZ3dNQXdzZ0JVRVVhaUlES0FJQUlnSkZCRUFnQlNnQ0VDSUNSUTBDSUFWQkVHb2hBd3NEUUNBRElRY2dBaUlBUVJScUlnTW9BZ0FpQWcwQUlBQkJFR29oQXlBQUtBSVFJZ0lOQUFzZ0IwRUFOZ0lBREFJTElBVWdBRUYrY1RZQ0JDQUJJQVJxSUFRMkFnQWdBU0FFUVFGeU5nSUVEQU1MUVFBaEFBc2dCa1VOQUFKQUlBVW9BaHdpQWtFQ2RFR3cxZ0JxSWdNb0FnQWdCVVlFUUNBRElBQTJBZ0FnQUEwQlFZVFVBRUdFMUFBb0FnQkJmaUFDZDNFMkFnQU1BZ3NnQmtFUVFSUWdCaWdDRUNBRlJodHFJQUEyQWdBZ0FFVU5BUXNnQUNBR05nSVlJQVVvQWhBaUFnUkFJQUFnQWpZQ0VDQUNJQUEyQWhnTElBVkJGR29vQWdBaUFrVU5BQ0FBUVJScUlBSTJBZ0FnQWlBQU5nSVlDeUFCSUFScUlBUTJBZ0FnQVNBRVFRRnlOZ0lFSUFGQmxOUUFLQUlBUncwQVFZalVBQ0FFTmdJQURBRUxJQVJCL3dGTkJFQWdCRUY0Y1VHbzFBQnFJUUFDZjBHQTFBQW9BZ0FpQWtFQklBUkJBM1owSWdOeFJRUkFRWURVQUNBQ0lBTnlOZ0lBSUFBTUFRc2dBQ2dDQ0FzaUFpQUJOZ0lNSUFBZ0FUWUNDQ0FCSUFBMkFnd2dBU0FDTmdJSURBRUxRUjhoQWlBRVFmLy8vd2ROQkVBZ0JFRW1JQVJCQ0habklnQnJka0VCY1NBQVFRRjBhMEUrYWlFQ0N5QUJJQUkyQWh3Z0FVSUFOd0lRSUFKQkFuUkJzTllBYWlFQUFrQkJoTlFBS0FJQUlnTkJBU0FDZENJSGNVVUVRQ0FBSUFFMkFnQkJoTlFBSUFNZ0IzSTJBZ0FnQVNBQU5nSVlJQUVnQVRZQ0NDQUJJQUUyQWd3TUFRc2dCRUVaSUFKQkFYWnJRUUFnQWtFZlJ4dDBJUUlnQUNnQ0FDRUFBa0FEUUNBQUlnTW9BZ1JCZUhFZ0JFWU5BU0FDUVIxMklRQWdBa0VCZENFQ0lBTWdBRUVFY1dwQkVHb2lCeWdDQUNJQURRQUxJQWNnQVRZQ0FDQUJJQU0yQWhnZ0FTQUJOZ0lNSUFFZ0FUWUNDQXdCQ3lBREtBSUlJZ0FnQVRZQ0RDQURJQUUyQWdnZ0FVRUFOZ0lZSUFFZ0F6WUNEQ0FCSUFBMkFnZ0xRYURVQUVHZzFBQW9BZ0JCQVdzaUFFRi9JQUFiTmdJQUN3c0hBQ0FBTFFBb0N3Y0FJQUF0QUNvTEJ3QWdBQzBBS3dzSEFDQUFMUUFwQ3djQUlBQXZBVFFMQndBZ0FDMEFNQXRBQVFSL0lBQW9BaGdoQVNBQUx3RXVJUUlnQUMwQUtDRURJQUFvQWpnaEJDQUFFRGNnQUNBRU5nSTRJQUFnQXpvQUtDQUFJQUk3QVM0Z0FDQUJOZ0lZQzhYNEFRSUhmd04rSUFFZ0Ftb2hCQUpBSUFBaUF5Z0NEQ0lBRFFBZ0F5Z0NCQVJBSUFNZ0FUWUNCQXNqQUVFUWF5SUpKQUFDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBbjhDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0F5Z0NIQ0lDUVFGckR1d0I3Z0VCNkFFQ0F3UUZCZ2NJQ1FvTERBME9EeEFSRXVjQkUrWUJGQlhsQVJZWDVBRVlHUm9iSEIwZUh5RHZBZTBCSWVNQklpTWtKU1luS0NrcUsrSUJMQzB1THpBeE11RUI0QUV6Tk44QjNnRTFOamM0T1RvN1BEMCtQMEJCUWtORVJVWkhTRWxLUzB4TlRrL3BBVkJSVWxQZEFkd0JWTnNCVmRvQlZsZFlXVnBiWEYxZVgyQmhZbU5rWldabmFHbHFhMnh0Ym05d2NYSnpkSFYyZDNoNWVudDhmWDUvZ0FHQkFZSUJnd0dFQVlVQmhnR0hBWWdCaVFHS0FZc0JqQUdOQVk0Qmp3R1FBWkVCa2dHVEFaUUJsUUdXQVpjQm1BR1pBWm9CbXdHY0FaMEJuZ0dmQWFBQm9RR2lBYU1CcEFHbEFhWUJwd0dvQWFrQnFnR3JBYXdCclFHdUFhOEJzQUd4QWJJQnN3RzBBYlVCdGdHM0FiZ0J1UUc2QWJzQnZBRzlBYjRCdndIQUFjRUJ3Z0hEQWNRQnhRSFpBZGdCeGdIWEFjY0IxZ0hJQWNrQnlnSExBY3dCelFIT0FjOEIwQUhSQWRJQjB3SFVBUURxQVF0QkFBelVBUXRCRGd6VEFRdEJEUXpTQVF0QkR3elJBUXRCRUF6UUFRdEJFUXpQQVF0QkVnek9BUXRCRXd6TkFRdEJGQXpNQVF0QkZRekxBUXRCRmd6S0FRdEJGd3pKQVF0QkdBeklBUXRCR1F6SEFRdEJHZ3pHQVF0Qkd3ekZBUXRCSEF6RUFRdEJIUXpEQVF0QkhnekNBUXRCSHd6QkFRdEJDQXpBQVF0QklBeS9BUXRCSWd5K0FRdEJJUXk5QVF0QkJ3eThBUXRCSXd5N0FRdEJKQXk2QVF0QkpReTVBUXRCSmd5NEFRdEJKd3kzQVF0QnpnRU10Z0VMUVNnTXRRRUxRU2tNdEFFTFFTb01zd0VMUVNzTXNnRUxRYzhCRExFQkMwRXRETEFCQzBFdURLOEJDMEV2REs0QkMwRXdESzBCQzBFeERLd0JDMEV5REtzQkMwRXpES29CQzBIUUFReXBBUXRCTkF5b0FRdEJPQXluQVF0QkRBeW1BUXRCTlF5bEFRdEJOZ3lrQVF0Qk53eWpBUXRCUFF5aUFRdEJPUXloQVF0QjBRRU1vQUVMUVFzTW53RUxRVDRNbmdFTFFUb01uUUVMUVFvTW5BRUxRVHNNbXdFTFFUd01tZ0VMUWRJQkRKa0JDMEhBQUF5WUFRdEJQd3lYQVF0QndRQU1sZ0VMUVFrTWxRRUxRU3dNbEFFTFFjSUFESk1CQzBIREFBeVNBUXRCeEFBTWtRRUxRY1VBREpBQkMwSEdBQXlQQVF0Qnh3QU1qZ0VMUWNnQURJMEJDMEhKQUF5TUFRdEJ5Z0FNaXdFTFFjc0FESW9CQzBITUFBeUpBUXRCelFBTWlBRUxRYzRBREljQkMwSFBBQXlHQVF0QjBBQU1oUUVMUWRFQURJUUJDMEhTQUF5REFRdEIxQUFNZ2dFTFFkTUFESUVCQzBIVkFBeUFBUXRCMWdBTWZ3dEIxd0FNZmd0QjJBQU1mUXRCMlFBTWZBdEIyZ0FNZXd0QjJ3QU1lZ3RCMHdFTWVRdEIzQUFNZUF0QjNRQU1kd3RCQmd4MkMwSGVBQXgxQzBFRkRIUUxRZDhBREhNTFFRUU1jZ3RCNEFBTWNRdEI0UUFNY0F0QjRnQU1id3RCNHdBTWJndEJBd3h0QzBIa0FBeHNDMEhsQUF4ckMwSG1BQXhxQzBIb0FBeHBDMEhuQUF4b0MwSHBBQXhuQzBIcUFBeG1DMEhyQUF4bEMwSHNBQXhrQzBFQ0RHTUxRZTBBREdJTFFlNEFER0VMUWU4QURHQUxRZkFBREY4TFFmRUFERjRMUWZJQURGMExRZk1BREZ3TFFmUUFERnNMUWZVQURGb0xRZllBREZrTFFmY0FERmdMUWZnQURGY0xRZmtBREZZTFFmb0FERlVMUWZzQURGUUxRZndBREZNTFFmMEFERklMUWY0QURGRUxRZjhBREZBTFFZQUJERThMUVlFQkRFNExRWUlCREUwTFFZTUJERXdMUVlRQkRFc0xRWVVCREVvTFFZWUJERWtMUVljQkRFZ0xRWWdCREVjTFFZa0JERVlMUVlvQkRFVUxRWXNCREVRTFFZd0JERU1MUVkwQkRFSUxRWTRCREVFTFFZOEJERUFMUVpBQkREOExRWkVCREQ0TFFaSUJERDBMUVpNQkREd0xRWlFCRERzTFFaVUJERG9MUVpZQkREa0xRWmNCRERnTFFaZ0JERGNMUVprQkREWUxRWm9CRERVTFFac0JERFFMUVp3QkRETUxRWjBCRERJTFFaNEJEREVMUVo4QkREQUxRYUFCREM4TFFhRUJEQzRMUWFJQkRDMExRYU1CREN3TFFhUUJEQ3NMUWFVQkRDb0xRYVlCRENrTFFhY0JEQ2dMUWFnQkRDY0xRYWtCRENZTFFhb0JEQ1VMUWFzQkRDUUxRYXdCRENNTFFhMEJEQ0lMUWE0QkRDRUxRYThCRENBTFFiQUJEQjhMUWJFQkRCNExRYklCREIwTFFiTUJEQndMUWJRQkRCc0xRYlVCREJvTFFiWUJEQmtMUWJjQkRCZ0xRYmdCREJjTFFRRU1GZ3RCdVFFTUZRdEJ1Z0VNRkF0QnV3RU1Fd3RCdkFFTUVndEJ2UUVNRVF0QnZnRU1FQXRCdndFTUR3dEJ3QUVNRGd0QndRRU1EUXRCd2dFTURBdEJ3d0VNQ3d0QnhBRU1DZ3RCeFFFTUNRdEJ4Z0VNQ0F0QjFBRU1Cd3RCeHdFTUJndEJ5QUVNQlF0QnlRRU1CQXRCeWdFTUF3dEJ5d0VNQWd0QnpRRU1BUXRCekFFTElRSURRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBTUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQW44Q1FBSkFBa0FDUUFKQUFrQUNRQUovQWtBQ1FBSkFBbjhDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFNQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQ0R0UUJBQUVDQXdRRkJnY0lDUW9MREEwT0R4QVJGQlVXRnhnWkdoc2NIUjRmSUNFakpDVW5LQ21JQTRjRGhRT0VBL3dDOVFMdUF1c0M2QUxtQXVNQzRBTGZBdDBDMndMV0F0VUMxQUxUQXRJQ3lnTEpBc2dDeHdMR0FzVUN4QUxEQXIwQ3ZBSzZBcmtDdUFLM0FyWUN0UUswQXJJQ3NRS3NBcW9DcUFLbkFxWUNwUUtrQXFNQ29nS2hBcUFDbndLYkFwb0NtUUtZQXBjQ2tBS0lBb1FDZ3dLQ0F2a0I5Z0gxQWZRQjh3SHlBZkVCOEFIdkFlMEI2d0hvQWVNQjRRSGdBZDhCM2dIZEFkd0Iyd0hhQWRrQjJBSFhBZFlCMVFIVUFkSUIwUUhRQWM4QnpnSE5BY3dCeXdIS0Fja0J5QUhIQWNZQnhRSEVBY01Cd2dIQkFjQUJ2d0crQWIwQnZBRzdBYm9CdVFHNEFiY0J0Z0cxQWJRQnN3R3lBYkVCc0FHdkFhNEJyUUdzQWFzQnFnR3BBYWdCcHdHbUFhVUJwQUdqQWFJQm9RR2dBWjhCbmdHZEFad0Jtd0dhQVpjQmxnR1JBWkFCandHT0FZMEJqQUdMQVlvQmlRR0lBWVVCaEFHREFYNTlmSHQ2ZDNaMUxGRlNVMVJWVmdzZ0FTQUVSdzF6UWV3QklRSU1xUU1MSUFFZ0JFY05rQUZCMFFFaEFneW9Bd3NnQVNBRVJ3M3BBVUdFQVNFQ0RLY0RDeUFCSUFSSERmUUJRZm9BSVFJTXBnTUxJQUVnQkVjTmdnSkI5UUFoQWd5bEF3c2dBU0FFUncySkFrSHpBQ0VDREtRREN5QUJJQVJIRFl3Q1FmRUFJUUlNb3dNTElBRWdCRWNOSGtFZUlRSU1vZ01MSUFFZ0JFY05HVUVZSVFJTW9RTUxJQUVnQkVjTnVBSkJ6UUFoQWd5Z0F3c2dBU0FFUnczREFrSEdBQ0VDREo4REN5QUJJQVJIRGNRQ1FjTUFJUUlNbmdNTElBRWdCRWNOeWdKQk9DRUNESjBEQ3lBRExRQXdRUUZHRFpVRERQSUNDMEVBSVFBQ1FBSkFBa0FnQXkwQUtrVU5BQ0FETFFBclJRMEFJQU12QVRJaUFrRUNjVVVOQVF3Q0N5QURMd0V5SWdKQkFYRkZEUUVMUVFFaEFDQURMUUFvUVFGR0RRQWdBeThCTkNJR1FlUUFhMEhrQUVrTkFDQUdRY3dCUmcwQUlBWkJzQUpHRFFBZ0FrSEFBSEVOQUVFQUlRQWdBa0dJQkhGQmdBUkdEUUFnQWtFb2NVRUFSeUVBQ3lBRFFRQTdBVElnQTBFQU9nQXhBa0FnQUVVRVFDQURRUUE2QURFZ0F5MEFMa0VFY1EwQkRKd0RDeUFEUWdBM0F5QUxJQU5CQURvQU1TQURRUUU2QURZTVNRdEJBQ0VBQWtBZ0F5Z0NPQ0lDUlEwQUlBSW9BaXdpQWtVTkFDQURJQUlSQUFBaEFBc2dBRVVOU1NBQVFSVkhEV01nQTBFRU5nSWNJQU1nQVRZQ0ZDQURRYjBhTmdJUUlBTkJGVFlDREVFQUlRSU1tZ01MSUFFZ0JFWUVRRUVHSVFJTW1nTUxJQUV0QUFCQkNrWU5HUXdCQ3lBQklBUkdCRUJCQnlFQ0RKa0RDd0pBSUFFdEFBQkJDbXNPQkFJQkFRQUJDeUFCUVFGcUlRRkJFQ0VDRFA0Q0N5QURMUUF1UVlBQmNRMFlRUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5CcVI4MkFoQWdBMEVDTmdJTURKY0RDeUFCUVFGcUlRRWdBMEV2YWkwQUFFRUJjUTBYUVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQmhCODJBaEFnQTBFWk5nSU1ESllEQ3lBRElBTXBBeUFpRENBRUlBRnJyU0lLZlNJTFFnQWdDeUFNV0JzM0F5QWdDaUFNV2cwWlFRZ2hBZ3lWQXdzZ0FTQUVSd1JBSUFOQkNUWUNDQ0FESUFFMkFnUkJFaUVDRFBzQ0MwRUpJUUlNbEFNTElBTXBBeUJRRFp3Q0RFUUxJQUVnQkVZRVFFRUxJUUlNa3dNTElBRXRBQUJCQ2tjTkZ5QUJRUUZxSVFFTUdBc2dBMEV2YWkwQUFFRUJjVVVOR2d3bkMwRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NTQ0lDUlEwQUlBTWdBaEVBQUNFQUN5QUFEUm9NUXd0QkFDRUFBa0FnQXlnQ09DSUNSUTBBSUFJb0FrZ2lBa1VOQUNBRElBSVJBQUFoQUFzZ0FBMGJEQ1VMUVFBaEFBSkFJQU1vQWpnaUFrVU5BQ0FDS0FKSUlnSkZEUUFnQXlBQ0VRQUFJUUFMSUFBTkhBd3pDeUFEUVM5cUxRQUFRUUZ4UlEwZERDTUxRUUFoQUFKQUlBTW9BamdpQWtVTkFDQUNLQUpNSWdKRkRRQWdBeUFDRVFBQUlRQUxJQUFOSFF4REMwRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NUQ0lDUlEwQUlBTWdBaEVBQUNFQUN5QUFEUjRNSVFzZ0FTQUVSZ1JBUVJNaEFneUxBd3NDUUNBQkxRQUFJZ0JCQ21zT0JDQWtKQUFqQ3lBQlFRRnFJUUVNSUF0QkFDRUFBa0FnQXlnQ09DSUNSUTBBSUFJb0Frd2lBa1VOQUNBRElBSVJBQUFoQUFzZ0FBMGpERU1MSUFFZ0JFWUVRRUVXSVFJTWlRTUxJQUV0QUFCQjhEOXFMUUFBUVFGSERTUU03UUlMQWtBRFFDQUJMUUFBUWVBNWFpMEFBQ0lBUVFGSEJFQUNRQ0FBUVFKckRnSURBQ2dMSUFGQkFXb2hBVUVmSVFJTThBSUxJQVFnQVVFQmFpSUJSdzBBQzBFWUlRSU1pQU1MSUFNb0FnUWhBRUVBSVFJZ0EwRUFOZ0lFSUFNZ0FDQUJRUUZxSWdFUU15SUFEU0lNUWd0QkFDRUFBa0FnQXlnQ09DSUNSUTBBSUFJb0Frd2lBa1VOQUNBRElBSVJBQUFoQUFzZ0FBMGtEQ3NMSUFFZ0JFWUVRRUVjSVFJTWhnTUxJQU5CQ2pZQ0NDQURJQUUyQWdSQkFDRUFBa0FnQXlnQ09DSUNSUTBBSUFJb0FrZ2lBa1VOQUNBRElBSVJBQUFoQUFzZ0FBMG1RU0loQWd6ckFnc2dBU0FFUndSQUEwQWdBUzBBQUVIZ08yb3RBQUFpQUVFRFJ3UkFJQUJCQVdzT0JSa2JKK3dDSmljTElBUWdBVUVCYWlJQlJ3MEFDMEViSVFJTWhRTUxRUnNoQWd5RUF3c0RRQ0FCTFFBQVFlQTlhaTBBQUNJQVFRTkhCRUFnQUVFQmF3NEZFQklvRkNjb0N5QUVJQUZCQVdvaUFVY05BQXRCSGlFQ0RJTURDeUFCSUFSSEJFQWdBMEVMTmdJSUlBTWdBVFlDQkVFSElRSU02UUlMUVI4aEFneUNBd3NnQVNBRVJnUkFRU0FoQWd5Q0F3c0NRQ0FCTFFBQVFRMXJEaFF2UUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVBTFFRQWhBaUFEUVFBMkFod2dBMEczQ3pZQ0VDQURRUUkyQWd3Z0F5QUJRUUZxTmdJVURJRURDeUFEUVM5cUlRSURRQ0FCSUFSR0JFQkJJU0VDRElJREN3SkFBa0FDUUNBQkxRQUFJZ0JCQ1dzT0dBSUFLaW9CS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xQWlnTElBRkJBV29oQVNBRFFTOXFMUUFBUVFGeFJRMExEQmtMSUFGQkFXb2hBUXdZQ3lBQlFRRnFJUUVnQWkwQUFFRUNjUTBBQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFjNFVOZ0lRSUFOQkREWUNEQXlBQXdzZ0FVRUJhaUVCQzBFQUlRQUNRQ0FES0FJNElnSkZEUUFnQWlnQ1ZDSUNSUTBBSUFNZ0FoRUFBQ0VBQ3lBQURRRU0wUUlMSUFOQ0FEY0RJQXc4Q3lBQVFSVkdCRUFnQTBFa05nSWNJQU1nQVRZQ0ZDQURRWVlhTmdJUUlBTkJGVFlDREVFQUlRSU0vUUlMUVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQjRnMDJBaEFnQTBFVU5nSU1EUHdDQ3lBREtBSUVJUUJCQUNFQ0lBTkJBRFlDQkNBRElBQWdBU0FNcDJvaUFSQXhJZ0JGRFNzZ0EwRUhOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFnd00rd0lMSUFNdEFDNUJ3QUJ4UlEwQkMwRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NVQ0lDUlEwQUlBTWdBaEVBQUNFQUN5QUFSUTBySUFCQkZVWUVRQ0FEUVFvMkFod2dBeUFCTmdJVUlBTkI4UmcyQWhBZ0EwRVZOZ0lNUVFBaEFnejZBZ3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBHTEREWUNFQ0FEUVJNMkFnd00rUUlMUVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQnNSUTJBaEFnQTBFQ05nSU1EUGdDQzBFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFZd1VOZ0lRSUFOQkdUWUNEQXozQWd0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSFJIRFlDRUNBRFFSazJBZ3dNOWdJTElBQkJGVVlOUFVFQUlRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFhSVBOZ0lRSUFOQklqWUNEQXoxQWdzZ0F5Z0NCQ0VBUVFBaEFpQURRUUEyQWdRZ0F5QUFJQUVRTWlJQVJRMG9JQU5CRFRZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNRFBRQ0N5QUFRUlZHRFRwQkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR2lEellDRUNBRFFTSTJBZ3dNOHdJTElBTW9BZ1FoQUVFQUlRSWdBMEVBTmdJRUlBTWdBQ0FCRURJaUFFVUVRQ0FCUVFGcUlRRU1LQXNnQTBFT05nSWNJQU1nQURZQ0RDQURJQUZCQVdvMkFoUU04Z0lMSUFCQkZVWU5OMEVBSVFJZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWFJUE5nSVFJQU5CSWpZQ0RBenhBZ3NnQXlnQ0JDRUFRUUFoQWlBRFFRQTJBZ1FnQXlBQUlBRVFNaUlBUlFSQUlBRkJBV29oQVF3bkN5QURRUTgyQWh3Z0F5QUFOZ0lNSUFNZ0FVRUJhallDRkF6d0FndEJBQ0VDSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEhvRmpZQ0VDQURRUmsyQWd3TTd3SUxJQUJCRlVZTk0wRUFJUUlnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRYzRNTmdJUUlBTkJJellDREF6dUFnc2dBeWdDQkNFQVFRQWhBaUFEUVFBMkFnUWdBeUFBSUFFUU15SUFSUTBsSUFOQkVUWUNIQ0FESUFFMkFoUWdBeUFBTmdJTURPMENDeUFBUVJWR0RUQkJBQ0VDSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEhPRERZQ0VDQURRU00yQWd3TTdBSUxJQU1vQWdRaEFFRUFJUUlnQTBFQU5nSUVJQU1nQUNBQkVETWlBRVVFUUNBQlFRRnFJUUVNSlFzZ0EwRVNOZ0ljSUFNZ0FEWUNEQ0FESUFGQkFXbzJBaFFNNndJTElBTkJMMm90QUFCQkFYRkZEUUVMUVJVaEFnelBBZ3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBIb0ZqWUNFQ0FEUVJrMkFnd002QUlMSUFCQk8wY05BQ0FCUVFGcUlRRU1EQXRCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBHWUZ6WUNFQ0FEUVFJMkFnd001Z0lMSUFCQkZVWU5LRUVBSVFJZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWM0TU5nSVFJQU5CSXpZQ0RBemxBZ3NnQTBFVU5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd3TTVBSUxJQU1vQWdRaEFFRUFJUUlnQTBFQU5nSUVJQU1nQUNBQkVETWlBRVVFUUNBQlFRRnFJUUVNM0FJTElBTkJGVFlDSENBRElBQTJBZ3dnQXlBQlFRRnFOZ0lVRE9NQ0N5QURLQUlFSVFCQkFDRUNJQU5CQURZQ0JDQURJQUFnQVJBeklnQkZCRUFnQVVFQmFpRUJETm9DQ3lBRFFSYzJBaHdnQXlBQU5nSU1JQU1nQVVFQmFqWUNGQXppQWdzZ0FFRVZSZzBqUVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQnpndzJBaEFnQTBFak5nSU1ET0VDQ3lBREtBSUVJUUJCQUNFQ0lBTkJBRFlDQkNBRElBQWdBUkF6SWdCRkJFQWdBVUVCYWlFQkRCMExJQU5CR1RZQ0hDQURJQUEyQWd3Z0F5QUJRUUZxTmdJVURPQUNDeUFES0FJRUlRQkJBQ0VDSUFOQkFEWUNCQ0FESUFBZ0FSQXpJZ0JGQkVBZ0FVRUJhaUVCRE5ZQ0N5QURRUm8yQWh3Z0F5QUFOZ0lNSUFNZ0FVRUJhallDRkF6ZkFnc2dBRUVWUmcwZlFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJvZzgyQWhBZ0EwRWlOZ0lNRE40Q0N5QURLQUlFSVFCQkFDRUNJQU5CQURZQ0JDQURJQUFnQVJBeUlnQkZCRUFnQVVFQmFpRUJEQnNMSUFOQkhEWUNIQ0FESUFBMkFnd2dBeUFCUVFGcU5nSVVETjBDQ3lBREtBSUVJUUJCQUNFQ0lBTkJBRFlDQkNBRElBQWdBUkF5SWdCRkJFQWdBVUVCYWlFQkROSUNDeUFEUVIwMkFod2dBeUFBTmdJTUlBTWdBVUVCYWpZQ0ZBemNBZ3NnQUVFN1J3MEJJQUZCQVdvaEFRdEJKQ0VDRE1BQ0MwRUFJUUlnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRYzRVTmdJUUlBTkJERFlDREF6WkFnc2dBU0FFUndSQUEwQWdBUzBBQUVFZ1J3M3hBU0FFSUFGQkFXb2lBVWNOQUF0QkxDRUNETmtDQzBFc0lRSU0yQUlMSUFFZ0JFWUVRRUUwSVFJTTJBSUxBa0FDUUFOQUFrQWdBUzBBQUVFS2F3NEVBZ0FBQXdBTElBUWdBVUVCYWlJQlJ3MEFDMEUwSVFJTTJRSUxJQU1vQWdRaEFDQURRUUEyQWdRZ0F5QUFJQUVRTUNJQVJRMk1BaUFEUVRJMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU0yQUlMSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUU1DSUFSUVJBSUFGQkFXb2hBUXlNQWdzZ0EwRXlOZ0ljSUFNZ0FEWUNEQ0FESUFGQkFXbzJBaFJCQUNFQ0ROY0NDeUFCSUFSSEJFQUNRQU5BSUFFdEFBQkJNR3NpQUVIL0FYRkJDazhFUUVFNUlRSU13QUlMSUFNcEF5QWlDMEtacytiTW1iUG16QmxXRFFFZ0F5QUxRZ3ArSWdvM0F5QWdDaUFBclVML0FZTWlDMEovaFZZTkFTQURJQW9nQzN3M0F5QWdCQ0FCUVFGcUlnRkhEUUFMUWNBQUlRSU0yQUlMSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFGQkFXb2lBUkF3SWdBTkZ3ekpBZ3RCd0FBaEFneldBZ3NnQVNBRVJnUkFRY2tBSVFJTTFnSUxBa0FEUUFKQUlBRXRBQUJCQ1dzT0dBQUNqd0tQQXBNQ2p3S1BBbzhDandLUEFvOENqd0tQQW84Q2p3S1BBbzhDandLUEFvOENqd0tQQW84Q0FJOENDeUFFSUFGQkFXb2lBVWNOQUF0QnlRQWhBZ3pXQWdzZ0FVRUJhaUVCSUFOQkwyb3RBQUJCQVhFTmp3SWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFla1BOZ0lRSUFOQkNqWUNERUVBSVFJTTFRSUxJQUVnQkVjRVFBTkFJQUV0QUFBaUFFRWdSd1JBQWtBQ1FBSkFJQUJCeUFCckRnc0FBYzBCelFITkFjMEJ6UUhOQWMwQnpRRUN6UUVMSUFGQkFXb2hBVUhaQUNFQ0RMOENDeUFCUVFGcUlRRkIyZ0FoQWd5K0Fnc2dBVUVCYWlFQlFkc0FJUUlNdlFJTElBUWdBVUVCYWlJQlJ3MEFDMEh1QUNFQ0ROVUNDMEh1QUNFQ0ROUUNDeUFEUVFJNkFDZ01NQXRCQUNFQ0lBTkJBRFlDSENBRFFiY0xOZ0lRSUFOQkFqWUNEQ0FESUFGQkFXbzJBaFFNMGdJTFFRQWhBZ3kzQWd0QkRTRUNETFlDQzBFUklRSU10UUlMUVJNaEFneTBBZ3RCRkNFQ0RMTUNDMEVXSVFJTXNnSUxRUmNoQWd5eEFndEJHQ0VDRExBQ0MwRVpJUUlNcndJTFFSb2hBZ3l1QWd0Qkd5RUNESzBDQzBFY0lRSU1yQUlMUVIwaEFneXJBZ3RCSGlFQ0RLb0NDMEVnSVFJTXFRSUxRU0VoQWd5b0FndEJJeUVDREtjQ0MwRW5JUUlNcGdJTElBTkJQVFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5L0Fnc2dBMEViTmdJY0lBTWdBVFlDRkNBRFFZOGJOZ0lRSUFOQkZUWUNERUVBSVFJTXZnSUxJQU5CSURZQ0hDQURJQUUyQWhRZ0EwR2VHVFlDRUNBRFFSVTJBZ3hCQUNFQ0RMMENDeUFEUVJNMkFod2dBeUFCTmdJVUlBTkJuaGsyQWhBZ0EwRVZOZ0lNUVFBaEFneThBZ3NnQTBFTE5nSWNJQU1nQVRZQ0ZDQURRWjRaTmdJUUlBTkJGVFlDREVFQUlRSU11d0lMSUFOQkVEWUNIQ0FESUFFMkFoUWdBMEdlR1RZQ0VDQURRUlUyQWd4QkFDRUNETG9DQ3lBRFFTQTJBaHdnQXlBQk5nSVVJQU5CanhzMkFoQWdBMEVWTmdJTVFRQWhBZ3k1QWdzZ0EwRUxOZ0ljSUFNZ0FUWUNGQ0FEUVk4Yk5nSVFJQU5CRlRZQ0RFRUFJUUlNdUFJTElBTkJERFlDSENBRElBRTJBaFFnQTBHUEd6WUNFQ0FEUVJVMkFneEJBQ0VDRExjQ0MwRUFJUUlnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRYThPTmdJUUlBTkJFallDREF5MkFnc0NRQU5BQWtBZ0FTMEFBRUVLYXc0RUFBSUNBQUlMSUFRZ0FVRUJhaUlCUncwQUMwSHNBU0VDRExZQ0N3SkFBa0FnQXkwQU5rRUJSdzBBUVFBaEFBSkFJQU1vQWpnaUFrVU5BQ0FDS0FKWUlnSkZEUUFnQXlBQ0VRQUFJUUFMSUFCRkRRQWdBRUVWUncwQklBTkI2d0UyQWh3Z0F5QUJOZ0lVSUFOQjRoZzJBaEFnQTBFVk5nSU1RUUFoQWd5M0FndEJ6QUVoQWd5Y0Fnc2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFmRUxOZ0lRSUFOQkh6WUNERUVBSVFJTXRRSUxBa0FDUUNBRExRQW9RUUZyRGdJRUFRQUxRY3NCSVFJTW13SUxRY1FCSVFJTW1nSUxJQU5CQWpvQU1VRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NBQ0lDUlEwQUlBTWdBaEVBQUNFQUN5QUFSUVJBUWMwQklRSU1tZ0lMSUFCQkZVY0VRQ0FEUVFBMkFod2dBeUFCTmdJVUlBTkJyQXcyQWhBZ0EwRVFOZ0lNUVFBaEFneTBBZ3NnQTBIcUFUWUNIQ0FESUFFMkFoUWdBMEdIR1RZQ0VDQURRUlUyQWd4QkFDRUNETE1DQ3lBQklBUkdCRUJCNlFFaEFneXpBZ3NnQVMwQUFFSElBRVlOQVNBRFFRRTZBQ2dMUWJZQklRSU1sd0lMUWNvQklRSU1sZ0lMSUFFZ0JFY0VRQ0FEUVF3MkFnZ2dBeUFCTmdJRVFja0JJUUlNbGdJTFFlZ0JJUUlNcndJTElBRWdCRVlFUUVIbkFTRUNESzhDQ3lBQkxRQUFRY2dBUncwRUlBRkJBV29oQVVISUFTRUNESlFDQ3lBQklBUkdCRUJCNWdFaEFneXVBZ3NDUUFKQUlBRXRBQUJCeFFCckRoQUFCUVVGQlFVRkJRVUZCUVVGQlFVQkJRc2dBVUVCYWlFQlFjWUJJUUlNbEFJTElBRkJBV29oQVVISEFTRUNESk1DQzBIbEFTRUNJQUVnQkVZTnJBSWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVDYWlFR0FrQURRQ0FCTFFBQUlBQkI5OU1BYWkwQUFFY05BeUFBUVFKR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU1yUUlMSUFNb0FnUWhBQ0FEUWdBM0F3QWdBeUFBSUFaQkFXb2lBUkF0SWdCRkJFQkIxQUVoQWd5VEFnc2dBMEhrQVRZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNUVFBaEFneXNBZ3RCNHdFaEFpQUJJQVJHRGFzQ0lBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBV29oQmdKQUEwQWdBUzBBQUNBQVFmWFRBR290QUFCSERRSWdBRUVCUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURLd0NDeUFEUVlFRU93RW9JQU1vQWdRaEFDQURRZ0EzQXdBZ0F5QUFJQVpCQVdvaUFSQXRJZ0FOQXd3Q0N5QURRUUEyQWdBTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkIwQjQyQWhBZ0EwRUlOZ0lNREtrQ0MwSEZBU0VDREk0Q0N5QURRZUlCTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3hCQUNFQ0RLY0NDMEVBSVFBQ1FDQURLQUk0SWdKRkRRQWdBaWdDT0NJQ1JRMEFJQU1nQWhFQUFDRUFDeUFBUlExbElBQkJGVWNFUUNBRFFRQTJBaHdnQXlBQk5nSVVJQU5CMUE0MkFoQWdBMEVnTmdJTVFRQWhBZ3luQWdzZ0EwR0ZBVFlDSENBRElBRTJBaFFnQTBIWEdqWUNFQ0FEUVJVMkFneEJBQ0VDREtZQ0MwSGhBU0VDSUFRZ0FTSUFSZzJsQWlBRUlBRnJJQU1vQWdBaUFXb2hCU0FBSUFGclFRUnFJUVlDUUFOQUlBQXRBQUFnQVVIdzB3QnFMUUFBUncwQklBRkJCRVlOQXlBQlFRRnFJUUVnQkNBQVFRRnFJZ0JIRFFBTElBTWdCVFlDQUF5bUFnc2dBMEVBTmdJY0lBTWdBRFlDRkNBRFFZUTNOZ0lRSUFOQkNEWUNEQ0FEUVFBMkFnQkJBQ0VDREtVQ0N5QUJJQVJIQkVBZ0EwRU5OZ0lJSUFNZ0FUWUNCRUhDQVNFQ0RJc0NDMEhnQVNFQ0RLUUNDeUFEUVFBMkFnQWdCa0VCYWlFQkMwSERBU0VDRElnQ0N5QUJJQVJHQkVCQjN3RWhBZ3lpQWdzZ0FTMEFBRUV3YXlJQVFmOEJjVUVLU1FSQUlBTWdBRG9BS2lBQlFRRnFJUUZCd1FFaEFneUlBZ3NnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBdUlnQkZEWWdDSUFOQjNnRTJBaHdnQXlBQk5nSVVJQU1nQURZQ0RFRUFJUUlNb1FJTElBRWdCRVlFUUVIZEFTRUNES0VDQ3dKQUlBRXRBQUJCTGtZRVFDQUJRUUZxSVFFTUFRc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkF1SWdCRkRZa0NJQU5CM0FFMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1vUUlMUWNBQklRSU1oZ0lMSUFFZ0JFWUVRRUhiQVNFQ0RLQUNDMEVBSVFCQkFTRUZRUUVoQjBFQUlRSUNRQUpBQWtBQ1FBSkFBbjhDUUFKQUFrQUNRQUpBQWtBQ1FDQUJMUUFBUVRCckRnb0tDUUFCQWdNRUJRWUlDd3RCQWd3R0MwRUREQVVMUVFRTUJBdEJCUXdEQzBFR0RBSUxRUWNNQVF0QkNBc2hBa0VBSVFWQkFDRUhEQUlMUVFraEFrRUJJUUJCQUNFRlFRQWhCd3dCQzBFQUlRVkJBU0VDQ3lBRElBSTZBQ3NnQVVFQmFpRUJBa0FDUUNBRExRQXVRUkJ4RFFBQ1FBSkFBa0FnQXkwQUtnNERBUUFDQkFzZ0IwVU5Bd3dDQ3lBQURRRU1BZ3NnQlVVTkFRc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkF1SWdCRkRRSWdBMEhZQVRZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNUVFBaEFneWlBZ3NnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBdUlnQkZEWXNDSUFOQjJRRTJBaHdnQXlBQk5nSVVJQU1nQURZQ0RFRUFJUUlNb1FJTElBTW9BZ1FoQUNBRFFRQTJBZ1FnQXlBQUlBRVFMaUlBUlEySkFpQURRZG9CTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3dNb0FJTFFiOEJJUUlNaFFJTFFRQWhBQUpBSUFNb0FqZ2lBa1VOQUNBQ0tBSThJZ0pGRFFBZ0F5QUNFUUFBSVFBTEFrQWdBQVJBSUFCQkZVWU5BU0FEUVFBMkFod2dBeUFCTmdJVUlBTkJuQTAyQWhBZ0EwRWhOZ0lNUVFBaEFneWdBZ3RCdmdFaEFneUZBZ3NnQTBIWEFUWUNIQ0FESUFFMkFoUWdBMEhXR1RZQ0VDQURRUlUyQWd4QkFDRUNESjRDQ3lBQklBUkdCRUJCMXdFaEFneWVBZ3NDUUNBQkxRQUFRU0JHQkVBZ0EwRUFPd0UwSUFGQkFXb2hBUXdCQ3lBRFFRQTJBaHdnQXlBQk5nSVVJQU5CNnhBMkFoQWdBMEVKTmdJTVFRQWhBZ3llQWd0QnZRRWhBZ3lEQWdzZ0FTQUVSZ1JBUWRZQklRSU1uUUlMQWtBZ0FTMEFBRUV3YTBIL0FYRWlBa0VLU1FSQUlBRkJBV29oQVFKQUlBTXZBVFFpQUVHWk0wc05BQ0FESUFCQkNtd2lBRHNCTkNBQVFmNy9BM0VnQWtILy93TnpTdzBBSUFNZ0FDQUNhanNCTkF3Q0MwRUFJUUlnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRWUFkTmdJUUlBTkJEVFlDREF5ZUFnc2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFZQWROZ0lRSUFOQkRUWUNERUVBSVFJTW5RSUxRYndCSVFJTWdnSUxJQUVnQkVZRVFFSFZBU0VDREp3Q0N3SkFJQUV0QUFCQk1HdEIvd0Z4SWdKQkNra0VRQ0FCUVFGcUlRRUNRQ0FETHdFMElnQkJtVE5MRFFBZ0F5QUFRUXBzSWdBN0FUUWdBRUgrL3dOeElBSkIvLzhEYzBzTkFDQURJQUFnQW1vN0FUUU1BZ3RCQUNFQ0lBTkJBRFlDSENBRElBRTJBaFFnQTBHQUhUWUNFQ0FEUVEwMkFnd01uUUlMSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdBSFRZQ0VDQURRUTAyQWd4QkFDRUNESndDQzBHN0FTRUNESUVDQ3lBQklBUkdCRUJCMUFFaEFneWJBZ3NDUUNBQkxRQUFRVEJyUWY4QmNTSUNRUXBKQkVBZ0FVRUJhaUVCQWtBZ0F5OEJOQ0lBUVprelN3MEFJQU1nQUVFS2JDSUFPd0UwSUFCQi92OERjU0FDUWYvL0EzTkxEUUFnQXlBQUlBSnFPd0UwREFJTFFRQWhBaUFEUVFBMkFod2dBeUFCTmdJVUlBTkJnQjAyQWhBZ0EwRU5OZ0lNREp3Q0N5QURRUUEyQWh3Z0F5QUJOZ0lVSUFOQmdCMDJBaEFnQTBFTk5nSU1RUUFoQWd5YkFndEJ1Z0VoQWd5QUFnc2dBU0FFUmdSQVFkTUJJUUlNbWdJTEFrQUNRQUpBQWtBZ0FTMEFBRUVLYXc0WEFnTURBQU1EQXdNREF3TURBd01EQXdNREF3TURBd0VEQ3lBQlFRRnFEQVVMSUFGQkFXb2hBVUc1QVNFQ0RJRUNDeUFCUVFGcUlRRWdBMEV2YWkwQUFFRUJjUTBJSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdGQ3pZQ0VDQURRUTAyQWd4QkFDRUNESm9DQ3lBRFFRQTJBaHdnQXlBQk5nSVVJQU5CaFFzMkFoQWdBMEVOTmdJTVFRQWhBZ3laQWdzZ0FTQUVSd1JBSUFOQkRqWUNDQ0FESUFFMkFnUkJBU0VDRFA4QkMwSFNBU0VDREpnQ0N3SkFBa0FEUUFKQUlBRXRBQUJCQ21zT0JBSUFBQU1BQ3lBRUlBRkJBV29pQVVjTkFBdEIwUUVoQWd5WkFnc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkFzSWdCRkJFQWdBVUVCYWlFQkRBUUxJQU5CMEFFMkFod2dBeUFBTmdJTUlBTWdBVUVCYWpZQ0ZFRUFJUUlNbUFJTElBTW9BZ1FoQUNBRFFRQTJBZ1FnQXlBQUlBRVFMQ0lBRFFFZ0FVRUJhZ3NoQVVHM0FTRUNEUHdCQ3lBRFFjOEJOZ0ljSUFNZ0FEWUNEQ0FESUFGQkFXbzJBaFJCQUNFQ0RKVUNDMEc0QVNFQ0RQb0JDeUFEUVM5cUxRQUFRUUZ4RFFFZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWM4Yk5nSVFJQU5CR1RZQ0RFRUFJUUlNa3dJTElBRWdCRVlFUUVIUEFTRUNESk1DQ3dKQUFrQUNRQ0FCTFFBQVFRcHJEZ1FCQWdJQUFnc2dBVUVCYWlFQkRBSUxJQUZCQVdvaEFRd0JDeUFETFFBdVFjQUFjVVVOQVF0QkFDRUFBa0FnQXlnQ09DSUNSUTBBSUFJb0FqUWlBa1VOQUNBRElBSVJBQUFoQUFzZ0FFVU5sZ0VnQUVFVlJnUkFJQU5CMlFBMkFod2dBeUFCTmdJVUlBTkJ2UmsyQWhBZ0EwRVZOZ0lNUVFBaEFneVNBZ3NnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRZmdNTmdJUUlBTkJHellDREVFQUlRSU1rUUlMSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEhISnpZQ0VDQURRUUkyQWd4QkFDRUNESkFDQ3lBQklBUkhCRUFnQTBFTU5nSUlJQU1nQVRZQ0JFRzFBU0VDRFBZQkMwSE9BU0VDREk4Q0N5QUJJQVJHQkVCQnpRRWhBZ3lQQWdzQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFFdEFBQkJ3UUJyRGhVQUFRSURXZ1FGQmxwYVdnY0lDUW9MREEwT0R4QmFDeUFCUVFGcUlRRkI4UUFoQWd5RUFnc2dBVUVCYWlFQlFmSUFJUUlNZ3dJTElBRkJBV29oQVVIM0FDRUNESUlDQ3lBQlFRRnFJUUZCK3dBaEFneUJBZ3NnQVVFQmFpRUJRZndBSVFJTWdBSUxJQUZCQVdvaEFVSC9BQ0VDRFA4QkN5QUJRUUZxSVFGQmdBRWhBZ3orQVFzZ0FVRUJhaUVCUVlNQklRSU0vUUVMSUFGQkFXb2hBVUdNQVNFQ0RQd0JDeUFCUVFGcUlRRkJqUUVoQWd6N0FRc2dBVUVCYWlFQlFZNEJJUUlNK2dFTElBRkJBV29oQVVHYkFTRUNEUGtCQ3lBQlFRRnFJUUZCbkFFaEFnejRBUXNnQVVFQmFpRUJRYUlCSVFJTTl3RUxJQUZCQVdvaEFVR3FBU0VDRFBZQkN5QUJRUUZxSVFGQnJRRWhBZ3oxQVFzZ0FVRUJhaUVCUWJRQklRSU05QUVMSUFFZ0JFWUVRRUhNQVNFQ0RJNENDeUFCTFFBQVFjNEFSdzFJSUFGQkFXb2hBVUd6QVNFQ0RQTUJDeUFCSUFSR0JFQkJ5d0VoQWd5TkFnc0NRQUpBQWtBZ0FTMEFBRUhDQUdzT0VnQktTa3BLU2twS1Nrb0JTa3BLU2twS0Frb0xJQUZCQVdvaEFVR3VBU0VDRFBRQkN5QUJRUUZxSVFGQnNRRWhBZ3p6QVFzZ0FVRUJhaUVCUWJJQklRSU04Z0VMUWNvQklRSWdBU0FFUmcyTEFpQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUWRxSVFZQ1FBTkFJQUV0QUFBZ0FFSG8wd0JxTFFBQVJ3MUZJQUJCQjBZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBeU1BZ3NnQTBFQU5nSUFJQVpCQVdvaEFVRWJERVVMSUFFZ0JFWUVRRUhKQVNFQ0RJc0NDd0pBQWtBZ0FTMEFBRUhKQUdzT0J3QkhSMGRIUndGSEN5QUJRUUZxSVFGQnJ3RWhBZ3p4QVFzZ0FVRUJhaUVCUWJBQklRSU04QUVMUWNnQklRSWdBU0FFUmcySkFpQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUZxSVFZQ1FBTkFJQUV0QUFBZ0FFSG0wd0JxTFFBQVJ3MURJQUJCQVVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBeUtBZ3NnQTBFQU5nSUFJQVpCQVdvaEFVRVBERU1MUWNjQklRSWdBU0FFUmcySUFpQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUZxSVFZQ1FBTkFJQUV0QUFBZ0FFSGswd0JxTFFBQVJ3MUNJQUJCQVVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBeUpBZ3NnQTBFQU5nSUFJQVpCQVdvaEFVRWdERUlMUWNZQklRSWdBU0FFUmcySEFpQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFSGgwd0JxTFFBQVJ3MUJJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBeUlBZ3NnQTBFQU5nSUFJQVpCQVdvaEFVRVNERUVMSUFFZ0JFWUVRRUhGQVNFQ0RJY0NDd0pBQWtBZ0FTMEFBRUhGQUdzT0RnQkRRME5EUTBORFEwTkRRME1CUXdzZ0FVRUJhaUVCUWFzQklRSU03UUVMSUFGQkFXb2hBVUdzQVNFQ0RPd0JDMEhFQVNFQ0lBRWdCRVlOaFFJZ0F5Z0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUNhaUVHQWtBRFFDQUJMUUFBSUFCQjN0TUFhaTBBQUVjTlB5QUFRUUpHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QURJQVUyQWdBTWhnSUxJQU5CQURZQ0FDQUdRUUZxSVFGQkJ3dy9DMEhEQVNFQ0lBRWdCRVlOaEFJZ0F5Z0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUZhaUVHQWtBRFFDQUJMUUFBSUFCQjJOTUFhaTBBQUVjTlBpQUFRUVZHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QURJQVUyQWdBTWhRSUxJQU5CQURZQ0FDQUdRUUZxSVFGQktBdytDeUFCSUFSR0JFQkJ3Z0VoQWd5RUFnc0NRQUpBQWtBZ0FTMEFBRUhGQUdzT0VRQkJRVUZCUVVGQlFVRUJRVUZCUVVFQ1FRc2dBVUVCYWlFQlFhY0JJUUlNNndFTElBRkJBV29oQVVHb0FTRUNET29CQ3lBQlFRRnFJUUZCcVFFaEFnenBBUXRCd1FFaEFpQUJJQVJHRFlJQ0lBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCbW9oQmdKQUEwQWdBUzBBQUNBQVFkSFRBR290QUFCSERUd2dBRUVHUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURJTUNDeUFEUVFBMkFnQWdCa0VCYWlFQlFSb01QQXRCd0FFaEFpQUJJQVJHRFlFQ0lBTW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBMm9oQmdKQUEwQWdBUzBBQUNBQVFjM1RBR290QUFCSERUc2dBRUVEUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBeUFGTmdJQURJSUNDeUFEUVFBMkFnQWdCa0VCYWlFQlFTRU1Pd3NnQVNBRVJnUkFRYjhCSVFJTWdRSUxBa0FDUUNBQkxRQUFRY0VBYXc0VUFEMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBRRTlDeUFCUVFGcUlRRkJvd0VoQWd6bkFRc2dBVUVCYWlFQlFhWUJJUUlNNWdFTElBRWdCRVlFUUVHK0FTRUNESUFDQ3dKQUFrQWdBUzBBQUVIVkFHc09Dd0E4UER3OFBEdzhQRHdCUEFzZ0FVRUJhaUVCUWFRQklRSU01Z0VMSUFGQkFXb2hBVUdsQVNFQ0RPVUJDMEc5QVNFQ0lBRWdCRVlOL2dFZ0F5Z0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUlhaUVHQWtBRFFDQUJMUUFBSUFCQnhOTUFhaTBBQUVjTk9DQUFRUWhHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QURJQVUyQWdBTS93RUxJQU5CQURZQ0FDQUdRUUZxSVFGQktndzRDeUFCSUFSR0JFQkJ2QUVoQWd6K0FRc2dBUzBBQUVIUUFFY05PQ0FCUVFGcUlRRkJKUXczQzBHN0FTRUNJQUVnQkVZTi9BRWdBeWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVDYWlFR0FrQURRQ0FCTFFBQUlBQkJ3ZE1BYWkwQUFFY05OaUFBUVFKR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFESUFVMkFnQU0vUUVMSUFOQkFEWUNBQ0FHUVFGcUlRRkJEZ3cyQ3lBQklBUkdCRUJCdWdFaEFnejhBUXNnQVMwQUFFSEZBRWNOTmlBQlFRRnFJUUZCb1FFaEFnemhBUXNnQVNBRVJnUkFRYmtCSVFJTSt3RUxBa0FDUUFKQUFrQWdBUzBBQUVIQ0FHc09Ed0FCQWprNU9UazVPVGs1T1RrNUF6a0xJQUZCQVdvaEFVR2RBU0VDRE9NQkN5QUJRUUZxSVFGQm5nRWhBZ3ppQVFzZ0FVRUJhaUVCUVo4QklRSU00UUVMSUFGQkFXb2hBVUdnQVNFQ0RPQUJDMEc0QVNFQ0lBRWdCRVlOK1FFZ0F5Z0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUNhaUVHQWtBRFFDQUJMUUFBSUFCQnZ0TUFhaTBBQUVjTk15QUFRUUpHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QURJQVUyQWdBTStnRUxJQU5CQURZQ0FDQUdRUUZxSVFGQkZBd3pDMEczQVNFQ0lBRWdCRVlOK0FFZ0F5Z0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUVhaUVHQWtBRFFDQUJMUUFBSUFCQnVkTUFhaTBBQUVjTk1pQUFRUVJHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QURJQVUyQWdBTStRRUxJQU5CQURZQ0FDQUdRUUZxSVFGQkt3d3lDMEcyQVNFQ0lBRWdCRVlOOXdFZ0F5Z0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUNhaUVHQWtBRFFDQUJMUUFBSUFCQnR0TUFhaTBBQUVjTk1TQUFRUUpHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QURJQVUyQWdBTStBRUxJQU5CQURZQ0FDQUdRUUZxSVFGQkxBd3hDMEcxQVNFQ0lBRWdCRVlOOWdFZ0F5Z0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUNhaUVHQWtBRFFDQUJMUUFBSUFCQjRkTUFhaTBBQUVjTk1DQUFRUUpHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QURJQVUyQWdBTTl3RUxJQU5CQURZQ0FDQUdRUUZxSVFGQkVRd3dDMEcwQVNFQ0lBRWdCRVlOOVFFZ0F5Z0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRURhaUVHQWtBRFFDQUJMUUFBSUFCQnN0TUFhaTBBQUVjTkx5QUFRUU5HRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QURJQVUyQWdBTTlnRUxJQU5CQURZQ0FDQUdRUUZxSVFGQkxnd3ZDeUFCSUFSR0JFQkJzd0VoQWd6MUFRc0NRQUpBQWtBQ1FBSkFJQUV0QUFCQndRQnJEaFVBTkRRME5EUTBORFEwTkFFME5BSTBOQU0wTkFRMEN5QUJRUUZxSVFGQmtRRWhBZ3plQVFzZ0FVRUJhaUVCUVpJQklRSU0zUUVMSUFGQkFXb2hBVUdUQVNFQ0ROd0JDeUFCUVFGcUlRRkJtQUVoQWd6YkFRc2dBVUVCYWlFQlFab0JJUUlNMmdFTElBRWdCRVlFUUVHeUFTRUNEUFFCQ3dKQUFrQWdBUzBBQUVIU0FHc09Bd0F3QVRBTElBRkJBV29oQVVHWkFTRUNETm9CQ3lBQlFRRnFJUUZCQkF3dEMwR3hBU0VDSUFFZ0JFWU44Z0VnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCc05NQWFpMEFBRWNOTENBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNOHdFTElBTkJBRFlDQUNBR1FRRnFJUUZCSFF3c0N5QUJJQVJHQkVCQnNBRWhBZ3p5QVFzQ1FBSkFJQUV0QUFCQnlRQnJEZ2NCTGk0dUxpNEFMZ3NnQVVFQmFpRUJRWmNCSVFJTTJBRUxJQUZCQVdvaEFVRWlEQ3NMSUFFZ0JFWUVRRUd2QVNFQ0RQRUJDeUFCTFFBQVFkQUFSdzBySUFGQkFXb2hBVUdXQVNFQ0ROWUJDeUFCSUFSR0JFQkJyZ0VoQWd6d0FRc0NRQUpBSUFFdEFBQkJ4Z0JyRGdzQUxDd3NMQ3dzTEN3c0FTd0xJQUZCQVdvaEFVR1VBU0VDRE5ZQkN5QUJRUUZxSVFGQmxRRWhBZ3pWQVF0QnJRRWhBaUFCSUFSR0RlNEJJQU1vQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQTJvaEJnSkFBMEFnQVMwQUFDQUFRYXpUQUdvdEFBQkhEU2dnQUVFRFJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQXlBRk5nSUFETzhCQ3lBRFFRQTJBZ0FnQmtFQmFpRUJRUTBNS0F0QnJBRWhBaUFCSUFSR0RlMEJJQU1vQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQW1vaEJnSkFBMEFnQVMwQUFDQUFRZUhUQUdvdEFBQkhEU2NnQUVFQ1JnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQXlBRk5nSUFETzRCQ3lBRFFRQTJBZ0FnQmtFQmFpRUJRUXdNSnd0QnF3RWhBaUFCSUFSR0Rld0JJQU1vQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQVdvaEJnSkFBMEFnQVMwQUFDQUFRYXJUQUdvdEFBQkhEU1lnQUVFQlJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQXlBRk5nSUFETzBCQ3lBRFFRQTJBZ0FnQmtFQmFpRUJRUU1NSmd0QnFnRWhBaUFCSUFSR0Rlc0JJQU1vQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQVdvaEJnSkFBMEFnQVMwQUFDQUFRYWpUQUdvdEFBQkhEU1VnQUVFQlJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQXlBRk5nSUFET3dCQ3lBRFFRQTJBZ0FnQmtFQmFpRUJRU1lNSlFzZ0FTQUVSZ1JBUWFrQklRSU02d0VMQWtBQ1FDQUJMUUFBUWRRQWF3NENBQUVuQ3lBQlFRRnFJUUZCandFaEFnelJBUXNnQVVFQmFpRUJRWkFCSVFJTTBBRUxRYWdCSVFJZ0FTQUVSZzNwQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVHbTB3QnFMUUFBUncwaklBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6cUFRc2dBMEVBTmdJQUlBWkJBV29oQVVFbkRDTUxRYWNCSVFJZ0FTQUVSZzNvQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVHazB3QnFMUUFBUncwaUlBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6cEFRc2dBMEVBTmdJQUlBWkJBV29oQVVFY0RDSUxRYVlCSVFJZ0FTQUVSZzNuQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRVnFJUVlDUUFOQUlBRXRBQUFnQUVHZTB3QnFMUUFBUncwaElBQkJCVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6b0FRc2dBMEVBTmdJQUlBWkJBV29oQVVFR0RDRUxRYVVCSVFJZ0FTQUVSZzNtQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRUnFJUVlDUUFOQUlBRXRBQUFnQUVHWjB3QnFMUUFBUncwZ0lBQkJCRVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6bkFRc2dBMEVBTmdJQUlBWkJBV29oQVVFWkRDQUxJQUVnQkVZRVFFR2tBU0VDRE9ZQkN3SkFBa0FDUUFKQUlBRXRBQUJCTFdzT0l3QWtKQ1FrSkNRa0pDUWtKQ1FrSkNRa0pDUWtKQ1FrSkFFa0pDUWtKQUlrSkNRREpBc2dBVUVCYWlFQlFZUUJJUUlNemdFTElBRkJBV29oQVVHRkFTRUNETTBCQ3lBQlFRRnFJUUZCaWdFaEFnek1BUXNnQVVFQmFpRUJRWXNCSVFJTXl3RUxRYU1CSVFJZ0FTQUVSZzNrQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVHWDB3QnFMUUFBUncwZUlBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6bEFRc2dBMEVBTmdJQUlBWkJBV29oQVVFTERCNExJQUVnQkVZRVFFR2lBU0VDRE9RQkN3SkFBa0FnQVMwQUFFSEJBR3NPQXdBZ0FTQUxJQUZCQVdvaEFVR0dBU0VDRE1vQkN5QUJRUUZxSVFGQmlRRWhBZ3pKQVFzZ0FTQUVSZ1JBUWFFQklRSU00d0VMQWtBQ1FDQUJMUUFBUWNFQWF3NFBBQjhmSHg4Zkh4OGZIeDhmSHg4Qkh3c2dBVUVCYWlFQlFZY0JJUUlNeVFFTElBRkJBV29oQVVHSUFTRUNETWdCQ3lBQklBUkdCRUJCb0FFaEFnemlBUXNnQVMwQUFFSE1BRWNOSENBQlFRRnFJUUZCQ2d3YkMwR2ZBU0VDSUFFZ0JFWU40QUVnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRmFpRUdBa0FEUUNBQkxRQUFJQUJCa2RNQWFpMEFBRWNOR2lBQVFRVkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNNFFFTElBTkJBRFlDQUNBR1FRRnFJUUZCSGd3YUMwR2VBU0VDSUFFZ0JFWU4zd0VnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFR2FpRUdBa0FEUUNBQkxRQUFJQUJCaXRNQWFpMEFBRWNOR1NBQVFRWkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNNEFFTElBTkJBRFlDQUNBR1FRRnFJUUZCRlF3WkMwR2RBU0VDSUFFZ0JFWU4zZ0VnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCaDlNQWFpMEFBRWNOR0NBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNM3dFTElBTkJBRFlDQUNBR1FRRnFJUUZCRnd3WUMwR2NBU0VDSUFFZ0JFWU4zUUVnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRmFpRUdBa0FEUUNBQkxRQUFJQUJCZ2RNQWFpMEFBRWNORnlBQVFRVkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNM2dFTElBTkJBRFlDQUNBR1FRRnFJUUZCR0F3WEN5QUJJQVJHQkVCQm13RWhBZ3pkQVFzQ1FBSkFJQUV0QUFCQnlRQnJEZ2NBR1JrWkdSa0JHUXNnQVVFQmFpRUJRWUVCSVFJTXd3RUxJQUZCQVdvaEFVR0NBU0VDRE1JQkMwR2FBU0VDSUFFZ0JFWU4yd0VnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCNXRNQWFpMEFBRWNORlNBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNM0FFTElBTkJBRFlDQUNBR1FRRnFJUUZCQ1F3VkMwR1pBU0VDSUFFZ0JFWU4yZ0VnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCNU5NQWFpMEFBRWNORkNBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNMndFTElBTkJBRFlDQUNBR1FRRnFJUUZCSHd3VUMwR1lBU0VDSUFFZ0JFWU4yUUVnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCL3RJQWFpMEFBRWNORXlBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNMmdFTElBTkJBRFlDQUNBR1FRRnFJUUZCQWd3VEMwR1hBU0VDSUFFZ0JFWU4yQUVnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBMEFnQVMwQUFDQUFRZnpTQUdvdEFBQkhEUkVnQUVFQlJnMENJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQXlBRk5nSUFETmdCQ3lBQklBUkdCRUJCbGdFaEFnellBUXRCQVNBQkxRQUFRZDhBUncwUkdpQUJRUUZxSVFGQi9RQWhBZ3k5QVFzZ0EwRUFOZ0lBSUFaQkFXb2hBVUgrQUNFQ0RMd0JDMEdWQVNFQ0lBRWdCRVlOMVFFZ0F5Z0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUlhaUVHQWtBRFFDQUJMUUFBSUFCQnhOTUFhaTBBQUVjTkR5QUFRUWhHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QURJQVUyQWdBTTFnRUxJQU5CQURZQ0FDQUdRUUZxSVFGQktRd1BDMEdVQVNFQ0lBRWdCRVlOMUFFZ0F5Z0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRURhaUVHQWtBRFFDQUJMUUFBSUFCQitOSUFhaTBBQUVjTkRpQUFRUU5HRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QURJQVUyQWdBTTFRRUxJQU5CQURZQ0FDQUdRUUZxSVFGQkxRd09DeUFCSUFSR0JFQkJrd0VoQWd6VUFRc2dBUzBBQUVIRkFFY05EaUFCUVFGcUlRRkIrZ0FoQWd5NUFRc2dBU0FFUmdSQVFaSUJJUUlNMHdFTEFrQUNRQ0FCTFFBQVFjd0FhdzRJQUE4UER3OFBEd0VQQ3lBQlFRRnFJUUZCK0FBaEFneTVBUXNnQVVFQmFpRUJRZmtBSVFJTXVBRUxRWkVCSVFJZ0FTQUVSZzNSQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRUnFJUVlDUUFOQUlBRXRBQUFnQUVIejBnQnFMUUFBUncwTElBQkJCRVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6U0FRc2dBMEVBTmdJQUlBWkJBV29oQVVFakRBc0xRWkFCSVFJZ0FTQUVSZzNRQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVIdzBnQnFMUUFBUncwS0lBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6UkFRc2dBMEVBTmdJQUlBWkJBV29oQVVFQURBb0xJQUVnQkVZRVFFR1BBU0VDRE5BQkN3SkFBa0FnQVMwQUFFSElBR3NPQ0FBTURBd01EQXdCREFzZ0FVRUJhaUVCUWZNQUlRSU10Z0VMSUFGQkFXb2hBVUgyQUNFQ0RMVUJDeUFCSUFSR0JFQkJqZ0VoQWd6UEFRc0NRQUpBSUFFdEFBQkJ6Z0JyRGdNQUN3RUxDeUFCUVFGcUlRRkI5QUFoQWd5MUFRc2dBVUVCYWlFQlFmVUFJUUlNdEFFTElBRWdCRVlFUUVHTkFTRUNETTRCQ3lBQkxRQUFRZGtBUncwSUlBRkJBV29oQVVFSURBY0xRWXdCSVFJZ0FTQUVSZzNNQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRTnFJUVlDUUFOQUlBRXRBQUFnQUVIczBnQnFMUUFBUncwR0lBQkJBMFlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6TkFRc2dBMEVBTmdJQUlBWkJBV29oQVVFRkRBWUxRWXNCSVFJZ0FTQUVSZzNMQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRVnFJUVlDUUFOQUlBRXRBQUFnQUVIbTBnQnFMUUFBUncwRklBQkJCVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6TUFRc2dBMEVBTmdJQUlBWkJBV29oQVVFV0RBVUxRWW9CSVFJZ0FTQUVSZzNLQVNBREtBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVIaDB3QnFMUUFBUncwRUlBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBTWdCVFlDQUF6TEFRc2dBMEVBTmdJQUlBWkJBV29oQVVFUURBUUxJQUVnQkVZRVFFR0pBU0VDRE1vQkN3SkFBa0FnQVMwQUFFSERBR3NPREFBR0JnWUdCZ1lHQmdZR0FRWUxJQUZCQVdvaEFVSHZBQ0VDRExBQkN5QUJRUUZxSVFGQjhBQWhBZ3l2QVF0QmlBRWhBaUFCSUFSR0RjZ0JJQU1vQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQldvaEJnSkFBMEFnQVMwQUFDQUFRZURTQUdvdEFBQkhEUUlnQUVFRlJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQXlBRk5nSUFETWtCQ3lBRFFRQTJBZ0FnQmtFQmFpRUJRU1FNQWdzZ0EwRUFOZ0lBREFJTElBRWdCRVlFUUVHSEFTRUNETWNCQ3lBQkxRQUFRY3dBUncwQklBRkJBV29oQVVFVEN6b0FLU0FES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRUMwaUFBMENEQUVMUVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQjZSNDJBaEFnQTBFR05nSU1ETVFCQzBIdUFDRUNES2tCQ3lBRFFZWUJOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFneEJBQ0VDRE1JQkMwRUFJUUFDUUNBREtBSTRJZ0pGRFFBZ0FpZ0NPQ0lDUlEwQUlBTWdBaEVBQUNFQUN5QUFSUTBBSUFCQkZVWU5BU0FEUVFBMkFod2dBeUFCTmdJVUlBTkIxQTQyQWhBZ0EwRWdOZ0lNUVFBaEFnekJBUXRCN1FBaEFneW1BUXNnQTBHRkFUWUNIQ0FESUFFMkFoUWdBMEhYR2pZQ0VDQURRUlUyQWd4QkFDRUNETDhCQ3lBQklBUkdCRUJCaFFFaEFneS9BUXNDUUNBQkxRQUFRU0JHQkVBZ0FVRUJhaUVCREFFTElBTkJBRFlDSENBRElBRTJBaFFnQTBHR0hqWUNFQ0FEUVFZMkFneEJBQ0VDREw4QkMwRUNJUUlNcEFFTEEwQWdBUzBBQUVFZ1J3MENJQVFnQVVFQmFpSUJSdzBBQzBHRUFTRUNETDBCQ3lBQklBUkdCRUJCZ3dFaEFneTlBUXNDUUNBQkxRQUFRUWxyRGdSQUFBQkFBQXRCNndBaEFneWlBUXNnQXkwQUtVRUZSZ1JBUWV3QUlRSU1vZ0VMUWVvQUlRSU1vUUVMSUFFZ0JFWUVRRUdDQVNFQ0RMc0JDeUFEUVE4MkFnZ2dBeUFCTmdJRURBb0xJQUVnQkVZRVFFR0JBU0VDRExvQkN3SkFJQUV0QUFCQkNXc09CRDBBQUQwQUMwSHBBQ0VDREo4QkN5QUJJQVJIQkVBZ0EwRVBOZ0lJSUFNZ0FUWUNCRUhuQUNFQ0RKOEJDMEdBQVNFQ0RMZ0JDd0pBSUFFZ0JFY0VRQU5BSUFFdEFBQkI0TTRBYWkwQUFDSUFRUU5IQkVBQ1FDQUFRUUZyRGdJL0FBUUxRZVlBSVFJTW9RRUxJQVFnQVVFQmFpSUJSdzBBQzBIK0FDRUNETGtCQzBIK0FDRUNETGdCQ3lBRFFRQTJBaHdnQXlBQk5nSVVJQU5CeGg4MkFoQWdBMEVITmdJTVFRQWhBZ3kzQVFzZ0FTQUVSZ1JBUWY4QUlRSU10d0VMQWtBQ1FBSkFJQUV0QUFCQjROQUFhaTBBQUVFQmF3NERQQUlBQVF0QjZBQWhBZ3llQVFzZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUVlZU05nSVFJQU5CQnpZQ0RFRUFJUUlNdHdFTFFlQUFJUUlNbkFFTElBRWdCRWNFUUNBQlFRRnFJUUZCNVFBaEFneWNBUXRCL1FBaEFneTFBUXNnQkNBQklnQkdCRUJCL0FBaEFneTFBUXNnQUMwQUFDSUJRUzlHQkVBZ0FFRUJhaUVCUWVRQUlRSU1td0VMSUFGQkNXc2lBa0VYU3cwQklBQWhBVUVCSUFKMFFadUFnQVJ4RFRjTUFRc2dCQ0FCSWdCR0JFQkIrd0FoQWd5MEFRc2dBQzBBQUVFdlJ3MEFJQUJCQVdvaEFRd0RDMEVBSVFJZ0EwRUFOZ0ljSUFNZ0FEWUNGQ0FEUWNZZk5nSVFJQU5CQnpZQ0RBeXlBUXNDUUFKQUFrQUNRQUpBQTBBZ0FTMEFBRUhnekFCcUxRQUFJZ0JCQlVjRVFBSkFBa0FnQUVFQmF3NElQUVVHQndnQUJBRUlDMEhoQUNFQ0RKOEJDeUFCUVFGcUlRRkI0d0FoQWd5ZUFRc2dCQ0FCUVFGcUlnRkhEUUFMUWZvQUlRSU10Z0VMSUFGQkFXb01GQXNnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBcklnQkZEUjRnQTBIYkFEWUNIQ0FESUFFMkFoUWdBeUFBTmdJTVFRQWhBZ3kwQVFzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXJJZ0JGRFI0Z0EwSGRBRFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5ekFRc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkFySWdCRkRSNGdBMEh3QURZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNUVFBaEFneXlBUXNnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRY3NQTmdJUUlBTkJCellDREVFQUlRSU1zUUVMSUFFZ0JFWUVRRUg1QUNFQ0RMRUJDd0pBSUFFdEFBQkI0TXdBYWkwQUFFRUJhdzRJTkFRRkJnQUlBZ01IQ3lBQlFRRnFJUUVMUVFNaEFneVZBUXNnQVVFQmFnd05DMEVBSVFJZ0EwRUFOZ0ljSUFOQm94STJBaEFnQTBFSE5nSU1JQU1nQVVFQmFqWUNGQXl0QVFzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXJJZ0JGRFJZZ0EwSGJBRFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5c0FRc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkFySWdCRkRSWWdBMEhkQURZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNUVFBaEFneXJBUXNnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBcklnQkZEUllnQTBId0FEWUNIQ0FESUFFMkFoUWdBeUFBTmdJTVFRQWhBZ3lxQVFzZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWNzUE5nSVFJQU5CQnpZQ0RFRUFJUUlNcVFFTFFlSUFJUUlNamdFTElBRWdCRVlFUUVINEFDRUNES2dCQ3lBQlFRRnFEQUlMSUFFZ0JFWUVRRUgzQUNFQ0RLY0JDeUFCUVFGcURBRUxJQUVnQkVZTkFTQUJRUUZxQ3lFQlFRUWhBZ3lLQVF0QjlnQWhBZ3lqQVFzRFFDQUJMUUFBUWVES0FHb3RBQUFpQUVFQ1J3UkFJQUJCQVVjRVFFSGZBQ0VDRElzQkN3d25DeUFFSUFGQkFXb2lBVWNOQUF0QjlRQWhBZ3lpQVFzZ0FTQUVSZ1JBUWZRQUlRSU1vZ0VMQWtBZ0FTMEFBRUVKYXc0M0pRTUdKUVFHQmdZR0JnWUdCZ1lHQmdZR0JnWUdCZ1lGQmdZQ0JnWUdCZ1lHQmdZR0JnWUdCZ1lHQmdZR0JnWUdCZ1lHQmdZR0FBWUxJQUZCQVdvTElRRkJCU0VDRElZQkN5QUJRUUZxREFZTElBTW9BZ1FoQUNBRFFRQTJBZ1FnQXlBQUlBRVFLeUlBUlEwSUlBTkIyd0EyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTW5nRUxJQU1vQWdRaEFDQURRUUEyQWdRZ0F5QUFJQUVRS3lJQVJRMElJQU5CM1FBMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1uUUVMSUFNb0FnUWhBQ0FEUVFBMkFnUWdBeUFBSUFFUUt5SUFSUTBJSUFOQjhBQTJBaHdnQXlBQk5nSVVJQU1nQURZQ0RFRUFJUUlNbkFFTElBTkJBRFlDSENBRElBRTJBaFFnQTBHOEV6WUNFQ0FEUVFjMkFneEJBQ0VDREpzQkN3SkFBa0FDUUFKQUEwQWdBUzBBQUVIZ3lBQnFMUUFBSWdCQkJVY0VRQUpBSUFCQkFXc09CaVFEQkFVR0FBWUxRZDRBSVFJTWhnRUxJQVFnQVVFQmFpSUJSdzBBQzBIekFDRUNESjRCQ3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQkVDc2lBRVVOQnlBRFFkc0FOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFneEJBQ0VDREowQkN5QURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFQ3NpQUVVTkJ5QURRZDBBTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3hCQUNFQ0RKd0JDeUFES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRUNzaUFFVU5CeUFEUWZBQU5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd4QkFDRUNESnNCQ3lBRFFRQTJBaHdnQXlBQk5nSVVJQU5CM0FnMkFoQWdBMEVITmdJTVFRQWhBZ3lhQVFzZ0FTQUVSZzBCSUFGQkFXb0xJUUZCQmlFQ0RINExRZklBSVFJTWx3RUxBa0FDUUFKQUFrQURRQ0FCTFFBQVFlREdBR290QUFBaUFFRUZSd1JBSUFCQkFXc09CQjhDQXdRRkN5QUVJQUZCQVdvaUFVY05BQXRCOFFBaEFneWFBUXNnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBcklnQkZEUU1nQTBIYkFEWUNIQ0FESUFFMkFoUWdBeUFBTmdJTVFRQWhBZ3laQVFzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXJJZ0JGRFFNZ0EwSGRBRFlDSENBRElBRTJBaFFnQXlBQU5nSU1RUUFoQWd5WUFRc2dBeWdDQkNFQUlBTkJBRFlDQkNBRElBQWdBUkFySWdCRkRRTWdBMEh3QURZQ0hDQURJQUUyQWhRZ0F5QUFOZ0lNUVFBaEFneVhBUXNnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRYlFLTmdJUUlBTkJCellDREVFQUlRSU1sZ0VMUWM0QUlRSU1ld3RCMEFBaEFneDZDMEhkQUNFQ0RIa0xJQUVnQkVZRVFFSHdBQ0VDREpNQkN3SkFJQUV0QUFCQkNXc09CQllBQUJZQUN5QUJRUUZxSVFGQjNBQWhBZ3g0Q3lBQklBUkdCRUJCN3dBaEFneVNBUXNDUUNBQkxRQUFRUWxyRGdRVkFBQVZBQXRCQUNFQUFrQWdBeWdDT0NJQ1JRMEFJQUlvQWpBaUFrVU5BQ0FESUFJUkFBQWhBQXNnQUVVRVFFSFRBU0VDREhnTElBQkJGVWNFUUNBRFFRQTJBaHdnQXlBQk5nSVVJQU5Cd1EwMkFoQWdBMEVhTmdJTVFRQWhBZ3lTQVFzZ0EwSHVBRFlDSENBRElBRTJBaFFnQTBId0dUWUNFQ0FEUVJVMkFneEJBQ0VDREpFQkMwSHRBQ0VDSUFFZ0JFWU5rQUVnQXlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRGFpRUdBa0FEUUNBQkxRQUFJQUJCMThZQWFpMEFBRWNOQkNBQVFRTkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBRElBVTJBZ0FNa1FFTElBTkJBRFlDQUNBR1FRRnFJUUVnQXkwQUtTSUFRU05yUVF0SkRRUUNRQ0FBUVFaTERRQkJBU0FBZEVIS0FIRkZEUUFNQlF0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSGxDVFlDRUNBRFFRZzJBZ3dNa0FFTFFld0FJUUlnQVNBRVJnMlBBU0FES0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhVeGdCcUxRQUFSdzBESUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFNZ0JUWUNBQXlRQVFzZ0EwRUFOZ0lBSUFaQkFXb2hBU0FETFFBcFFTRkdEUU1nQTBFQU5nSWNJQU1nQVRZQ0ZDQURRWWtLTmdJUUlBTkJDRFlDREVFQUlRSU1qd0VMUWVzQUlRSWdBU0FFUmcyT0FTQURLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUU5xSVFZQ1FBTkFJQUV0QUFBZ0FFSFF4Z0JxTFFBQVJ3MENJQUJCQTBZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQU1nQlRZQ0FBeVBBUXNnQTBFQU5nSUFJQVpCQVdvaEFTQURMUUFwSWdCQkkwa05BaUFBUVM1R0RRSWdBMEVBTmdJY0lBTWdBVFlDRkNBRFFjRUpOZ0lRSUFOQkNEWUNERUVBSVFJTWpnRUxJQU5CQURZQ0FBdEJBQ0VDSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdFTnpZQ0VDQURRUWcyQWd3TWpBRUxRZGdBSVFJTWNRc2dBU0FFUndSQUlBTkJEVFlDQ0NBRElBRTJBZ1JCMXdBaEFneHhDMEhxQUNFQ0RJb0JDeUFCSUFSR0JFQkI2UUFoQWd5S0FRc2dBUzBBQUVFd2F5SUFRZjhCY1VFS1NRUkFJQU1nQURvQUtpQUJRUUZxSVFGQjFnQWhBZ3h3Q3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQkVDNGlBRVVOZENBRFFlZ0FOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFneEJBQ0VDRElrQkN5QUJJQVJHQkVCQjV3QWhBZ3lKQVFzQ1FDQUJMUUFBUVM1R0JFQWdBVUVCYWlFQkRBRUxJQU1vQWdRaEFDQURRUUEyQWdRZ0F5QUFJQUVRTGlJQVJRMTFJQU5CNWdBMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1pUUVMUWRVQUlRSU1iZ3NnQVNBRVJnUkFRZVVBSVFJTWlBRUxRUUFoQUVFQklRVkJBU0VIUVFBaEFnSkFBa0FDUUFKQUFrQUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUlBRXRBQUJCTUdzT0Nnb0pBQUVDQXdRRkJnZ0xDMEVDREFZTFFRTU1CUXRCQkF3RUMwRUZEQU1MUVFZTUFndEJCd3dCQzBFSUN5RUNRUUFoQlVFQUlRY01BZ3RCQ1NFQ1FRRWhBRUVBSVFWQkFDRUhEQUVMUVFBaEJVRUJJUUlMSUFNZ0Fqb0FLeUFCUVFGcUlRRUNRQUpBSUFNdEFDNUJFSEVOQUFKQUFrQUNRQ0FETFFBcURnTUJBQUlFQ3lBSFJRMEREQUlMSUFBTkFRd0NDeUFGUlEwQkN5QURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFQzRpQUVVTkFpQURRZUlBTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3hCQUNFQ0RJb0JDeUFES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRUM0aUFFVU5keUFEUWVNQU5nSWNJQU1nQVRZQ0ZDQURJQUEyQWd4QkFDRUNESWtCQ3lBREtBSUVJUUFnQTBFQU5nSUVJQU1nQUNBQkVDNGlBRVVOZFNBRFFlUUFOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFnd01pQUVMUWRNQUlRSU1iUXNnQXkwQUtVRWlSZzJBQVVIU0FDRUNER3dMUVFBaEFBSkFJQU1vQWpnaUFrVU5BQ0FDS0FJOElnSkZEUUFnQXlBQ0VRQUFJUUFMSUFCRkJFQkIxQUFoQWd4c0N5QUFRUlZIQkVBZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUVp3Tk5nSVFJQU5CSVRZQ0RFRUFJUUlNaGdFTElBTkI0UUEyQWh3Z0F5QUJOZ0lVSUFOQjFoazJBaEFnQTBFVk5nSU1RUUFoQWd5RkFRc2dBU0FFUmdSQVFlQUFJUUlNaFFFTEFrQUNRQUpBQWtBQ1FDQUJMUUFBUVFwckRnUUJCQVFBQkFzZ0FVRUJhaUVCREFFTElBRkJBV29oQVNBRFFTOXFMUUFBUVFGeFJRMEJDMEhSQUNFQ0RHd0xJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR0lFVFlDRUNBRFFRazJBZ3hCQUNFQ0RJVUJDeUFEUVFBMkFod2dBeUFCTmdJVUlBTkJpQkUyQWhBZ0EwRUpOZ0lNUVFBaEFneUVBUXNnQVNBRVJnUkFRZDhBSVFJTWhBRUxJQUV0QUFCQkNrWUVRQ0FCUVFGcUlRRU1DUXNnQXkwQUxrSEFBSEVOQ0NBRFFRQTJBaHdnQXlBQk5nSVVJQU5CaUJFMkFoQWdBMEVDTmdJTVFRQWhBZ3lEQVFzZ0FTQUVSZ1JBUWQwQUlRSU1nd0VMSUFFdEFBQWlBa0VOUmdSQUlBRkJBV29oQVVIUEFDRUNER2tMSUFFaEFDQUNRUWxyRGdRRkFRRUZBUXNnQkNBQklnQkdCRUJCM0FBaEFneUNBUXNnQUMwQUFFRUtSdzBBSUFCQkFXb01BZ3RCQUNFQ0lBTkJBRFlDSENBRElBQTJBaFFnQTBHMUxEWUNFQ0FEUVFjMkFnd01nQUVMSUFFZ0JFWUVRRUhiQUNFQ0RJQUJDd0pBSUFFdEFBQkJDV3NPQkFNQUFBTUFDeUFCUVFGcUN5RUJRYzBBSVFJTVpBc2dBU0FFUmdSQVFkb0FJUUlNZmdzZ0FTMEFBRUVKYXc0RUFBRUJBQUVMUVFBaEFpQURRUUEyQWh3Z0EwSHNFVFlDRUNBRFFRYzJBZ3dnQXlBQlFRRnFOZ0lVREh3TElBTkJnQkk3QVNwQkFDRUFBa0FnQXlnQ09DSUNSUTBBSUFJb0FqQWlBa1VOQUNBRElBSVJBQUFoQUFzZ0FFVU5BQ0FBUVJWSERRRWdBMEhaQURZQ0hDQURJQUUyQWhRZ0EwSHdHVFlDRUNBRFFSVTJBZ3hCQUNFQ0RIc0xRY3dBSVFJTVlBc2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFjRU5OZ0lRSUFOQkdqWUNERUVBSVFJTWVRc2dBU0FFUmdSQVFka0FJUUlNZVFzZ0FTMEFBRUVnUncwNklBRkJBV29oQVNBRExRQXVRUUZ4RFRvZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWEwYk5nSVFJQU5CSGpZQ0RFRUFJUUlNZUFzZ0FTQUVSZ1JBUWRnQUlRSU1lQXNDUUFKQUFrQUNRQUpBSUFFdEFBQWlBRUVLYXc0RUFnTURBQUVMSUFGQkFXb2hBVUVySVFJTVlRc2dBRUU2UncwQklBTkJBRFlDSENBRElBRTJBaFFnQTBHNUVUWUNFQ0FEUVFvMkFneEJBQ0VDREhvTElBRkJBV29oQVNBRFFTOXFMUUFBUVFGeFJRMXRJQU10QURKQmdBRnhSUVJBSUFOQk1tb2hBaUFERURSQkFDRUFBa0FnQXlnQ09DSUdSUTBBSUFZb0FpUWlCa1VOQUNBRElBWVJBQUFoQUFzQ1FBSkFJQUFPRmtwSlNBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJDeUFEUVNrMkFod2dBeUFCTmdJVUlBTkJzaGcyQWhBZ0EwRVZOZ0lNUVFBaEFneDdDeUFEUVFBMkFod2dBeUFCTmdJVUlBTkIzUXMyQWhBZ0EwRVJOZ0lNUVFBaEFneDZDMEVBSVFBQ1FDQURLQUk0SWdKRkRRQWdBaWdDVkNJQ1JRMEFJQU1nQWhFQUFDRUFDeUFBUlExVklBQkJGVWNOQVNBRFFRVTJBaHdnQXlBQk5nSVVJQU5CaGhvMkFoQWdBMEVWTmdJTVFRQWhBZ3g1QzBIS0FDRUNERjRMUVFBaEFpQURRUUEyQWh3Z0F5QUJOZ0lVSUFOQjRnMDJBaEFnQTBFVU5nSU1ESGNMSUFNZ0F5OEJNa0dBQVhJN0FUSU1PQXNnQVNBRVJ3UkFJQU5CRURZQ0NDQURJQUUyQWdSQnlRQWhBZ3hjQzBIWEFDRUNESFVMSUFFZ0JFWUVRRUhXQUNFQ0RIVUxBa0FDUUFKQUFrQWdBUzBBQUNJQVFTQnlJQUFnQUVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZCNHdCckRoTUFQVDA5UFQwOVBUMDlQVDA5QVQwOVBRSURQUXNnQVVFQmFpRUJRY1VBSVFJTVhRc2dBVUVCYWlFQlFjWUFJUUlNWEFzZ0FVRUJhaUVCUWNjQUlRSU1Xd3NnQVVFQmFpRUJRY2dBSVFJTVdndEIxUUFoQWlBRUlBRWlBRVlOY3lBRUlBRnJJQU1vQWdBaUFXb2hCaUFBSUFGclFRVnFJUWNEUUNBQlFjREdBR290QUFBZ0FDMEFBQ0lGUVNCeUlBVWdCVUhCQUd0Qi93RnhRUnBKRzBIL0FYRkhEUWhCQkNBQlFRVkdEUW9hSUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0F5QUdOZ0lBREhNTFFkUUFJUUlnQkNBQklnQkdEWElnQkNBQmF5QURLQUlBSWdGcUlRWWdBQ0FCYTBFUGFpRUhBMEFnQVVHd3hnQnFMUUFBSUFBdEFBQWlCVUVnY2lBRklBVkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFJ3MEhRUU1nQVVFUFJnMEpHaUFCUVFGcUlRRWdCQ0FBUVFGcUlnQkhEUUFMSUFNZ0JqWUNBQXh5QzBIVEFDRUNJQVFnQVNJQVJnMXhJQVFnQVdzZ0F5Z0NBQ0lCYWlFR0lBQWdBV3RCRG1vaEJ3TkFJQUZCa3NZQWFpMEFBQ0FBTFFBQUlnVkJJSElnQlNBRlFjRUFhMEgvQVhGQkdra2JRZjhCY1VjTkJpQUJRUTVHRFFjZ0FVRUJhaUVCSUFRZ0FFRUJhaUlBUncwQUN5QURJQVkyQWdBTWNRdEIwZ0FoQWlBRUlBRWlBRVlOY0NBRUlBRnJJQU1vQWdBaUFXb2hCU0FBSUFGclFRRnFJUVlEUUNBQlFaREdBR290QUFBZ0FDMEFBQ0lIUVNCeUlBY2dCMEhCQUd0Qi93RnhRUnBKRzBIL0FYRkhEUVVnQVVFQlJnMENJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQXlBRk5nSUFESEFMSUFFZ0JFWUVRRUhSQUNFQ0RIQUxBa0FDUUNBQkxRQUFJZ0JCSUhJZ0FDQUFRY0VBYTBIL0FYRkJHa2tiUWY4QmNVSHVBR3NPQndBMk5qWTJOZ0UyQ3lBQlFRRnFJUUZCd2dBaEFneFdDeUFCUVFGcUlRRkJ3d0FoQWd4VkN5QURRUUEyQWdBZ0JrRUJhaUVCUWNRQUlRSU1WQXRCMEFBaEFpQUVJQUVpQUVZTmJTQUVJQUZySUFNb0FnQWlBV29oQmlBQUlBRnJRUWxxSVFjRFFDQUJRWWJHQUdvdEFBQWdBQzBBQUNJRlFTQnlJQVVnQlVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZIRFFKQkFpQUJRUWxHRFFRYUlBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBeUFHTmdJQURHMExRYzhBSVFJZ0JDQUJJZ0JHRFd3Z0JDQUJheUFES0FJQUlnRnFJUVlnQUNBQmEwRUZhaUVIQTBBZ0FVR0F4Z0JxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzBCSUFGQkJVWU5BaUFCUVFGcUlRRWdCQ0FBUVFGcUlnQkhEUUFMSUFNZ0JqWUNBQXhzQ3lBQUlRRWdBMEVBTmdJQUREQUxRUUVMT2dBc0lBTkJBRFlDQUNBSFFRRnFJUUVMUVN3aEFneE9Dd0pBQTBBZ0FTMEFBRUdBeEFCcUxRQUFRUUZIRFFFZ0JDQUJRUUZxSWdGSERRQUxRYzBBSVFJTWFBdEJ3UUFoQWd4TkN5QUJJQVJHQkVCQnpBQWhBZ3huQ3lBQkxRQUFRVHBHQkVBZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXZJZ0JGRFRBZ0EwSExBRFlDSENBRElBQTJBZ3dnQXlBQlFRRnFOZ0lVUVFBaEFneG5DeUFEUVFBMkFod2dBeUFCTmdJVUlBTkJ1UkUyQWhBZ0EwRUtOZ0lNUVFBaEFneG1Dd0pBQWtBZ0F5MEFMRUVDYXc0Q0FBRWtDeUFEUVROcUxRQUFRUUp4UlEwaklBTXRBQzVCQW5FTkl5QURRUUEyQWh3Z0F5QUJOZ0lVSUFOQjFSTTJBaEFnQTBFTE5nSU1RUUFoQWd4bUN5QURMUUF5UVNCeFJRMGlJQU10QUM1QkFuRU5JaUFEUVFBMkFod2dBeUFCTmdJVUlBTkI3QkkyQWhBZ0EwRVBOZ0lNUVFBaEFneGxDMEVBSVFBQ1FDQURLQUk0SWdKRkRRQWdBaWdDUUNJQ1JRMEFJQU1nQWhFQUFDRUFDeUFBUlFSQVFjQUFJUUlNU3dzZ0FFRVZSd1JBSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEg0RGpZQ0VDQURRUncyQWd4QkFDRUNER1VMSUFOQnlnQTJBaHdnQXlBQk5nSVVJQU5COEJvMkFoQWdBMEVWTmdJTVFRQWhBZ3hrQ3lBQklBUkhCRUFEUUNBQkxRQUFRZkEvYWkwQUFFRUJSdzBYSUFRZ0FVRUJhaUlCUncwQUMwSEVBQ0VDREdRTFFjUUFJUUlNWXdzZ0FTQUVSd1JBQTBBQ1FDQUJMUUFBSWdCQklISWdBQ0FBUWNFQWEwSC9BWEZCR2trYlFmOEJjU0lBUVFsR0RRQWdBRUVnUmcwQUFrQUNRQUpBQWtBZ0FFSGpBR3NPRXdBREF3TURBd01EQVFNREF3TURBd01EQXdJREN5QUJRUUZxSVFGQk5TRUNERTRMSUFGQkFXb2hBVUUySVFJTVRRc2dBVUVCYWlFQlFUY2hBZ3hNQ3d3VkN5QUVJQUZCQVdvaUFVY05BQXRCUENFQ0RHTUxRVHdoQWd4aUN5QUJJQVJHQkVCQnlBQWhBZ3hpQ3lBRFFSRTJBZ2dnQXlBQk5nSUVBa0FDUUFKQUFrQUNRQ0FETFFBc1FRRnJEZ1FVQUFFQ0NRc2dBeTBBTWtFZ2NRMERRZEVCSVFJTVN3c0NRQ0FETHdFeUlnQkJDSEZGRFFBZ0F5MEFLRUVCUncwQUlBTXRBQzVCQ0hGRkRRSUxJQU1nQUVIMyt3TnhRWUFFY2pzQk1nd0xDeUFESUFNdkFUSkJFSEk3QVRJTUJBc2dBMEVBTmdJRUlBTWdBU0FCRURBaUFBUkFJQU5Cd1FBMkFod2dBeUFBTmdJTUlBTWdBVUVCYWpZQ0ZFRUFJUUlNWXdzZ0FVRUJhaUVCREZJTElBTkJBRFlDSENBRElBRTJBaFFnQTBHakV6WUNFQ0FEUVFRMkFneEJBQ0VDREdFTFFjY0FJUUlnQVNBRVJnMWdJQU1vQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQm1vaEJnSkFBMEFnQUVId3d3QnFMUUFBSUFFdEFBQkJJSEpIRFFFZ0FFRUdSZzFHSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0F5QUZOZ0lBREdFTElBTkJBRFlDQUF3RkN3SkFJQUVnQkVjRVFBTkFJQUV0QUFCQjhNRUFhaTBBQUNJQVFRRkhCRUFnQUVFQ1J3MERJQUZCQVdvaEFRd0ZDeUFFSUFGQkFXb2lBVWNOQUF0QnhRQWhBZ3hoQzBIRkFDRUNER0FMQ3lBRFFRQTZBQ3dNQVF0QkN5RUNERU1MUVQ0aEFneENDd0pBQWtBRFFDQUJMUUFBSWdCQklFY0VRQUpBSUFCQkNtc09CQU1GQlFNQUN5QUFRU3hHRFFNTUJBc2dCQ0FCUVFGcUlnRkhEUUFMUWNZQUlRSU1YUXNnQTBFSU9nQXNEQTRMSUFNdEFDaEJBVWNOQWlBRExRQXVRUWh4RFFJZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXdJZ0FFUUNBRFFjSUFOZ0ljSUFNZ0FEWUNEQ0FESUFGQkFXbzJBaFJCQUNFQ0RGd0xJQUZCQVdvaEFReEtDMEU2SVFJTVFBc0NRQU5BSUFFdEFBQWlBRUVnUnlBQVFRbEhjUTBCSUFRZ0FVRUJhaUlCUncwQUMwSERBQ0VDREZvTEMwRTdJUUlNUGdzQ1FBSkFJQUVnQkVjRVFBTkFJQUV0QUFBaUFFRWdSd1JBSUFCQkNtc09CQU1FQkFNRUN5QUVJQUZCQVdvaUFVY05BQXRCUHlFQ0RGb0xRVDhoQWd4WkN5QURJQU12QVRKQklISTdBVElNQ2dzZ0F5Z0NCQ0VBSUFOQkFEWUNCQ0FESUFBZ0FSQXdJZ0JGRFVnZ0EwRStOZ0ljSUFNZ0FUWUNGQ0FESUFBMkFneEJBQ0VDREZjTEFrQWdBU0FFUndSQUEwQWdBUzBBQUVId3dRQnFMUUFBSWdCQkFVY0VRQ0FBUVFKR0RRTU1EQXNnQkNBQlFRRnFJZ0ZIRFFBTFFUY2hBZ3hZQzBFM0lRSU1Wd3NnQVVFQmFpRUJEQVFMUVRzaEFpQUVJQUVpQUVZTlZTQUVJQUZySUFNb0FnQWlBV29oQmlBQUlBRnJRUVZxSVFjQ1FBTkFJQUZCd01ZQWFpMEFBQ0FBTFFBQUlnVkJJSElnQlNBRlFjRUFhMEgvQVhGQkdra2JRZjhCY1VjTkFTQUJRUVZHQkVCQkJ5RUJERHNMSUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0F5QUdOZ0lBREZZTElBTkJBRFlDQUNBQUlRRU1CUXRCT2lFQ0lBUWdBU0lBUmcxVUlBUWdBV3NnQXlnQ0FDSUJhaUVHSUFBZ0FXdEJDR29oQndKQUEwQWdBVUhrUDJvdEFBQWdBQzBBQUNJRlFTQnlJQVVnQlVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZIRFFFZ0FVRUlSZ1JBUVFVaEFRdzZDeUFCUVFGcUlRRWdCQ0FBUVFGcUlnQkhEUUFMSUFNZ0JqWUNBQXhWQ3lBRFFRQTJBZ0FnQUNFQkRBUUxRVGtoQWlBRUlBRWlBRVlOVXlBRUlBRnJJQU1vQWdBaUFXb2hCaUFBSUFGclFRTnFJUWNDUUFOQUlBRkI0RDlxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzBCSUFGQkEwWUVRRUVHSVFFTU9Rc2dBVUVCYWlFQklBUWdBRUVCYWlJQVJ3MEFDeUFESUFZMkFnQU1WQXNnQTBFQU5nSUFJQUFoQVF3REN3SkFBMEFnQVMwQUFDSUFRU0JIQkVBZ0FFRUthdzRFQndRRUJ3SUxJQVFnQVVFQmFpSUJSdzBBQzBFNElRSU1Vd3NnQUVFc1J3MEJJQUZCQVdvaEFFRUJJUUVDUUFKQUFrQUNRQUpBSUFNdEFDeEJCV3NPQkFNQkFnUUFDeUFBSVFFTUJBdEJBaUVCREFFTFFRUWhBUXNnQTBFQk9nQXNJQU1nQXk4Qk1pQUJjanNCTWlBQUlRRU1BUXNnQXlBREx3RXlRUWh5T3dFeUlBQWhBUXRCUFNFQ0REY0xJQU5CQURvQUxBdEJPQ0VDRERVTElBRWdCRVlFUUVFMklRSU1Ud3NDUUFKQUFrQUNRQUpBSUFFdEFBQkJDbXNPQkFBQ0FnRUNDeUFES0FJRUlRQWdBMEVBTmdJRUlBTWdBQ0FCRURBaUFFVU5BaUFEUVRNMkFod2dBeUFCTmdJVUlBTWdBRFlDREVFQUlRSU1VZ3NnQXlnQ0JDRUFJQU5CQURZQ0JDQURJQUFnQVJBd0lnQkZCRUFnQVVFQmFpRUJEQVlMSUFOQk1qWUNIQ0FESUFBMkFnd2dBeUFCUVFGcU5nSVVRUUFoQWd4UkN5QURMUUF1UVFGeEJFQkIwQUVoQWd3M0N5QURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFREFpQUEwQkRFTUxRVE1oQWd3MUN5QURRVFUyQWh3Z0F5QUJOZ0lVSUFNZ0FEWUNERUVBSVFJTVRndEJOQ0VDRERNTElBTkJMMm90QUFCQkFYRU5BQ0FEUVFBMkFod2dBeUFCTmdJVUlBTkI4UlUyQWhBZ0EwRVpOZ0lNUVFBaEFneE1DMEV5SVFJTU1Rc2dBU0FFUmdSQVFUSWhBZ3hMQ3dKQUlBRXRBQUJCQ2tZRVFDQUJRUUZxSVFFTUFRc2dBMEVBTmdJY0lBTWdBVFlDRkNBRFFaZ1dOZ0lRSUFOQkF6WUNERUVBSVFJTVN3dEJNU0VDRERBTElBRWdCRVlFUUVFeElRSU1TZ3NnQVMwQUFDSUFRUWxISUFCQklFZHhEUUVnQXkwQUxFRUlSdzBBSUFOQkFEb0FMQXRCUENFQ0RDNExRUUVoQWdKQUFrQUNRQUpBSUFNdEFDeEJCV3NPQkFNQkFnQUtDeUFESUFNdkFUSkJDSEk3QVRJTUNRdEJBaUVDREFFTFFRUWhBZ3NnQTBFQk9nQXNJQU1nQXk4Qk1pQUNjanNCTWd3R0N5QUJJQVJHQkVCQk1DRUNERWNMSUFFdEFBQkJDa1lFUUNBQlFRRnFJUUVNQVFzZ0F5MEFMa0VCY1EwQUlBTkJBRFlDSENBRElBRTJBaFFnQTBISEp6WUNFQ0FEUVFJMkFneEJBQ0VDREVZTFFTOGhBZ3dyQ3lBQlFRRnFJUUZCTUNFQ0RDb0xJQUVnQkVZRVFFRXZJUUlNUkFzZ0FTMEFBQ0lBUVFsSElBQkJJRWR4UlFSQUlBRkJBV29oQVNBRExRQXVRUUZ4RFFFZ0EwRUFOZ0ljSUFNZ0FUWUNGQ0FEUWVrUE5nSVFJQU5CQ2pZQ0RFRUFJUUlNUkF0QkFTRUNBa0FDUUFKQUFrQUNRQUpBSUFNdEFDeEJBbXNPQndVRUJBTUJBZ0FFQ3lBRElBTXZBVEpCQ0hJN0FUSU1Bd3RCQWlFQ0RBRUxRUVFoQWdzZ0EwRUJPZ0FzSUFNZ0F5OEJNaUFDY2pzQk1ndEJMaUVDRENvTElBTkJBRFlDSENBRElBRTJBaFFnQTBHekVqWUNFQ0FEUVFzMkFneEJBQ0VDREVNTFFkSUJJUUlNS0FzZ0FTQUVSZ1JBUVM0aEFneENDeUFEUVFBMkFnUWdBMEVSTmdJSUlBTWdBU0FCRURBaUFBMEJDMEV0SVFJTUpnc2dBMEV0TmdJY0lBTWdBVFlDRkNBRElBQTJBZ3hCQUNFQ0REOExRUUFoQUFKQUlBTW9BamdpQWtVTkFDQUNLQUpFSWdKRkRRQWdBeUFDRVFBQUlRQUxJQUJGRFFBZ0FFRVZSdzBCSUFOQjJBQTJBaHdnQXlBQk5nSVVJQU5CbmhvMkFoQWdBMEVWTmdJTVFRQWhBZ3crQzBITEFDRUNEQ01MSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdGRGpZQ0VDQURRUjAyQWd4QkFDRUNERHdMSUFFZ0JFWUVRRUhPQUNFQ0REd0xJQUV0QUFBaUFFRWdSZzBDSUFCQk9rWU5BUXNnQTBFQU9nQXNRUWtoQWd3Z0N5QURLQUlFSVFBZ0EwRUFOZ0lFSUFNZ0FDQUJFQzhpQUEwQkRBSUxJQU10QUM1QkFYRUVRRUhQQVNFQ0RCOExJQU1vQWdRaEFDQURRUUEyQWdRZ0F5QUFJQUVRTHlJQVJRMENJQU5CS2pZQ0hDQURJQUEyQWd3Z0F5QUJRUUZxTmdJVVFRQWhBZ3c0Q3lBRFFjc0FOZ0ljSUFNZ0FEWUNEQ0FESUFGQkFXbzJBaFJCQUNFQ0REY0xJQUZCQVdvaEFVRS9JUUlNSEFzZ0FVRUJhaUVCRENrTElBRWdCRVlFUUVFcklRSU1OUXNDUUNBQkxRQUFRUXBHQkVBZ0FVRUJhaUVCREFFTElBTXRBQzVCd0FCeFJRMEdDeUFETFFBeVFZQUJjUVJBUVFBaEFBSkFJQU1vQWpnaUFrVU5BQ0FDS0FKVUlnSkZEUUFnQXlBQ0VRQUFJUUFMSUFCRkRSRWdBRUVWUmdSQUlBTkJCVFlDSENBRElBRTJBaFFnQTBHR0dqWUNFQ0FEUVJVMkFneEJBQ0VDRERZTElBTkJBRFlDSENBRElBRTJBaFFnQTBIaURUWUNFQ0FEUVJRMkFneEJBQ0VDRERVTElBTkJNbW9oQWlBREVEUkJBQ0VBQWtBZ0F5Z0NPQ0lHUlEwQUlBWW9BaVFpQmtVTkFDQURJQVlSQUFBaEFBc2dBQTRXQWdFQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUF3UUxJQU5CQVRvQU1Bc2dBaUFDTHdFQVFjQUFjanNCQUF0QktpRUNEQmNMSUFOQktUWUNIQ0FESUFFMkFoUWdBMEd5R0RZQ0VDQURRUlUyQWd4QkFDRUNEREFMSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEhkQ3pZQ0VDQURRUkUyQWd4QkFDRUNEQzhMSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEdkQ3pZQ0VDQURRUUkyQWd4QkFDRUNEQzRMUVFFaEJ5QURMd0V5SWdWQkNIRkZCRUFnQXlrRElFSUFVaUVIQ3dKQUlBTXRBREFFUUVFQklRQWdBeTBBS1VFRlJnMEJJQVZCd0FCeFJTQUhjVVVOQVFzQ1FDQURMUUFvSWdKQkFrWUVRRUVCSVFBZ0F5OEJOQ0lHUWVVQVJnMENRUUFoQUNBRlFjQUFjUTBDSUFaQjVBQkdEUUlnQmtIbUFHdEJBa2tOQWlBR1Fjd0JSZzBDSUFaQnNBSkdEUUlNQVF0QkFDRUFJQVZCd0FCeERRRUxRUUloQUNBRlFRaHhEUUFnQlVHQUJIRUVRQUpBSUFKQkFVY05BQ0FETFFBdVFRcHhEUUJCQlNFQURBSUxRUVFoQUF3QkN5QUZRU0J4UlFSQUlBTVFOVUVBUjBFQ2RDRUFEQUVMUVFCQkF5QURLUU1nVUJzaEFBc0NRQ0FBUVFGckRnVUFBUVlIQWdNTFFRQWhBZ0pBSUFNb0FqZ2lBRVVOQUNBQUtBSXNJZ0JGRFFBZ0F5QUFFUUFBSVFJTElBSkZEU1lnQWtFVlJnUkFJQU5CQXpZQ0hDQURJQUUyQWhRZ0EwRzlHallDRUNBRFFSVTJBZ3hCQUNFQ0RDNExRUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5Ccnc0MkFoQWdBMEVTTmdJTURDMExRYzRCSVFJTUVndEJBQ0VDSUFOQkFEWUNIQ0FESUFFMkFoUWdBMEhrSHpZQ0VDQURRUTgyQWd3TUt3dEJBQ0VBQWtBZ0F5Z0NPQ0lDUlEwQUlBSW9BaXdpQWtVTkFDQURJQUlSQUFBaEFBc2dBQTBCQzBFT0lRSU1Ed3NnQUVFVlJnUkFJQU5CQWpZQ0hDQURJQUUyQWhRZ0EwRzlHallDRUNBRFFSVTJBZ3hCQUNFQ0RDa0xRUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5Ccnc0MkFoQWdBMEVTTmdJTURDZ0xRU2toQWd3TkN5QURRUUU2QURFTUpBc2dBU0FFUndSQUlBTkJDVFlDQ0NBRElBRTJBZ1JCS0NFQ0RBd0xRU1loQWd3bEN5QURJQU1wQXlBaURDQUVJQUZyclNJS2ZTSUxRZ0FnQ3lBTVdCczNBeUFnQ2lBTVZBUkFRU1VoQWd3bEN5QURLQUlFSVFCQkFDRUNJQU5CQURZQ0JDQURJQUFnQVNBTXAyb2lBUkF4SWdCRkRRQWdBMEVGTmdJY0lBTWdBVFlDRkNBRElBQTJBZ3dNSkF0QkR5RUNEQWtMSUFFZ0JFWUVRRUVqSVFJTUl3dENBQ0VLQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUV0QUFCQk1Hc09OeGNXQUFFQ0F3UUZCZ2NVRkJRVUZCUVVDQWtLQ3d3TkZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRT0R4QVJFaE1VQzBJQ0lRb01GZ3RDQXlFS0RCVUxRZ1FoQ2d3VUMwSUZJUW9NRXd0Q0JpRUtEQklMUWdjaENnd1JDMElJSVFvTUVBdENDU0VLREE4TFFnb2hDZ3dPQzBJTElRb01EUXRDRENFS0RBd0xRZzBoQ2d3TEMwSU9JUW9NQ2d0Q0R5RUtEQWtMUWdvaENnd0lDMElMSVFvTUJ3dENEQ0VLREFZTFFnMGhDZ3dGQzBJT0lRb01CQXRDRHlFS0RBTUxRUUFoQWlBRFFRQTJBaHdnQXlBQk5nSVVJQU5CemhRMkFoQWdBMEVNTmdJTURDSUxJQUVnQkVZRVFFRWlJUUlNSWd0Q0FDRUtBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQkxRQUFRVEJyRGpjVkZBQUJBZ01FQlFZSEZoWVdGaFlXRmdnSkNnc01EUllXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdEZzhRRVJJVEZndENBaUVLREJRTFFnTWhDZ3dUQzBJRUlRb01FZ3RDQlNFS0RCRUxRZ1loQ2d3UUMwSUhJUW9NRHd0Q0NDRUtEQTRMUWdraENnd05DMElLSVFvTURBdENDeUVLREFzTFFnd2hDZ3dLQzBJTklRb01DUXRDRGlFS0RBZ0xRZzhoQ2d3SEMwSUtJUW9NQmd0Q0N5RUtEQVVMUWd3aENnd0VDMElOSVFvTUF3dENEaUVLREFJTFFnOGhDZ3dCQzBJQklRb0xJQUZCQVdvaEFTQURLUU1nSWd0Qy8vLy8vLy8vLy84UFdBUkFJQU1nQzBJRWhpQUtoRGNESUF3Q0MwRUFJUUlnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRYTBKTmdJUUlBTkJERFlDREF3ZkMwRWxJUUlNQkF0QkppRUNEQU1MSUFNZ0FUb0FMQ0FEUVFBMkFnQWdCMEVCYWlFQlFRd2hBZ3dDQ3lBRFFRQTJBZ0FnQmtFQmFpRUJRUW9oQWd3QkN5QUJRUUZxSVFGQkNDRUNEQUFMQUF0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSFZFRFlDRUNBRFFRazJBZ3dNR0F0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSFhDallDRUNBRFFRazJBZ3dNRnd0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwRy9FRFlDRUNBRFFRazJBZ3dNRmd0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR2tFVFlDRUNBRFFRazJBZ3dNRlF0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSFZFRFlDRUNBRFFRazJBZ3dNRkF0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSFhDallDRUNBRFFRazJBZ3dNRXd0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwRy9FRFlDRUNBRFFRazJBZ3dNRWd0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR2tFVFlDRUNBRFFRazJBZ3dNRVF0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwRy9GallDRUNBRFFRODJBZ3dNRUF0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwRy9GallDRUNBRFFRODJBZ3dNRHd0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSElFallDRUNBRFFRczJBZ3dNRGd0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR1ZDVFlDRUNBRFFRczJBZ3dNRFF0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSHBEellDRUNBRFFRbzJBZ3dNREF0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR0RFRFlDRUNBRFFRbzJBZ3dNQ3d0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwR21IRFlDRUNBRFFRSTJBZ3dNQ2d0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSEZGVFlDRUNBRFFRSTJBZ3dNQ1F0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSC9GellDRUNBRFFRSTJBZ3dNQ0F0QkFDRUNJQU5CQURZQ0hDQURJQUUyQWhRZ0EwSEtGellDRUNBRFFRSTJBZ3dNQndzZ0EwRUNOZ0ljSUFNZ0FUWUNGQ0FEUVpRZE5nSVFJQU5CRmpZQ0RFRUFJUUlNQmd0QjNnQWhBaUFCSUFSR0RRVWdDVUVJYWlFSElBTW9BZ0FoQlFKQUFrQWdBU0FFUndSQUlBVkJ4c1lBYWlFSUlBUWdCV29nQVdzaEJpQUZRWDl6UVFwcUlnVWdBV29oQUFOQUlBRXRBQUFnQ0MwQUFFY0VRRUVDSVFnTUF3c2dCVVVFUUVFQUlRZ2dBQ0VCREFNTElBVkJBV3NoQlNBSVFRRnFJUWdnQkNBQlFRRnFJZ0ZIRFFBTElBWWhCU0FFSVFFTElBZEJBVFlDQUNBRElBVTJBZ0FNQVFzZ0EwRUFOZ0lBSUFjZ0NEWUNBQXNnQnlBQk5nSUVJQWtvQWd3aEFDQUpLQUlJRGdNQkJRSUFDd0FMSUFOQkFEWUNIQ0FEUWEwZE5nSVFJQU5CRnpZQ0RDQURJQUJCQVdvMkFoUkJBQ0VDREFNTElBTkJBRFlDSENBRElBQTJBaFFnQTBIQ0hUWUNFQ0FEUVFrMkFneEJBQ0VDREFJTElBRWdCRVlFUUVFb0lRSU1BZ3NnQTBFSk5nSUlJQU1nQVRZQ0JFRW5JUUlNQVFzZ0FTQUVSZ1JBUVFFaEFnd0JDd05BQWtBQ1FBSkFJQUV0QUFCQkNtc09CQUFCQVFBQkN5QUJRUUZxSVFFTUFRc2dBVUVCYWlFQklBTXRBQzVCSUhFTkFFRUFJUUlnQTBFQU5nSWNJQU1nQVRZQ0ZDQURRWXdnTmdJUUlBTkJCVFlDREF3Q0MwRUJJUUlnQVNBRVJ3MEFDd3NnQ1VFUWFpUUFJQUpGQkVBZ0F5Z0NEQ0VBREFFTElBTWdBallDSEVFQUlRQWdBeWdDQkNJQlJRMEFJQU1nQVNBRUlBTW9BZ2dSQVFBaUFVVU5BQ0FESUFRMkFoUWdBeUFCTmdJTUlBRWhBQXNnQUF1K0FnRUNmeUFBUVFBNkFBQWdBRUhjQUdvaUFVRUJhMEVBT2dBQUlBQkJBRG9BQWlBQVFRQTZBQUVnQVVFRGEwRUFPZ0FBSUFGQkFtdEJBRG9BQUNBQVFRQTZBQU1nQVVFRWEwRUFPZ0FBUVFBZ0FHdEJBM0VpQVNBQWFpSUFRUUEyQWdCQjNBQWdBV3RCZkhFaUFpQUFhaUlCUVFSclFRQTJBZ0FDUUNBQ1FRbEpEUUFnQUVFQU5nSUlJQUJCQURZQ0JDQUJRUWhyUVFBMkFnQWdBVUVNYTBFQU5nSUFJQUpCR1VrTkFDQUFRUUEyQWhnZ0FFRUFOZ0lVSUFCQkFEWUNFQ0FBUVFBMkFnd2dBVUVRYTBFQU5nSUFJQUZCRkd0QkFEWUNBQ0FCUVJoclFRQTJBZ0FnQVVFY2EwRUFOZ0lBSUFJZ0FFRUVjVUVZY2lJQ2F5SUJRU0JKRFFBZ0FDQUNhaUVBQTBBZ0FFSUFOd01ZSUFCQ0FEY0RFQ0FBUWdBM0F3Z2dBRUlBTndNQUlBQkJJR29oQUNBQlFTQnJJZ0ZCSDBzTkFBc0xDMVlCQVg4Q1FDQUFLQUlNRFFBQ1FBSkFBa0FDUUNBQUxRQXhEZ01CQUFNQ0N5QUFLQUk0SWdGRkRRQWdBU2dDTENJQlJRMEFJQUFnQVJFQUFDSUJEUU1MUVFBUEN3QUxJQUJCMEJnMkFoQkJEaUVCQ3lBQkN4b0FJQUFvQWd4RkJFQWdBRUhKSGpZQ0VDQUFRUlUyQWd3TEN4UUFJQUFvQWd4QkZVWUVRQ0FBUVFBMkFnd0xDeFFBSUFBb0FneEJGa1lFUUNBQVFRQTJBZ3dMQ3djQUlBQW9BZ3dMQndBZ0FDZ0NFQXNKQUNBQUlBRTJBaEFMQndBZ0FDZ0NGQXNYQUNBQVFTUlBCRUFBQ3lBQVFRSjBRWlEzYWlnQ0FBc1hBQ0FBUVM5UEJFQUFDeUFBUVFKMFFhUTRhaWdDQUF1L0NRRUJmMEhmTENFQkFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBRUhrQUdzTzlBTmpZZ0FCWVdGaFlXRmhBZ01FQldGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRUdCd2dKQ2dzTURRNFBZV0ZoWVdFUVlXRmhZV0ZoWVdGaFlXRVJZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhFaE1VRlJZWEdCa2FHMkZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0VjSFI0ZklDRWlJeVFsSmljb0tTb3JMQzB1THpBeE1qTTBOVFpoTnpnNU9tRmhZV0ZoWVdGaE8yRmhZVHhoWVdGaFBUNC9ZV0ZoWVdGaFlXRkFZV0ZCWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFFrTkVSVVpIU0VsS1MweE5UazlRVVZKVFlXRmhZV0ZoWVdGVVZWWlhXRmxhVzJGY1hXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZVjVoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZmWUdFTFFkVXJEd3RCZ3lVUEMwRy9NQThMUWZJMUR3dEJ0Q2dQQzBHZktBOExRWUVzRHd0QjFpb1BDMEgwTXc4TFFhMHpEd3RCeXlnUEMwSE9JdzhMUWNBakR3dEIyU01QQzBIUkpBOExRWnd6RHd0Qm9qWVBDMEg4TXc4TFFlQXJEd3RCNFNVUEMwSHRJQThMUWNReUR3dEJxU2NQQzBHNU5nOExRYmdnRHd0QnF5QVBDMEdqSkE4TFFiWWtEd3RCZ1NNUEMwSGhNZzhMUVo4MER3dEJ5Q2tQQzBIQU1nOExRZTR5RHd0QjhDOFBDMEhHTkE4TFFkQWhEd3RCbWlRUEMwSHJMdzhMUVlRMUR3dEJ5elVQQzBHV01ROExRY2dyRHd0QjFDOFBDMEdUTUE4TFFkODFEd3RCdENNUEMwRytOUThMUWRJcER3dEJzeUlQQzBITklBOExRWnMyRHd0QmtDRVBDMEgvSUE4TFFhMDFEd3RCc0RRUEMwSHhKQThMUWFjcUR3dEIzVEFQQzBHTElnOExRY2d2RHd0QjZ5b1BDMEgwS1E4TFFZOGxEd3RCM1NJUEMwSHNKZzhMUWYwd0R3dEIxaVlQQzBHVU5ROExRWTBqRHd0QnVpa1BDMEhISWc4TFFmSWxEd3RCdGpNUEMwR2lJUThMUWY4dkR3dEJ3Q0VQQzBHQk13OExRY2tsRHd0QnFERVBDMEhHTXc4TFFkTTJEd3RCeGpZUEMwSGtOQThMUVlnbUR3dEI3U2NQQzBINElROExRYWt3RHd0Qmp6UVBDMEdHTmc4TFFhb3ZEd3RCb1NZUEMwSHNOZzhMUVpJcER3dEJyeVlQQzBHWklnOExRZUFoRHdzQUMwRzFKU0VCQ3lBQkN4Y0FJQUFnQUM4QkxrSCsvd054SUFGQkFFZHlPd0V1Q3hvQUlBQWdBQzhCTGtIOS93TnhJQUZCQUVkQkFYUnlPd0V1Q3hvQUlBQWdBQzhCTGtINy93TnhJQUZCQUVkQkFuUnlPd0V1Q3hvQUlBQWdBQzhCTGtIMy93TnhJQUZCQUVkQkEzUnlPd0V1Q3hvQUlBQWdBQzhCTGtIdi93TnhJQUZCQUVkQkJIUnlPd0V1Q3hvQUlBQWdBQzhCTGtIZi93TnhJQUZCQUVkQkJYUnlPd0V1Q3hvQUlBQWdBQzhCTGtHLy93TnhJQUZCQUVkQkJuUnlPd0V1Q3hvQUlBQWdBQzhCTGtILy9nTnhJQUZCQUVkQkIzUnlPd0V1Q3hvQUlBQWdBQzhCTGtILy9RTnhJQUZCQUVkQkNIUnlPd0V1Q3hvQUlBQWdBQzhCTGtILyt3TnhJQUZCQUVkQkNYUnlPd0V1Q3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0JDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJ6aEUyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0NDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI1QW8yQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0RDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI1UjAyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0VDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJuUkEyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0ZDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJvaDQyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0dDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI3aFEyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0tDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI5Z2cyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0hDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI5eHMyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0lDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJsUlUyQWhCQkdDRUVDeUFFQ3pnQUlBQUNmeUFBTHdFeVFSUnhRUlJHQkVCQkFTQUFMUUFvUVFGR0RRRWFJQUF2QVRSQjVRQkdEQUVMSUFBdEFDbEJCVVlMT2dBd0Mxa0JBbjhDUUNBQUxRQW9RUUZHRFFBZ0FDOEJOQ0lCUWVRQWEwSGtBRWtOQUNBQlFjd0JSZzBBSUFGQnNBSkdEUUFnQUM4Qk1pSUFRY0FBY1EwQVFRRWhBaUFBUVlnRWNVR0FCRVlOQUNBQVFTaHhSU0VDQ3lBQ0M0d0JBUUovQWtBQ1FBSkFJQUF0QUNwRkRRQWdBQzBBSzBVTkFDQUFMd0V5SWdGQkFuRkZEUUVNQWdzZ0FDOEJNaUlCUVFGeFJRMEJDMEVCSVFJZ0FDMEFLRUVCUmcwQUlBQXZBVFFpQUVIa0FHdEI1QUJKRFFBZ0FFSE1BVVlOQUNBQVFiQUNSZzBBSUFGQndBQnhEUUJCQUNFQ0lBRkJpQVJ4UVlBRVJnMEFJQUZCS0hGQkFFY2hBZ3NnQWd0ekFDQUFRUkJxL1F3QUFBQUFBQUFBQUFBQUFBQUFBQUFBL1FzREFDQUEvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUXNEQUNBQVFUQnEvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUXNEQUNBQVFTQnEvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUXNEQUNBQVFld0JOZ0ljQ3dZQUlBQVFPUXVhTFFFTGZ5TUFRUkJySWdva0FFR1kxQUFvQWdBaUNVVUVRRUhZMXdBb0FnQWlCVVVFUUVIazF3QkNmemNDQUVIYzF3QkNnSUNFZ0lDQXdBQTNBZ0JCMk5jQUlBcEJDR3BCY0hGQjJLclZxZ1Z6SWdVMkFnQkI3TmNBUVFBMkFnQkJ2TmNBUVFBMkFnQUxRY0RYQUVHQTJBUTJBZ0JCa05RQVFZRFlCRFlDQUVHazFBQWdCVFlDQUVHZzFBQkJmellDQUVIRTF3QkJnS2dETmdJQUEwQWdBVUc4MUFCcUlBRkJzTlFBYWlJQ05nSUFJQUlnQVVHbzFBQnFJZ00yQWdBZ0FVRzAxQUJxSUFNMkFnQWdBVUhFMUFCcUlBRkJ1TlFBYWlJRE5nSUFJQU1nQWpZQ0FDQUJRY3pVQUdvZ0FVSEExQUJxSWdJMkFnQWdBaUFETmdJQUlBRkJ5TlFBYWlBQ05nSUFJQUZCSUdvaUFVR0FBa2NOQUF0QmpOZ0VRY0duQXpZQ0FFR2MxQUJCNk5jQUtBSUFOZ0lBUVl6VUFFSEFwd00yQWdCQm1OUUFRWWpZQkRZQ0FFSE0vd2RCT0RZQ0FFR0kyQVFoQ1FzQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FBUWV3QlRRUkFRWURVQUNnQ0FDSUdRUkFnQUVFVGFrRndjU0FBUVF0Skd5SUVRUU4ySWdCMklnRkJBM0VFUUFKQUlBRkJBWEVnQUhKQkFYTWlBa0VEZENJQVFhalVBR29pQVNBQVFiRFVBR29vQWdBaUFDZ0NDQ0lEUmdSQVFZRFVBQ0FHUVg0Z0FuZHhOZ0lBREFFTElBRWdBellDQ0NBRElBRTJBZ3dMSUFCQkNHb2hBU0FBSUFKQkEzUWlBa0VEY2pZQ0JDQUFJQUpxSWdBZ0FDZ0NCRUVCY2pZQ0JBd1JDMEdJMUFBb0FnQWlDQ0FFVHcwQklBRUVRQUpBUVFJZ0FIUWlBa0VBSUFKcmNpQUJJQUIwY1dnaUFFRURkQ0lDUWFqVUFHb2lBU0FDUWJEVUFHb29BZ0FpQWlnQ0NDSURSZ1JBUVlEVUFDQUdRWDRnQUhkeElnWTJBZ0FNQVFzZ0FTQUROZ0lJSUFNZ0FUWUNEQXNnQWlBRVFRTnlOZ0lFSUFCQkEzUWlBQ0FFYXlFRklBQWdBbW9nQlRZQ0FDQUNJQVJxSWdRZ0JVRUJjallDQkNBSUJFQWdDRUY0Y1VHbzFBQnFJUUJCbE5RQUtBSUFJUU1DZjBFQklBaEJBM1owSWdFZ0JuRkZCRUJCZ05RQUlBRWdCbkkyQWdBZ0FBd0JDeUFBS0FJSUN5SUJJQU0yQWd3Z0FDQUROZ0lJSUFNZ0FEWUNEQ0FESUFFMkFnZ0xJQUpCQ0dvaEFVR1UxQUFnQkRZQ0FFR0kxQUFnQlRZQ0FBd1JDMEdFMUFBb0FnQWlDMFVOQVNBTGFFRUNkRUd3MWdCcUtBSUFJZ0FvQWdSQmVIRWdCR3NoQlNBQUlRSURRQUpBSUFJb0FoQWlBVVVFUUNBQ1FSUnFLQUlBSWdGRkRRRUxJQUVvQWdSQmVIRWdCR3NpQXlBRlNTRUNJQU1nQlNBQ0d5RUZJQUVnQUNBQ0d5RUFJQUVoQWd3QkN3c2dBQ2dDR0NFSklBQW9BZ3dpQXlBQVJ3UkFRWkRVQUNnQ0FCb2dBeUFBS0FJSUlnRTJBZ2dnQVNBRE5nSU1EQkFMSUFCQkZHb2lBaWdDQUNJQlJRUkFJQUFvQWhBaUFVVU5BeUFBUVJCcUlRSUxBMEFnQWlFSElBRWlBMEVVYWlJQ0tBSUFJZ0VOQUNBRFFSQnFJUUlnQXlnQ0VDSUJEUUFMSUFkQkFEWUNBQXdQQzBGL0lRUWdBRUcvZjBzTkFDQUFRUk5xSWdGQmNIRWhCRUdFMUFBb0FnQWlDRVVOQUVFQUlBUnJJUVVDUUFKQUFrQUNmMEVBSUFSQmdBSkpEUUFhUVI4Z0JFSC8vLzhIU3cwQUdpQUVRU1lnQVVFSWRtY2lBR3QyUVFGeElBQkJBWFJyUVQ1cUN5SUdRUUowUWJEV0FHb29BZ0FpQWtVRVFFRUFJUUZCQUNFRERBRUxRUUFoQVNBRVFSa2dCa0VCZG10QkFDQUdRUjlIRzNRaEFFRUFJUU1EUUFKQUlBSW9BZ1JCZUhFZ0JHc2lCeUFGVHcwQUlBSWhBeUFISWdVTkFFRUFJUVVnQWlFQkRBTUxJQUVnQWtFVWFpZ0NBQ0lISUFjZ0FpQUFRUjEyUVFSeGFrRVFhaWdDQUNJQ1Joc2dBU0FIR3lFQklBQkJBWFFoQUNBQ0RRQUxDeUFCSUFOeVJRUkFRUUFoQTBFQ0lBWjBJZ0JCQUNBQWEzSWdDSEVpQUVVTkF5QUFhRUVDZEVHdzFnQnFLQUlBSVFFTElBRkZEUUVMQTBBZ0FTZ0NCRUY0Y1NBRWF5SUNJQVZKSVFBZ0FpQUZJQUFiSVFVZ0FTQURJQUFiSVFNZ0FTZ0NFQ0lBQkg4Z0FBVWdBVUVVYWlnQ0FBc2lBUTBBQ3dzZ0EwVU5BQ0FGUVlqVUFDZ0NBQ0FFYTA4TkFDQURLQUlZSVFjZ0F5QURLQUlNSWdCSEJFQkJrTlFBS0FJQUdpQUFJQU1vQWdnaUFUWUNDQ0FCSUFBMkFnd01EZ3NnQTBFVWFpSUNLQUlBSWdGRkJFQWdBeWdDRUNJQlJRMERJQU5CRUdvaEFnc0RRQ0FDSVFZZ0FTSUFRUlJxSWdJb0FnQWlBUTBBSUFCQkVHb2hBaUFBS0FJUUlnRU5BQXNnQmtFQU5nSUFEQTBMUVlqVUFDZ0NBQ0lESUFSUEJFQkJsTlFBS0FJQUlRRUNRQ0FESUFScklnSkJFRThFUUNBQklBUnFJZ0FnQWtFQmNqWUNCQ0FCSUFOcUlBSTJBZ0FnQVNBRVFRTnlOZ0lFREFFTElBRWdBMEVEY2pZQ0JDQUJJQU5xSWdBZ0FDZ0NCRUVCY2pZQ0JFRUFJUUJCQUNFQ0MwR0kxQUFnQWpZQ0FFR1UxQUFnQURZQ0FDQUJRUWhxSVFFTUR3dEJqTlFBS0FJQUlnTWdCRXNFUUNBRUlBbHFJZ0FnQXlBRWF5SUJRUUZ5TmdJRVFaalVBQ0FBTmdJQVFZelVBQ0FCTmdJQUlBa2dCRUVEY2pZQ0JDQUpRUWhxSVFFTUR3dEJBQ0VCSUFRQ2YwSFkxd0FvQWdBRVFFSGcxd0FvQWdBTUFRdEI1TmNBUW44M0FnQkIzTmNBUW9DQWhJQ0FnTUFBTndJQVFkalhBQ0FLUVF4cVFYQnhRZGlxMWFvRmN6WUNBRUhzMXdCQkFEWUNBRUc4MXdCQkFEWUNBRUdBZ0FRTElnQWdCRUhIQUdvaUJXb2lCa0VBSUFCcklnZHhJZ0pQQkVCQjhOY0FRVEEyQWdBTUR3c0NRRUc0MXdBb0FnQWlBVVVOQUVHdzF3QW9BZ0FpQ0NBQ2FpRUFJQUFnQVUwZ0FDQUlTM0VOQUVFQUlRRkI4TmNBUVRBMkFnQU1Ed3RCdk5jQUxRQUFRUVJ4RFFRQ1FBSkFJQWtFUUVIQTF3QWhBUU5BSUFFb0FnQWlBQ0FKVFFSQUlBQWdBU2dDQkdvZ0NVc05Bd3NnQVNnQ0NDSUJEUUFMQzBFQUVEb2lBRUYvUmcwRklBSWhCa0hjMXdBb0FnQWlBVUVCYXlJRElBQnhCRUFnQWlBQWF5QUFJQU5xUVFBZ0FXdHhhaUVHQ3lBRUlBWlBEUVVnQmtIKy8vLy9CMHNOQlVHNDF3QW9BZ0FpQXdSQVFiRFhBQ2dDQUNJSElBWnFJUUVnQVNBSFRRMEdJQUVnQTBzTkJnc2dCaEE2SWdFZ0FFY05BUXdIQ3lBR0lBTnJJQWR4SWdaQi92Ly8vd2RMRFFRZ0JoQTZJUUFnQUNBQktBSUFJQUVvQWdScVJnMERJQUFoQVFzQ1FDQUdJQVJCeUFCcVR3MEFJQUZCZjBZTkFFSGcxd0FvQWdBaUFDQUZJQVpyYWtFQUlBQnJjU0lBUWY3Ly8vOEhTd1JBSUFFaEFBd0hDeUFBRURwQmYwY0VRQ0FBSUFacUlRWWdBU0VBREFjTFFRQWdCbXNRT2hvTUJBc2dBU0lBUVg5SERRVU1Bd3RCQUNFRERBd0xRUUFoQUF3S0N5QUFRWDlIRFFJTFFielhBRUc4MXdBb0FnQkJCSEkyQWdBTElBSkIvdi8vL3dkTERRRWdBaEE2SVFCQkFCQTZJUUVnQUVGL1JnMEJJQUZCZjBZTkFTQUFJQUZQRFFFZ0FTQUFheUlHSUFSQk9HcE5EUUVMUWJEWEFFR3cxd0FvQWdBZ0Jtb2lBVFlDQUVHMDF3QW9BZ0FnQVVrRVFFRzAxd0FnQVRZQ0FBc0NRQUpBQWtCQm1OUUFLQUlBSWdJRVFFSEExd0FoQVFOQUlBQWdBU2dDQUNJRElBRW9BZ1FpQldwR0RRSWdBU2dDQ0NJQkRRQUxEQUlMUVpEVUFDZ0NBQ0lCUVFCSElBQWdBVTl4UlFSQVFaRFVBQ0FBTmdJQUMwRUFJUUZCeE5jQUlBWTJBZ0JCd05jQUlBQTJBZ0JCb05RQVFYODJBZ0JCcE5RQVFkalhBQ2dDQURZQ0FFSE0xd0JCQURZQ0FBTkFJQUZCdk5RQWFpQUJRYkRVQUdvaUFqWUNBQ0FDSUFGQnFOUUFhaUlETmdJQUlBRkJ0TlFBYWlBRE5nSUFJQUZCeE5RQWFpQUJRYmpVQUdvaUF6WUNBQ0FESUFJMkFnQWdBVUhNMUFCcUlBRkJ3TlFBYWlJQ05nSUFJQUlnQXpZQ0FDQUJRY2pVQUdvZ0FqWUNBQ0FCUVNCcUlnRkJnQUpIRFFBTFFYZ2dBR3RCRDNFaUFTQUFhaUlDSUFaQk9Hc2lBeUFCYXlJQlFRRnlOZ0lFUVp6VUFFSG8xd0FvQWdBMkFnQkJqTlFBSUFFMkFnQkJtTlFBSUFJMkFnQWdBQ0FEYWtFNE5nSUVEQUlMSUFBZ0FrME5BQ0FDSUFOSkRRQWdBU2dDREVFSWNRMEFRWGdnQW10QkQzRWlBQ0FDYWlJRFFZelVBQ2dDQUNBR2FpSUhJQUJySWdCQkFYSTJBZ1FnQVNBRklBWnFOZ0lFUVp6VUFFSG8xd0FvQWdBMkFnQkJqTlFBSUFBMkFnQkJtTlFBSUFNMkFnQWdBaUFIYWtFNE5nSUVEQUVMSUFCQmtOUUFLQUlBU1FSQVFaRFVBQ0FBTmdJQUN5QUFJQVpxSVFOQndOY0FJUUVDUUFKQUFrQURRQ0FESUFFb0FnQkhCRUFnQVNnQ0NDSUJEUUVNQWdzTElBRXRBQXhCQ0hGRkRRRUxRY0RYQUNFQkEwQWdBU2dDQUNJRElBSk5CRUFnQXlBQktBSUVhaUlGSUFKTERRTUxJQUVvQWdnaEFRd0FDd0FMSUFFZ0FEWUNBQ0FCSUFFb0FnUWdCbW8yQWdRZ0FFRjRJQUJyUVE5eGFpSUpJQVJCQTNJMkFnUWdBMEY0SUFOclFROXhhaUlHSUFRZ0NXb2lCR3NoQVNBQ0lBWkdCRUJCbU5RQUlBUTJBZ0JCak5RQVFZelVBQ2dDQUNBQmFpSUFOZ0lBSUFRZ0FFRUJjallDQkF3SUMwR1UxQUFvQWdBZ0JrWUVRRUdVMUFBZ0JEWUNBRUdJMUFCQmlOUUFLQUlBSUFGcUlnQTJBZ0FnQkNBQVFRRnlOZ0lFSUFBZ0JHb2dBRFlDQUF3SUN5QUdLQUlFSWdWQkEzRkJBVWNOQmlBRlFYaHhJUWdnQlVIL0FVMEVRQ0FGUVFOMklRTWdCaWdDQ0NJQUlBWW9BZ3dpQWtZRVFFR0ExQUJCZ05RQUtBSUFRWDRnQTNkeE5nSUFEQWNMSUFJZ0FEWUNDQ0FBSUFJMkFnd01CZ3NnQmlnQ0dDRUhJQVlnQmlnQ0RDSUFSd1JBSUFBZ0JpZ0NDQ0lDTmdJSUlBSWdBRFlDREF3RkN5QUdRUlJxSWdJb0FnQWlCVVVFUUNBR0tBSVFJZ1ZGRFFRZ0JrRVFhaUVDQ3dOQUlBSWhBeUFGSWdCQkZHb2lBaWdDQUNJRkRRQWdBRUVRYWlFQ0lBQW9BaEFpQlEwQUN5QURRUUEyQWdBTUJBdEJlQ0FBYTBFUGNTSUJJQUJxSWdjZ0JrRTRheUlESUFGcklnRkJBWEkyQWdRZ0FDQURha0U0TmdJRUlBSWdCVUUzSUFWclFROXhha0UvYXlJRElBTWdBa0VRYWtrYklnTkJJellDQkVHYzFBQkI2TmNBS0FJQU5nSUFRWXpVQUNBQk5nSUFRWmpVQUNBSE5nSUFJQU5CRUdwQnlOY0FLUUlBTndJQUlBTkJ3TmNBS1FJQU53SUlRY2pYQUNBRFFRaHFOZ0lBUWNUWEFDQUdOZ0lBUWNEWEFDQUFOZ0lBUWN6WEFFRUFOZ0lBSUFOQkpHb2hBUU5BSUFGQkJ6WUNBQ0FGSUFGQkJHb2lBVXNOQUFzZ0FpQURSZzBBSUFNZ0F5Z0NCRUYrY1RZQ0JDQURJQU1nQW1zaUJUWUNBQ0FDSUFWQkFYSTJBZ1FnQlVIL0FVMEVRQ0FGUVhoeFFhalVBR29oQUFKL1FZRFVBQ2dDQUNJQlFRRWdCVUVEZG5RaUEzRkZCRUJCZ05RQUlBRWdBM0kyQWdBZ0FBd0JDeUFBS0FJSUN5SUJJQUkyQWd3Z0FDQUNOZ0lJSUFJZ0FEWUNEQ0FDSUFFMkFnZ01BUXRCSHlFQklBVkIvLy8vQjAwRVFDQUZRU1lnQlVFSWRtY2lBR3QyUVFGeElBQkJBWFJyUVQ1cUlRRUxJQUlnQVRZQ0hDQUNRZ0EzQWhBZ0FVRUNkRUd3MWdCcUlRQkJoTlFBS0FJQUlnTkJBU0FCZENJR2NVVUVRQ0FBSUFJMkFnQkJoTlFBSUFNZ0JuSTJBZ0FnQWlBQU5nSVlJQUlnQWpZQ0NDQUNJQUkyQWd3TUFRc2dCVUVaSUFGQkFYWnJRUUFnQVVFZlJ4dDBJUUVnQUNnQ0FDRURBa0FEUUNBRElnQW9BZ1JCZUhFZ0JVWU5BU0FCUVIxMklRTWdBVUVCZENFQklBQWdBMEVFY1dwQkVHb2lCaWdDQUNJRERRQUxJQVlnQWpZQ0FDQUNJQUEyQWhnZ0FpQUNOZ0lNSUFJZ0FqWUNDQXdCQ3lBQUtBSUlJZ0VnQWpZQ0RDQUFJQUkyQWdnZ0FrRUFOZ0lZSUFJZ0FEWUNEQ0FDSUFFMkFnZ0xRWXpVQUNnQ0FDSUJJQVJORFFCQm1OUUFLQUlBSWdBZ0JHb2lBaUFCSUFScklnRkJBWEkyQWdSQmpOUUFJQUUyQWdCQm1OUUFJQUkyQWdBZ0FDQUVRUU55TmdJRUlBQkJDR29oQVF3SUMwRUFJUUZCOE5jQVFUQTJBZ0FNQnd0QkFDRUFDeUFIUlEwQUFrQWdCaWdDSENJQ1FRSjBRYkRXQUdvaUF5Z0NBQ0FHUmdSQUlBTWdBRFlDQUNBQURRRkJoTlFBUVlUVUFDZ0NBRUYrSUFKM2NUWUNBQXdDQ3lBSFFSQkJGQ0FIS0FJUUlBWkdHMm9nQURZQ0FDQUFSUTBCQ3lBQUlBYzJBaGdnQmlnQ0VDSUNCRUFnQUNBQ05nSVFJQUlnQURZQ0dBc2dCa0VVYWlnQ0FDSUNSUTBBSUFCQkZHb2dBallDQUNBQ0lBQTJBaGdMSUFFZ0NHb2hBU0FHSUFocUlnWW9BZ1FoQlFzZ0JpQUZRWDV4TmdJRUlBRWdCR29nQVRZQ0FDQUVJQUZCQVhJMkFnUWdBVUgvQVUwRVFDQUJRWGh4UWFqVUFHb2hBQUovUVlEVUFDZ0NBQ0lDUVFFZ0FVRURkblFpQVhGRkJFQkJnTlFBSUFFZ0FuSTJBZ0FnQUF3QkN5QUFLQUlJQ3lJQklBUTJBZ3dnQUNBRU5nSUlJQVFnQURZQ0RDQUVJQUUyQWdnTUFRdEJIeUVGSUFGQi8vLy9CMDBFUUNBQlFTWWdBVUVJZG1jaUFHdDJRUUZ4SUFCQkFYUnJRVDVxSVFVTElBUWdCVFlDSENBRVFnQTNBaEFnQlVFQ2RFR3cxZ0JxSVFCQmhOUUFLQUlBSWdKQkFTQUZkQ0lEY1VVRVFDQUFJQVEyQWdCQmhOUUFJQUlnQTNJMkFnQWdCQ0FBTmdJWUlBUWdCRFlDQ0NBRUlBUTJBZ3dNQVFzZ0FVRVpJQVZCQVhaclFRQWdCVUVmUnh0MElRVWdBQ2dDQUNFQUFrQURRQ0FBSWdJb0FnUkJlSEVnQVVZTkFTQUZRUjEySVFBZ0JVRUJkQ0VGSUFJZ0FFRUVjV3BCRUdvaUF5Z0NBQ0lBRFFBTElBTWdCRFlDQUNBRUlBSTJBaGdnQkNBRU5nSU1JQVFnQkRZQ0NBd0JDeUFDS0FJSUlnQWdCRFlDRENBQ0lBUTJBZ2dnQkVFQU5nSVlJQVFnQWpZQ0RDQUVJQUEyQWdnTElBbEJDR29oQVF3Q0N3SkFJQWRGRFFBQ1FDQURLQUljSWdGQkFuUkJzTllBYWlJQ0tBSUFJQU5HQkVBZ0FpQUFOZ0lBSUFBTkFVR0UxQUFnQ0VGK0lBRjNjU0lJTmdJQURBSUxJQWRCRUVFVUlBY29BaEFnQTBZYmFpQUFOZ0lBSUFCRkRRRUxJQUFnQnpZQ0dDQURLQUlRSWdFRVFDQUFJQUUyQWhBZ0FTQUFOZ0lZQ3lBRFFSUnFLQUlBSWdGRkRRQWdBRUVVYWlBQk5nSUFJQUVnQURZQ0dBc0NRQ0FGUVE5TkJFQWdBeUFFSUFWcUlnQkJBM0kyQWdRZ0FDQURhaUlBSUFBb0FnUkJBWEkyQWdRTUFRc2dBeUFFYWlJQ0lBVkJBWEkyQWdRZ0F5QUVRUU55TmdJRUlBSWdCV29nQlRZQ0FDQUZRZjhCVFFSQUlBVkJlSEZCcU5RQWFpRUFBbjlCZ05RQUtBSUFJZ0ZCQVNBRlFRTjJkQ0lGY1VVRVFFR0ExQUFnQVNBRmNqWUNBQ0FBREFFTElBQW9BZ2dMSWdFZ0FqWUNEQ0FBSUFJMkFnZ2dBaUFBTmdJTUlBSWdBVFlDQ0F3QkMwRWZJUUVnQlVILy8vOEhUUVJBSUFWQkppQUZRUWgyWnlJQWEzWkJBWEVnQUVFQmRHdEJQbW9oQVFzZ0FpQUJOZ0ljSUFKQ0FEY0NFQ0FCUVFKMFFiRFdBR29oQUVFQklBRjBJZ1FnQ0hGRkJFQWdBQ0FDTmdJQVFZVFVBQ0FFSUFoeU5nSUFJQUlnQURZQ0dDQUNJQUkyQWdnZ0FpQUNOZ0lNREFFTElBVkJHU0FCUVFGMmEwRUFJQUZCSDBjYmRDRUJJQUFvQWdBaEJBSkFBMEFnQkNJQUtBSUVRWGh4SUFWR0RRRWdBVUVkZGlFRUlBRkJBWFFoQVNBQUlBUkJCSEZxUVJCcUlnWW9BZ0FpQkEwQUN5QUdJQUkyQWdBZ0FpQUFOZ0lZSUFJZ0FqWUNEQ0FDSUFJMkFnZ01BUXNnQUNnQ0NDSUJJQUkyQWd3Z0FDQUNOZ0lJSUFKQkFEWUNHQ0FDSUFBMkFnd2dBaUFCTmdJSUN5QURRUWhxSVFFTUFRc0NRQ0FKUlEwQUFrQWdBQ2dDSENJQlFRSjBRYkRXQUdvaUFpZ0NBQ0FBUmdSQUlBSWdBellDQUNBRERRRkJoTlFBSUF0QmZpQUJkM0UyQWdBTUFnc2dDVUVRUVJRZ0NTZ0NFQ0FBUmh0cUlBTTJBZ0FnQTBVTkFRc2dBeUFKTmdJWUlBQW9BaEFpQVFSQUlBTWdBVFlDRUNBQklBTTJBaGdMSUFCQkZHb29BZ0FpQVVVTkFDQURRUlJxSUFFMkFnQWdBU0FETmdJWUN3SkFJQVZCRDAwRVFDQUFJQVFnQldvaUFVRURjallDQkNBQUlBRnFJZ0VnQVNnQ0JFRUJjallDQkF3QkN5QUFJQVJxSWdjZ0JVRUJjallDQkNBQUlBUkJBM0kyQWdRZ0JTQUhhaUFGTmdJQUlBZ0VRQ0FJUVhoeFFhalVBR29oQVVHVTFBQW9BZ0FoQXdKL1FRRWdDRUVEZG5RaUFpQUdjVVVFUUVHQTFBQWdBaUFHY2pZQ0FDQUJEQUVMSUFFb0FnZ0xJZ0lnQXpZQ0RDQUJJQU0yQWdnZ0F5QUJOZ0lNSUFNZ0FqWUNDQXRCbE5RQUlBYzJBZ0JCaU5RQUlBVTJBZ0FMSUFCQkNHb2hBUXNnQ2tFUWFpUUFJQUVMUXdBZ0FFVUVRRDhBUVJCMER3c0NRQ0FBUWYvL0EzRU5BQ0FBUVFCSURRQWdBRUVRZGtBQUlnQkJmMFlFUUVIdzF3QkJNRFlDQUVGL0R3c2dBRUVRZEE4TEFBc0wyMEFpQUVHQUNBc0pBUUFBQUFJQUFBQURBRUdVQ0FzRkJBQUFBQVVBUWFRSUN3a0dBQUFBQndBQUFBZ0FRZHdJQzRJeFNXNTJZV3hwWkNCamFHRnlJR2x1SUhWeWJDQnhkV1Z5ZVFCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDJKdlpIa0FRMjl1ZEdWdWRDMU1aVzVuZEdnZ2IzWmxjbVpzYjNjQVEyaDFibXNnYzJsNlpTQnZkbVZ5Wm14dmR3QkpiblpoYkdsa0lHMWxkR2h2WkNCbWIzSWdTRlJVVUM5NExuZ2djbVZ4ZFdWemRBQkpiblpoYkdsa0lHMWxkR2h2WkNCbWIzSWdVbFJUVUM5NExuZ2djbVZ4ZFdWemRBQkZlSEJsWTNSbFpDQlRUMVZTUTBVZ2JXVjBhRzlrSUdadmNpQkpRMFV2ZUM1NElISmxjWFZsYzNRQVNXNTJZV3hwWkNCamFHRnlJR2x1SUhWeWJDQm1jbUZuYldWdWRDQnpkR0Z5ZEFCRmVIQmxZM1JsWkNCa2IzUUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOXpkR0YwZFhNQVNXNTJZV3hwWkNCeVpYTndiMjV6WlNCemRHRjBkWE1BUlhod1pXTjBaV1FnVEVZZ1lXWjBaWElnYUdWaFpHVnljd0JKYm5aaGJHbGtJR05vWVhKaFkzUmxjaUJwYmlCamFIVnVheUJsZUhSbGJuTnBiMjV6QUZWelpYSWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYM0psYzJWMFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZZMmgxYm10ZmFHVmhaR1Z5WUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmJXVnpjMkZuWlY5aVpXZHBibUFnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDJOb2RXNXJYMlY0ZEdWdWMybHZibDkyWVd4MVpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYM04wWVhSMWMxOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYM1psY25OcGIyNWZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDkxY214ZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOWphSFZ1YTE5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyaGxZV1JsY2w5MllXeDFaVjlqYjIxd2JHVjBaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDIxbGMzTmhaMlZmWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5dFpYUm9iMlJmWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5b1pXRmtaWEpmWm1sbGJHUmZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlqYUhWdWExOWxlSFJsYm5OcGIyNWZibUZ0WldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBVlc1bGVIQmxZM1JsWkNCamFHRnlJR2x1SUhWeWJDQnpaWEoyWlhJQVNXNTJZV3hwWkNCb1pXRmtaWElnZG1Gc2RXVWdZMmhoY2dCSmJuWmhiR2xrSUdobFlXUmxjaUJtYVdWc1pDQmphR0Z5QUZOd1lXNGdZMkZzYkdKaFkyc2daWEp5YjNJZ2FXNGdiMjVmZG1WeWMybHZiZ0JKYm5aaGJHbGtJRzFwYm05eUlIWmxjbk5wYjI0QVNXNTJZV3hwWkNCdFlXcHZjaUIyWlhKemFXOXVBRVY0Y0dWamRHVmtJSE53WVdObElHRm1kR1Z5SUhabGNuTnBiMjRBUlhod1pXTjBaV1FnUTFKTVJpQmhablJsY2lCMlpYSnphVzl1QUVsdWRtRnNhV1FnU0ZSVVVDQjJaWEp6YVc5dUFFbHVkbUZzYVdRZ2FHVmhaR1Z5SUhSdmEyVnVBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZkWEpzQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5Y3lCcGJpQjFjbXdBVlc1bGVIQmxZM1JsWkNCemRHRnlkQ0JqYUdGeUlHbHVJSFZ5YkFCRWIzVmliR1VnUUNCcGJpQjFjbXdBUlcxd2RIa2dRMjl1ZEdWdWRDMU1aVzVuZEdnQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdRMjl1ZEdWdWRDMU1aVzVuZEdnQVZISmhibk5tWlhJdFJXNWpiMlJwYm1jZ1kyRnVKM1FnWW1VZ2NISmxjMlZ1ZENCM2FYUm9JRU52Ym5SbGJuUXRUR1Z1WjNSb0FFUjFjR3hwWTJGMFpTQkRiMjUwWlc1MExVeGxibWQwYUFCSmJuWmhiR2xrSUdOb1lYSWdhVzRnZFhKc0lIQmhkR2dBUTI5dWRHVnVkQzFNWlc1bmRHZ2dZMkZ1SjNRZ1ltVWdjSEpsYzJWdWRDQjNhWFJvSUZSeVlXNXpabVZ5TFVWdVkyOWthVzVuQUUxcGMzTnBibWNnWlhod1pXTjBaV1FnUTFJZ1lXWjBaWElnWTJoMWJtc2djMmw2WlFCRmVIQmxZM1JsWkNCTVJpQmhablJsY2lCamFIVnVheUJ6YVhwbEFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklITnBlbVVBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDlvWldGa1pYSmZkbUZzZFdVQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5amFIVnVhMTlsZUhSbGJuTnBiMjVmZG1Gc2RXVUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjeUIyWVd4MVpRQk5hWE56YVc1bklHVjRjR1ZqZEdWa0lFTlNJR0ZtZEdWeUlHaGxZV1JsY2lCMllXeDFaUUJOYVhOemFXNW5JR1Y0Y0dWamRHVmtJRXhHSUdGbWRHVnlJR2hsWVdSbGNpQjJZV3gxWlFCSmJuWmhiR2xrSUdCVWNtRnVjMlpsY2kxRmJtTnZaR2x1WjJBZ2FHVmhaR1Z5SUhaaGJIVmxBRTFwYzNOcGJtY2daWGh3WldOMFpXUWdRMUlnWVdaMFpYSWdZMmgxYm1zZ1pYaDBaVzV6YVc5dUlIWmhiSFZsQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlHTm9kVzVySUdWNGRHVnVjMmx2Ym5NZ2NYVnZkR1VnZG1Gc2RXVUFTVzUyWVd4cFpDQnhkVzkwWldRdGNHRnBjaUJwYmlCamFIVnVheUJsZUhSbGJuTnBiMjV6SUhGMWIzUmxaQ0IyWVd4MVpRQkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNpQnBiaUJqYUhWdWF5QmxlSFJsYm5OcGIyNXpJSEYxYjNSbFpDQjJZV3gxWlFCUVlYVnpaV1FnWW5rZ2IyNWZhR1ZoWkdWeWMxOWpiMjF3YkdWMFpRQkpiblpoYkdsa0lFVlBSaUJ6ZEdGMFpRQnZibDl5WlhObGRDQndZWFZ6WlFCdmJsOWphSFZ1YTE5b1pXRmtaWElnY0dGMWMyVUFiMjVmYldWemMyRm5aVjlpWldkcGJpQndZWFZ6WlFCdmJsOWphSFZ1YTE5bGVIUmxibk5wYjI1ZmRtRnNkV1VnY0dGMWMyVUFiMjVmYzNSaGRIVnpYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYM1psY25OcGIyNWZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZkWEpzWDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDJOb2RXNXJYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYMmhsWVdSbGNsOTJZV3gxWlY5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5dFpYTnpZV2RsWDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDIxbGRHaHZaRjlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDlvWldGa1pYSmZabWxsYkdSZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDI1aGJXVWdjR0YxYzJVQVZXNWxlSEJsWTNSbFpDQnpjR0ZqWlNCaFpuUmxjaUJ6ZEdGeWRDQnNhVzVsQUUxcGMzTnBibWNnWlhod1pXTjBaV1FnUTFJZ1lXWjBaWElnY21WemNHOXVjMlVnYkdsdVpRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyTm9kVzVyWDJWNGRHVnVjMmx2Ymw5dVlXMWxBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJR1Y0ZEdWdWMybHZibk1nYm1GdFpRQk5hWE56YVc1bklHVjRjR1ZqZEdWa0lFTlNJR0ZtZEdWeUlHTm9kVzVySUdWNGRHVnVjMmx2YmlCdVlXMWxBRWx1ZG1Gc2FXUWdjM1JoZEhWeklHTnZaR1VBVUdGMWMyVWdiMjRnUTA5T1RrVkRWQzlWY0dkeVlXUmxBRkJoZFhObElHOXVJRkJTU1M5VmNHZHlZV1JsQUVWNGNHVmpkR1ZrSUVoVVZGQXZNaUJEYjI1dVpXTjBhVzl1SUZCeVpXWmhZMlVBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDl0WlhSb2IyUUFSWGh3WldOMFpXUWdjM0JoWTJVZ1lXWjBaWElnYldWMGFHOWtBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZhR1ZoWkdWeVgyWnBaV3hrQUZCaGRYTmxaQUJKYm5aaGJHbGtJSGR2Y21RZ1pXNWpiM1Z1ZEdWeVpXUUFTVzUyWVd4cFpDQnRaWFJvYjJRZ1pXNWpiM1Z1ZEdWeVpXUUFUV2x6YzJsdVp5QmxlSEJsWTNSbFpDQkRVaUJoWm5SbGNpQmphSFZ1YXlCa1lYUmhBRVY0Y0dWamRHVmtJRXhHSUdGbWRHVnlJR05vZFc1cklHUmhkR0VBVlc1bGVIQmxZM1JsWkNCamFHRnlJR2x1SUhWeWJDQnpZMmhsYldFQVVtVnhkV1Z6ZENCb1lYTWdhVzUyWVd4cFpDQmdWSEpoYm5ObVpYSXRSVzVqYjJScGJtZGdBRVJoZEdFZ1lXWjBaWElnWUVOdmJtNWxZM1JwYjI0NklHTnNiM05sWUFCVFYwbFVRMGhmVUZKUFdGa0FWVk5GWDFCU1QxaFpBRTFMUVVOVVNWWkpWRmtBVlU1UVVrOURSVk5UUVVKTVJWOUZUbFJKVkZrQVVWVkZVbGtBUTA5UVdRQk5UMVpGUkY5UVJWSk5RVTVGVGxSTVdRQlVUMDlmUlVGU1RGa0FUazlVU1VaWkFFWkJTVXhGUkY5RVJWQkZUa1JGVGtOWkFFSkJSRjlIUVZSRlYwRlpBRkJNUVZrQVVGVlVBRU5JUlVOTFQxVlVBRWRCVkVWWFFWbGZWRWxOUlU5VlZBQlNSVkZWUlZOVVgxUkpUVVZQVlZRQVRrVlVWMDlTUzE5RFQwNU9SVU5VWDFSSlRVVlBWVlFBUTA5T1RrVkRWRWxQVGw5VVNVMUZUMVZVQUV4UFIwbE9YMVJKVFVWUFZWUUFUa1ZVVjA5U1MxOVNSVUZFWDFSSlRVVlBWVlFBVUU5VFZBQk5TVk5FU1ZKRlExUkZSRjlTUlZGVlJWTlVBRU5NU1VWT1ZGOURURTlUUlVSZlVrVlJWVVZUVkFCRFRFbEZUbFJmUTB4UFUwVkVYMHhQUVVSZlFrRk1RVTVEUlVSZlVrVlJWVVZUVkFCQ1FVUmZVa1ZSVlVWVFZBQklWRlJRWDFKRlVWVkZVMVJmVTBWT1ZGOVVUMTlJVkZSUVUxOVFUMUpVQUZKRlVFOVNWQUJKVFY5QlgxUkZRVkJQVkFCU1JWTkZWRjlEVDA1VVJVNVVBRTVQWDBOUFRsUkZUbFFBVUVGU1ZFbEJURjlEVDA1VVJVNVVBRWhRUlY5SlRsWkJURWxFWDBOUFRsTlVRVTVVQUVoUVJWOURRbDlTUlZORlZBQkhSVlFBU0ZCRlgxTlVVa2xEVkFCRFQwNUdURWxEVkFCVVJVMVFUMUpCVWxsZlVrVkVTVkpGUTFRQVVFVlNUVUZPUlU1VVgxSkZSRWxTUlVOVUFFTlBUazVGUTFRQVRWVk1WRWxmVTFSQlZGVlRBRWhRUlY5SlRsWkJURWxFWDFOVVFWUlZVd0JVVDA5ZlRVRk9XVjlTUlZGVlJWTlVVd0JGUVZKTVdWOUlTVTVVVXdCVlRrRldRVWxNUVVKTVJWOUdUMUpmVEVWSFFVeGZVa1ZCVTA5T1V3QlBVRlJKVDA1VEFGTlhTVlJEU0VsT1IxOVFVazlVVDBOUFRGTUFWa0ZTU1VGT1ZGOUJURk5QWDA1RlIwOVVTVUZVUlZNQVRWVk1WRWxRVEVWZlEwaFBTVU5GVXdCSlRsUkZVazVCVEY5VFJWSldSVkpmUlZKU1QxSUFWMFZDWDFORlVsWkZVbDlWVGt0T1QxZE9YMFZTVWs5U0FGSkJTVXhIVlU1ZlJWSlNUMUlBU1VSRlRsUkpWRmxmVUZKUFZrbEVSVkpmUVZWVVNFVk9WRWxEUVZSSlQwNWZSVkpTVDFJQVUxTk1YME5GVWxSSlJrbERRVlJGWDBWU1VrOVNBRWxPVmtGTVNVUmZXRjlHVDFKWFFWSkVSVVJmUms5U0FGTkZWRjlRUVZKQlRVVlVSVklBUjBWVVgxQkJVa0ZOUlZSRlVnQklVRVZmVlZORlVnQlRSVVZmVDFSSVJWSUFTRkJGWDBOQ1gwTklWVTVMWDBoRlFVUkZVZ0JGZUhCbFkzUmxaQ0JNUmlCaFpuUmxjaUJEVWdCTlMwTkJURVZPUkVGU0FGTkZWRlZRQUZkRlFsOVRSVkpXUlZKZlNWTmZSRTlYVGdCVVJVRlNSRTlYVGdCSVVFVmZRMHhQVTBWRVgwTlBUazVGUTFSSlQwNEFTRVZWVWtsVFZFbERYMFZZVUVsU1FWUkpUMDRBUkVsVFEwOU9Ua1ZEVkVWRVgwOVFSVkpCVkVsUFRnQk9UMDVmUVZWVVNFOVNTVlJCVkVsV1JWOUpUa1pQVWsxQlZFbFBUZ0JJVUVWZlNVNVdRVXhKUkY5V1JWSlRTVTlPQUVoUVJWOURRbDlOUlZOVFFVZEZYMEpGUjBsT0FGTkpWRVZmU1ZOZlJsSlBXa1ZPQUVoUVJWOUpUbFpCVEVsRVgwaEZRVVJGVWw5VVQwdEZUZ0JKVGxaQlRFbEVYMVJQUzBWT0FFWlBVa0pKUkVSRlRnQkZUa2hCVGtORlgxbFBWVkpmUTBGTVRRQklVRVZmU1U1V1FVeEpSRjlWVWt3QVFreFBRMHRGUkY5Q1dWOVFRVkpGVGxSQlRGOURUMDVVVWs5TUFFMUxRMDlNQUVGRFRBQklVRVZmU1U1VVJWSk9RVXdBVWtWUlZVVlRWRjlJUlVGRVJWSmZSa2xGVEVSVFgxUlBUMTlNUVZKSFJWOVZUazlHUmtsRFNVRk1BRWhRUlY5UFN3QlZUa3hKVGtzQVZVNU1UME5MQUZCU1NRQlNSVlJTV1Y5WFNWUklBRWhRUlY5SlRsWkJURWxFWDBOUFRsUkZUbFJmVEVWT1IxUklBRWhRUlY5VlRrVllVRVZEVkVWRVgwTlBUbFJGVGxSZlRFVk9SMVJJQUVaTVZWTklBRkJTVDFCUVFWUkRTQUJOTFZORlFWSkRTQUJWVWtsZlZFOVBYMHhQVGtjQVVGSlBRMFZUVTBsT1J3Qk5TVk5EUlV4TVFVNUZUMVZUWDFCRlVsTkpVMVJGVGxSZlYwRlNUa2xPUndCTlNWTkRSVXhNUVU1RlQxVlRYMWRCVWs1SlRrY0FTRkJGWDBsT1ZrRk1TVVJmVkZKQlRsTkdSVkpmUlU1RFQwUkpUa2NBUlhod1pXTjBaV1FnUTFKTVJnQklVRVZmU1U1V1FVeEpSRjlEU0ZWT1MxOVRTVnBGQUUxUFZrVUFRMDlPVkVsT1ZVVUFTRkJGWDBOQ1gxTlVRVlJWVTE5RFQwMVFURVZVUlFCSVVFVmZRMEpmU0VWQlJFVlNVMTlEVDAxUVRFVlVSUUJJVUVWZlEwSmZWa1ZTVTBsUFRsOURUMDFRVEVWVVJRQklVRVZmUTBKZlZWSk1YME5QVFZCTVJWUkZBRWhRUlY5RFFsOURTRlZPUzE5RFQwMVFURVZVUlFCSVVFVmZRMEpmU0VWQlJFVlNYMVpCVEZWRlgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5RFNGVk9TMTlGV0ZSRlRsTkpUMDVmVmtGTVZVVmZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gwTklWVTVMWDBWWVZFVk9VMGxQVGw5T1FVMUZYME5QVFZCTVJWUkZBRWhRUlY5RFFsOU5SVk5UUVVkRlgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5TlJWUklUMFJmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMGhGUVVSRlVsOUdTVVZNUkY5RFQwMVFURVZVUlFCRVJVeEZWRVVBU0ZCRlgwbE9Wa0ZNU1VSZlJVOUdYMU5VUVZSRkFFbE9Wa0ZNU1VSZlUxTk1YME5GVWxSSlJrbERRVlJGQUZCQlZWTkZBRTVQWDFKRlUxQlBUbE5GQUZWT1UxVlFVRTlTVkVWRVgwMUZSRWxCWDFSWlVFVUFSMDlPUlFCT1QxUmZRVU5EUlZCVVFVSk1SUUJUUlZKV1NVTkZYMVZPUVZaQlNVeEJRa3hGQUZKQlRrZEZYMDVQVkY5VFFWUkpVMFpKUVVKTVJRQlBVa2xIU1U1ZlNWTmZWVTVTUlVGRFNFRkNURVVBVWtWVFVFOU9VMFZmU1ZOZlUxUkJURVVBVUZWU1IwVUFUVVZTUjBVQVVrVlJWVVZUVkY5SVJVRkVSVkpmUmtsRlRFUlRYMVJQVDE5TVFWSkhSUUJTUlZGVlJWTlVYMGhGUVVSRlVsOVVUMDlmVEVGU1IwVUFVRUZaVEU5QlJGOVVUMDlmVEVGU1IwVUFTVTVUVlVaR1NVTkpSVTVVWDFOVVQxSkJSMFVBU0ZCRlgxQkJWVk5GUkY5VlVFZFNRVVJGQUVoUVJWOVFRVlZUUlVSZlNESmZWVkJIVWtGRVJRQlRUMVZTUTBVQVFVNU9UMVZPUTBVQVZGSkJRMFVBU0ZCRlgxVk9SVmhRUlVOVVJVUmZVMUJCUTBVQVJFVlRRMUpKUWtVQVZVNVRWVUpUUTFKSlFrVUFVa1ZEVDFKRUFFaFFSVjlKVGxaQlRFbEVYMDFGVkVoUFJBQk9UMVJmUms5VlRrUUFVRkpQVUVaSlRrUUFWVTVDU1U1RUFGSkZRa2xPUkFCVlRrRlZWRWhQVWtsYVJVUUFUVVZVU0U5RVgwNVBWRjlCVEV4UFYwVkVBRWhVVkZCZlZrVlNVMGxQVGw5T1QxUmZVMVZRVUU5U1ZFVkVBRUZNVWtWQlJGbGZVa1ZRVDFKVVJVUUFRVU5EUlZCVVJVUUFUazlVWDBsTlVFeEZUVVZPVkVWRUFFeFBUMUJmUkVWVVJVTlVSVVFBU0ZCRlgwTlNYMFZZVUVWRFZFVkVBRWhRUlY5TVJsOUZXRkJGUTFSRlJBQkRVa1ZCVkVWRUFFbE5YMVZUUlVRQVNGQkZYMUJCVlZORlJBQlVTVTFGVDFWVVgwOURRMVZTUlVRQVVFRlpUVVZPVkY5U1JWRlZTVkpGUkFCUVVrVkRUMDVFU1ZSSlQwNWZVa1ZSVlVsU1JVUUFVRkpQV0ZsZlFWVlVTRVZPVkVsRFFWUkpUMDVmVWtWUlZVbFNSVVFBVGtWVVYwOVNTMTlCVlZSSVJVNVVTVU5CVkVsUFRsOVNSVkZWU1ZKRlJBQk1SVTVIVkVoZlVrVlJWVWxTUlVRQVUxTk1YME5GVWxSSlJrbERRVlJGWDFKRlVWVkpVa1ZFQUZWUVIxSkJSRVZmVWtWUlZVbFNSVVFBVUVGSFJWOUZXRkJKVWtWRUFGQlNSVU5QVGtSSlZFbFBUbDlHUVVsTVJVUUFSVmhRUlVOVVFWUkpUMDVmUmtGSlRFVkVBRkpGVmtGTVNVUkJWRWxQVGw5R1FVbE1SVVFBVTFOTVgwaEJUa1JUU0VGTFJWOUdRVWxNUlVRQVRFOURTMFZFQUZSU1FVNVRSazlTVFVGVVNVOU9YMEZRVUV4SlJVUUFUazlVWDAxUFJFbEdTVVZFQUU1UFZGOUZXRlJGVGtSRlJBQkNRVTVFVjBsRVZFaGZURWxOU1ZSZlJWaERSVVZFUlVRQVUwbFVSVjlKVTE5UFZrVlNURTlCUkVWRUFFaEZRVVFBUlhod1pXTjBaV1FnU0ZSVVVDOEFBRklWQUFBYUZRQUFEeElBQU9RWkFBQ1JGUUFBQ1JRQUFDMFpBQURrRkFBQTZSRUFBR2tVQUFDaEZBQUFkaFVBQUVNV0FBQmVFZ0FBbEJjQUFCY1dBQUI5RkFBQWZ4WUFBRUVYQUFDekV3QUF3eFlBQUFRYUFBQzlHQUFBMEJnQUFLQVRBQURVR1FBQXJ4WUFBR2dXQUFCd0Z3QUEyUllBQVB3WUFBRCtFUUFBV1JjQUFKY1dBQUFjRndBQTloWUFBSTBYQUFBTEVnQUFmeHNBQUM0UkFBQ3pFQUFBU1JJQUFLMFNBQUQyR0FBQWFCQUFBR0lWQUFBUUZRQUFXaFlBQUVvWkFBQzFGUUFBd1JVQUFHQVZBQUJjR1FBQVdoa0FBRk1aQUFBV0ZRQUFyUkVBQUVJUUFBQzNFQUFBVnhnQUFMOFZBQUNKRUFBQUhCa0FBQm9aQUFDNUZRQUFVUmdBQU53VEFBQmJGUUFBV1JVQUFPWVlBQUJuRlFBQUVSa0FBTzBZQUFEbkV3QUFyaEFBQU1JWEFBQUFGQUFBa2hNQUFJUVRBQUJBRWdBQUpoa0FBSzhWQUFCaUVBQkI2VGtMQVFFQVFZQTZDK0FCQVFFQ0FRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBd0VCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBUWVvN0N3UUJBQUFDQUVHQlBBdGVBd1FEQXdNREF3QUFBd01BQXdNQUF3TURBd01EQXdNREF3QUZBQUFBQUFBREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdBQUFBTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQU1BQXdCQjZqMExCQUVBQUFJQVFZRStDMTREQUFNREF3TURBQUFEQXdBREF3QURBd01EQXdNREF3TURBQVFBQlFBQUFBTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREFBQUFBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01BQXdBREFFSGdQd3NOYkc5elpXVmxjQzFoYkdsMlpRQkIrVDhMQVFFQVFaREFBQXZnQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUVINXdRQUxBUUVBUVpEQ0FBdm5BUUVCQVFFQkFRRUJBUUVCQVFJQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJZMmgxYm10bFpBQkJvY1FBQzE0QkFBRUJBUUVCQUFBQkFRQUJBUUFCQVFFQkFRRUJBUUVCQUFBQUFBQUFBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUFBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRQUJBRUdBeGdBTElXVmpkR2x2Ym1WdWRDMXNaVzVuZEdodmJuSnZlSGt0WTI5dWJtVmpkR2x2YmdCQnNNWUFDeXR5WVc1elptVnlMV1Z1WTI5a2FXNW5jR2R5WVdSbERRb05DbE5ORFFvTkNsUlVVQzlEUlM5VVUxQXZBRUhweGdBTEJRRUNBQUVEQUVHQXh3QUxYd1FGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkFFSHB5QUFMQlFFQ0FBRURBRUdBeVFBTFh3UUZCUVlGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQUVIcHlnQUxCQUVBQUFFQVFZSExBQXRlQWdJQUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FBSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQkI2Y3dBQ3dVQkFnQUJBd0JCZ00wQUMxOEVCUUFBQlFVRkJRVUZCUVVGQlFVR0JRVUZCUVVGQlFVRkJRVUZBQVVBQndnRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVQUJRQUZBQVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZBQUFBQlFCQjZjNEFDd1VCQVFBQkFRQkJnTThBQ3dFQkFFR2F6d0FMUVFJQUFBQUFBQUFEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd0FBQUFBQUFBTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREFFSHAwQUFMQlFFQkFBRUJBRUdBMFFBTEFRRUFRWXJSQUFzR0FnQUFBQUFDQUVHaDBRQUxPZ01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQUFBQUF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQVFlRFNBQXVhQVU1UFZVNURSVVZEUzA5VlZFNUZRMVJGVkVWRFVrbENSVXhWVTBoRlZFVkJSRk5GUVZKRFNGSkhSVU5VU1ZaSlZGbE1SVTVFUVZKV1JVOVVTVVpaVUZSSlQwNVRRMGhUUlVGWlUxUkJWRU5JUjBWVlJWSlpUMUpFU1ZKRlExUlBVbFJTUTBoUVFWSkJUVVZVUlZKVlVrTkZRbE5EVWtsQ1JVRlNSRTlYVGtGRFJVbE9SRTVMUTB0VlFsTkRVa2xDUlVoVVZGQXZRVVJVVUM4PSdcblxubGV0IHdhc21CdWZmZXJcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgJ2V4cG9ydHMnLCB7XG4gIGdldDogKCkgPT4ge1xuICAgIHJldHVybiB3YXNtQnVmZmVyXG4gICAgICA/IHdhc21CdWZmZXJcbiAgICAgIDogKHdhc21CdWZmZXIgPSBCdWZmZXIuZnJvbSh3YXNtQmFzZTY0LCAnYmFzZTY0JykpXG4gIH1cbn0pXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/llhttp/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.enumToMap = void 0;\nfunction enumToMap(obj, filter = [], exceptions = []) {\n    var _a, _b;\n    const emptyFilter = ((_a = filter === null || filter === void 0 ? void 0 : filter.length) !== null && _a !== void 0 ? _a : 0) === 0;\n    const emptyExceptions = ((_b = exceptions === null || exceptions === void 0 ? void 0 : exceptions.length) !== null && _b !== void 0 ? _b : 0) === 0;\n    return Object.fromEntries(Object.entries(obj).filter(([, value]) => {\n        return (typeof value === 'number' &&\n            (emptyFilter || filter.includes(value)) &&\n            (emptyExceptions || !exceptions.includes(value)));\n    }));\n}\nexports.enumToMap = enumToMap;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbnVtVG9NYXAgPSB2b2lkIDA7XG5mdW5jdGlvbiBlbnVtVG9NYXAob2JqLCBmaWx0ZXIgPSBbXSwgZXhjZXB0aW9ucyA9IFtdKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBlbXB0eUZpbHRlciA9ICgoX2EgPSBmaWx0ZXIgPT09IG51bGwgfHwgZmlsdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWx0ZXIubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSA9PT0gMDtcbiAgICBjb25zdCBlbXB0eUV4Y2VwdGlvbnMgPSAoKF9iID0gZXhjZXB0aW9ucyA9PT0gbnVsbCB8fCBleGNlcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGNlcHRpb25zLmxlbmd0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgPT09IDA7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvYmopLmZpbHRlcigoWywgdmFsdWVdKSA9PiB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgKGVtcHR5RmlsdGVyIHx8IGZpbHRlci5pbmNsdWRlcyh2YWx1ZSkpICYmXG4gICAgICAgICAgICAoZW1wdHlFeGNlcHRpb25zIHx8ICFleGNlcHRpb25zLmluY2x1ZGVzKHZhbHVlKSkpO1xuICAgIH0pKTtcbn1cbmV4cG9ydHMuZW51bVRvTWFwID0gZW51bVRvTWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/llhttp/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-agent.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-agent.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { kClients } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst Agent = __webpack_require__(/*! ../dispatcher/agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/agent.js\")\nconst {\n  kAgent,\n  kMockAgentSet,\n  kMockAgentGet,\n  kDispatches,\n  kIsMockActive,\n  kNetConnect,\n  kGetNetConnect,\n  kOptions,\n  kFactory,\n  kMockAgentRegisterCallHistory,\n  kMockAgentIsCallHistoryEnabled,\n  kMockAgentAddCallHistoryLog,\n  kMockAgentMockCallHistoryInstance,\n  kMockAgentAcceptsNonStandardSearchParameters,\n  kMockCallHistoryAddLog\n} = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst MockClient = __webpack_require__(/*! ./mock-client */ \"(rsc)/./node_modules/undici/lib/mock/mock-client.js\")\nconst MockPool = __webpack_require__(/*! ./mock-pool */ \"(rsc)/./node_modules/undici/lib/mock/mock-pool.js\")\nconst { matchValue, normalizeSearchParams, buildAndValidateMockOptions } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst { InvalidArgumentError, UndiciError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst Dispatcher = __webpack_require__(/*! ../dispatcher/dispatcher */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js\")\nconst PendingInterceptorsFormatter = __webpack_require__(/*! ./pending-interceptors-formatter */ \"(rsc)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js\")\nconst { MockCallHistory } = __webpack_require__(/*! ./mock-call-history */ \"(rsc)/./node_modules/undici/lib/mock/mock-call-history.js\")\n\nclass MockAgent extends Dispatcher {\n  constructor (opts) {\n    super(opts)\n\n    const mockOptions = buildAndValidateMockOptions(opts)\n\n    this[kNetConnect] = true\n    this[kIsMockActive] = true\n    this[kMockAgentIsCallHistoryEnabled] = mockOptions?.enableCallHistory ?? false\n    this[kMockAgentAcceptsNonStandardSearchParameters] = mockOptions?.acceptNonStandardSearchParameters ?? false\n\n    // Instantiate Agent and encapsulate\n    if (opts?.agent && typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n    const agent = opts?.agent ? opts.agent : new Agent(opts)\n    this[kAgent] = agent\n\n    this[kClients] = agent[kClients]\n    this[kOptions] = mockOptions\n\n    if (this[kMockAgentIsCallHistoryEnabled]) {\n      this[kMockAgentRegisterCallHistory]()\n    }\n  }\n\n  get (origin) {\n    let dispatcher = this[kMockAgentGet](origin)\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](origin)\n      this[kMockAgentSet](origin, dispatcher)\n    }\n    return dispatcher\n  }\n\n  dispatch (opts, handler) {\n    // Call MockAgent.get to perform additional setup before dispatching as normal\n    this.get(opts.origin)\n\n    this[kMockAgentAddCallHistoryLog](opts)\n\n    const acceptNonStandardSearchParameters = this[kMockAgentAcceptsNonStandardSearchParameters]\n\n    const dispatchOpts = { ...opts }\n\n    if (acceptNonStandardSearchParameters && dispatchOpts.path) {\n      const [path, searchParams] = dispatchOpts.path.split('?')\n      const normalizedSearchParams = normalizeSearchParams(searchParams, acceptNonStandardSearchParameters)\n      dispatchOpts.path = `${path}?${normalizedSearchParams}`\n    }\n\n    return this[kAgent].dispatch(dispatchOpts, handler)\n  }\n\n  async close () {\n    this.clearCallHistory()\n    await this[kAgent].close()\n    this[kClients].clear()\n  }\n\n  deactivate () {\n    this[kIsMockActive] = false\n  }\n\n  activate () {\n    this[kIsMockActive] = true\n  }\n\n  enableNetConnect (matcher) {\n    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {\n      if (Array.isArray(this[kNetConnect])) {\n        this[kNetConnect].push(matcher)\n      } else {\n        this[kNetConnect] = [matcher]\n      }\n    } else if (typeof matcher === 'undefined') {\n      this[kNetConnect] = true\n    } else {\n      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')\n    }\n  }\n\n  disableNetConnect () {\n    this[kNetConnect] = false\n  }\n\n  enableCallHistory () {\n    this[kMockAgentIsCallHistoryEnabled] = true\n\n    return this\n  }\n\n  disableCallHistory () {\n    this[kMockAgentIsCallHistoryEnabled] = false\n\n    return this\n  }\n\n  getCallHistory () {\n    return this[kMockAgentMockCallHistoryInstance]\n  }\n\n  clearCallHistory () {\n    if (this[kMockAgentMockCallHistoryInstance] !== undefined) {\n      this[kMockAgentMockCallHistoryInstance].clear()\n    }\n  }\n\n  // This is required to bypass issues caused by using global symbols - see:\n  // https://github.com/nodejs/undici/issues/1447\n  get isMockActive () {\n    return this[kIsMockActive]\n  }\n\n  [kMockAgentRegisterCallHistory] () {\n    if (this[kMockAgentMockCallHistoryInstance] === undefined) {\n      this[kMockAgentMockCallHistoryInstance] = new MockCallHistory()\n    }\n  }\n\n  [kMockAgentAddCallHistoryLog] (opts) {\n    if (this[kMockAgentIsCallHistoryEnabled]) {\n      // additional setup when enableCallHistory class method is used after mockAgent instantiation\n      this[kMockAgentRegisterCallHistory]()\n\n      // add call history log on every call (intercepted or not)\n      this[kMockAgentMockCallHistoryInstance][kMockCallHistoryAddLog](opts)\n    }\n  }\n\n  [kMockAgentSet] (origin, dispatcher) {\n    this[kClients].set(origin, { count: 0, dispatcher })\n  }\n\n  [kFactory] (origin) {\n    const mockOptions = Object.assign({ agent: this }, this[kOptions])\n    return this[kOptions] && this[kOptions].connections === 1\n      ? new MockClient(origin, mockOptions)\n      : new MockPool(origin, mockOptions)\n  }\n\n  [kMockAgentGet] (origin) {\n    // First check if we can immediately find it\n    const result = this[kClients].get(origin)\n    if (result?.dispatcher) {\n      return result.dispatcher\n    }\n\n    // If the origin is not a string create a dummy parent pool and return to user\n    if (typeof origin !== 'string') {\n      const dispatcher = this[kFactory]('http://localhost:9999')\n      this[kMockAgentSet](origin, dispatcher)\n      return dispatcher\n    }\n\n    // If we match, create a pool and assign the same dispatches\n    for (const [keyMatcher, result] of Array.from(this[kClients])) {\n      if (result && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {\n        const dispatcher = this[kFactory](origin)\n        this[kMockAgentSet](origin, dispatcher)\n        dispatcher[kDispatches] = result.dispatcher[kDispatches]\n        return dispatcher\n      }\n    }\n  }\n\n  [kGetNetConnect] () {\n    return this[kNetConnect]\n  }\n\n  pendingInterceptors () {\n    const mockAgentClients = this[kClients]\n\n    return Array.from(mockAgentClients.entries())\n      .flatMap(([origin, result]) => result.dispatcher[kDispatches].map(dispatch => ({ ...dispatch, origin })))\n      .filter(({ pending }) => pending)\n  }\n\n  assertNoPendingInterceptors ({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {\n    const pending = this.pendingInterceptors()\n\n    if (pending.length === 0) {\n      return\n    }\n\n    throw new UndiciError(\n      pending.length === 1\n        ? `1 interceptor is pending:\\n\\n${pendingInterceptorsFormatter.format(pending)}`.trim()\n        : `${pending.length} interceptors are pending:\\n\\n${pendingInterceptorsFormatter.format(pending)}`.trim()\n    )\n  }\n}\n\nmodule.exports = MockAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLGdGQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1QixtQkFBbUIsbUJBQU8sQ0FBQywwRUFBZTtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBYTtBQUN0QyxRQUFRLGlFQUFpRSxFQUFFLG1CQUFPLENBQUMsd0VBQWM7QUFDakcsUUFBUSxvQ0FBb0MsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN0RSxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBMEI7QUFDckQscUNBQXFDLG1CQUFPLENBQUMsZ0hBQWtDO0FBQy9FLFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQyxzRkFBcUI7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSyxHQUFHLHVCQUF1QjtBQUM1RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsc0JBQXNCO0FBQ3ZEOztBQUVBO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVGQUF1RixxQkFBcUI7QUFDNUcsaUJBQWlCLFNBQVM7QUFDMUI7O0FBRUEsaUNBQWlDLG9FQUFvRSxJQUFJO0FBQ3pHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLDZDQUE2QztBQUN2RixhQUFhLGdCQUFnQiwrQkFBK0IsNkNBQTZDO0FBQ3pHO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stYWdlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga0NsaWVudHMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4uL2Rpc3BhdGNoZXIvYWdlbnQnKVxuY29uc3Qge1xuICBrQWdlbnQsXG4gIGtNb2NrQWdlbnRTZXQsXG4gIGtNb2NrQWdlbnRHZXQsXG4gIGtEaXNwYXRjaGVzLFxuICBrSXNNb2NrQWN0aXZlLFxuICBrTmV0Q29ubmVjdCxcbiAga0dldE5ldENvbm5lY3QsXG4gIGtPcHRpb25zLFxuICBrRmFjdG9yeSxcbiAga01vY2tBZ2VudFJlZ2lzdGVyQ2FsbEhpc3RvcnksXG4gIGtNb2NrQWdlbnRJc0NhbGxIaXN0b3J5RW5hYmxlZCxcbiAga01vY2tBZ2VudEFkZENhbGxIaXN0b3J5TG9nLFxuICBrTW9ja0FnZW50TW9ja0NhbGxIaXN0b3J5SW5zdGFuY2UsXG4gIGtNb2NrQWdlbnRBY2NlcHRzTm9uU3RhbmRhcmRTZWFyY2hQYXJhbWV0ZXJzLFxuICBrTW9ja0NhbGxIaXN0b3J5QWRkTG9nXG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgTW9ja0NsaWVudCA9IHJlcXVpcmUoJy4vbW9jay1jbGllbnQnKVxuY29uc3QgTW9ja1Bvb2wgPSByZXF1aXJlKCcuL21vY2stcG9vbCcpXG5jb25zdCB7IG1hdGNoVmFsdWUsIG5vcm1hbGl6ZVNlYXJjaFBhcmFtcywgYnVpbGRBbmRWYWxpZGF0ZU1vY2tPcHRpb25zIH0gPSByZXF1aXJlKCcuL21vY2stdXRpbHMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgVW5kaWNpRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXInKVxuY29uc3QgUGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlciA9IHJlcXVpcmUoJy4vcGVuZGluZy1pbnRlcmNlcHRvcnMtZm9ybWF0dGVyJylcbmNvbnN0IHsgTW9ja0NhbGxIaXN0b3J5IH0gPSByZXF1aXJlKCcuL21vY2stY2FsbC1oaXN0b3J5JylcblxuY2xhc3MgTW9ja0FnZW50IGV4dGVuZHMgRGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcblxuICAgIGNvbnN0IG1vY2tPcHRpb25zID0gYnVpbGRBbmRWYWxpZGF0ZU1vY2tPcHRpb25zKG9wdHMpXG5cbiAgICB0aGlzW2tOZXRDb25uZWN0XSA9IHRydWVcbiAgICB0aGlzW2tJc01vY2tBY3RpdmVdID0gdHJ1ZVxuICAgIHRoaXNba01vY2tBZ2VudElzQ2FsbEhpc3RvcnlFbmFibGVkXSA9IG1vY2tPcHRpb25zPy5lbmFibGVDYWxsSGlzdG9yeSA/PyBmYWxzZVxuICAgIHRoaXNba01vY2tBZ2VudEFjY2VwdHNOb25TdGFuZGFyZFNlYXJjaFBhcmFtZXRlcnNdID0gbW9ja09wdGlvbnM/LmFjY2VwdE5vblN0YW5kYXJkU2VhcmNoUGFyYW1ldGVycyA/PyBmYWxzZVxuXG4gICAgLy8gSW5zdGFudGlhdGUgQWdlbnQgYW5kIGVuY2Fwc3VsYXRlXG4gICAgaWYgKG9wdHM/LmFnZW50ICYmIHR5cGVvZiBvcHRzLmFnZW50LmRpc3BhdGNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0FyZ3VtZW50IG9wdHMuYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnQnKVxuICAgIH1cbiAgICBjb25zdCBhZ2VudCA9IG9wdHM/LmFnZW50ID8gb3B0cy5hZ2VudCA6IG5ldyBBZ2VudChvcHRzKVxuICAgIHRoaXNba0FnZW50XSA9IGFnZW50XG5cbiAgICB0aGlzW2tDbGllbnRzXSA9IGFnZW50W2tDbGllbnRzXVxuICAgIHRoaXNba09wdGlvbnNdID0gbW9ja09wdGlvbnNcblxuICAgIGlmICh0aGlzW2tNb2NrQWdlbnRJc0NhbGxIaXN0b3J5RW5hYmxlZF0pIHtcbiAgICAgIHRoaXNba01vY2tBZ2VudFJlZ2lzdGVyQ2FsbEhpc3RvcnldKClcbiAgICB9XG4gIH1cblxuICBnZXQgKG9yaWdpbikge1xuICAgIGxldCBkaXNwYXRjaGVyID0gdGhpc1trTW9ja0FnZW50R2V0XShvcmlnaW4pXG5cbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShvcmlnaW4pXG4gICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbiwgZGlzcGF0Y2hlcilcbiAgICB9XG4gICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgLy8gQ2FsbCBNb2NrQWdlbnQuZ2V0IHRvIHBlcmZvcm0gYWRkaXRpb25hbCBzZXR1cCBiZWZvcmUgZGlzcGF0Y2hpbmcgYXMgbm9ybWFsXG4gICAgdGhpcy5nZXQob3B0cy5vcmlnaW4pXG5cbiAgICB0aGlzW2tNb2NrQWdlbnRBZGRDYWxsSGlzdG9yeUxvZ10ob3B0cylcblxuICAgIGNvbnN0IGFjY2VwdE5vblN0YW5kYXJkU2VhcmNoUGFyYW1ldGVycyA9IHRoaXNba01vY2tBZ2VudEFjY2VwdHNOb25TdGFuZGFyZFNlYXJjaFBhcmFtZXRlcnNdXG5cbiAgICBjb25zdCBkaXNwYXRjaE9wdHMgPSB7IC4uLm9wdHMgfVxuXG4gICAgaWYgKGFjY2VwdE5vblN0YW5kYXJkU2VhcmNoUGFyYW1ldGVycyAmJiBkaXNwYXRjaE9wdHMucGF0aCkge1xuICAgICAgY29uc3QgW3BhdGgsIHNlYXJjaFBhcmFtc10gPSBkaXNwYXRjaE9wdHMucGF0aC5zcGxpdCgnPycpXG4gICAgICBjb25zdCBub3JtYWxpemVkU2VhcmNoUGFyYW1zID0gbm9ybWFsaXplU2VhcmNoUGFyYW1zKHNlYXJjaFBhcmFtcywgYWNjZXB0Tm9uU3RhbmRhcmRTZWFyY2hQYXJhbWV0ZXJzKVxuICAgICAgZGlzcGF0Y2hPcHRzLnBhdGggPSBgJHtwYXRofT8ke25vcm1hbGl6ZWRTZWFyY2hQYXJhbXN9YFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzW2tBZ2VudF0uZGlzcGF0Y2goZGlzcGF0Y2hPcHRzLCBoYW5kbGVyKVxuICB9XG5cbiAgYXN5bmMgY2xvc2UgKCkge1xuICAgIHRoaXMuY2xlYXJDYWxsSGlzdG9yeSgpXG4gICAgYXdhaXQgdGhpc1trQWdlbnRdLmNsb3NlKClcbiAgICB0aGlzW2tDbGllbnRzXS5jbGVhcigpXG4gIH1cblxuICBkZWFjdGl2YXRlICgpIHtcbiAgICB0aGlzW2tJc01vY2tBY3RpdmVdID0gZmFsc2VcbiAgfVxuXG4gIGFjdGl2YXRlICgpIHtcbiAgICB0aGlzW2tJc01vY2tBY3RpdmVdID0gdHJ1ZVxuICB9XG5cbiAgZW5hYmxlTmV0Q29ubmVjdCAobWF0Y2hlcikge1xuICAgIGlmICh0eXBlb2YgbWF0Y2hlciA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG1hdGNoZXIgPT09ICdmdW5jdGlvbicgfHwgbWF0Y2hlciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpc1trTmV0Q29ubmVjdF0pKSB7XG4gICAgICAgIHRoaXNba05ldENvbm5lY3RdLnB1c2gobWF0Y2hlcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNba05ldENvbm5lY3RdID0gW21hdGNoZXJdXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWF0Y2hlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXNba05ldENvbm5lY3RdID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ1Vuc3VwcG9ydGVkIG1hdGNoZXIuIE11c3QgYmUgb25lIG9mIFN0cmluZ3xGdW5jdGlvbnxSZWdFeHAuJylcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlTmV0Q29ubmVjdCAoKSB7XG4gICAgdGhpc1trTmV0Q29ubmVjdF0gPSBmYWxzZVxuICB9XG5cbiAgZW5hYmxlQ2FsbEhpc3RvcnkgKCkge1xuICAgIHRoaXNba01vY2tBZ2VudElzQ2FsbEhpc3RvcnlFbmFibGVkXSA9IHRydWVcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBkaXNhYmxlQ2FsbEhpc3RvcnkgKCkge1xuICAgIHRoaXNba01vY2tBZ2VudElzQ2FsbEhpc3RvcnlFbmFibGVkXSA9IGZhbHNlXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0Q2FsbEhpc3RvcnkgKCkge1xuICAgIHJldHVybiB0aGlzW2tNb2NrQWdlbnRNb2NrQ2FsbEhpc3RvcnlJbnN0YW5jZV1cbiAgfVxuXG4gIGNsZWFyQ2FsbEhpc3RvcnkgKCkge1xuICAgIGlmICh0aGlzW2tNb2NrQWdlbnRNb2NrQ2FsbEhpc3RvcnlJbnN0YW5jZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpc1trTW9ja0FnZW50TW9ja0NhbGxIaXN0b3J5SW5zdGFuY2VdLmNsZWFyKClcbiAgICB9XG4gIH1cblxuICAvLyBUaGlzIGlzIHJlcXVpcmVkIHRvIGJ5cGFzcyBpc3N1ZXMgY2F1c2VkIGJ5IHVzaW5nIGdsb2JhbCBzeW1ib2xzIC0gc2VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTQ0N1xuICBnZXQgaXNNb2NrQWN0aXZlICgpIHtcbiAgICByZXR1cm4gdGhpc1trSXNNb2NrQWN0aXZlXVxuICB9XG5cbiAgW2tNb2NrQWdlbnRSZWdpc3RlckNhbGxIaXN0b3J5XSAoKSB7XG4gICAgaWYgKHRoaXNba01vY2tBZ2VudE1vY2tDYWxsSGlzdG9yeUluc3RhbmNlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzW2tNb2NrQWdlbnRNb2NrQ2FsbEhpc3RvcnlJbnN0YW5jZV0gPSBuZXcgTW9ja0NhbGxIaXN0b3J5KClcbiAgICB9XG4gIH1cblxuICBba01vY2tBZ2VudEFkZENhbGxIaXN0b3J5TG9nXSAob3B0cykge1xuICAgIGlmICh0aGlzW2tNb2NrQWdlbnRJc0NhbGxIaXN0b3J5RW5hYmxlZF0pIHtcbiAgICAgIC8vIGFkZGl0aW9uYWwgc2V0dXAgd2hlbiBlbmFibGVDYWxsSGlzdG9yeSBjbGFzcyBtZXRob2QgaXMgdXNlZCBhZnRlciBtb2NrQWdlbnQgaW5zdGFudGlhdGlvblxuICAgICAgdGhpc1trTW9ja0FnZW50UmVnaXN0ZXJDYWxsSGlzdG9yeV0oKVxuXG4gICAgICAvLyBhZGQgY2FsbCBoaXN0b3J5IGxvZyBvbiBldmVyeSBjYWxsIChpbnRlcmNlcHRlZCBvciBub3QpXG4gICAgICB0aGlzW2tNb2NrQWdlbnRNb2NrQ2FsbEhpc3RvcnlJbnN0YW5jZV1ba01vY2tDYWxsSGlzdG9yeUFkZExvZ10ob3B0cylcbiAgICB9XG4gIH1cblxuICBba01vY2tBZ2VudFNldF0gKG9yaWdpbiwgZGlzcGF0Y2hlcikge1xuICAgIHRoaXNba0NsaWVudHNdLnNldChvcmlnaW4sIHsgY291bnQ6IDAsIGRpc3BhdGNoZXIgfSlcbiAgfVxuXG4gIFtrRmFjdG9yeV0gKG9yaWdpbikge1xuICAgIGNvbnN0IG1vY2tPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGFnZW50OiB0aGlzIH0sIHRoaXNba09wdGlvbnNdKVxuICAgIHJldHVybiB0aGlzW2tPcHRpb25zXSAmJiB0aGlzW2tPcHRpb25zXS5jb25uZWN0aW9ucyA9PT0gMVxuICAgICAgPyBuZXcgTW9ja0NsaWVudChvcmlnaW4sIG1vY2tPcHRpb25zKVxuICAgICAgOiBuZXcgTW9ja1Bvb2wob3JpZ2luLCBtb2NrT3B0aW9ucylcbiAgfVxuXG4gIFtrTW9ja0FnZW50R2V0XSAob3JpZ2luKSB7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgd2UgY2FuIGltbWVkaWF0ZWx5IGZpbmQgaXRcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzW2tDbGllbnRzXS5nZXQob3JpZ2luKVxuICAgIGlmIChyZXN1bHQ/LmRpc3BhdGNoZXIpIHtcbiAgICAgIHJldHVybiByZXN1bHQuZGlzcGF0Y2hlclxuICAgIH1cblxuICAgIC8vIElmIHRoZSBvcmlnaW4gaXMgbm90IGEgc3RyaW5nIGNyZWF0ZSBhIGR1bW15IHBhcmVudCBwb29sIGFuZCByZXR1cm4gdG8gdXNlclxuICAgIGlmICh0eXBlb2Ygb3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKCdodHRwOi8vbG9jYWxob3N0Ojk5OTknKVxuICAgICAgdGhpc1trTW9ja0FnZW50U2V0XShvcmlnaW4sIGRpc3BhdGNoZXIpXG4gICAgICByZXR1cm4gZGlzcGF0Y2hlclxuICAgIH1cblxuICAgIC8vIElmIHdlIG1hdGNoLCBjcmVhdGUgYSBwb29sIGFuZCBhc3NpZ24gdGhlIHNhbWUgZGlzcGF0Y2hlc1xuICAgIGZvciAoY29uc3QgW2tleU1hdGNoZXIsIHJlc3VsdF0gb2YgQXJyYXkuZnJvbSh0aGlzW2tDbGllbnRzXSkpIHtcbiAgICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIGtleU1hdGNoZXIgIT09ICdzdHJpbmcnICYmIG1hdGNoVmFsdWUoa2V5TWF0Y2hlciwgb3JpZ2luKSkge1xuICAgICAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0ob3JpZ2luKVxuICAgICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbiwgZGlzcGF0Y2hlcilcbiAgICAgICAgZGlzcGF0Y2hlcltrRGlzcGF0Y2hlc10gPSByZXN1bHQuZGlzcGF0Y2hlcltrRGlzcGF0Y2hlc11cbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBba0dldE5ldENvbm5lY3RdICgpIHtcbiAgICByZXR1cm4gdGhpc1trTmV0Q29ubmVjdF1cbiAgfVxuXG4gIHBlbmRpbmdJbnRlcmNlcHRvcnMgKCkge1xuICAgIGNvbnN0IG1vY2tBZ2VudENsaWVudHMgPSB0aGlzW2tDbGllbnRzXVxuXG4gICAgcmV0dXJuIEFycmF5LmZyb20obW9ja0FnZW50Q2xpZW50cy5lbnRyaWVzKCkpXG4gICAgICAuZmxhdE1hcCgoW29yaWdpbiwgcmVzdWx0XSkgPT4gcmVzdWx0LmRpc3BhdGNoZXJba0Rpc3BhdGNoZXNdLm1hcChkaXNwYXRjaCA9PiAoeyAuLi5kaXNwYXRjaCwgb3JpZ2luIH0pKSlcbiAgICAgIC5maWx0ZXIoKHsgcGVuZGluZyB9KSA9PiBwZW5kaW5nKVxuICB9XG5cbiAgYXNzZXJ0Tm9QZW5kaW5nSW50ZXJjZXB0b3JzICh7IHBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIgPSBuZXcgUGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlcigpIH0gPSB7fSkge1xuICAgIGNvbnN0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdJbnRlcmNlcHRvcnMoKVxuXG4gICAgaWYgKHBlbmRpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVW5kaWNpRXJyb3IoXG4gICAgICBwZW5kaW5nLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IGAxIGludGVyY2VwdG9yIGlzIHBlbmRpbmc6XFxuXFxuJHtwZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyLmZvcm1hdChwZW5kaW5nKX1gLnRyaW0oKVxuICAgICAgICA6IGAke3BlbmRpbmcubGVuZ3RofSBpbnRlcmNlcHRvcnMgYXJlIHBlbmRpbmc6XFxuXFxuJHtwZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyLmZvcm1hdChwZW5kaW5nKX1gLnRyaW0oKVxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vY2tBZ2VudFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-call-history.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-call-history.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { kMockCallHistoryAddLog } = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nfunction handleFilterCallsWithOptions (criteria, options, handler, store) {\n  switch (options.operator) {\n    case 'OR':\n      store.push(...handler(criteria))\n\n      return store\n    case 'AND':\n      return handler.call({ logs: store }, criteria)\n    default:\n      // guard -- should never happens because buildAndValidateFilterCallsOptions is called before\n      throw new InvalidArgumentError('options.operator must to be a case insensitive string equal to \\'OR\\' or \\'AND\\'')\n  }\n}\n\nfunction buildAndValidateFilterCallsOptions (options = {}) {\n  const finalOptions = {}\n\n  if ('operator' in options) {\n    if (typeof options.operator !== 'string' || (options.operator.toUpperCase() !== 'OR' && options.operator.toUpperCase() !== 'AND')) {\n      throw new InvalidArgumentError('options.operator must to be a case insensitive string equal to \\'OR\\' or \\'AND\\'')\n    }\n\n    return {\n      ...finalOptions,\n      operator: options.operator.toUpperCase()\n    }\n  }\n\n  return finalOptions\n}\n\nfunction makeFilterCalls (parameterName) {\n  return (parameterValue) => {\n    if (typeof parameterValue === 'string' || parameterValue == null) {\n      return this.logs.filter((log) => {\n        return log[parameterName] === parameterValue\n      })\n    }\n    if (parameterValue instanceof RegExp) {\n      return this.logs.filter((log) => {\n        return parameterValue.test(log[parameterName])\n      })\n    }\n\n    throw new InvalidArgumentError(`${parameterName} parameter should be one of string, regexp, undefined or null`)\n  }\n}\nfunction computeUrlWithMaybeSearchParameters (requestInit) {\n  // path can contains query url parameters\n  // or query can contains query url parameters\n  try {\n    const url = new URL(requestInit.path, requestInit.origin)\n\n    // requestInit.path contains query url parameters\n    // requestInit.query is then undefined\n    if (url.search.length !== 0) {\n      return url\n    }\n\n    // requestInit.query can be populated here\n    url.search = new URLSearchParams(requestInit.query).toString()\n\n    return url\n  } catch (error) {\n    throw new InvalidArgumentError('An error occurred when computing MockCallHistoryLog.url', { cause: error })\n  }\n}\n\nclass MockCallHistoryLog {\n  constructor (requestInit = {}) {\n    this.body = requestInit.body\n    this.headers = requestInit.headers\n    this.method = requestInit.method\n\n    const url = computeUrlWithMaybeSearchParameters(requestInit)\n\n    this.fullUrl = url.toString()\n    this.origin = url.origin\n    this.path = url.pathname\n    this.searchParams = Object.fromEntries(url.searchParams)\n    this.protocol = url.protocol\n    this.host = url.host\n    this.port = url.port\n    this.hash = url.hash\n  }\n\n  toMap () {\n    return new Map([\n      ['protocol', this.protocol],\n      ['host', this.host],\n      ['port', this.port],\n      ['origin', this.origin],\n      ['path', this.path],\n      ['hash', this.hash],\n      ['searchParams', this.searchParams],\n      ['fullUrl', this.fullUrl],\n      ['method', this.method],\n      ['body', this.body],\n      ['headers', this.headers]]\n    )\n  }\n\n  toString () {\n    const options = { betweenKeyValueSeparator: '->', betweenPairSeparator: '|' }\n    let result = ''\n\n    this.toMap().forEach((value, key) => {\n      if (typeof value === 'string' || value === undefined || value === null) {\n        result = `${result}${key}${options.betweenKeyValueSeparator}${value}${options.betweenPairSeparator}`\n      }\n      if ((typeof value === 'object' && value !== null) || Array.isArray(value)) {\n        result = `${result}${key}${options.betweenKeyValueSeparator}${JSON.stringify(value)}${options.betweenPairSeparator}`\n      }\n      // maybe miss something for non Record / Array headers and searchParams here\n    })\n\n    // delete last betweenPairSeparator\n    return result.slice(0, -1)\n  }\n}\n\nclass MockCallHistory {\n  logs = []\n\n  calls () {\n    return this.logs\n  }\n\n  firstCall () {\n    return this.logs.at(0)\n  }\n\n  lastCall () {\n    return this.logs.at(-1)\n  }\n\n  nthCall (number) {\n    if (typeof number !== 'number') {\n      throw new InvalidArgumentError('nthCall must be called with a number')\n    }\n    if (!Number.isInteger(number)) {\n      throw new InvalidArgumentError('nthCall must be called with an integer')\n    }\n    if (Math.sign(number) !== 1) {\n      throw new InvalidArgumentError('nthCall must be called with a positive value. use firstCall or lastCall instead')\n    }\n\n    // non zero based index. this is more human readable\n    return this.logs.at(number - 1)\n  }\n\n  filterCalls (criteria, options) {\n    // perf\n    if (this.logs.length === 0) {\n      return this.logs\n    }\n    if (typeof criteria === 'function') {\n      return this.logs.filter(criteria)\n    }\n    if (criteria instanceof RegExp) {\n      return this.logs.filter((log) => {\n        return criteria.test(log.toString())\n      })\n    }\n    if (typeof criteria === 'object' && criteria !== null) {\n      // no criteria - returning all logs\n      if (Object.keys(criteria).length === 0) {\n        return this.logs\n      }\n\n      const finalOptions = { operator: 'OR', ...buildAndValidateFilterCallsOptions(options) }\n\n      let maybeDuplicatedLogsFiltered = []\n      if ('protocol' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.protocol, finalOptions, this.filterCallsByProtocol, maybeDuplicatedLogsFiltered)\n      }\n      if ('host' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.host, finalOptions, this.filterCallsByHost, maybeDuplicatedLogsFiltered)\n      }\n      if ('port' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.port, finalOptions, this.filterCallsByPort, maybeDuplicatedLogsFiltered)\n      }\n      if ('origin' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.origin, finalOptions, this.filterCallsByOrigin, maybeDuplicatedLogsFiltered)\n      }\n      if ('path' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.path, finalOptions, this.filterCallsByPath, maybeDuplicatedLogsFiltered)\n      }\n      if ('hash' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.hash, finalOptions, this.filterCallsByHash, maybeDuplicatedLogsFiltered)\n      }\n      if ('fullUrl' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.fullUrl, finalOptions, this.filterCallsByFullUrl, maybeDuplicatedLogsFiltered)\n      }\n      if ('method' in criteria) {\n        maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.method, finalOptions, this.filterCallsByMethod, maybeDuplicatedLogsFiltered)\n      }\n\n      const uniqLogsFiltered = [...new Set(maybeDuplicatedLogsFiltered)]\n\n      return uniqLogsFiltered\n    }\n\n    throw new InvalidArgumentError('criteria parameter should be one of function, regexp, or object')\n  }\n\n  filterCallsByProtocol = makeFilterCalls.call(this, 'protocol')\n\n  filterCallsByHost = makeFilterCalls.call(this, 'host')\n\n  filterCallsByPort = makeFilterCalls.call(this, 'port')\n\n  filterCallsByOrigin = makeFilterCalls.call(this, 'origin')\n\n  filterCallsByPath = makeFilterCalls.call(this, 'path')\n\n  filterCallsByHash = makeFilterCalls.call(this, 'hash')\n\n  filterCallsByFullUrl = makeFilterCalls.call(this, 'fullUrl')\n\n  filterCallsByMethod = makeFilterCalls.call(this, 'method')\n\n  clear () {\n    this.logs = []\n  }\n\n  [kMockCallHistoryAddLog] (requestInit) {\n    const log = new MockCallHistoryLog(requestInit)\n\n    this.logs.push(log)\n\n    return log\n  }\n\n  * [Symbol.iterator] () {\n    for (const log of this.calls()) {\n      yield log\n    }\n  }\n}\n\nmodule.exports.MockCallHistory = MockCallHistory\nmodule.exports.MockCallHistoryLog = MockCallHistoryLog\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stY2FsbC1oaXN0b3J5LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEseUJBQXlCLEVBQUUsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDM0QsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLHNDQUFzQyxlQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSixnR0FBZ0csY0FBYztBQUM5RztBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTyxFQUFFLElBQUksRUFBRSxpQ0FBaUMsRUFBRSxNQUFNLEVBQUUsNkJBQTZCO0FBQzNHO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTyxFQUFFLElBQUksRUFBRSxpQ0FBaUMsRUFBRSxzQkFBc0IsRUFBRSw2QkFBNkI7QUFDM0g7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLGlDQUFpQyIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stY2FsbC1oaXN0b3J5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtNb2NrQ2FsbEhpc3RvcnlBZGRMb2cgfSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuZnVuY3Rpb24gaGFuZGxlRmlsdGVyQ2FsbHNXaXRoT3B0aW9ucyAoY3JpdGVyaWEsIG9wdGlvbnMsIGhhbmRsZXIsIHN0b3JlKSB7XG4gIHN3aXRjaCAob3B0aW9ucy5vcGVyYXRvcikge1xuICAgIGNhc2UgJ09SJzpcbiAgICAgIHN0b3JlLnB1c2goLi4uaGFuZGxlcihjcml0ZXJpYSkpXG5cbiAgICAgIHJldHVybiBzdG9yZVxuICAgIGNhc2UgJ0FORCc6XG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHsgbG9nczogc3RvcmUgfSwgY3JpdGVyaWEpXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGd1YXJkIC0tIHNob3VsZCBuZXZlciBoYXBwZW5zIGJlY2F1c2UgYnVpbGRBbmRWYWxpZGF0ZUZpbHRlckNhbGxzT3B0aW9ucyBpcyBjYWxsZWQgYmVmb3JlXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdGlvbnMub3BlcmF0b3IgbXVzdCB0byBiZSBhIGNhc2UgaW5zZW5zaXRpdmUgc3RyaW5nIGVxdWFsIHRvIFxcJ09SXFwnIG9yIFxcJ0FORFxcJycpXG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRBbmRWYWxpZGF0ZUZpbHRlckNhbGxzT3B0aW9ucyAob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGZpbmFsT3B0aW9ucyA9IHt9XG5cbiAgaWYgKCdvcGVyYXRvcicgaW4gb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5vcGVyYXRvciAhPT0gJ3N0cmluZycgfHwgKG9wdGlvbnMub3BlcmF0b3IudG9VcHBlckNhc2UoKSAhPT0gJ09SJyAmJiBvcHRpb25zLm9wZXJhdG9yLnRvVXBwZXJDYXNlKCkgIT09ICdBTkQnKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRpb25zLm9wZXJhdG9yIG11c3QgdG8gYmUgYSBjYXNlIGluc2Vuc2l0aXZlIHN0cmluZyBlcXVhbCB0byBcXCdPUlxcJyBvciBcXCdBTkRcXCcnKVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5maW5hbE9wdGlvbnMsXG4gICAgICBvcGVyYXRvcjogb3B0aW9ucy5vcGVyYXRvci50b1VwcGVyQ2FzZSgpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsT3B0aW9uc1xufVxuXG5mdW5jdGlvbiBtYWtlRmlsdGVyQ2FsbHMgKHBhcmFtZXRlck5hbWUpIHtcbiAgcmV0dXJuIChwYXJhbWV0ZXJWYWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcGFyYW1ldGVyVmFsdWUgPT09ICdzdHJpbmcnIHx8IHBhcmFtZXRlclZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvZ3MuZmlsdGVyKChsb2cpID0+IHtcbiAgICAgICAgcmV0dXJuIGxvZ1twYXJhbWV0ZXJOYW1lXSA9PT0gcGFyYW1ldGVyVmFsdWVcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXJWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRoaXMubG9ncy5maWx0ZXIoKGxvZykgPT4ge1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVyVmFsdWUudGVzdChsb2dbcGFyYW1ldGVyTmFtZV0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgJHtwYXJhbWV0ZXJOYW1lfSBwYXJhbWV0ZXIgc2hvdWxkIGJlIG9uZSBvZiBzdHJpbmcsIHJlZ2V4cCwgdW5kZWZpbmVkIG9yIG51bGxgKVxuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlVXJsV2l0aE1heWJlU2VhcmNoUGFyYW1ldGVycyAocmVxdWVzdEluaXQpIHtcbiAgLy8gcGF0aCBjYW4gY29udGFpbnMgcXVlcnkgdXJsIHBhcmFtZXRlcnNcbiAgLy8gb3IgcXVlcnkgY2FuIGNvbnRhaW5zIHF1ZXJ5IHVybCBwYXJhbWV0ZXJzXG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXF1ZXN0SW5pdC5wYXRoLCByZXF1ZXN0SW5pdC5vcmlnaW4pXG5cbiAgICAvLyByZXF1ZXN0SW5pdC5wYXRoIGNvbnRhaW5zIHF1ZXJ5IHVybCBwYXJhbWV0ZXJzXG4gICAgLy8gcmVxdWVzdEluaXQucXVlcnkgaXMgdGhlbiB1bmRlZmluZWRcbiAgICBpZiAodXJsLnNlYXJjaC5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldHVybiB1cmxcbiAgICB9XG5cbiAgICAvLyByZXF1ZXN0SW5pdC5xdWVyeSBjYW4gYmUgcG9wdWxhdGVkIGhlcmVcbiAgICB1cmwuc2VhcmNoID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhyZXF1ZXN0SW5pdC5xdWVyeSkudG9TdHJpbmcoKVxuXG4gICAgcmV0dXJuIHVybFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiBjb21wdXRpbmcgTW9ja0NhbGxIaXN0b3J5TG9nLnVybCcsIHsgY2F1c2U6IGVycm9yIH0pXG4gIH1cbn1cblxuY2xhc3MgTW9ja0NhbGxIaXN0b3J5TG9nIHtcbiAgY29uc3RydWN0b3IgKHJlcXVlc3RJbml0ID0ge30pIHtcbiAgICB0aGlzLmJvZHkgPSByZXF1ZXN0SW5pdC5ib2R5XG4gICAgdGhpcy5oZWFkZXJzID0gcmVxdWVzdEluaXQuaGVhZGVyc1xuICAgIHRoaXMubWV0aG9kID0gcmVxdWVzdEluaXQubWV0aG9kXG5cbiAgICBjb25zdCB1cmwgPSBjb21wdXRlVXJsV2l0aE1heWJlU2VhcmNoUGFyYW1ldGVycyhyZXF1ZXN0SW5pdClcblxuICAgIHRoaXMuZnVsbFVybCA9IHVybC50b1N0cmluZygpXG4gICAgdGhpcy5vcmlnaW4gPSB1cmwub3JpZ2luXG4gICAgdGhpcy5wYXRoID0gdXJsLnBhdGhuYW1lXG4gICAgdGhpcy5zZWFyY2hQYXJhbXMgPSBPYmplY3QuZnJvbUVudHJpZXModXJsLnNlYXJjaFBhcmFtcylcbiAgICB0aGlzLnByb3RvY29sID0gdXJsLnByb3RvY29sXG4gICAgdGhpcy5ob3N0ID0gdXJsLmhvc3RcbiAgICB0aGlzLnBvcnQgPSB1cmwucG9ydFxuICAgIHRoaXMuaGFzaCA9IHVybC5oYXNoXG4gIH1cblxuICB0b01hcCAoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoW1xuICAgICAgWydwcm90b2NvbCcsIHRoaXMucHJvdG9jb2xdLFxuICAgICAgWydob3N0JywgdGhpcy5ob3N0XSxcbiAgICAgIFsncG9ydCcsIHRoaXMucG9ydF0sXG4gICAgICBbJ29yaWdpbicsIHRoaXMub3JpZ2luXSxcbiAgICAgIFsncGF0aCcsIHRoaXMucGF0aF0sXG4gICAgICBbJ2hhc2gnLCB0aGlzLmhhc2hdLFxuICAgICAgWydzZWFyY2hQYXJhbXMnLCB0aGlzLnNlYXJjaFBhcmFtc10sXG4gICAgICBbJ2Z1bGxVcmwnLCB0aGlzLmZ1bGxVcmxdLFxuICAgICAgWydtZXRob2QnLCB0aGlzLm1ldGhvZF0sXG4gICAgICBbJ2JvZHknLCB0aGlzLmJvZHldLFxuICAgICAgWydoZWFkZXJzJywgdGhpcy5oZWFkZXJzXV1cbiAgICApXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgYmV0d2VlbktleVZhbHVlU2VwYXJhdG9yOiAnLT4nLCBiZXR3ZWVuUGFpclNlcGFyYXRvcjogJ3wnIH1cbiAgICBsZXQgcmVzdWx0ID0gJydcblxuICAgIHRoaXMudG9NYXAoKS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IGAke3Jlc3VsdH0ke2tleX0ke29wdGlvbnMuYmV0d2VlbktleVZhbHVlU2VwYXJhdG9yfSR7dmFsdWV9JHtvcHRpb25zLmJldHdlZW5QYWlyU2VwYXJhdG9yfWBcbiAgICAgIH1cbiAgICAgIGlmICgodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0ID0gYCR7cmVzdWx0fSR7a2V5fSR7b3B0aW9ucy5iZXR3ZWVuS2V5VmFsdWVTZXBhcmF0b3J9JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9JHtvcHRpb25zLmJldHdlZW5QYWlyU2VwYXJhdG9yfWBcbiAgICAgIH1cbiAgICAgIC8vIG1heWJlIG1pc3Mgc29tZXRoaW5nIGZvciBub24gUmVjb3JkIC8gQXJyYXkgaGVhZGVycyBhbmQgc2VhcmNoUGFyYW1zIGhlcmVcbiAgICB9KVxuXG4gICAgLy8gZGVsZXRlIGxhc3QgYmV0d2VlblBhaXJTZXBhcmF0b3JcbiAgICByZXR1cm4gcmVzdWx0LnNsaWNlKDAsIC0xKVxuICB9XG59XG5cbmNsYXNzIE1vY2tDYWxsSGlzdG9yeSB7XG4gIGxvZ3MgPSBbXVxuXG4gIGNhbGxzICgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2dzXG4gIH1cblxuICBmaXJzdENhbGwgKCkge1xuICAgIHJldHVybiB0aGlzLmxvZ3MuYXQoMClcbiAgfVxuXG4gIGxhc3RDYWxsICgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2dzLmF0KC0xKVxuICB9XG5cbiAgbnRoQ2FsbCAobnVtYmVyKSB7XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ250aENhbGwgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIG51bWJlcicpXG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ250aENhbGwgbXVzdCBiZSBjYWxsZWQgd2l0aCBhbiBpbnRlZ2VyJylcbiAgICB9XG4gICAgaWYgKE1hdGguc2lnbihudW1iZXIpICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ250aENhbGwgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIHBvc2l0aXZlIHZhbHVlLiB1c2UgZmlyc3RDYWxsIG9yIGxhc3RDYWxsIGluc3RlYWQnKVxuICAgIH1cblxuICAgIC8vIG5vbiB6ZXJvIGJhc2VkIGluZGV4LiB0aGlzIGlzIG1vcmUgaHVtYW4gcmVhZGFibGVcbiAgICByZXR1cm4gdGhpcy5sb2dzLmF0KG51bWJlciAtIDEpXG4gIH1cblxuICBmaWx0ZXJDYWxscyAoY3JpdGVyaWEsIG9wdGlvbnMpIHtcbiAgICAvLyBwZXJmXG4gICAgaWYgKHRoaXMubG9ncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmxvZ3NcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjcml0ZXJpYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMubG9ncy5maWx0ZXIoY3JpdGVyaWEpXG4gICAgfVxuICAgIGlmIChjcml0ZXJpYSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRoaXMubG9ncy5maWx0ZXIoKGxvZykgPT4ge1xuICAgICAgICByZXR1cm4gY3JpdGVyaWEudGVzdChsb2cudG9TdHJpbmcoKSlcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3JpdGVyaWEgPT09ICdvYmplY3QnICYmIGNyaXRlcmlhICE9PSBudWxsKSB7XG4gICAgICAvLyBubyBjcml0ZXJpYSAtIHJldHVybmluZyBhbGwgbG9nc1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGNyaXRlcmlhKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nc1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSB7IG9wZXJhdG9yOiAnT1InLCAuLi5idWlsZEFuZFZhbGlkYXRlRmlsdGVyQ2FsbHNPcHRpb25zKG9wdGlvbnMpIH1cblxuICAgICAgbGV0IG1heWJlRHVwbGljYXRlZExvZ3NGaWx0ZXJlZCA9IFtdXG4gICAgICBpZiAoJ3Byb3RvY29sJyBpbiBjcml0ZXJpYSkge1xuICAgICAgICBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQgPSBoYW5kbGVGaWx0ZXJDYWxsc1dpdGhPcHRpb25zKGNyaXRlcmlhLnByb3RvY29sLCBmaW5hbE9wdGlvbnMsIHRoaXMuZmlsdGVyQ2FsbHNCeVByb3RvY29sLCBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXG4gICAgICB9XG4gICAgICBpZiAoJ2hvc3QnIGluIGNyaXRlcmlhKSB7XG4gICAgICAgIG1heWJlRHVwbGljYXRlZExvZ3NGaWx0ZXJlZCA9IGhhbmRsZUZpbHRlckNhbGxzV2l0aE9wdGlvbnMoY3JpdGVyaWEuaG9zdCwgZmluYWxPcHRpb25zLCB0aGlzLmZpbHRlckNhbGxzQnlIb3N0LCBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXG4gICAgICB9XG4gICAgICBpZiAoJ3BvcnQnIGluIGNyaXRlcmlhKSB7XG4gICAgICAgIG1heWJlRHVwbGljYXRlZExvZ3NGaWx0ZXJlZCA9IGhhbmRsZUZpbHRlckNhbGxzV2l0aE9wdGlvbnMoY3JpdGVyaWEucG9ydCwgZmluYWxPcHRpb25zLCB0aGlzLmZpbHRlckNhbGxzQnlQb3J0LCBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXG4gICAgICB9XG4gICAgICBpZiAoJ29yaWdpbicgaW4gY3JpdGVyaWEpIHtcbiAgICAgICAgbWF5YmVEdXBsaWNhdGVkTG9nc0ZpbHRlcmVkID0gaGFuZGxlRmlsdGVyQ2FsbHNXaXRoT3B0aW9ucyhjcml0ZXJpYS5vcmlnaW4sIGZpbmFsT3B0aW9ucywgdGhpcy5maWx0ZXJDYWxsc0J5T3JpZ2luLCBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXG4gICAgICB9XG4gICAgICBpZiAoJ3BhdGgnIGluIGNyaXRlcmlhKSB7XG4gICAgICAgIG1heWJlRHVwbGljYXRlZExvZ3NGaWx0ZXJlZCA9IGhhbmRsZUZpbHRlckNhbGxzV2l0aE9wdGlvbnMoY3JpdGVyaWEucGF0aCwgZmluYWxPcHRpb25zLCB0aGlzLmZpbHRlckNhbGxzQnlQYXRoLCBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXG4gICAgICB9XG4gICAgICBpZiAoJ2hhc2gnIGluIGNyaXRlcmlhKSB7XG4gICAgICAgIG1heWJlRHVwbGljYXRlZExvZ3NGaWx0ZXJlZCA9IGhhbmRsZUZpbHRlckNhbGxzV2l0aE9wdGlvbnMoY3JpdGVyaWEuaGFzaCwgZmluYWxPcHRpb25zLCB0aGlzLmZpbHRlckNhbGxzQnlIYXNoLCBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXG4gICAgICB9XG4gICAgICBpZiAoJ2Z1bGxVcmwnIGluIGNyaXRlcmlhKSB7XG4gICAgICAgIG1heWJlRHVwbGljYXRlZExvZ3NGaWx0ZXJlZCA9IGhhbmRsZUZpbHRlckNhbGxzV2l0aE9wdGlvbnMoY3JpdGVyaWEuZnVsbFVybCwgZmluYWxPcHRpb25zLCB0aGlzLmZpbHRlckNhbGxzQnlGdWxsVXJsLCBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXG4gICAgICB9XG4gICAgICBpZiAoJ21ldGhvZCcgaW4gY3JpdGVyaWEpIHtcbiAgICAgICAgbWF5YmVEdXBsaWNhdGVkTG9nc0ZpbHRlcmVkID0gaGFuZGxlRmlsdGVyQ2FsbHNXaXRoT3B0aW9ucyhjcml0ZXJpYS5tZXRob2QsIGZpbmFsT3B0aW9ucywgdGhpcy5maWx0ZXJDYWxsc0J5TWV0aG9kLCBtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVuaXFMb2dzRmlsdGVyZWQgPSBbLi4ubmV3IFNldChtYXliZUR1cGxpY2F0ZWRMb2dzRmlsdGVyZWQpXVxuXG4gICAgICByZXR1cm4gdW5pcUxvZ3NGaWx0ZXJlZFxuICAgIH1cblxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignY3JpdGVyaWEgcGFyYW1ldGVyIHNob3VsZCBiZSBvbmUgb2YgZnVuY3Rpb24sIHJlZ2V4cCwgb3Igb2JqZWN0JylcbiAgfVxuXG4gIGZpbHRlckNhbGxzQnlQcm90b2NvbCA9IG1ha2VGaWx0ZXJDYWxscy5jYWxsKHRoaXMsICdwcm90b2NvbCcpXG5cbiAgZmlsdGVyQ2FsbHNCeUhvc3QgPSBtYWtlRmlsdGVyQ2FsbHMuY2FsbCh0aGlzLCAnaG9zdCcpXG5cbiAgZmlsdGVyQ2FsbHNCeVBvcnQgPSBtYWtlRmlsdGVyQ2FsbHMuY2FsbCh0aGlzLCAncG9ydCcpXG5cbiAgZmlsdGVyQ2FsbHNCeU9yaWdpbiA9IG1ha2VGaWx0ZXJDYWxscy5jYWxsKHRoaXMsICdvcmlnaW4nKVxuXG4gIGZpbHRlckNhbGxzQnlQYXRoID0gbWFrZUZpbHRlckNhbGxzLmNhbGwodGhpcywgJ3BhdGgnKVxuXG4gIGZpbHRlckNhbGxzQnlIYXNoID0gbWFrZUZpbHRlckNhbGxzLmNhbGwodGhpcywgJ2hhc2gnKVxuXG4gIGZpbHRlckNhbGxzQnlGdWxsVXJsID0gbWFrZUZpbHRlckNhbGxzLmNhbGwodGhpcywgJ2Z1bGxVcmwnKVxuXG4gIGZpbHRlckNhbGxzQnlNZXRob2QgPSBtYWtlRmlsdGVyQ2FsbHMuY2FsbCh0aGlzLCAnbWV0aG9kJylcblxuICBjbGVhciAoKSB7XG4gICAgdGhpcy5sb2dzID0gW11cbiAgfVxuXG4gIFtrTW9ja0NhbGxIaXN0b3J5QWRkTG9nXSAocmVxdWVzdEluaXQpIHtcbiAgICBjb25zdCBsb2cgPSBuZXcgTW9ja0NhbGxIaXN0b3J5TG9nKHJlcXVlc3RJbml0KVxuXG4gICAgdGhpcy5sb2dzLnB1c2gobG9nKVxuXG4gICAgcmV0dXJuIGxvZ1xuICB9XG5cbiAgKiBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgZm9yIChjb25zdCBsb2cgb2YgdGhpcy5jYWxscygpKSB7XG4gICAgICB5aWVsZCBsb2dcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuTW9ja0NhbGxIaXN0b3J5ID0gTW9ja0NhbGxIaXN0b3J5XG5tb2R1bGUuZXhwb3J0cy5Nb2NrQ2FsbEhpc3RvcnlMb2cgPSBNb2NrQ2FsbEhpc3RvcnlMb2dcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-call-history.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-client.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-client.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { promisify } = __webpack_require__(/*! node:util */ \"node:util\")\nconst Client = __webpack_require__(/*! ../dispatcher/client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected,\n  kIgnoreTrailingSlash\n} = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(rsc)/./node_modules/undici/lib/mock/mock-interceptor.js\")\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\n/**\n * MockClient provides an API that extends the Client to influence the mockDispatches.\n */\nclass MockClient extends Client {\n  constructor (origin, opts) {\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    super(origin, opts)\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(\n      opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts },\n      this[kDispatches]\n    )\n  }\n\n  cleanMocks () {\n    this[kDispatches] = []\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockClient\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDekMsZUFBZSxtQkFBTyxDQUFDLGtGQUFzQjtBQUM3QyxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsd0VBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVCLFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDeEQsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQWlCO0FBQ3pDLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUEwRDtBQUMxRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcbmNvbnN0IENsaWVudCA9IHJlcXVpcmUoJy4uL2Rpc3BhdGNoZXIvY2xpZW50JylcbmNvbnN0IHsgYnVpbGRNb2NrRGlzcGF0Y2ggfSA9IHJlcXVpcmUoJy4vbW9jay11dGlscycpXG5jb25zdCB7XG4gIGtEaXNwYXRjaGVzLFxuICBrTW9ja0FnZW50LFxuICBrQ2xvc2UsXG4gIGtPcmlnaW5hbENsb3NlLFxuICBrT3JpZ2luLFxuICBrT3JpZ2luYWxEaXNwYXRjaCxcbiAga0Nvbm5lY3RlZCxcbiAga0lnbm9yZVRyYWlsaW5nU2xhc2hcbn0gPSByZXF1aXJlKCcuL21vY2stc3ltYm9scycpXG5jb25zdCB7IE1vY2tJbnRlcmNlcHRvciB9ID0gcmVxdWlyZSgnLi9tb2NrLWludGVyY2VwdG9yJylcbmNvbnN0IFN5bWJvbHMgPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuXG4vKipcbiAqIE1vY2tDbGllbnQgcHJvdmlkZXMgYW4gQVBJIHRoYXQgZXh0ZW5kcyB0aGUgQ2xpZW50IHRvIGluZmx1ZW5jZSB0aGUgbW9ja0Rpc3BhdGNoZXMuXG4gKi9cbmNsYXNzIE1vY2tDbGllbnQgZXh0ZW5kcyBDbGllbnQge1xuICBjb25zdHJ1Y3RvciAob3JpZ2luLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzIHx8ICFvcHRzLmFnZW50IHx8IHR5cGVvZiBvcHRzLmFnZW50LmRpc3BhdGNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0FyZ3VtZW50IG9wdHMuYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnQnKVxuICAgIH1cblxuICAgIHN1cGVyKG9yaWdpbiwgb3B0cylcblxuICAgIHRoaXNba01vY2tBZ2VudF0gPSBvcHRzLmFnZW50XG4gICAgdGhpc1trT3JpZ2luXSA9IG9yaWdpblxuICAgIHRoaXNba0lnbm9yZVRyYWlsaW5nU2xhc2hdID0gb3B0cy5pZ25vcmVUcmFpbGluZ1NsYXNoID8/IGZhbHNlXG4gICAgdGhpc1trRGlzcGF0Y2hlc10gPSBbXVxuICAgIHRoaXNba0Nvbm5lY3RlZF0gPSAxXG4gICAgdGhpc1trT3JpZ2luYWxEaXNwYXRjaF0gPSB0aGlzLmRpc3BhdGNoXG4gICAgdGhpc1trT3JpZ2luYWxDbG9zZV0gPSB0aGlzLmNsb3NlLmJpbmQodGhpcylcblxuICAgIHRoaXMuZGlzcGF0Y2ggPSBidWlsZE1vY2tEaXNwYXRjaC5jYWxsKHRoaXMpXG4gICAgdGhpcy5jbG9zZSA9IHRoaXNba0Nsb3NlXVxuICB9XG5cbiAgZ2V0IFtTeW1ib2xzLmtDb25uZWN0ZWRdICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ29ubmVjdGVkXVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIGJhc2UgaW50ZXJjZXB0b3IgZm9yIG1vY2tpbmcgcmVwbGllcyBmcm9tIHVuZGljaS5cbiAgICovXG4gIGludGVyY2VwdCAob3B0cykge1xuICAgIHJldHVybiBuZXcgTW9ja0ludGVyY2VwdG9yKFxuICAgICAgb3B0cyAmJiB7IGlnbm9yZVRyYWlsaW5nU2xhc2g6IHRoaXNba0lnbm9yZVRyYWlsaW5nU2xhc2hdLCAuLi5vcHRzIH0sXG4gICAgICB0aGlzW2tEaXNwYXRjaGVzXVxuICAgIClcbiAgfVxuXG4gIGNsZWFuTW9ja3MgKCkge1xuICAgIHRoaXNba0Rpc3BhdGNoZXNdID0gW11cbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBhd2FpdCBwcm9taXNpZnkodGhpc1trT3JpZ2luYWxDbG9zZV0pKClcbiAgICB0aGlzW2tDb25uZWN0ZWRdID0gMFxuICAgIHRoaXNba01vY2tBZ2VudF1bU3ltYm9scy5rQ2xpZW50c10uZGVsZXRlKHRoaXNba09yaWdpbl0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNb2NrQ2xpZW50XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-errors.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { UndiciError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\n/**\n * The request does not match any registered mock dispatches.\n */\nclass MockNotMatchedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'MockNotMatchedError'\n    this.message = message || 'The request does not match any registered mock dispatches'\n    this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED'\n  }\n}\n\nmodule.exports = {\n  MockNotMatchedError\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFVuZGljaUVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbi8qKlxuICogVGhlIHJlcXVlc3QgZG9lcyBub3QgbWF0Y2ggYW55IHJlZ2lzdGVyZWQgbW9jayBkaXNwYXRjaGVzLlxuICovXG5jbGFzcyBNb2NrTm90TWF0Y2hlZEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ01vY2tOb3RNYXRjaGVkRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVGhlIHJlcXVlc3QgZG9lcyBub3QgbWF0Y2ggYW55IHJlZ2lzdGVyZWQgbW9jayBkaXNwYXRjaGVzJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfTU9DS19FUlJfTU9DS19OT1RfTUFUQ0hFRCdcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTW9ja05vdE1hdGNoZWRFcnJvclxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-interceptor.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-interceptor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { getResponseData, buildKey, addMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kDispatchKey,\n  kDefaultHeaders,\n  kDefaultTrailers,\n  kContentLength,\n  kMockDispatch,\n  kIgnoreTrailingSlash\n} = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { serializePathWithQuery } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\n/**\n * Defines the scope API for an interceptor reply\n */\nclass MockScope {\n  constructor (mockDispatch) {\n    this[kMockDispatch] = mockDispatch\n  }\n\n  /**\n   * Delay a reply by a set amount in ms.\n   */\n  delay (waitInMs) {\n    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n      throw new InvalidArgumentError('waitInMs must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].delay = waitInMs\n    return this\n  }\n\n  /**\n   * For a defined reply, never mark as consumed.\n   */\n  persist () {\n    this[kMockDispatch].persist = true\n    return this\n  }\n\n  /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */\n  times (repeatTimes) {\n    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].times = repeatTimes\n    return this\n  }\n}\n\n/**\n * Defines an interceptor for a Mock\n */\nclass MockInterceptor {\n  constructor (opts, mockDispatches) {\n    if (typeof opts !== 'object') {\n      throw new InvalidArgumentError('opts must be an object')\n    }\n    if (typeof opts.path === 'undefined') {\n      throw new InvalidArgumentError('opts.path must be defined')\n    }\n    if (typeof opts.method === 'undefined') {\n      opts.method = 'GET'\n    }\n    // See https://github.com/nodejs/undici/issues/1245\n    // As per RFC 3986, clients are not supposed to send URI\n    // fragments to servers when they retrieve a document,\n    if (typeof opts.path === 'string') {\n      if (opts.query) {\n        opts.path = serializePathWithQuery(opts.path, opts.query)\n      } else {\n        // Matches https://github.com/nodejs/undici/blob/main/lib/web/fetch/index.js#L1811\n        const parsedURL = new URL(opts.path, 'data://')\n        opts.path = parsedURL.pathname + parsedURL.search\n      }\n    }\n    if (typeof opts.method === 'string') {\n      opts.method = opts.method.toUpperCase()\n    }\n\n    this[kDispatchKey] = buildKey(opts)\n    this[kDispatches] = mockDispatches\n    this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false\n    this[kDefaultHeaders] = {}\n    this[kDefaultTrailers] = {}\n    this[kContentLength] = false\n  }\n\n  createMockScopeDispatchData ({ statusCode, data, responseOptions }) {\n    const responseData = getResponseData(data)\n    const contentLength = this[kContentLength] ? { 'content-length': responseData.length } : {}\n    const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers }\n    const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers }\n\n    return { statusCode, data, headers, trailers }\n  }\n\n  validateReplyParameters (replyParameters) {\n    if (typeof replyParameters.statusCode === 'undefined') {\n      throw new InvalidArgumentError('statusCode must be defined')\n    }\n    if (typeof replyParameters.responseOptions !== 'object' || replyParameters.responseOptions === null) {\n      throw new InvalidArgumentError('responseOptions must be an object')\n    }\n  }\n\n  /**\n   * Mock an undici request with a defined reply.\n   */\n  reply (replyOptionsCallbackOrStatusCode) {\n    // Values of reply aren't available right now as they\n    // can only be available when the reply callback is invoked.\n    if (typeof replyOptionsCallbackOrStatusCode === 'function') {\n      // We'll first wrap the provided callback in another function,\n      // this function will properly resolve the data from the callback\n      // when invoked.\n      const wrappedDefaultsCallback = (opts) => {\n        // Our reply options callback contains the parameter for statusCode, data and options.\n        const resolvedData = replyOptionsCallbackOrStatusCode(opts)\n\n        // Check if it is in the right format\n        if (typeof resolvedData !== 'object' || resolvedData === null) {\n          throw new InvalidArgumentError('reply options callback must return an object')\n        }\n\n        const replyParameters = { data: '', responseOptions: {}, ...resolvedData }\n        this.validateReplyParameters(replyParameters)\n        // Since the values can be obtained immediately we return them\n        // from this higher order function that will be resolved later.\n        return {\n          ...this.createMockScopeDispatchData(replyParameters)\n        }\n      }\n\n      // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.\n      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] })\n      return new MockScope(newMockDispatch)\n    }\n\n    // We can have either one or three parameters, if we get here,\n    // we should have 1-3 parameters. So we spread the arguments of\n    // this function to obtain the parameters, since replyData will always\n    // just be the statusCode.\n    const replyParameters = {\n      statusCode: replyOptionsCallbackOrStatusCode,\n      data: arguments[1] === undefined ? '' : arguments[1],\n      responseOptions: arguments[2] === undefined ? {} : arguments[2]\n    }\n    this.validateReplyParameters(replyParameters)\n\n    // Send in-already provided data like usual\n    const dispatchData = this.createMockScopeDispatchData(replyParameters)\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] })\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Mock an undici request with a defined error.\n   */\n  replyWithError (error) {\n    if (typeof error === 'undefined') {\n      throw new InvalidArgumentError('error must be defined')\n    }\n\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error }, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] })\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */\n  defaultReplyHeaders (headers) {\n    if (typeof headers === 'undefined') {\n      throw new InvalidArgumentError('headers must be defined')\n    }\n\n    this[kDefaultHeaders] = headers\n    return this\n  }\n\n  /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */\n  defaultReplyTrailers (trailers) {\n    if (typeof trailers === 'undefined') {\n      throw new InvalidArgumentError('trailers must be defined')\n    }\n\n    this[kDefaultTrailers] = trailers\n    return this\n  }\n\n  /**\n   * Set reply content length header for replies on the interceptor\n   */\n  replyContentLength () {\n    this[kContentLength] = true\n    return this\n  }\n}\n\nmodule.exports.MockInterceptor = MockInterceptor\nmodule.exports.MockScope = MockScope\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2staW50ZXJjZXB0b3IuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSw2Q0FBNkMsRUFBRSxtQkFBTyxDQUFDLHdFQUFjO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUIsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN6RCxRQUFRLHlCQUF5QixFQUFFLG1CQUFPLENBQUMsa0VBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLG1DQUFtQztBQUNwRTtBQUNBLG1EQUFtRCx3Q0FBd0M7QUFDM0Ysc0JBQXNCO0FBQ3RCLHVCQUF1Qjs7QUFFdkIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLDZCQUE2QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdIQUFnSCxpREFBaUQ7QUFDaks7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtR0FBbUcsaURBQWlEO0FBQ3BKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUZBQXFGLE9BQU8sSUFBSSxpREFBaUQ7QUFDako7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLHdCQUF3QiIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2staW50ZXJjZXB0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgZ2V0UmVzcG9uc2VEYXRhLCBidWlsZEtleSwgYWRkTW9ja0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuL21vY2stdXRpbHMnKVxuY29uc3Qge1xuICBrRGlzcGF0Y2hlcyxcbiAga0Rpc3BhdGNoS2V5LFxuICBrRGVmYXVsdEhlYWRlcnMsXG4gIGtEZWZhdWx0VHJhaWxlcnMsXG4gIGtDb250ZW50TGVuZ3RoLFxuICBrTW9ja0Rpc3BhdGNoLFxuICBrSWdub3JlVHJhaWxpbmdTbGFzaFxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsgc2VyaWFsaXplUGF0aFdpdGhRdWVyeSB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBzY29wZSBBUEkgZm9yIGFuIGludGVyY2VwdG9yIHJlcGx5XG4gKi9cbmNsYXNzIE1vY2tTY29wZSB7XG4gIGNvbnN0cnVjdG9yIChtb2NrRGlzcGF0Y2gpIHtcbiAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdID0gbW9ja0Rpc3BhdGNoXG4gIH1cblxuICAvKipcbiAgICogRGVsYXkgYSByZXBseSBieSBhIHNldCBhbW91bnQgaW4gbXMuXG4gICAqL1xuICBkZWxheSAod2FpdEluTXMpIHtcbiAgICBpZiAodHlwZW9mIHdhaXRJbk1zICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcih3YWl0SW5NcykgfHwgd2FpdEluTXMgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd3YWl0SW5NcyBtdXN0IGJlIGEgdmFsaWQgaW50ZWdlciA+IDAnKVxuICAgIH1cblxuICAgIHRoaXNba01vY2tEaXNwYXRjaF0uZGVsYXkgPSB3YWl0SW5Nc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogRm9yIGEgZGVmaW5lZCByZXBseSwgbmV2ZXIgbWFyayBhcyBjb25zdW1lZC5cbiAgICovXG4gIHBlcnNpc3QgKCkge1xuICAgIHRoaXNba01vY2tEaXNwYXRjaF0ucGVyc2lzdCA9IHRydWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IG9uZSB0byBkZWZpbmUgYSByZXBseSBmb3IgYSBzZXQgYW1vdW50IG9mIG1hdGNoaW5nIHJlcXVlc3RzLlxuICAgKi9cbiAgdGltZXMgKHJlcGVhdFRpbWVzKSB7XG4gICAgaWYgKHR5cGVvZiByZXBlYXRUaW1lcyAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIocmVwZWF0VGltZXMpIHx8IHJlcGVhdFRpbWVzIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncmVwZWF0VGltZXMgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgPiAwJylcbiAgICB9XG5cbiAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdLnRpbWVzID0gcmVwZWF0VGltZXNcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbi8qKlxuICogRGVmaW5lcyBhbiBpbnRlcmNlcHRvciBmb3IgYSBNb2NrXG4gKi9cbmNsYXNzIE1vY2tJbnRlcmNlcHRvciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBtb2NrRGlzcGF0Y2hlcykge1xuICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignb3B0cyBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5wYXRoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzLnBhdGggbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLm1ldGhvZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdHMubWV0aG9kID0gJ0dFVCdcbiAgICB9XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xMjQ1XG4gICAgLy8gQXMgcGVyIFJGQyAzOTg2LCBjbGllbnRzIGFyZSBub3Qgc3VwcG9zZWQgdG8gc2VuZCBVUklcbiAgICAvLyBmcmFnbWVudHMgdG8gc2VydmVycyB3aGVuIHRoZXkgcmV0cmlldmUgYSBkb2N1bWVudCxcbiAgICBpZiAodHlwZW9mIG9wdHMucGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChvcHRzLnF1ZXJ5KSB7XG4gICAgICAgIG9wdHMucGF0aCA9IHNlcmlhbGl6ZVBhdGhXaXRoUXVlcnkob3B0cy5wYXRoLCBvcHRzLnF1ZXJ5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWF0Y2hlcyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9ibG9iL21haW4vbGliL3dlYi9mZXRjaC9pbmRleC5qcyNMMTgxMVxuICAgICAgICBjb25zdCBwYXJzZWRVUkwgPSBuZXcgVVJMKG9wdHMucGF0aCwgJ2RhdGE6Ly8nKVxuICAgICAgICBvcHRzLnBhdGggPSBwYXJzZWRVUkwucGF0aG5hbWUgKyBwYXJzZWRVUkwuc2VhcmNoXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRob2QgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRzLm1ldGhvZCA9IG9wdHMubWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICB9XG5cbiAgICB0aGlzW2tEaXNwYXRjaEtleV0gPSBidWlsZEtleShvcHRzKVxuICAgIHRoaXNba0Rpc3BhdGNoZXNdID0gbW9ja0Rpc3BhdGNoZXNcbiAgICB0aGlzW2tJZ25vcmVUcmFpbGluZ1NsYXNoXSA9IG9wdHMuaWdub3JlVHJhaWxpbmdTbGFzaCA/PyBmYWxzZVxuICAgIHRoaXNba0RlZmF1bHRIZWFkZXJzXSA9IHt9XG4gICAgdGhpc1trRGVmYXVsdFRyYWlsZXJzXSA9IHt9XG4gICAgdGhpc1trQ29udGVudExlbmd0aF0gPSBmYWxzZVxuICB9XG5cbiAgY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhICh7IHN0YXR1c0NvZGUsIGRhdGEsIHJlc3BvbnNlT3B0aW9ucyB9KSB7XG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gZ2V0UmVzcG9uc2VEYXRhKGRhdGEpXG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IHRoaXNba0NvbnRlbnRMZW5ndGhdID8geyAnY29udGVudC1sZW5ndGgnOiByZXNwb25zZURhdGEubGVuZ3RoIH0gOiB7fVxuICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXNba0RlZmF1bHRIZWFkZXJzXSwgLi4uY29udGVudExlbmd0aCwgLi4ucmVzcG9uc2VPcHRpb25zLmhlYWRlcnMgfVxuICAgIGNvbnN0IHRyYWlsZXJzID0geyAuLi50aGlzW2tEZWZhdWx0VHJhaWxlcnNdLCAuLi5yZXNwb25zZU9wdGlvbnMudHJhaWxlcnMgfVxuXG4gICAgcmV0dXJuIHsgc3RhdHVzQ29kZSwgZGF0YSwgaGVhZGVycywgdHJhaWxlcnMgfVxuICB9XG5cbiAgdmFsaWRhdGVSZXBseVBhcmFtZXRlcnMgKHJlcGx5UGFyYW1ldGVycykge1xuICAgIGlmICh0eXBlb2YgcmVwbHlQYXJhbWV0ZXJzLnN0YXR1c0NvZGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3N0YXR1c0NvZGUgbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXBseVBhcmFtZXRlcnMucmVzcG9uc2VPcHRpb25zICE9PSAnb2JqZWN0JyB8fCByZXBseVBhcmFtZXRlcnMucmVzcG9uc2VPcHRpb25zID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Jlc3BvbnNlT3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vY2sgYW4gdW5kaWNpIHJlcXVlc3Qgd2l0aCBhIGRlZmluZWQgcmVwbHkuXG4gICAqL1xuICByZXBseSAocmVwbHlPcHRpb25zQ2FsbGJhY2tPclN0YXR1c0NvZGUpIHtcbiAgICAvLyBWYWx1ZXMgb2YgcmVwbHkgYXJlbid0IGF2YWlsYWJsZSByaWdodCBub3cgYXMgdGhleVxuICAgIC8vIGNhbiBvbmx5IGJlIGF2YWlsYWJsZSB3aGVuIHRoZSByZXBseSBjYWxsYmFjayBpcyBpbnZva2VkLlxuICAgIGlmICh0eXBlb2YgcmVwbHlPcHRpb25zQ2FsbGJhY2tPclN0YXR1c0NvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFdlJ2xsIGZpcnN0IHdyYXAgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGluIGFub3RoZXIgZnVuY3Rpb24sXG4gICAgICAvLyB0aGlzIGZ1bmN0aW9uIHdpbGwgcHJvcGVybHkgcmVzb2x2ZSB0aGUgZGF0YSBmcm9tIHRoZSBjYWxsYmFja1xuICAgICAgLy8gd2hlbiBpbnZva2VkLlxuICAgICAgY29uc3Qgd3JhcHBlZERlZmF1bHRzQ2FsbGJhY2sgPSAob3B0cykgPT4ge1xuICAgICAgICAvLyBPdXIgcmVwbHkgb3B0aW9ucyBjYWxsYmFjayBjb250YWlucyB0aGUgcGFyYW1ldGVyIGZvciBzdGF0dXNDb2RlLCBkYXRhIGFuZCBvcHRpb25zLlxuICAgICAgICBjb25zdCByZXNvbHZlZERhdGEgPSByZXBseU9wdGlvbnNDYWxsYmFja09yU3RhdHVzQ29kZShvcHRzKVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGlzIGluIHRoZSByaWdodCBmb3JtYXRcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlZERhdGEgIT09ICdvYmplY3QnIHx8IHJlc29sdmVkRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncmVwbHkgb3B0aW9ucyBjYWxsYmFjayBtdXN0IHJldHVybiBhbiBvYmplY3QnKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVwbHlQYXJhbWV0ZXJzID0geyBkYXRhOiAnJywgcmVzcG9uc2VPcHRpb25zOiB7fSwgLi4ucmVzb2x2ZWREYXRhIH1cbiAgICAgICAgdGhpcy52YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyhyZXBseVBhcmFtZXRlcnMpXG4gICAgICAgIC8vIFNpbmNlIHRoZSB2YWx1ZXMgY2FuIGJlIG9idGFpbmVkIGltbWVkaWF0ZWx5IHdlIHJldHVybiB0aGVtXG4gICAgICAgIC8vIGZyb20gdGhpcyBoaWdoZXIgb3JkZXIgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHJlc29sdmVkIGxhdGVyLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnRoaXMuY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhKHJlcGx5UGFyYW1ldGVycylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdXN1YWwgZGlzcGF0Y2ggZGF0YSwgYnV0IHRoaXMgdGltZSBzZXQgdGhlIGRhdGEgcGFyYW1ldGVyIHRvIGZ1bmN0aW9uIHRoYXQgd2lsbCBldmVudHVhbGx5IHByb3ZpZGUgZGF0YS5cbiAgICAgIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IGFkZE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwgdGhpc1trRGlzcGF0Y2hLZXldLCB3cmFwcGVkRGVmYXVsdHNDYWxsYmFjaywgeyBpZ25vcmVUcmFpbGluZ1NsYXNoOiB0aGlzW2tJZ25vcmVUcmFpbGluZ1NsYXNoXSB9KVxuICAgICAgcmV0dXJuIG5ldyBNb2NrU2NvcGUobmV3TW9ja0Rpc3BhdGNoKVxuICAgIH1cblxuICAgIC8vIFdlIGNhbiBoYXZlIGVpdGhlciBvbmUgb3IgdGhyZWUgcGFyYW1ldGVycywgaWYgd2UgZ2V0IGhlcmUsXG4gICAgLy8gd2Ugc2hvdWxkIGhhdmUgMS0zIHBhcmFtZXRlcnMuIFNvIHdlIHNwcmVhZCB0aGUgYXJndW1lbnRzIG9mXG4gICAgLy8gdGhpcyBmdW5jdGlvbiB0byBvYnRhaW4gdGhlIHBhcmFtZXRlcnMsIHNpbmNlIHJlcGx5RGF0YSB3aWxsIGFsd2F5c1xuICAgIC8vIGp1c3QgYmUgdGhlIHN0YXR1c0NvZGUuXG4gICAgY29uc3QgcmVwbHlQYXJhbWV0ZXJzID0ge1xuICAgICAgc3RhdHVzQ29kZTogcmVwbHlPcHRpb25zQ2FsbGJhY2tPclN0YXR1c0NvZGUsXG4gICAgICBkYXRhOiBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/ICcnIDogYXJndW1lbnRzWzFdLFxuICAgICAgcmVzcG9uc2VPcHRpb25zOiBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdXG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGVSZXBseVBhcmFtZXRlcnMocmVwbHlQYXJhbWV0ZXJzKVxuXG4gICAgLy8gU2VuZCBpbi1hbHJlYWR5IHByb3ZpZGVkIGRhdGEgbGlrZSB1c3VhbFxuICAgIGNvbnN0IGRpc3BhdGNoRGF0YSA9IHRoaXMuY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhKHJlcGx5UGFyYW1ldGVycylcbiAgICBjb25zdCBuZXdNb2NrRGlzcGF0Y2ggPSBhZGRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIHRoaXNba0Rpc3BhdGNoS2V5XSwgZGlzcGF0Y2hEYXRhLCB7IGlnbm9yZVRyYWlsaW5nU2xhc2g6IHRoaXNba0lnbm9yZVRyYWlsaW5nU2xhc2hdIH0pXG4gICAgcmV0dXJuIG5ldyBNb2NrU2NvcGUobmV3TW9ja0Rpc3BhdGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIE1vY2sgYW4gdW5kaWNpIHJlcXVlc3Qgd2l0aCBhIGRlZmluZWQgZXJyb3IuXG4gICAqL1xuICByZXBseVdpdGhFcnJvciAoZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdlcnJvciBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IGFkZE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwgdGhpc1trRGlzcGF0Y2hLZXldLCB7IGVycm9yIH0sIHsgaWdub3JlVHJhaWxpbmdTbGFzaDogdGhpc1trSWdub3JlVHJhaWxpbmdTbGFzaF0gfSlcbiAgICByZXR1cm4gbmV3IE1vY2tTY29wZShuZXdNb2NrRGlzcGF0Y2gpXG4gIH1cblxuICAvKipcbiAgICogU2V0IGRlZmF1bHQgcmVwbHkgaGVhZGVycyBvbiB0aGUgaW50ZXJjZXB0b3IgZm9yIHN1YnNlcXVlbnQgcmVwbGllc1xuICAgKi9cbiAgZGVmYXVsdFJlcGx5SGVhZGVycyAoaGVhZGVycykge1xuICAgIGlmICh0eXBlb2YgaGVhZGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVycyBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cblxuICAgIHRoaXNba0RlZmF1bHRIZWFkZXJzXSA9IGhlYWRlcnNcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IHJlcGx5IHRyYWlsZXJzIG9uIHRoZSBpbnRlcmNlcHRvciBmb3Igc3Vic2VxdWVudCByZXBsaWVzXG4gICAqL1xuICBkZWZhdWx0UmVwbHlUcmFpbGVycyAodHJhaWxlcnMpIHtcbiAgICBpZiAodHlwZW9mIHRyYWlsZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd0cmFpbGVycyBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cblxuICAgIHRoaXNba0RlZmF1bHRUcmFpbGVyc10gPSB0cmFpbGVyc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0IHJlcGx5IGNvbnRlbnQgbGVuZ3RoIGhlYWRlciBmb3IgcmVwbGllcyBvbiB0aGUgaW50ZXJjZXB0b3JcbiAgICovXG4gIHJlcGx5Q29udGVudExlbmd0aCAoKSB7XG4gICAgdGhpc1trQ29udGVudExlbmd0aF0gPSB0cnVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5Nb2NrSW50ZXJjZXB0b3IgPSBNb2NrSW50ZXJjZXB0b3Jcbm1vZHVsZS5leHBvcnRzLk1vY2tTY29wZSA9IE1vY2tTY29wZVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-interceptor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-pool.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-pool.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { promisify } = __webpack_require__(/*! node:util */ \"node:util\")\nconst Pool = __webpack_require__(/*! ../dispatcher/pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected,\n  kIgnoreTrailingSlash\n} = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(rsc)/./node_modules/undici/lib/mock/mock-interceptor.js\")\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\n/**\n * MockPool provides an API that extends the Pool to influence the mockDispatches.\n */\nclass MockPool extends Pool {\n  constructor (origin, opts) {\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    super(origin, opts)\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(\n      opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts },\n      this[kDispatches]\n    )\n  }\n\n  cleanMocks () {\n    this[kDispatches] = []\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockPool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stcG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLDRCQUFXO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyw4RUFBb0I7QUFDekMsUUFBUSxvQkFBb0IsRUFBRSxtQkFBTyxDQUFDLHdFQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1QixRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ3hELGdCQUFnQixtQkFBTyxDQUFDLHdFQUFpQjtBQUN6QyxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwREFBMEQ7QUFDMUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXBvb2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4uL2Rpc3BhdGNoZXIvcG9vbCcpXG5jb25zdCB7IGJ1aWxkTW9ja0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuL21vY2stdXRpbHMnKVxuY29uc3Qge1xuICBrRGlzcGF0Y2hlcyxcbiAga01vY2tBZ2VudCxcbiAga0Nsb3NlLFxuICBrT3JpZ2luYWxDbG9zZSxcbiAga09yaWdpbixcbiAga09yaWdpbmFsRGlzcGF0Y2gsXG4gIGtDb25uZWN0ZWQsXG4gIGtJZ25vcmVUcmFpbGluZ1NsYXNoXG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgeyBNb2NrSW50ZXJjZXB0b3IgfSA9IHJlcXVpcmUoJy4vbW9jay1pbnRlcmNlcHRvcicpXG5jb25zdCBTeW1ib2xzID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuLyoqXG4gKiBNb2NrUG9vbCBwcm92aWRlcyBhbiBBUEkgdGhhdCBleHRlbmRzIHRoZSBQb29sIHRvIGluZmx1ZW5jZSB0aGUgbW9ja0Rpc3BhdGNoZXMuXG4gKi9cbmNsYXNzIE1vY2tQb29sIGV4dGVuZHMgUG9vbCB7XG4gIGNvbnN0cnVjdG9yIChvcmlnaW4sIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMgfHwgIW9wdHMuYWdlbnQgfHwgdHlwZW9mIG9wdHMuYWdlbnQuZGlzcGF0Y2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQXJndW1lbnQgb3B0cy5hZ2VudCBtdXN0IGltcGxlbWVudCBBZ2VudCcpXG4gICAgfVxuXG4gICAgc3VwZXIob3JpZ2luLCBvcHRzKVxuXG4gICAgdGhpc1trTW9ja0FnZW50XSA9IG9wdHMuYWdlbnRcbiAgICB0aGlzW2tPcmlnaW5dID0gb3JpZ2luXG4gICAgdGhpc1trSWdub3JlVHJhaWxpbmdTbGFzaF0gPSBvcHRzLmlnbm9yZVRyYWlsaW5nU2xhc2ggPz8gZmFsc2VcbiAgICB0aGlzW2tEaXNwYXRjaGVzXSA9IFtdXG4gICAgdGhpc1trQ29ubmVjdGVkXSA9IDFcbiAgICB0aGlzW2tPcmlnaW5hbERpc3BhdGNoXSA9IHRoaXMuZGlzcGF0Y2hcbiAgICB0aGlzW2tPcmlnaW5hbENsb3NlXSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5kaXNwYXRjaCA9IGJ1aWxkTW9ja0Rpc3BhdGNoLmNhbGwodGhpcylcbiAgICB0aGlzLmNsb3NlID0gdGhpc1trQ2xvc2VdXG4gIH1cblxuICBnZXQgW1N5bWJvbHMua0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiB0aGlzW2tDb25uZWN0ZWRdXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgYmFzZSBpbnRlcmNlcHRvciBmb3IgbW9ja2luZyByZXBsaWVzIGZyb20gdW5kaWNpLlxuICAgKi9cbiAgaW50ZXJjZXB0IChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBNb2NrSW50ZXJjZXB0b3IoXG4gICAgICBvcHRzICYmIHsgaWdub3JlVHJhaWxpbmdTbGFzaDogdGhpc1trSWdub3JlVHJhaWxpbmdTbGFzaF0sIC4uLm9wdHMgfSxcbiAgICAgIHRoaXNba0Rpc3BhdGNoZXNdXG4gICAgKVxuICB9XG5cbiAgY2xlYW5Nb2NrcyAoKSB7XG4gICAgdGhpc1trRGlzcGF0Y2hlc10gPSBbXVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGF3YWl0IHByb21pc2lmeSh0aGlzW2tPcmlnaW5hbENsb3NlXSkoKVxuICAgIHRoaXNba0Nvbm5lY3RlZF0gPSAwXG4gICAgdGhpc1trTW9ja0FnZW50XVtTeW1ib2xzLmtDbGllbnRzXS5kZWxldGUodGhpc1trT3JpZ2luXSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vY2tQb29sXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-symbols.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = {\n  kAgent: Symbol('agent'),\n  kOptions: Symbol('options'),\n  kFactory: Symbol('factory'),\n  kDispatches: Symbol('dispatches'),\n  kDispatchKey: Symbol('dispatch key'),\n  kDefaultHeaders: Symbol('default headers'),\n  kDefaultTrailers: Symbol('default trailers'),\n  kContentLength: Symbol('content length'),\n  kMockAgent: Symbol('mock agent'),\n  kMockAgentSet: Symbol('mock agent set'),\n  kMockAgentGet: Symbol('mock agent get'),\n  kMockDispatch: Symbol('mock dispatch'),\n  kClose: Symbol('close'),\n  kOriginalClose: Symbol('original agent close'),\n  kOriginalDispatch: Symbol('original dispatch'),\n  kOrigin: Symbol('origin'),\n  kIsMockActive: Symbol('is mock active'),\n  kNetConnect: Symbol('net connect'),\n  kGetNetConnect: Symbol('get net connect'),\n  kConnected: Symbol('connected'),\n  kIgnoreTrailingSlash: Symbol('ignore trailing slash'),\n  kMockAgentMockCallHistoryInstance: Symbol('mock agent mock call history name'),\n  kMockAgentRegisterCallHistory: Symbol('mock agent register mock call history'),\n  kMockAgentAddCallHistoryLog: Symbol('mock agent add call history log'),\n  kMockAgentIsCallHistoryEnabled: Symbol('mock agent is call history enabled'),\n  kMockAgentAcceptsNonStandardSearchParameters: Symbol('mock agent accepts non standard search parameters'),\n  kMockCallHistoryAddLog: Symbol('mock call history add log')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1zeW1ib2xzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga0FnZW50OiBTeW1ib2woJ2FnZW50JyksXG4gIGtPcHRpb25zOiBTeW1ib2woJ29wdGlvbnMnKSxcbiAga0ZhY3Rvcnk6IFN5bWJvbCgnZmFjdG9yeScpLFxuICBrRGlzcGF0Y2hlczogU3ltYm9sKCdkaXNwYXRjaGVzJyksXG4gIGtEaXNwYXRjaEtleTogU3ltYm9sKCdkaXNwYXRjaCBrZXknKSxcbiAga0RlZmF1bHRIZWFkZXJzOiBTeW1ib2woJ2RlZmF1bHQgaGVhZGVycycpLFxuICBrRGVmYXVsdFRyYWlsZXJzOiBTeW1ib2woJ2RlZmF1bHQgdHJhaWxlcnMnKSxcbiAga0NvbnRlbnRMZW5ndGg6IFN5bWJvbCgnY29udGVudCBsZW5ndGgnKSxcbiAga01vY2tBZ2VudDogU3ltYm9sKCdtb2NrIGFnZW50JyksXG4gIGtNb2NrQWdlbnRTZXQ6IFN5bWJvbCgnbW9jayBhZ2VudCBzZXQnKSxcbiAga01vY2tBZ2VudEdldDogU3ltYm9sKCdtb2NrIGFnZW50IGdldCcpLFxuICBrTW9ja0Rpc3BhdGNoOiBTeW1ib2woJ21vY2sgZGlzcGF0Y2gnKSxcbiAga0Nsb3NlOiBTeW1ib2woJ2Nsb3NlJyksXG4gIGtPcmlnaW5hbENsb3NlOiBTeW1ib2woJ29yaWdpbmFsIGFnZW50IGNsb3NlJyksXG4gIGtPcmlnaW5hbERpc3BhdGNoOiBTeW1ib2woJ29yaWdpbmFsIGRpc3BhdGNoJyksXG4gIGtPcmlnaW46IFN5bWJvbCgnb3JpZ2luJyksXG4gIGtJc01vY2tBY3RpdmU6IFN5bWJvbCgnaXMgbW9jayBhY3RpdmUnKSxcbiAga05ldENvbm5lY3Q6IFN5bWJvbCgnbmV0IGNvbm5lY3QnKSxcbiAga0dldE5ldENvbm5lY3Q6IFN5bWJvbCgnZ2V0IG5ldCBjb25uZWN0JyksXG4gIGtDb25uZWN0ZWQ6IFN5bWJvbCgnY29ubmVjdGVkJyksXG4gIGtJZ25vcmVUcmFpbGluZ1NsYXNoOiBTeW1ib2woJ2lnbm9yZSB0cmFpbGluZyBzbGFzaCcpLFxuICBrTW9ja0FnZW50TW9ja0NhbGxIaXN0b3J5SW5zdGFuY2U6IFN5bWJvbCgnbW9jayBhZ2VudCBtb2NrIGNhbGwgaGlzdG9yeSBuYW1lJyksXG4gIGtNb2NrQWdlbnRSZWdpc3RlckNhbGxIaXN0b3J5OiBTeW1ib2woJ21vY2sgYWdlbnQgcmVnaXN0ZXIgbW9jayBjYWxsIGhpc3RvcnknKSxcbiAga01vY2tBZ2VudEFkZENhbGxIaXN0b3J5TG9nOiBTeW1ib2woJ21vY2sgYWdlbnQgYWRkIGNhbGwgaGlzdG9yeSBsb2cnKSxcbiAga01vY2tBZ2VudElzQ2FsbEhpc3RvcnlFbmFibGVkOiBTeW1ib2woJ21vY2sgYWdlbnQgaXMgY2FsbCBoaXN0b3J5IGVuYWJsZWQnKSxcbiAga01vY2tBZ2VudEFjY2VwdHNOb25TdGFuZGFyZFNlYXJjaFBhcmFtZXRlcnM6IFN5bWJvbCgnbW9jayBhZ2VudCBhY2NlcHRzIG5vbiBzdGFuZGFyZCBzZWFyY2ggcGFyYW1ldGVycycpLFxuICBrTW9ja0NhbGxIaXN0b3J5QWRkTG9nOiBTeW1ib2woJ21vY2sgY2FsbCBoaXN0b3J5IGFkZCBsb2cnKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-utils.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { MockNotMatchedError } = __webpack_require__(/*! ./mock-errors */ \"(rsc)/./node_modules/undici/lib/mock/mock-errors.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kOriginalDispatch,\n  kOrigin,\n  kGetNetConnect\n} = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { serializePathWithQuery } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { STATUS_CODES } = __webpack_require__(/*! node:http */ \"node:http\")\nconst {\n  types: {\n    isPromise\n  }\n} = __webpack_require__(/*! node:util */ \"node:util\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nfunction matchValue (match, value) {\n  if (typeof match === 'string') {\n    return match === value\n  }\n  if (match instanceof RegExp) {\n    return match.test(value)\n  }\n  if (typeof match === 'function') {\n    return match(value) === true\n  }\n  return false\n}\n\nfunction lowerCaseEntries (headers) {\n  return Object.fromEntries(\n    Object.entries(headers).map(([headerName, headerValue]) => {\n      return [headerName.toLocaleLowerCase(), headerValue]\n    })\n  )\n}\n\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */\nfunction getHeaderByName (headers, key) {\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n        return headers[i + 1]\n      }\n    }\n\n    return undefined\n  } else if (typeof headers.get === 'function') {\n    return headers.get(key)\n  } else {\n    return lowerCaseEntries(headers)[key.toLocaleLowerCase()]\n  }\n}\n\n/** @param {string[]} headers */\nfunction buildHeadersFromArray (headers) { // fetch HeadersList\n  const clone = headers.slice()\n  const entries = []\n  for (let index = 0; index < clone.length; index += 2) {\n    entries.push([clone[index], clone[index + 1]])\n  }\n  return Object.fromEntries(entries)\n}\n\nfunction matchHeaders (mockDispatch, headers) {\n  if (typeof mockDispatch.headers === 'function') {\n    if (Array.isArray(headers)) { // fetch HeadersList\n      headers = buildHeadersFromArray(headers)\n    }\n    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {})\n  }\n  if (typeof mockDispatch.headers === 'undefined') {\n    return true\n  }\n  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n    return false\n  }\n\n  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {\n    const headerValue = getHeaderByName(headers, matchHeaderName)\n\n    if (!matchValue(matchHeaderValue, headerValue)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction normalizeSearchParams (query) {\n  if (typeof query !== 'string') {\n    return query\n  }\n\n  const originalQp = new URLSearchParams(query)\n  const normalizedQp = new URLSearchParams()\n\n  for (let [key, value] of originalQp.entries()) {\n    key = key.replace('[]', '')\n\n    const valueRepresentsString = /^(['\"]).*\\1$/.test(value)\n    if (valueRepresentsString) {\n      normalizedQp.append(key, value)\n      continue\n    }\n\n    if (value.includes(',')) {\n      const values = value.split(',')\n      for (const v of values) {\n        normalizedQp.append(key, v)\n      }\n      continue\n    }\n\n    normalizedQp.append(key, value)\n  }\n\n  return normalizedQp\n}\n\nfunction safeUrl (path) {\n  if (typeof path !== 'string') {\n    return path\n  }\n  const pathSegments = path.split('?', 3)\n  if (pathSegments.length !== 2) {\n    return path\n  }\n\n  const qp = new URLSearchParams(pathSegments.pop())\n  qp.sort()\n  return [...pathSegments, qp.toString()].join('?')\n}\n\nfunction matchKey (mockDispatch, { path, method, body, headers }) {\n  const pathMatch = matchValue(mockDispatch.path, path)\n  const methodMatch = matchValue(mockDispatch.method, method)\n  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true\n  const headersMatch = matchHeaders(mockDispatch, headers)\n  return pathMatch && methodMatch && bodyMatch && headersMatch\n}\n\nfunction getResponseData (data) {\n  if (Buffer.isBuffer(data)) {\n    return data\n  } else if (data instanceof Uint8Array) {\n    return data\n  } else if (data instanceof ArrayBuffer) {\n    return data\n  } else if (typeof data === 'object') {\n    return JSON.stringify(data)\n  } else if (data) {\n    return data.toString()\n  } else {\n    return ''\n  }\n}\n\nfunction getMockDispatch (mockDispatches, key) {\n  const basePath = key.query ? serializePathWithQuery(key.path, key.query) : key.path\n  const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath\n\n  const resolvedPathWithoutTrailingSlash = removeTrailingSlash(resolvedPath)\n\n  // Match path\n  let matchedMockDispatches = mockDispatches\n    .filter(({ consumed }) => !consumed)\n    .filter(({ path, ignoreTrailingSlash }) => {\n      return ignoreTrailingSlash\n        ? matchValue(removeTrailingSlash(safeUrl(path)), resolvedPathWithoutTrailingSlash)\n        : matchValue(safeUrl(path), resolvedPath)\n    })\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`)\n  }\n\n  // Match method\n  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`)\n  }\n\n  // Match body\n  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true)\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`)\n  }\n\n  // Match headers\n  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers))\n  if (matchedMockDispatches.length === 0) {\n    const headers = typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers\n    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`)\n  }\n\n  return matchedMockDispatches[0]\n}\n\nfunction addMockDispatch (mockDispatches, key, data, opts) {\n  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false, ...opts }\n  const replyData = typeof data === 'function' ? { callback: data } : { ...data }\n  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } }\n  mockDispatches.push(newMockDispatch)\n  return newMockDispatch\n}\n\nfunction deleteMockDispatch (mockDispatches, key) {\n  const index = mockDispatches.findIndex(dispatch => {\n    if (!dispatch.consumed) {\n      return false\n    }\n    return matchKey(dispatch, key)\n  })\n  if (index !== -1) {\n    mockDispatches.splice(index, 1)\n  }\n}\n\n/**\n * @param {string} path Path to remove trailing slash from\n */\nfunction removeTrailingSlash (path) {\n  while (path.endsWith('/')) {\n    path = path.slice(0, -1)\n  }\n\n  if (path.length === 0) {\n    path = '/'\n  }\n\n  return path\n}\n\nfunction buildKey (opts) {\n  const { path, method, body, headers, query } = opts\n\n  return {\n    path,\n    method,\n    body,\n    headers,\n    query\n  }\n}\n\nfunction generateKeyValues (data) {\n  const keys = Object.keys(data)\n  const result = []\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i]\n    const value = data[key]\n    const name = Buffer.from(`${key}`)\n    if (Array.isArray(value)) {\n      for (let j = 0; j < value.length; ++j) {\n        result.push(name, Buffer.from(`${value[j]}`))\n      }\n    } else {\n      result.push(name, Buffer.from(`${value}`))\n    }\n  }\n  return result\n}\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */\nfunction getStatusText (statusCode) {\n  return STATUS_CODES[statusCode] || 'unknown'\n}\n\nasync function getResponse (body) {\n  const buffers = []\n  for await (const data of body) {\n    buffers.push(data)\n  }\n  return Buffer.concat(buffers).toString('utf8')\n}\n\n/**\n * Mock dispatch function used to simulate undici dispatches\n */\nfunction mockDispatch (opts, handler) {\n  // Get mock dispatch from built key\n  const key = buildKey(opts)\n  const mockDispatch = getMockDispatch(this[kDispatches], key)\n\n  mockDispatch.timesInvoked++\n\n  // Here's where we resolve a callback if a callback is present for the dispatch data.\n  if (mockDispatch.data.callback) {\n    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) }\n  }\n\n  // Parse mockDispatch data\n  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch\n  const { timesInvoked, times } = mockDispatch\n\n  // If it's used up and not persistent, mark as consumed\n  mockDispatch.consumed = !persist && timesInvoked >= times\n  mockDispatch.pending = timesInvoked < times\n\n  // If specified, trigger dispatch error\n  if (error !== null) {\n    deleteMockDispatch(this[kDispatches], key)\n    handler.onError(error)\n    return true\n  }\n\n  // Handle the request with a delay if necessary\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(() => {\n      handleReply(this[kDispatches])\n    }, delay)\n  } else {\n    handleReply(this[kDispatches])\n  }\n\n  function handleReply (mockDispatches, _data = data) {\n    // fetch's HeadersList is a 1D string array\n    const optsHeaders = Array.isArray(opts.headers)\n      ? buildHeadersFromArray(opts.headers)\n      : opts.headers\n    const body = typeof _data === 'function'\n      ? _data({ ...opts, headers: optsHeaders })\n      : _data\n\n    // util.types.isPromise is likely needed for jest.\n    if (isPromise(body)) {\n      // If handleReply is asynchronous, throwing an error\n      // in the callback will reject the promise, rather than\n      // synchronously throw the error, which breaks some tests.\n      // Rather, we wait for the callback to resolve if it is a\n      // promise, and then re-run handleReply with the new body.\n      body.then((newData) => handleReply(mockDispatches, newData))\n      return\n    }\n\n    const responseData = getResponseData(body)\n    const responseHeaders = generateKeyValues(headers)\n    const responseTrailers = generateKeyValues(trailers)\n\n    handler.onConnect?.(err => handler.onError(err), null)\n    handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode))\n    handler.onData?.(Buffer.from(responseData))\n    handler.onComplete?.(responseTrailers)\n    deleteMockDispatch(mockDispatches, key)\n  }\n\n  function resume () {}\n\n  return true\n}\n\nfunction buildMockDispatch () {\n  const agent = this[kMockAgent]\n  const origin = this[kOrigin]\n  const originalDispatch = this[kOriginalDispatch]\n\n  return function dispatch (opts, handler) {\n    if (agent.isMockActive) {\n      try {\n        mockDispatch.call(this, opts, handler)\n      } catch (error) {\n        if (error instanceof MockNotMatchedError) {\n          const netConnect = agent[kGetNetConnect]()\n          if (netConnect === false) {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)\n          }\n          if (checkNetConnect(netConnect, origin)) {\n            originalDispatch.call(this, opts, handler)\n          } else {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)\n          }\n        } else {\n          throw error\n        }\n      }\n    } else {\n      originalDispatch.call(this, opts, handler)\n    }\n  }\n}\n\nfunction checkNetConnect (netConnect, origin) {\n  const url = new URL(origin)\n  if (netConnect === true) {\n    return true\n  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {\n    return true\n  }\n  return false\n}\n\nfunction buildAndValidateMockOptions (opts) {\n  if (opts) {\n    const { agent, ...mockOptions } = opts\n\n    if ('enableCallHistory' in mockOptions && typeof mockOptions.enableCallHistory !== 'boolean') {\n      throw new InvalidArgumentError('options.enableCallHistory must to be a boolean')\n    }\n\n    if ('acceptNonStandardSearchParameters' in mockOptions && typeof mockOptions.acceptNonStandardSearchParameters !== 'boolean') {\n      throw new InvalidArgumentError('options.acceptNonStandardSearchParameters must to be a boolean')\n    }\n\n    return mockOptions\n  }\n}\n\nmodule.exports = {\n  getResponseData,\n  getMockDispatch,\n  addMockDispatch,\n  deleteMockDispatch,\n  buildKey,\n  generateKeyValues,\n  matchValue,\n  getResponse,\n  getStatusText,\n  mockDispatch,\n  buildMockDispatch,\n  checkNetConnect,\n  buildAndValidateMockOptions,\n  getHeaderByName,\n  buildHeadersFromArray,\n  normalizeSearchParams\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLDBFQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1QixRQUFRLHlCQUF5QixFQUFFLG1CQUFPLENBQUMsa0VBQWM7QUFDekQsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyw0QkFBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRCQUFXO0FBQ3ZCLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsV0FBVywrREFBK0Q7QUFDMUUsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLFlBQVksVUFBVTtBQUN0QiwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IE1vY2tOb3RNYXRjaGVkRXJyb3IgfSA9IHJlcXVpcmUoJy4vbW9jay1lcnJvcnMnKVxuY29uc3Qge1xuICBrRGlzcGF0Y2hlcyxcbiAga01vY2tBZ2VudCxcbiAga09yaWdpbmFsRGlzcGF0Y2gsXG4gIGtPcmlnaW4sXG4gIGtHZXROZXRDb25uZWN0XG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgeyBzZXJpYWxpemVQYXRoV2l0aFF1ZXJ5IH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBTVEFUVVNfQ09ERVMgfSA9IHJlcXVpcmUoJ25vZGU6aHR0cCcpXG5jb25zdCB7XG4gIHR5cGVzOiB7XG4gICAgaXNQcm9taXNlXG4gIH1cbn0gPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuXG5mdW5jdGlvbiBtYXRjaFZhbHVlIChtYXRjaCwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbWF0Y2ggPT09IHZhbHVlXG4gIH1cbiAgaWYgKG1hdGNoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIG1hdGNoLnRlc3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiBtYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXRjaCh2YWx1ZSkgPT09IHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gbG93ZXJDYXNlRW50cmllcyAoaGVhZGVycykge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpLm1hcCgoW2hlYWRlck5hbWUsIGhlYWRlclZhbHVlXSkgPT4ge1xuICAgICAgcmV0dXJuIFtoZWFkZXJOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCksIGhlYWRlclZhbHVlXVxuICAgIH0pXG4gIClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vaW5kZXgnKS5IZWFkZXJzfHN0cmluZ1tdfFJlY29yZDxzdHJpbmcsIHN0cmluZz59IGhlYWRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuZnVuY3Rpb24gZ2V0SGVhZGVyQnlOYW1lIChoZWFkZXJzLCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGlmIChoZWFkZXJzW2ldLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IGtleS50b0xvY2FsZUxvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHJldHVybiBoZWFkZXJzW2kgKyAxXVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfSBlbHNlIGlmICh0eXBlb2YgaGVhZGVycy5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaGVhZGVycy5nZXQoa2V5KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBsb3dlckNhc2VFbnRyaWVzKGhlYWRlcnMpW2tleS50b0xvY2FsZUxvd2VyQ2FzZSgpXVxuICB9XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ1tdfSBoZWFkZXJzICovXG5mdW5jdGlvbiBidWlsZEhlYWRlcnNGcm9tQXJyYXkgKGhlYWRlcnMpIHsgLy8gZmV0Y2ggSGVhZGVyc0xpc3RcbiAgY29uc3QgY2xvbmUgPSBoZWFkZXJzLnNsaWNlKClcbiAgY29uc3QgZW50cmllcyA9IFtdXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjbG9uZS5sZW5ndGg7IGluZGV4ICs9IDIpIHtcbiAgICBlbnRyaWVzLnB1c2goW2Nsb25lW2luZGV4XSwgY2xvbmVbaW5kZXggKyAxXV0pXG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhlbnRyaWVzKVxufVxuXG5mdW5jdGlvbiBtYXRjaEhlYWRlcnMgKG1vY2tEaXNwYXRjaCwgaGVhZGVycykge1xuICBpZiAodHlwZW9mIG1vY2tEaXNwYXRjaC5oZWFkZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHsgLy8gZmV0Y2ggSGVhZGVyc0xpc3RcbiAgICAgIGhlYWRlcnMgPSBidWlsZEhlYWRlcnNGcm9tQXJyYXkoaGVhZGVycylcbiAgICB9XG4gICAgcmV0dXJuIG1vY2tEaXNwYXRjaC5oZWFkZXJzKGhlYWRlcnMgPyBsb3dlckNhc2VFbnRyaWVzKGhlYWRlcnMpIDoge30pXG4gIH1cbiAgaWYgKHR5cGVvZiBtb2NrRGlzcGF0Y2guaGVhZGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmICh0eXBlb2YgaGVhZGVycyAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG1vY2tEaXNwYXRjaC5oZWFkZXJzICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBbbWF0Y2hIZWFkZXJOYW1lLCBtYXRjaEhlYWRlclZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtb2NrRGlzcGF0Y2guaGVhZGVycykpIHtcbiAgICBjb25zdCBoZWFkZXJWYWx1ZSA9IGdldEhlYWRlckJ5TmFtZShoZWFkZXJzLCBtYXRjaEhlYWRlck5hbWUpXG5cbiAgICBpZiAoIW1hdGNoVmFsdWUobWF0Y2hIZWFkZXJWYWx1ZSwgaGVhZGVyVmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2VhcmNoUGFyYW1zIChxdWVyeSkge1xuICBpZiAodHlwZW9mIHF1ZXJ5ICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBxdWVyeVxuICB9XG5cbiAgY29uc3Qgb3JpZ2luYWxRcCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocXVlcnkpXG4gIGNvbnN0IG5vcm1hbGl6ZWRRcCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxuXG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBvcmlnaW5hbFFwLmVudHJpZXMoKSkge1xuICAgIGtleSA9IGtleS5yZXBsYWNlKCdbXScsICcnKVxuXG4gICAgY29uc3QgdmFsdWVSZXByZXNlbnRzU3RyaW5nID0gL14oWydcIl0pLipcXDEkLy50ZXN0KHZhbHVlKVxuICAgIGlmICh2YWx1ZVJlcHJlc2VudHNTdHJpbmcpIHtcbiAgICAgIG5vcm1hbGl6ZWRRcC5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmluY2x1ZGVzKCcsJykpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHZhbHVlLnNwbGl0KCcsJylcbiAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZXMpIHtcbiAgICAgICAgbm9ybWFsaXplZFFwLmFwcGVuZChrZXksIHYpXG4gICAgICB9XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIG5vcm1hbGl6ZWRRcC5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkUXBcbn1cblxuZnVuY3Rpb24gc2FmZVVybCAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdGhcbiAgfVxuICBjb25zdCBwYXRoU2VnbWVudHMgPSBwYXRoLnNwbGl0KCc/JywgMylcbiAgaWYgKHBhdGhTZWdtZW50cy5sZW5ndGggIT09IDIpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgY29uc3QgcXAgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhdGhTZWdtZW50cy5wb3AoKSlcbiAgcXAuc29ydCgpXG4gIHJldHVybiBbLi4ucGF0aFNlZ21lbnRzLCBxcC50b1N0cmluZygpXS5qb2luKCc/Jylcbn1cblxuZnVuY3Rpb24gbWF0Y2hLZXkgKG1vY2tEaXNwYXRjaCwgeyBwYXRoLCBtZXRob2QsIGJvZHksIGhlYWRlcnMgfSkge1xuICBjb25zdCBwYXRoTWF0Y2ggPSBtYXRjaFZhbHVlKG1vY2tEaXNwYXRjaC5wYXRoLCBwYXRoKVxuICBjb25zdCBtZXRob2RNYXRjaCA9IG1hdGNoVmFsdWUobW9ja0Rpc3BhdGNoLm1ldGhvZCwgbWV0aG9kKVxuICBjb25zdCBib2R5TWF0Y2ggPSB0eXBlb2YgbW9ja0Rpc3BhdGNoLmJvZHkgIT09ICd1bmRlZmluZWQnID8gbWF0Y2hWYWx1ZShtb2NrRGlzcGF0Y2guYm9keSwgYm9keSkgOiB0cnVlXG4gIGNvbnN0IGhlYWRlcnNNYXRjaCA9IG1hdGNoSGVhZGVycyhtb2NrRGlzcGF0Y2gsIGhlYWRlcnMpXG4gIHJldHVybiBwYXRoTWF0Y2ggJiYgbWV0aG9kTWF0Y2ggJiYgYm9keU1hdGNoICYmIGhlYWRlcnNNYXRjaFxufVxuXG5mdW5jdGlvbiBnZXRSZXNwb25zZURhdGEgKGRhdGEpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgIHJldHVybiBkYXRhXG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gZGF0YVxuICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBkYXRhXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gIH0gZWxzZSBpZiAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNb2NrRGlzcGF0Y2ggKG1vY2tEaXNwYXRjaGVzLCBrZXkpIHtcbiAgY29uc3QgYmFzZVBhdGggPSBrZXkucXVlcnkgPyBzZXJpYWxpemVQYXRoV2l0aFF1ZXJ5KGtleS5wYXRoLCBrZXkucXVlcnkpIDoga2V5LnBhdGhcbiAgY29uc3QgcmVzb2x2ZWRQYXRoID0gdHlwZW9mIGJhc2VQYXRoID09PSAnc3RyaW5nJyA/IHNhZmVVcmwoYmFzZVBhdGgpIDogYmFzZVBhdGhcblxuICBjb25zdCByZXNvbHZlZFBhdGhXaXRob3V0VHJhaWxpbmdTbGFzaCA9IHJlbW92ZVRyYWlsaW5nU2xhc2gocmVzb2x2ZWRQYXRoKVxuXG4gIC8vIE1hdGNoIHBhdGhcbiAgbGV0IG1hdGNoZWRNb2NrRGlzcGF0Y2hlcyA9IG1vY2tEaXNwYXRjaGVzXG4gICAgLmZpbHRlcigoeyBjb25zdW1lZCB9KSA9PiAhY29uc3VtZWQpXG4gICAgLmZpbHRlcigoeyBwYXRoLCBpZ25vcmVUcmFpbGluZ1NsYXNoIH0pID0+IHtcbiAgICAgIHJldHVybiBpZ25vcmVUcmFpbGluZ1NsYXNoXG4gICAgICAgID8gbWF0Y2hWYWx1ZShyZW1vdmVUcmFpbGluZ1NsYXNoKHNhZmVVcmwocGF0aCkpLCByZXNvbHZlZFBhdGhXaXRob3V0VHJhaWxpbmdTbGFzaClcbiAgICAgICAgOiBtYXRjaFZhbHVlKHNhZmVVcmwocGF0aCksIHJlc29sdmVkUGF0aClcbiAgICB9KVxuICBpZiAobWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGBNb2NrIGRpc3BhdGNoIG5vdCBtYXRjaGVkIGZvciBwYXRoICcke3Jlc29sdmVkUGF0aH0nYClcbiAgfVxuXG4gIC8vIE1hdGNoIG1ldGhvZFxuICBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMgPSBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMuZmlsdGVyKCh7IG1ldGhvZCB9KSA9PiBtYXRjaFZhbHVlKG1ldGhvZCwga2V5Lm1ldGhvZCkpXG4gIGlmIChtYXRjaGVkTW9ja0Rpc3BhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIG1ldGhvZCAnJHtrZXkubWV0aG9kfScgb24gcGF0aCAnJHtyZXNvbHZlZFBhdGh9J2ApXG4gIH1cblxuICAvLyBNYXRjaCBib2R5XG4gIG1hdGNoZWRNb2NrRGlzcGF0Y2hlcyA9IG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5maWx0ZXIoKHsgYm9keSB9KSA9PiB0eXBlb2YgYm9keSAhPT0gJ3VuZGVmaW5lZCcgPyBtYXRjaFZhbHVlKGJvZHksIGtleS5ib2R5KSA6IHRydWUpXG4gIGlmIChtYXRjaGVkTW9ja0Rpc3BhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIGJvZHkgJyR7a2V5LmJvZHl9JyBvbiBwYXRoICcke3Jlc29sdmVkUGF0aH0nYClcbiAgfVxuXG4gIC8vIE1hdGNoIGhlYWRlcnNcbiAgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmZpbHRlcigobW9ja0Rpc3BhdGNoKSA9PiBtYXRjaEhlYWRlcnMobW9ja0Rpc3BhdGNoLCBrZXkuaGVhZGVycykpXG4gIGlmIChtYXRjaGVkTW9ja0Rpc3BhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHR5cGVvZiBrZXkuaGVhZGVycyA9PT0gJ29iamVjdCcgPyBKU09OLnN0cmluZ2lmeShrZXkuaGVhZGVycykgOiBrZXkuaGVhZGVyc1xuICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGBNb2NrIGRpc3BhdGNoIG5vdCBtYXRjaGVkIGZvciBoZWFkZXJzICcke2hlYWRlcnN9JyBvbiBwYXRoICcke3Jlc29sdmVkUGF0aH0nYClcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVkTW9ja0Rpc3BhdGNoZXNbMF1cbn1cblxuZnVuY3Rpb24gYWRkTW9ja0Rpc3BhdGNoIChtb2NrRGlzcGF0Y2hlcywga2V5LCBkYXRhLCBvcHRzKSB7XG4gIGNvbnN0IGJhc2VEYXRhID0geyB0aW1lc0ludm9rZWQ6IDAsIHRpbWVzOiAxLCBwZXJzaXN0OiBmYWxzZSwgY29uc3VtZWQ6IGZhbHNlLCAuLi5vcHRzIH1cbiAgY29uc3QgcmVwbHlEYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicgPyB7IGNhbGxiYWNrOiBkYXRhIH0gOiB7IC4uLmRhdGEgfVxuICBjb25zdCBuZXdNb2NrRGlzcGF0Y2ggPSB7IC4uLmJhc2VEYXRhLCAuLi5rZXksIHBlbmRpbmc6IHRydWUsIGRhdGE6IHsgZXJyb3I6IG51bGwsIC4uLnJlcGx5RGF0YSB9IH1cbiAgbW9ja0Rpc3BhdGNoZXMucHVzaChuZXdNb2NrRGlzcGF0Y2gpXG4gIHJldHVybiBuZXdNb2NrRGlzcGF0Y2hcbn1cblxuZnVuY3Rpb24gZGVsZXRlTW9ja0Rpc3BhdGNoIChtb2NrRGlzcGF0Y2hlcywga2V5KSB7XG4gIGNvbnN0IGluZGV4ID0gbW9ja0Rpc3BhdGNoZXMuZmluZEluZGV4KGRpc3BhdGNoID0+IHtcbiAgICBpZiAoIWRpc3BhdGNoLmNvbnN1bWVkKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoS2V5KGRpc3BhdGNoLCBrZXkpXG4gIH0pXG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBtb2NrRGlzcGF0Y2hlcy5zcGxpY2UoaW5kZXgsIDEpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRvIHJlbW92ZSB0cmFpbGluZyBzbGFzaCBmcm9tXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVRyYWlsaW5nU2xhc2ggKHBhdGgpIHtcbiAgd2hpbGUgKHBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKVxuICB9XG5cbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgcGF0aCA9ICcvJ1xuICB9XG5cbiAgcmV0dXJuIHBhdGhcbn1cblxuZnVuY3Rpb24gYnVpbGRLZXkgKG9wdHMpIHtcbiAgY29uc3QgeyBwYXRoLCBtZXRob2QsIGJvZHksIGhlYWRlcnMsIHF1ZXJ5IH0gPSBvcHRzXG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoLFxuICAgIG1ldGhvZCxcbiAgICBib2R5LFxuICAgIGhlYWRlcnMsXG4gICAgcXVlcnlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUtleVZhbHVlcyAoZGF0YSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSlcbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldXG4gICAgY29uc3QgbmFtZSA9IEJ1ZmZlci5mcm9tKGAke2tleX1gKVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7ICsraikge1xuICAgICAgICByZXN1bHQucHVzaChuYW1lLCBCdWZmZXIuZnJvbShgJHt2YWx1ZVtqXX1gKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gobmFtZSwgQnVmZmVyLmZyb20oYCR7dmFsdWV9YCkpXG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzQ29kZVxuICovXG5mdW5jdGlvbiBnZXRTdGF0dXNUZXh0IChzdGF0dXNDb2RlKSB7XG4gIHJldHVybiBTVEFUVVNfQ09ERVNbc3RhdHVzQ29kZV0gfHwgJ3Vua25vd24nXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlIChib2R5KSB7XG4gIGNvbnN0IGJ1ZmZlcnMgPSBbXVxuICBmb3IgYXdhaXQgKGNvbnN0IGRhdGEgb2YgYm9keSkge1xuICAgIGJ1ZmZlcnMucHVzaChkYXRhKVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpLnRvU3RyaW5nKCd1dGY4Jylcbn1cblxuLyoqXG4gKiBNb2NrIGRpc3BhdGNoIGZ1bmN0aW9uIHVzZWQgdG8gc2ltdWxhdGUgdW5kaWNpIGRpc3BhdGNoZXNcbiAqL1xuZnVuY3Rpb24gbW9ja0Rpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gIC8vIEdldCBtb2NrIGRpc3BhdGNoIGZyb20gYnVpbHQga2V5XG4gIGNvbnN0IGtleSA9IGJ1aWxkS2V5KG9wdHMpXG4gIGNvbnN0IG1vY2tEaXNwYXRjaCA9IGdldE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwga2V5KVxuXG4gIG1vY2tEaXNwYXRjaC50aW1lc0ludm9rZWQrK1xuXG4gIC8vIEhlcmUncyB3aGVyZSB3ZSByZXNvbHZlIGEgY2FsbGJhY2sgaWYgYSBjYWxsYmFjayBpcyBwcmVzZW50IGZvciB0aGUgZGlzcGF0Y2ggZGF0YS5cbiAgaWYgKG1vY2tEaXNwYXRjaC5kYXRhLmNhbGxiYWNrKSB7XG4gICAgbW9ja0Rpc3BhdGNoLmRhdGEgPSB7IC4uLm1vY2tEaXNwYXRjaC5kYXRhLCAuLi5tb2NrRGlzcGF0Y2guZGF0YS5jYWxsYmFjayhvcHRzKSB9XG4gIH1cblxuICAvLyBQYXJzZSBtb2NrRGlzcGF0Y2ggZGF0YVxuICBjb25zdCB7IGRhdGE6IHsgc3RhdHVzQ29kZSwgZGF0YSwgaGVhZGVycywgdHJhaWxlcnMsIGVycm9yIH0sIGRlbGF5LCBwZXJzaXN0IH0gPSBtb2NrRGlzcGF0Y2hcbiAgY29uc3QgeyB0aW1lc0ludm9rZWQsIHRpbWVzIH0gPSBtb2NrRGlzcGF0Y2hcblxuICAvLyBJZiBpdCdzIHVzZWQgdXAgYW5kIG5vdCBwZXJzaXN0ZW50LCBtYXJrIGFzIGNvbnN1bWVkXG4gIG1vY2tEaXNwYXRjaC5jb25zdW1lZCA9ICFwZXJzaXN0ICYmIHRpbWVzSW52b2tlZCA+PSB0aW1lc1xuICBtb2NrRGlzcGF0Y2gucGVuZGluZyA9IHRpbWVzSW52b2tlZCA8IHRpbWVzXG5cbiAgLy8gSWYgc3BlY2lmaWVkLCB0cmlnZ2VyIGRpc3BhdGNoIGVycm9yXG4gIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgIGRlbGV0ZU1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwga2V5KVxuICAgIGhhbmRsZXIub25FcnJvcihlcnJvcilcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gSGFuZGxlIHRoZSByZXF1ZXN0IHdpdGggYSBkZWxheSBpZiBuZWNlc3NhcnlcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicgJiYgZGVsYXkgPiAwKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBoYW5kbGVSZXBseSh0aGlzW2tEaXNwYXRjaGVzXSlcbiAgICB9LCBkZWxheSlcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVSZXBseSh0aGlzW2tEaXNwYXRjaGVzXSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJlcGx5IChtb2NrRGlzcGF0Y2hlcywgX2RhdGEgPSBkYXRhKSB7XG4gICAgLy8gZmV0Y2gncyBIZWFkZXJzTGlzdCBpcyBhIDFEIHN0cmluZyBhcnJheVxuICAgIGNvbnN0IG9wdHNIZWFkZXJzID0gQXJyYXkuaXNBcnJheShvcHRzLmhlYWRlcnMpXG4gICAgICA/IGJ1aWxkSGVhZGVyc0Zyb21BcnJheShvcHRzLmhlYWRlcnMpXG4gICAgICA6IG9wdHMuaGVhZGVyc1xuICAgIGNvbnN0IGJvZHkgPSB0eXBlb2YgX2RhdGEgPT09ICdmdW5jdGlvbidcbiAgICAgID8gX2RhdGEoeyAuLi5vcHRzLCBoZWFkZXJzOiBvcHRzSGVhZGVycyB9KVxuICAgICAgOiBfZGF0YVxuXG4gICAgLy8gdXRpbC50eXBlcy5pc1Byb21pc2UgaXMgbGlrZWx5IG5lZWRlZCBmb3IgamVzdC5cbiAgICBpZiAoaXNQcm9taXNlKGJvZHkpKSB7XG4gICAgICAvLyBJZiBoYW5kbGVSZXBseSBpcyBhc3luY2hyb25vdXMsIHRocm93aW5nIGFuIGVycm9yXG4gICAgICAvLyBpbiB0aGUgY2FsbGJhY2sgd2lsbCByZWplY3QgdGhlIHByb21pc2UsIHJhdGhlciB0aGFuXG4gICAgICAvLyBzeW5jaHJvbm91c2x5IHRocm93IHRoZSBlcnJvciwgd2hpY2ggYnJlYWtzIHNvbWUgdGVzdHMuXG4gICAgICAvLyBSYXRoZXIsIHdlIHdhaXQgZm9yIHRoZSBjYWxsYmFjayB0byByZXNvbHZlIGlmIGl0IGlzIGFcbiAgICAgIC8vIHByb21pc2UsIGFuZCB0aGVuIHJlLXJ1biBoYW5kbGVSZXBseSB3aXRoIHRoZSBuZXcgYm9keS5cbiAgICAgIGJvZHkudGhlbigobmV3RGF0YSkgPT4gaGFuZGxlUmVwbHkobW9ja0Rpc3BhdGNoZXMsIG5ld0RhdGEpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gZ2V0UmVzcG9uc2VEYXRhKGJvZHkpXG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZ2VuZXJhdGVLZXlWYWx1ZXMoaGVhZGVycylcbiAgICBjb25zdCByZXNwb25zZVRyYWlsZXJzID0gZ2VuZXJhdGVLZXlWYWx1ZXModHJhaWxlcnMpXG5cbiAgICBoYW5kbGVyLm9uQ29ubmVjdD8uKGVyciA9PiBoYW5kbGVyLm9uRXJyb3IoZXJyKSwgbnVsbClcbiAgICBoYW5kbGVyLm9uSGVhZGVycz8uKHN0YXR1c0NvZGUsIHJlc3BvbnNlSGVhZGVycywgcmVzdW1lLCBnZXRTdGF0dXNUZXh0KHN0YXR1c0NvZGUpKVxuICAgIGhhbmRsZXIub25EYXRhPy4oQnVmZmVyLmZyb20ocmVzcG9uc2VEYXRhKSlcbiAgICBoYW5kbGVyLm9uQ29tcGxldGU/LihyZXNwb25zZVRyYWlsZXJzKVxuICAgIGRlbGV0ZU1vY2tEaXNwYXRjaChtb2NrRGlzcGF0Y2hlcywga2V5KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdW1lICgpIHt9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gYnVpbGRNb2NrRGlzcGF0Y2ggKCkge1xuICBjb25zdCBhZ2VudCA9IHRoaXNba01vY2tBZ2VudF1cbiAgY29uc3Qgb3JpZ2luID0gdGhpc1trT3JpZ2luXVxuICBjb25zdCBvcmlnaW5hbERpc3BhdGNoID0gdGhpc1trT3JpZ2luYWxEaXNwYXRjaF1cblxuICByZXR1cm4gZnVuY3Rpb24gZGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoYWdlbnQuaXNNb2NrQWN0aXZlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtb2NrRGlzcGF0Y2guY2FsbCh0aGlzLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTW9ja05vdE1hdGNoZWRFcnJvcikge1xuICAgICAgICAgIGNvbnN0IG5ldENvbm5lY3QgPSBhZ2VudFtrR2V0TmV0Q29ubmVjdF0oKVxuICAgICAgICAgIGlmIChuZXRDb25uZWN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYCR7ZXJyb3IubWVzc2FnZX06IHN1YnNlcXVlbnQgcmVxdWVzdCB0byBvcmlnaW4gJHtvcmlnaW59IHdhcyBub3QgYWxsb3dlZCAobmV0LmNvbm5lY3QgZGlzYWJsZWQpYClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoZWNrTmV0Q29ubmVjdChuZXRDb25uZWN0LCBvcmlnaW4pKSB7XG4gICAgICAgICAgICBvcmlnaW5hbERpc3BhdGNoLmNhbGwodGhpcywgb3B0cywgaGFuZGxlcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYCR7ZXJyb3IubWVzc2FnZX06IHN1YnNlcXVlbnQgcmVxdWVzdCB0byBvcmlnaW4gJHtvcmlnaW59IHdhcyBub3QgYWxsb3dlZCAobmV0LmNvbm5lY3QgaXMgbm90IGVuYWJsZWQgZm9yIHRoaXMgb3JpZ2luKWApXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ2luYWxEaXNwYXRjaC5jYWxsKHRoaXMsIG9wdHMsIGhhbmRsZXIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTmV0Q29ubmVjdCAobmV0Q29ubmVjdCwgb3JpZ2luKSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwob3JpZ2luKVxuICBpZiAobmV0Q29ubmVjdCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShuZXRDb25uZWN0KSAmJiBuZXRDb25uZWN0LnNvbWUoKG1hdGNoZXIpID0+IG1hdGNoVmFsdWUobWF0Y2hlciwgdXJsLmhvc3QpKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGJ1aWxkQW5kVmFsaWRhdGVNb2NrT3B0aW9ucyAob3B0cykge1xuICBpZiAob3B0cykge1xuICAgIGNvbnN0IHsgYWdlbnQsIC4uLm1vY2tPcHRpb25zIH0gPSBvcHRzXG5cbiAgICBpZiAoJ2VuYWJsZUNhbGxIaXN0b3J5JyBpbiBtb2NrT3B0aW9ucyAmJiB0eXBlb2YgbW9ja09wdGlvbnMuZW5hYmxlQ2FsbEhpc3RvcnkgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRpb25zLmVuYWJsZUNhbGxIaXN0b3J5IG11c3QgdG8gYmUgYSBib29sZWFuJylcbiAgICB9XG5cbiAgICBpZiAoJ2FjY2VwdE5vblN0YW5kYXJkU2VhcmNoUGFyYW1ldGVycycgaW4gbW9ja09wdGlvbnMgJiYgdHlwZW9mIG1vY2tPcHRpb25zLmFjY2VwdE5vblN0YW5kYXJkU2VhcmNoUGFyYW1ldGVycyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdGlvbnMuYWNjZXB0Tm9uU3RhbmRhcmRTZWFyY2hQYXJhbWV0ZXJzIG11c3QgdG8gYmUgYSBib29sZWFuJylcbiAgICB9XG5cbiAgICByZXR1cm4gbW9ja09wdGlvbnNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0UmVzcG9uc2VEYXRhLFxuICBnZXRNb2NrRGlzcGF0Y2gsXG4gIGFkZE1vY2tEaXNwYXRjaCxcbiAgZGVsZXRlTW9ja0Rpc3BhdGNoLFxuICBidWlsZEtleSxcbiAgZ2VuZXJhdGVLZXlWYWx1ZXMsXG4gIG1hdGNoVmFsdWUsXG4gIGdldFJlc3BvbnNlLFxuICBnZXRTdGF0dXNUZXh0LFxuICBtb2NrRGlzcGF0Y2gsXG4gIGJ1aWxkTW9ja0Rpc3BhdGNoLFxuICBjaGVja05ldENvbm5lY3QsXG4gIGJ1aWxkQW5kVmFsaWRhdGVNb2NrT3B0aW9ucyxcbiAgZ2V0SGVhZGVyQnlOYW1lLFxuICBidWlsZEhlYWRlcnNGcm9tQXJyYXksXG4gIG5vcm1hbGl6ZVNlYXJjaFBhcmFtc1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js":
/*!************************************************************************!*\
  !*** ./node_modules/undici/lib/mock/pending-interceptors-formatter.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { Console } = __webpack_require__(/*! node:console */ \"node:console\")\n\nconst PERSISTENT = process.versions.icu ? '' : 'Y '\nconst NOT_PERSISTENT = process.versions.icu ? '' : 'N '\n\n/**\n * Gets the output of `console.table()` as a string.\n */\nmodule.exports = class PendingInterceptorsFormatter {\n  constructor ({ disableColors } = {}) {\n    this.transform = new Transform({\n      transform (chunk, _enc, cb) {\n        cb(null, chunk)\n      }\n    })\n\n    this.logger = new Console({\n      stdout: this.transform,\n      inspectOptions: {\n        colors: !disableColors && !process.env.CI\n      }\n    })\n  }\n\n  format (pendingInterceptors) {\n    const withPrettyHeaders = pendingInterceptors.map(\n      ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({\n        Method: method,\n        Origin: origin,\n        Path: path,\n        'Status code': statusCode,\n        Persistent: persist ? PERSISTENT : NOT_PERSISTENT,\n        Invocations: timesInvoked,\n        Remaining: persist ? Infinity : times - timesInvoked\n      }))\n\n    this.logger.table(withPrettyHeaders)\n    return this.transform.read().toString()\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQzNDLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsa0NBQWM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFNBQVMsc0JBQXNCLFlBQVksd0NBQXdDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHsgQ29uc29sZSB9ID0gcmVxdWlyZSgnbm9kZTpjb25zb2xlJylcblxuY29uc3QgUEVSU0lTVEVOVCA9IHByb2Nlc3MudmVyc2lvbnMuaWN1ID8gJ+KchScgOiAnWSAnXG5jb25zdCBOT1RfUEVSU0lTVEVOVCA9IHByb2Nlc3MudmVyc2lvbnMuaWN1ID8gJ+KdjCcgOiAnTiAnXG5cbi8qKlxuICogR2V0cyB0aGUgb3V0cHV0IG9mIGBjb25zb2xlLnRhYmxlKOKApilgIGFzIGEgc3RyaW5nLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoeyBkaXNhYmxlQ29sb3JzIH0gPSB7fSkge1xuICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybSh7XG4gICAgICB0cmFuc2Zvcm0gKGNodW5rLCBfZW5jLCBjYikge1xuICAgICAgICBjYihudWxsLCBjaHVuaylcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5sb2dnZXIgPSBuZXcgQ29uc29sZSh7XG4gICAgICBzdGRvdXQ6IHRoaXMudHJhbnNmb3JtLFxuICAgICAgaW5zcGVjdE9wdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiAhZGlzYWJsZUNvbG9ycyAmJiAhcHJvY2Vzcy5lbnYuQ0lcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZm9ybWF0IChwZW5kaW5nSW50ZXJjZXB0b3JzKSB7XG4gICAgY29uc3Qgd2l0aFByZXR0eUhlYWRlcnMgPSBwZW5kaW5nSW50ZXJjZXB0b3JzLm1hcChcbiAgICAgICh7IG1ldGhvZCwgcGF0aCwgZGF0YTogeyBzdGF0dXNDb2RlIH0sIHBlcnNpc3QsIHRpbWVzLCB0aW1lc0ludm9rZWQsIG9yaWdpbiB9KSA9PiAoe1xuICAgICAgICBNZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgT3JpZ2luOiBvcmlnaW4sXG4gICAgICAgIFBhdGg6IHBhdGgsXG4gICAgICAgICdTdGF0dXMgY29kZSc6IHN0YXR1c0NvZGUsXG4gICAgICAgIFBlcnNpc3RlbnQ6IHBlcnNpc3QgPyBQRVJTSVNURU5UIDogTk9UX1BFUlNJU1RFTlQsXG4gICAgICAgIEludm9jYXRpb25zOiB0aW1lc0ludm9rZWQsXG4gICAgICAgIFJlbWFpbmluZzogcGVyc2lzdCA/IEluZmluaXR5IDogdGltZXMgLSB0aW1lc0ludm9rZWRcbiAgICAgIH0pKVxuXG4gICAgdGhpcy5sb2dnZXIudGFibGUod2l0aFByZXR0eUhlYWRlcnMpXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJlYWQoKS50b1N0cmluZygpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/util/cache.js":
/*!***********************************************!*\
  !*** ./node_modules/undici/lib/util/cache.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  safeHTTPMethods\n} = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nconst { serializePathWithQuery } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\n/**\n * @param {import('../../types/dispatcher.d.ts').default.DispatchOptions} opts\n */\nfunction makeCacheKey (opts) {\n  if (!opts.origin) {\n    throw new Error('opts.origin is undefined')\n  }\n\n  let fullPath\n  try {\n    fullPath = serializePathWithQuery(opts.path || '/', opts.query)\n  } catch (error) {\n    // If fails (path already has query params), use as-is\n    fullPath = opts.path || '/'\n  }\n\n  return {\n    origin: opts.origin.toString(),\n    method: opts.method,\n    path: fullPath,\n    headers: opts.headers\n  }\n}\n\n/**\n * @param {Record<string, string[] | string>}\n * @return {Record<string, string[] | string>}\n */\nfunction normaliseHeaders (opts) {\n  let headers\n  if (opts.headers == null) {\n    headers = {}\n  } else if (typeof opts.headers[Symbol.iterator] === 'function') {\n    headers = {}\n    for (const x of opts.headers) {\n      if (!Array.isArray(x)) {\n        throw new Error('opts.headers is not a valid header map')\n      }\n      const [key, val] = x\n      if (typeof key !== 'string' || typeof val !== 'string') {\n        throw new Error('opts.headers is not a valid header map')\n      }\n      headers[key.toLowerCase()] = val\n    }\n  } else if (typeof opts.headers === 'object') {\n    headers = {}\n\n    for (const key of Object.keys(opts.headers)) {\n      headers[key.toLowerCase()] = opts.headers[key]\n    }\n  } else {\n    throw new Error('opts.headers is not an object')\n  }\n\n  return headers\n}\n\n/**\n * @param {any} key\n */\nfunction assertCacheKey (key) {\n  if (typeof key !== 'object') {\n    throw new TypeError(`expected key to be object, got ${typeof key}`)\n  }\n\n  for (const property of ['origin', 'method', 'path']) {\n    if (typeof key[property] !== 'string') {\n      throw new TypeError(`expected key.${property} to be string, got ${typeof key[property]}`)\n    }\n  }\n\n  if (key.headers !== undefined && typeof key.headers !== 'object') {\n    throw new TypeError(`expected headers to be object, got ${typeof key}`)\n  }\n}\n\n/**\n * @param {any} value\n */\nfunction assertCacheValue (value) {\n  if (typeof value !== 'object') {\n    throw new TypeError(`expected value to be object, got ${typeof value}`)\n  }\n\n  for (const property of ['statusCode', 'cachedAt', 'staleAt', 'deleteAt']) {\n    if (typeof value[property] !== 'number') {\n      throw new TypeError(`expected value.${property} to be number, got ${typeof value[property]}`)\n    }\n  }\n\n  if (typeof value.statusMessage !== 'string') {\n    throw new TypeError(`expected value.statusMessage to be string, got ${typeof value.statusMessage}`)\n  }\n\n  if (value.headers != null && typeof value.headers !== 'object') {\n    throw new TypeError(`expected value.rawHeaders to be object, got ${typeof value.headers}`)\n  }\n\n  if (value.vary !== undefined && typeof value.vary !== 'object') {\n    throw new TypeError(`expected value.vary to be object, got ${typeof value.vary}`)\n  }\n\n  if (value.etag !== undefined && typeof value.etag !== 'string') {\n    throw new TypeError(`expected value.etag to be string, got ${typeof value.etag}`)\n  }\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc9111.html#name-cache-control\n * @see https://www.iana.org/assignments/http-cache-directives/http-cache-directives.xhtml\n\n * @param {string | string[]} header\n * @returns {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives}\n */\nfunction parseCacheControlHeader (header) {\n  /**\n   * @type {import('../../types/cache-interceptor.d.ts').default.CacheControlDirectives}\n   */\n  const output = {}\n\n  let directives\n  if (Array.isArray(header)) {\n    directives = []\n\n    for (const directive of header) {\n      directives.push(...directive.split(','))\n    }\n  } else {\n    directives = header.split(',')\n  }\n\n  for (let i = 0; i < directives.length; i++) {\n    const directive = directives[i].toLowerCase()\n    const keyValueDelimiter = directive.indexOf('=')\n\n    let key\n    let value\n    if (keyValueDelimiter !== -1) {\n      key = directive.substring(0, keyValueDelimiter).trimStart()\n      value = directive.substring(keyValueDelimiter + 1)\n    } else {\n      key = directive.trim()\n    }\n\n    switch (key) {\n      case 'min-fresh':\n      case 'max-stale':\n      case 'max-age':\n      case 's-maxage':\n      case 'stale-while-revalidate':\n      case 'stale-if-error': {\n        if (value === undefined || value[0] === ' ') {\n          continue\n        }\n\n        if (\n          value.length >= 2 &&\n          value[0] === '\"' &&\n          value[value.length - 1] === '\"'\n        ) {\n          value = value.substring(1, value.length - 1)\n        }\n\n        const parsedValue = parseInt(value, 10)\n        // eslint-disable-next-line no-self-compare\n        if (parsedValue !== parsedValue) {\n          continue\n        }\n\n        if (key === 'max-age' && key in output && output[key] >= parsedValue) {\n          continue\n        }\n\n        output[key] = parsedValue\n\n        break\n      }\n      case 'private':\n      case 'no-cache': {\n        if (value) {\n          // The private and no-cache directives can be unqualified (aka just\n          //  `private` or `no-cache`) or qualified (w/ a value). When they're\n          //  qualified, it's a list of headers like `no-cache=header1`,\n          //  `no-cache=\"header1\"`, or `no-cache=\"header1, header2\"`\n          // If we're given multiple headers, the comma messes us up since\n          //  we split the full header by commas. So, let's loop through the\n          //  remaining parts in front of us until we find one that ends in a\n          //  quote. We can then just splice all of the parts in between the\n          //  starting quote and the ending quote out of the directives array\n          //  and continue parsing like normal.\n          // https://www.rfc-editor.org/rfc/rfc9111.html#name-no-cache-2\n          if (value[0] === '\"') {\n            // Something like `no-cache=\"some-header\"` OR `no-cache=\"some-header, another-header\"`.\n\n            // Add the first header on and cut off the leading quote\n            const headers = [value.substring(1)]\n\n            let foundEndingQuote = value[value.length - 1] === '\"'\n            if (!foundEndingQuote) {\n              // Something like `no-cache=\"some-header, another-header\"`\n              //  This can still be something invalid, e.g. `no-cache=\"some-header, ...`\n              for (let j = i + 1; j < directives.length; j++) {\n                const nextPart = directives[j]\n                const nextPartLength = nextPart.length\n\n                headers.push(nextPart.trim())\n\n                if (nextPartLength !== 0 && nextPart[nextPartLength - 1] === '\"') {\n                  foundEndingQuote = true\n                  break\n                }\n              }\n            }\n\n            if (foundEndingQuote) {\n              let lastHeader = headers[headers.length - 1]\n              if (lastHeader[lastHeader.length - 1] === '\"') {\n                lastHeader = lastHeader.substring(0, lastHeader.length - 1)\n                headers[headers.length - 1] = lastHeader\n              }\n\n              if (key in output) {\n                output[key] = output[key].concat(headers)\n              } else {\n                output[key] = headers\n              }\n            }\n          } else {\n            // Something like `no-cache=some-header`\n            if (key in output) {\n              output[key] = output[key].concat(value)\n            } else {\n              output[key] = [value]\n            }\n          }\n\n          break\n        }\n      }\n      // eslint-disable-next-line no-fallthrough\n      case 'public':\n      case 'no-store':\n      case 'must-revalidate':\n      case 'proxy-revalidate':\n      case 'immutable':\n      case 'no-transform':\n      case 'must-understand':\n      case 'only-if-cached':\n        if (value) {\n          // These are qualified (something like `public=...`) when they aren't\n          //  allowed to be, skip\n          continue\n        }\n\n        output[key] = true\n        break\n      default:\n        // Ignore unknown directives as per https://www.rfc-editor.org/rfc/rfc9111.html#section-5.2.3-1\n        continue\n    }\n  }\n\n  return output\n}\n\n/**\n * @param {string | string[]} varyHeader Vary header from the server\n * @param {Record<string, string | string[]>} headers Request headers\n * @returns {Record<string, string | string[]>}\n */\nfunction parseVaryHeader (varyHeader, headers) {\n  if (typeof varyHeader === 'string' && varyHeader.includes('*')) {\n    return headers\n  }\n\n  const output = /** @type {Record<string, string | string[] | null>} */ ({})\n\n  const varyingHeaders = typeof varyHeader === 'string'\n    ? varyHeader.split(',')\n    : varyHeader\n\n  for (const header of varyingHeaders) {\n    const trimmedHeader = header.trim().toLowerCase()\n\n    output[trimmedHeader] = headers[trimmedHeader] ?? null\n  }\n\n  return output\n}\n\n/**\n * Note: this deviates from the spec a little. Empty etags (\"\", W/\"\") are valid,\n *  however, including them in cached resposnes serves little to no purpose.\n *\n * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-etag\n *\n * @param {string} etag\n * @returns {boolean}\n */\nfunction isEtagUsable (etag) {\n  if (etag.length <= 2) {\n    // Shortest an etag can be is two chars (just \"\"). This is where we deviate\n    //  from the spec requiring a min of 3 chars however\n    return false\n  }\n\n  if (etag[0] === '\"' && etag[etag.length - 1] === '\"') {\n    // ETag: \"\"asd123\"\" or ETag: \"W/\"asd123\"\", kinda undefined behavior in the\n    //  spec. Some servers will accept these while others don't.\n    // ETag: \"asd123\"\n    return !(etag[1] === '\"' || etag.startsWith('\"W/'))\n  }\n\n  if (etag.startsWith('W/\"') && etag[etag.length - 1] === '\"') {\n    // ETag: W/\"\", also where we deviate from the spec & require a min of 3\n    //  chars\n    // ETag: for W/\"\", W/\"asd123\"\n    return etag.length !== 4\n  }\n\n  // Anything else\n  return false\n}\n\n/**\n * @param {unknown} store\n * @returns {asserts store is import('../../types/cache-interceptor.d.ts').default.CacheStore}\n */\nfunction assertCacheStore (store, name = 'CacheStore') {\n  if (typeof store !== 'object' || store === null) {\n    throw new TypeError(`expected type of ${name} to be a CacheStore, got ${store === null ? 'null' : typeof store}`)\n  }\n\n  for (const fn of ['get', 'createWriteStream', 'delete']) {\n    if (typeof store[fn] !== 'function') {\n      throw new TypeError(`${name} needs to have a \\`${fn}()\\` function`)\n    }\n  }\n}\n/**\n * @param {unknown} methods\n * @returns {asserts methods is import('../../types/cache-interceptor.d.ts').default.CacheMethods[]}\n */\nfunction assertCacheMethods (methods, name = 'CacheMethods') {\n  if (!Array.isArray(methods)) {\n    throw new TypeError(`expected type of ${name} needs to be an array, got ${methods === null ? 'null' : typeof methods}`)\n  }\n\n  if (methods.length === 0) {\n    throw new TypeError(`${name} needs to have at least one method`)\n  }\n\n  for (const method of methods) {\n    if (!safeHTTPMethods.includes(method)) {\n      throw new TypeError(`element of ${name}-array needs to be one of following values: ${safeHTTPMethods.join(', ')}, got ${method}`)\n    }\n  }\n}\n\nmodule.exports = {\n  makeCacheKey,\n  normaliseHeaders,\n  assertCacheKey,\n  assertCacheValue,\n  parseCacheControlHeader,\n  parseVaryHeader,\n  isEtagUsable,\n  assertCacheMethods,\n  assertCacheStore\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL2NhY2hlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYzs7QUFFMUIsUUFBUSx5QkFBeUIsRUFBRSxtQkFBTyxDQUFDLGtFQUFjOztBQUV6RDtBQUNBLFdBQVcsK0RBQStEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVc7QUFDckU7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxVQUFVLG9CQUFvQixxQkFBcUI7QUFDN0Y7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RCxXQUFXO0FBQ3pFO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGFBQWE7QUFDekU7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxVQUFVLG9CQUFvQix1QkFBdUI7QUFDakc7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRSwyQkFBMkI7QUFDckc7O0FBRUE7QUFDQSx1RUFBdUUscUJBQXFCO0FBQzVGOztBQUVBO0FBQ0EsaUVBQWlFLGtCQUFrQjtBQUNuRjs7QUFFQTtBQUNBLGlFQUFpRSxrQkFBa0I7QUFDbkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLG1DQUFtQztBQUM5QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsMENBQTBDLE1BQU07O0FBRTVFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTSwwQkFBMEIsdUNBQXVDO0FBQ25IOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTSxvQkFBb0IsR0FBRztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU0sNEJBQTRCLDJDQUEyQztBQUN6SDs7QUFFQTtBQUNBLDJCQUEyQixNQUFNO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSyw4Q0FBOEMsMkJBQTJCLFFBQVEsT0FBTztBQUNySTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL2NhY2hlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIHNhZmVIVFRQTWV0aG9kc1xufSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbmNvbnN0IHsgc2VyaWFsaXplUGF0aFdpdGhRdWVyeSB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvZGlzcGF0Y2hlci5kLnRzJykuZGVmYXVsdC5EaXNwYXRjaE9wdGlvbnN9IG9wdHNcbiAqL1xuZnVuY3Rpb24gbWFrZUNhY2hlS2V5IChvcHRzKSB7XG4gIGlmICghb3B0cy5vcmlnaW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdHMub3JpZ2luIGlzIHVuZGVmaW5lZCcpXG4gIH1cblxuICBsZXQgZnVsbFBhdGhcbiAgdHJ5IHtcbiAgICBmdWxsUGF0aCA9IHNlcmlhbGl6ZVBhdGhXaXRoUXVlcnkob3B0cy5wYXRoIHx8ICcvJywgb3B0cy5xdWVyeSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBJZiBmYWlscyAocGF0aCBhbHJlYWR5IGhhcyBxdWVyeSBwYXJhbXMpLCB1c2UgYXMtaXNcbiAgICBmdWxsUGF0aCA9IG9wdHMucGF0aCB8fCAnLydcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb3JpZ2luOiBvcHRzLm9yaWdpbi50b1N0cmluZygpLFxuICAgIG1ldGhvZDogb3B0cy5tZXRob2QsXG4gICAgcGF0aDogZnVsbFBhdGgsXG4gICAgaGVhZGVyczogb3B0cy5oZWFkZXJzXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZ1tdIHwgc3RyaW5nPn1cbiAqIEByZXR1cm4ge1JlY29yZDxzdHJpbmcsIHN0cmluZ1tdIHwgc3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXNlSGVhZGVycyAob3B0cykge1xuICBsZXQgaGVhZGVyc1xuICBpZiAob3B0cy5oZWFkZXJzID09IG51bGwpIHtcbiAgICBoZWFkZXJzID0ge31cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5oZWFkZXJzW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBoZWFkZXJzID0ge31cbiAgICBmb3IgKGNvbnN0IHggb2Ygb3B0cy5oZWFkZXJzKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRzLmhlYWRlcnMgaXMgbm90IGEgdmFsaWQgaGVhZGVyIG1hcCcpXG4gICAgICB9XG4gICAgICBjb25zdCBba2V5LCB2YWxdID0geFxuICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0cy5oZWFkZXJzIGlzIG5vdCBhIHZhbGlkIGhlYWRlciBtYXAnKVxuICAgICAgfVxuICAgICAgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuaGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICBoZWFkZXJzID0ge31cblxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9wdHMuaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gb3B0cy5oZWFkZXJzW2tleV1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvcHRzLmhlYWRlcnMgaXMgbm90IGFuIG9iamVjdCcpXG4gIH1cblxuICByZXR1cm4gaGVhZGVyc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0Q2FjaGVLZXkgKGtleSkge1xuICBpZiAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBrZXkgdG8gYmUgb2JqZWN0LCBnb3QgJHt0eXBlb2Yga2V5fWApXG4gIH1cblxuICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIFsnb3JpZ2luJywgJ21ldGhvZCcsICdwYXRoJ10pIHtcbiAgICBpZiAodHlwZW9mIGtleVtwcm9wZXJ0eV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBrZXkuJHtwcm9wZXJ0eX0gdG8gYmUgc3RyaW5nLCBnb3QgJHt0eXBlb2Yga2V5W3Byb3BlcnR5XX1gKVxuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkuaGVhZGVycyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBrZXkuaGVhZGVycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBoZWFkZXJzIHRvIGJlIG9iamVjdCwgZ290ICR7dHlwZW9mIGtleX1gKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGFzc2VydENhY2hlVmFsdWUgKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgdmFsdWUgdG8gYmUgb2JqZWN0LCBnb3QgJHt0eXBlb2YgdmFsdWV9YClcbiAgfVxuXG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgWydzdGF0dXNDb2RlJywgJ2NhY2hlZEF0JywgJ3N0YWxlQXQnLCAnZGVsZXRlQXQnXSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWVbcHJvcGVydHldICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgdmFsdWUuJHtwcm9wZXJ0eX0gdG8gYmUgbnVtYmVyLCBnb3QgJHt0eXBlb2YgdmFsdWVbcHJvcGVydHldfWApXG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZS5zdGF0dXNNZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIHZhbHVlLnN0YXR1c01lc3NhZ2UgdG8gYmUgc3RyaW5nLCBnb3QgJHt0eXBlb2YgdmFsdWUuc3RhdHVzTWVzc2FnZX1gKVxuICB9XG5cbiAgaWYgKHZhbHVlLmhlYWRlcnMgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuaGVhZGVycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCB2YWx1ZS5yYXdIZWFkZXJzIHRvIGJlIG9iamVjdCwgZ290ICR7dHlwZW9mIHZhbHVlLmhlYWRlcnN9YClcbiAgfVxuXG4gIGlmICh2YWx1ZS52YXJ5ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlLnZhcnkgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgdmFsdWUudmFyeSB0byBiZSBvYmplY3QsIGdvdCAke3R5cGVvZiB2YWx1ZS52YXJ5fWApXG4gIH1cblxuICBpZiAodmFsdWUuZXRhZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZS5ldGFnICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIHZhbHVlLmV0YWcgdG8gYmUgc3RyaW5nLCBnb3QgJHt0eXBlb2YgdmFsdWUuZXRhZ31gKVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMS5odG1sI25hbWUtY2FjaGUtY29udHJvbFxuICogQHNlZSBodHRwczovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9odHRwLWNhY2hlLWRpcmVjdGl2ZXMvaHR0cC1jYWNoZS1kaXJlY3RpdmVzLnhodG1sXG5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGhlYWRlclxuICogQHJldHVybnMge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVDb250cm9sRGlyZWN0aXZlc31cbiAqL1xuZnVuY3Rpb24gcGFyc2VDYWNoZUNvbnRyb2xIZWFkZXIgKGhlYWRlcikge1xuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUtaW50ZXJjZXB0b3IuZC50cycpLmRlZmF1bHQuQ2FjaGVDb250cm9sRGlyZWN0aXZlc31cbiAgICovXG4gIGNvbnN0IG91dHB1dCA9IHt9XG5cbiAgbGV0IGRpcmVjdGl2ZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVyKSkge1xuICAgIGRpcmVjdGl2ZXMgPSBbXVxuXG4gICAgZm9yIChjb25zdCBkaXJlY3RpdmUgb2YgaGVhZGVyKSB7XG4gICAgICBkaXJlY3RpdmVzLnB1c2goLi4uZGlyZWN0aXZlLnNwbGl0KCcsJykpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpcmVjdGl2ZXMgPSBoZWFkZXIuc3BsaXQoJywnKVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGlyZWN0aXZlID0gZGlyZWN0aXZlc1tpXS50b0xvd2VyQ2FzZSgpXG4gICAgY29uc3Qga2V5VmFsdWVEZWxpbWl0ZXIgPSBkaXJlY3RpdmUuaW5kZXhPZignPScpXG5cbiAgICBsZXQga2V5XG4gICAgbGV0IHZhbHVlXG4gICAgaWYgKGtleVZhbHVlRGVsaW1pdGVyICE9PSAtMSkge1xuICAgICAga2V5ID0gZGlyZWN0aXZlLnN1YnN0cmluZygwLCBrZXlWYWx1ZURlbGltaXRlcikudHJpbVN0YXJ0KClcbiAgICAgIHZhbHVlID0gZGlyZWN0aXZlLnN1YnN0cmluZyhrZXlWYWx1ZURlbGltaXRlciArIDEpXG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IGRpcmVjdGl2ZS50cmltKClcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSAnbWluLWZyZXNoJzpcbiAgICAgIGNhc2UgJ21heC1zdGFsZSc6XG4gICAgICBjYXNlICdtYXgtYWdlJzpcbiAgICAgIGNhc2UgJ3MtbWF4YWdlJzpcbiAgICAgIGNhc2UgJ3N0YWxlLXdoaWxlLXJldmFsaWRhdGUnOlxuICAgICAgY2FzZSAnc3RhbGUtaWYtZXJyb3InOiB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlWzBdID09PSAnICcpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHZhbHVlLmxlbmd0aCA+PSAyICYmXG4gICAgICAgICAgdmFsdWVbMF0gPT09ICdcIicgJiZcbiAgICAgICAgICB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJ1wiJ1xuICAgICAgICApIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgICAgaWYgKHBhcnNlZFZhbHVlICE9PSBwYXJzZWRWYWx1ZSkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ID09PSAnbWF4LWFnZScgJiYga2V5IGluIG91dHB1dCAmJiBvdXRwdXRba2V5XSA+PSBwYXJzZWRWYWx1ZSkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXRba2V5XSA9IHBhcnNlZFZhbHVlXG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3ByaXZhdGUnOlxuICAgICAgY2FzZSAnbm8tY2FjaGUnOiB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIC8vIFRoZSBwcml2YXRlIGFuZCBuby1jYWNoZSBkaXJlY3RpdmVzIGNhbiBiZSB1bnF1YWxpZmllZCAoYWthIGp1c3RcbiAgICAgICAgICAvLyAgYHByaXZhdGVgIG9yIGBuby1jYWNoZWApIG9yIHF1YWxpZmllZCAody8gYSB2YWx1ZSkuIFdoZW4gdGhleSdyZVxuICAgICAgICAgIC8vICBxdWFsaWZpZWQsIGl0J3MgYSBsaXN0IG9mIGhlYWRlcnMgbGlrZSBgbm8tY2FjaGU9aGVhZGVyMWAsXG4gICAgICAgICAgLy8gIGBuby1jYWNoZT1cImhlYWRlcjFcImAsIG9yIGBuby1jYWNoZT1cImhlYWRlcjEsIGhlYWRlcjJcImBcbiAgICAgICAgICAvLyBJZiB3ZSdyZSBnaXZlbiBtdWx0aXBsZSBoZWFkZXJzLCB0aGUgY29tbWEgbWVzc2VzIHVzIHVwIHNpbmNlXG4gICAgICAgICAgLy8gIHdlIHNwbGl0IHRoZSBmdWxsIGhlYWRlciBieSBjb21tYXMuIFNvLCBsZXQncyBsb29wIHRocm91Z2ggdGhlXG4gICAgICAgICAgLy8gIHJlbWFpbmluZyBwYXJ0cyBpbiBmcm9udCBvZiB1cyB1bnRpbCB3ZSBmaW5kIG9uZSB0aGF0IGVuZHMgaW4gYVxuICAgICAgICAgIC8vICBxdW90ZS4gV2UgY2FuIHRoZW4ganVzdCBzcGxpY2UgYWxsIG9mIHRoZSBwYXJ0cyBpbiBiZXR3ZWVuIHRoZVxuICAgICAgICAgIC8vICBzdGFydGluZyBxdW90ZSBhbmQgdGhlIGVuZGluZyBxdW90ZSBvdXQgb2YgdGhlIGRpcmVjdGl2ZXMgYXJyYXlcbiAgICAgICAgICAvLyAgYW5kIGNvbnRpbnVlIHBhcnNpbmcgbGlrZSBub3JtYWwuXG4gICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTEuaHRtbCNuYW1lLW5vLWNhY2hlLTJcbiAgICAgICAgICBpZiAodmFsdWVbMF0gPT09ICdcIicpIHtcbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyBsaWtlIGBuby1jYWNoZT1cInNvbWUtaGVhZGVyXCJgIE9SIGBuby1jYWNoZT1cInNvbWUtaGVhZGVyLCBhbm90aGVyLWhlYWRlclwiYC5cblxuICAgICAgICAgICAgLy8gQWRkIHRoZSBmaXJzdCBoZWFkZXIgb24gYW5kIGN1dCBvZmYgdGhlIGxlYWRpbmcgcXVvdGVcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBbdmFsdWUuc3Vic3RyaW5nKDEpXVxuXG4gICAgICAgICAgICBsZXQgZm91bmRFbmRpbmdRdW90ZSA9IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnXCInXG4gICAgICAgICAgICBpZiAoIWZvdW5kRW5kaW5nUXVvdGUpIHtcbiAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIGxpa2UgYG5vLWNhY2hlPVwic29tZS1oZWFkZXIsIGFub3RoZXItaGVhZGVyXCJgXG4gICAgICAgICAgICAgIC8vICBUaGlzIGNhbiBzdGlsbCBiZSBzb21ldGhpbmcgaW52YWxpZCwgZS5nLiBgbm8tY2FjaGU9XCJzb21lLWhlYWRlciwgLi4uYFxuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBkaXJlY3RpdmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBhcnQgPSBkaXJlY3RpdmVzW2pdXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBhcnRMZW5ndGggPSBuZXh0UGFydC5sZW5ndGhcblxuICAgICAgICAgICAgICAgIGhlYWRlcnMucHVzaChuZXh0UGFydC50cmltKCkpXG5cbiAgICAgICAgICAgICAgICBpZiAobmV4dFBhcnRMZW5ndGggIT09IDAgJiYgbmV4dFBhcnRbbmV4dFBhcnRMZW5ndGggLSAxXSA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgZm91bmRFbmRpbmdRdW90ZSA9IHRydWVcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb3VuZEVuZGluZ1F1b3RlKSB7XG4gICAgICAgICAgICAgIGxldCBsYXN0SGVhZGVyID0gaGVhZGVyc1toZWFkZXJzLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgIGlmIChsYXN0SGVhZGVyW2xhc3RIZWFkZXIubGVuZ3RoIC0gMV0gPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBsYXN0SGVhZGVyID0gbGFzdEhlYWRlci5zdWJzdHJpbmcoMCwgbGFzdEhlYWRlci5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIGhlYWRlcnNbaGVhZGVycy5sZW5ndGggLSAxXSA9IGxhc3RIZWFkZXJcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChrZXkgaW4gb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBvdXRwdXRba2V5XS5jb25jYXQoaGVhZGVycylcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IGhlYWRlcnNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgbGlrZSBgbm8tY2FjaGU9c29tZS1oZWFkZXJgXG4gICAgICAgICAgICBpZiAoa2V5IGluIG91dHB1dCkge1xuICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IG91dHB1dFtrZXldLmNvbmNhdCh2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dHB1dFtrZXldID0gW3ZhbHVlXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgY2FzZSAncHVibGljJzpcbiAgICAgIGNhc2UgJ25vLXN0b3JlJzpcbiAgICAgIGNhc2UgJ211c3QtcmV2YWxpZGF0ZSc6XG4gICAgICBjYXNlICdwcm94eS1yZXZhbGlkYXRlJzpcbiAgICAgIGNhc2UgJ2ltbXV0YWJsZSc6XG4gICAgICBjYXNlICduby10cmFuc2Zvcm0nOlxuICAgICAgY2FzZSAnbXVzdC11bmRlcnN0YW5kJzpcbiAgICAgIGNhc2UgJ29ubHktaWYtY2FjaGVkJzpcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgLy8gVGhlc2UgYXJlIHF1YWxpZmllZCAoc29tZXRoaW5nIGxpa2UgYHB1YmxpYz0uLi5gKSB3aGVuIHRoZXkgYXJlbid0XG4gICAgICAgICAgLy8gIGFsbG93ZWQgdG8gYmUsIHNraXBcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0W2tleV0gPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBJZ25vcmUgdW5rbm93biBkaXJlY3RpdmVzIGFzIHBlciBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMS5odG1sI3NlY3Rpb24tNS4yLjMtMVxuICAgICAgICBjb250aW51ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSB2YXJ5SGVhZGVyIFZhcnkgaGVhZGVyIGZyb20gdGhlIHNlcnZlclxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXT59IGhlYWRlcnMgUmVxdWVzdCBoZWFkZXJzXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+fVxuICovXG5mdW5jdGlvbiBwYXJzZVZhcnlIZWFkZXIgKHZhcnlIZWFkZXIsIGhlYWRlcnMpIHtcbiAgaWYgKHR5cGVvZiB2YXJ5SGVhZGVyID09PSAnc3RyaW5nJyAmJiB2YXJ5SGVhZGVyLmluY2x1ZGVzKCcqJykpIHtcbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgY29uc3Qgb3V0cHV0ID0gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXSB8IG51bGw+fSAqLyAoe30pXG5cbiAgY29uc3QgdmFyeWluZ0hlYWRlcnMgPSB0eXBlb2YgdmFyeUhlYWRlciA9PT0gJ3N0cmluZydcbiAgICA/IHZhcnlIZWFkZXIuc3BsaXQoJywnKVxuICAgIDogdmFyeUhlYWRlclxuXG4gIGZvciAoY29uc3QgaGVhZGVyIG9mIHZhcnlpbmdIZWFkZXJzKSB7XG4gICAgY29uc3QgdHJpbW1lZEhlYWRlciA9IGhlYWRlci50cmltKCkudG9Mb3dlckNhc2UoKVxuXG4gICAgb3V0cHV0W3RyaW1tZWRIZWFkZXJdID0gaGVhZGVyc1t0cmltbWVkSGVhZGVyXSA/PyBudWxsXG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG5cbi8qKlxuICogTm90ZTogdGhpcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGEgbGl0dGxlLiBFbXB0eSBldGFncyAoXCJcIiwgVy9cIlwiKSBhcmUgdmFsaWQsXG4gKiAgaG93ZXZlciwgaW5jbHVkaW5nIHRoZW0gaW4gY2FjaGVkIHJlc3Bvc25lcyBzZXJ2ZXMgbGl0dGxlIHRvIG5vIHB1cnBvc2UuXG4gKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMC5odG1sI25hbWUtZXRhZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldGFnXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFdGFnVXNhYmxlIChldGFnKSB7XG4gIGlmIChldGFnLmxlbmd0aCA8PSAyKSB7XG4gICAgLy8gU2hvcnRlc3QgYW4gZXRhZyBjYW4gYmUgaXMgdHdvIGNoYXJzIChqdXN0IFwiXCIpLiBUaGlzIGlzIHdoZXJlIHdlIGRldmlhdGVcbiAgICAvLyAgZnJvbSB0aGUgc3BlYyByZXF1aXJpbmcgYSBtaW4gb2YgMyBjaGFycyBob3dldmVyXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoZXRhZ1swXSA9PT0gJ1wiJyAmJiBldGFnW2V0YWcubGVuZ3RoIC0gMV0gPT09ICdcIicpIHtcbiAgICAvLyBFVGFnOiBcIlwiYXNkMTIzXCJcIiBvciBFVGFnOiBcIlcvXCJhc2QxMjNcIlwiLCBraW5kYSB1bmRlZmluZWQgYmVoYXZpb3IgaW4gdGhlXG4gICAgLy8gIHNwZWMuIFNvbWUgc2VydmVycyB3aWxsIGFjY2VwdCB0aGVzZSB3aGlsZSBvdGhlcnMgZG9uJ3QuXG4gICAgLy8gRVRhZzogXCJhc2QxMjNcIlxuICAgIHJldHVybiAhKGV0YWdbMV0gPT09ICdcIicgfHwgZXRhZy5zdGFydHNXaXRoKCdcIlcvJykpXG4gIH1cblxuICBpZiAoZXRhZy5zdGFydHNXaXRoKCdXL1wiJykgJiYgZXRhZ1tldGFnLmxlbmd0aCAtIDFdID09PSAnXCInKSB7XG4gICAgLy8gRVRhZzogVy9cIlwiLCBhbHNvIHdoZXJlIHdlIGRldmlhdGUgZnJvbSB0aGUgc3BlYyAmIHJlcXVpcmUgYSBtaW4gb2YgM1xuICAgIC8vICBjaGFyc1xuICAgIC8vIEVUYWc6IGZvciBXL1wiXCIsIFcvXCJhc2QxMjNcIlxuICAgIHJldHVybiBldGFnLmxlbmd0aCAhPT0gNFxuICB9XG5cbiAgLy8gQW55dGhpbmcgZWxzZVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IHN0b3JlXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyBzdG9yZSBpcyBpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlU3RvcmV9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydENhY2hlU3RvcmUgKHN0b3JlLCBuYW1lID0gJ0NhY2hlU3RvcmUnKSB7XG4gIGlmICh0eXBlb2Ygc3RvcmUgIT09ICdvYmplY3QnIHx8IHN0b3JlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgdHlwZSBvZiAke25hbWV9IHRvIGJlIGEgQ2FjaGVTdG9yZSwgZ290ICR7c3RvcmUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2Ygc3RvcmV9YClcbiAgfVxuXG4gIGZvciAoY29uc3QgZm4gb2YgWydnZXQnLCAnY3JlYXRlV3JpdGVTdHJlYW0nLCAnZGVsZXRlJ10pIHtcbiAgICBpZiAodHlwZW9mIHN0b3JlW2ZuXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtuYW1lfSBuZWVkcyB0byBoYXZlIGEgXFxgJHtmbn0oKVxcYCBmdW5jdGlvbmApXG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gbWV0aG9kc1xuICogQHJldHVybnMge2Fzc2VydHMgbWV0aG9kcyBpcyBpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlLWludGVyY2VwdG9yLmQudHMnKS5kZWZhdWx0LkNhY2hlTWV0aG9kc1tdfVxuICovXG5mdW5jdGlvbiBhc3NlcnRDYWNoZU1ldGhvZHMgKG1ldGhvZHMsIG5hbWUgPSAnQ2FjaGVNZXRob2RzJykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobWV0aG9kcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCB0eXBlIG9mICR7bmFtZX0gbmVlZHMgdG8gYmUgYW4gYXJyYXksIGdvdCAke21ldGhvZHMgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgbWV0aG9kc31gKVxuICB9XG5cbiAgaWYgKG1ldGhvZHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtuYW1lfSBuZWVkcyB0byBoYXZlIGF0IGxlYXN0IG9uZSBtZXRob2RgKVxuICB9XG5cbiAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xuICAgIGlmICghc2FmZUhUVFBNZXRob2RzLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGVsZW1lbnQgb2YgJHtuYW1lfS1hcnJheSBuZWVkcyB0byBiZSBvbmUgb2YgZm9sbG93aW5nIHZhbHVlczogJHtzYWZlSFRUUE1ldGhvZHMuam9pbignLCAnKX0sIGdvdCAke21ldGhvZH1gKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWFrZUNhY2hlS2V5LFxuICBub3JtYWxpc2VIZWFkZXJzLFxuICBhc3NlcnRDYWNoZUtleSxcbiAgYXNzZXJ0Q2FjaGVWYWx1ZSxcbiAgcGFyc2VDYWNoZUNvbnRyb2xIZWFkZXIsXG4gIHBhcnNlVmFyeUhlYWRlcixcbiAgaXNFdGFnVXNhYmxlLFxuICBhc3NlcnRDYWNoZU1ldGhvZHMsXG4gIGFzc2VydENhY2hlU3RvcmVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/util/cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/util/date.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/util/date.js ***!
  \**********************************************/
/***/ ((module) => {

eval("\n\nconst IMF_DAYS = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']\nconst IMF_SPACES = [4, 7, 11, 16, 25]\nconst IMF_MONTHS = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec']\nconst IMF_COLONS = [19, 22]\n\nconst ASCTIME_SPACES = [3, 7, 10, 19]\n\nconst RFC850_DAYS = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc9110.html#name-date-time-formats\n *\n * @param {string} date\n * @param {Date} [now]\n * @returns {Date | undefined}\n */\nfunction parseHttpDate (date, now) {\n  // Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate\n  // Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format\n  // Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete RFC 850 format\n\n  date = date.toLowerCase()\n\n  switch (date[3]) {\n    case ',': return parseImfDate(date)\n    case ' ': return parseAscTimeDate(date)\n    default: return parseRfc850Date(date, now)\n  }\n}\n\n/**\n * @see https://httpwg.org/specs/rfc9110.html#preferred.date.format\n *\n * @param {string} date\n * @returns {Date | undefined}\n */\nfunction parseImfDate (date) {\n  if (date.length !== 29) {\n    return undefined\n  }\n\n  if (!date.endsWith('gmt')) {\n    // Unsupported timezone\n    return undefined\n  }\n\n  for (const spaceInx of IMF_SPACES) {\n    if (date[spaceInx] !== ' ') {\n      return undefined\n    }\n  }\n\n  for (const colonIdx of IMF_COLONS) {\n    if (date[colonIdx] !== ':') {\n      return undefined\n    }\n  }\n\n  const dayName = date.substring(0, 3)\n  if (!IMF_DAYS.includes(dayName)) {\n    return undefined\n  }\n\n  const dayString = date.substring(5, 7)\n  const day = Number.parseInt(dayString)\n  if (isNaN(day) || (day < 10 && dayString[0] !== '0')) {\n    // Not a number, 0, or it's less than 10 and didn't start with a 0\n    return undefined\n  }\n\n  const month = date.substring(8, 11)\n  const monthIdx = IMF_MONTHS.indexOf(month)\n  if (monthIdx === -1) {\n    return undefined\n  }\n\n  const year = Number.parseInt(date.substring(12, 16))\n  if (isNaN(year)) {\n    return undefined\n  }\n\n  const hourString = date.substring(17, 19)\n  const hour = Number.parseInt(hourString)\n  if (isNaN(hour) || (hour < 10 && hourString[0] !== '0')) {\n    return undefined\n  }\n\n  const minuteString = date.substring(20, 22)\n  const minute = Number.parseInt(minuteString)\n  if (isNaN(minute) || (minute < 10 && minuteString[0] !== '0')) {\n    return undefined\n  }\n\n  const secondString = date.substring(23, 25)\n  const second = Number.parseInt(secondString)\n  if (isNaN(second) || (second < 10 && secondString[0] !== '0')) {\n    return undefined\n  }\n\n  return new Date(Date.UTC(year, monthIdx, day, hour, minute, second))\n}\n\n/**\n * @see https://httpwg.org/specs/rfc9110.html#obsolete.date.formats\n *\n * @param {string} date\n * @returns {Date | undefined}\n */\nfunction parseAscTimeDate (date) {\n  // This is assumed to be in UTC\n\n  if (date.length !== 24) {\n    return undefined\n  }\n\n  for (const spaceIdx of ASCTIME_SPACES) {\n    if (date[spaceIdx] !== ' ') {\n      return undefined\n    }\n  }\n\n  const dayName = date.substring(0, 3)\n  if (!IMF_DAYS.includes(dayName)) {\n    return undefined\n  }\n\n  const month = date.substring(4, 7)\n  const monthIdx = IMF_MONTHS.indexOf(month)\n  if (monthIdx === -1) {\n    return undefined\n  }\n\n  const dayString = date.substring(8, 10)\n  const day = Number.parseInt(dayString)\n  if (isNaN(day) || (day < 10 && dayString[0] !== ' ')) {\n    return undefined\n  }\n\n  const hourString = date.substring(11, 13)\n  const hour = Number.parseInt(hourString)\n  if (isNaN(hour) || (hour < 10 && hourString[0] !== '0')) {\n    return undefined\n  }\n\n  const minuteString = date.substring(14, 16)\n  const minute = Number.parseInt(minuteString)\n  if (isNaN(minute) || (minute < 10 && minuteString[0] !== '0')) {\n    return undefined\n  }\n\n  const secondString = date.substring(17, 19)\n  const second = Number.parseInt(secondString)\n  if (isNaN(second) || (second < 10 && secondString[0] !== '0')) {\n    return undefined\n  }\n\n  const year = Number.parseInt(date.substring(20, 24))\n  if (isNaN(year)) {\n    return undefined\n  }\n\n  return new Date(Date.UTC(year, monthIdx, day, hour, minute, second))\n}\n\n/**\n * @see https://httpwg.org/specs/rfc9110.html#obsolete.date.formats\n *\n * @param {string} date\n * @param {Date} [now]\n * @returns {Date | undefined}\n */\nfunction parseRfc850Date (date, now = new Date()) {\n  if (!date.endsWith('gmt')) {\n    // Unsupported timezone\n    return undefined\n  }\n\n  const commaIndex = date.indexOf(',')\n  if (commaIndex === -1) {\n    return undefined\n  }\n\n  if ((date.length - commaIndex - 1) !== 23) {\n    return undefined\n  }\n\n  const dayName = date.substring(0, commaIndex)\n  if (!RFC850_DAYS.includes(dayName)) {\n    return undefined\n  }\n\n  if (\n    date[commaIndex + 1] !== ' ' ||\n    date[commaIndex + 4] !== '-' ||\n    date[commaIndex + 8] !== '-' ||\n    date[commaIndex + 11] !== ' ' ||\n    date[commaIndex + 14] !== ':' ||\n    date[commaIndex + 17] !== ':' ||\n    date[commaIndex + 20] !== ' '\n  ) {\n    return undefined\n  }\n\n  const dayString = date.substring(commaIndex + 2, commaIndex + 4)\n  const day = Number.parseInt(dayString)\n  if (isNaN(day) || (day < 10 && dayString[0] !== '0')) {\n    // Not a number, or it's less than 10 and didn't start with a 0\n    return undefined\n  }\n\n  const month = date.substring(commaIndex + 5, commaIndex + 8)\n  const monthIdx = IMF_MONTHS.indexOf(month)\n  if (monthIdx === -1) {\n    return undefined\n  }\n\n  // As of this point year is just the decade (i.e. 94)\n  let year = Number.parseInt(date.substring(commaIndex + 9, commaIndex + 11))\n  if (isNaN(year)) {\n    return undefined\n  }\n\n  const currentYear = now.getUTCFullYear()\n  const currentDecade = currentYear % 100\n  const currentCentury = Math.floor(currentYear / 100)\n\n  if (year > currentDecade && year - currentDecade >= 50) {\n    // Over 50 years in future, go to previous century\n    year += (currentCentury - 1) * 100\n  } else {\n    year += currentCentury * 100\n  }\n\n  const hourString = date.substring(commaIndex + 12, commaIndex + 14)\n  const hour = Number.parseInt(hourString)\n  if (isNaN(hour) || (hour < 10 && hourString[0] !== '0')) {\n    return undefined\n  }\n\n  const minuteString = date.substring(commaIndex + 15, commaIndex + 17)\n  const minute = Number.parseInt(minuteString)\n  if (isNaN(minute) || (minute < 10 && minuteString[0] !== '0')) {\n    return undefined\n  }\n\n  const secondString = date.substring(commaIndex + 18, commaIndex + 20)\n  const second = Number.parseInt(secondString)\n  if (isNaN(second) || (second < 10 && secondString[0] !== '0')) {\n    return undefined\n  }\n\n  return new Date(Date.UTC(year, monthIdx, day, hour, minute, second))\n}\n\nmodule.exports = {\n  parseHttpDate\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL2RhdGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsd0NBQXdDOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL2RhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IElNRl9EQVlTID0gWydtb24nLCAndHVlJywgJ3dlZCcsICd0aHUnLCAnZnJpJywgJ3NhdCcsICdzdW4nXVxuY29uc3QgSU1GX1NQQUNFUyA9IFs0LCA3LCAxMSwgMTYsIDI1XVxuY29uc3QgSU1GX01PTlRIUyA9IFsnamFuJywgJ2ZlYicsICdtYXInLCAnYXByJywgJ21heScsICdqdW4nLCAnanVsJywgJ2F1ZycsICdzZXAnLCAnb2N0JywgJ25vdicsICdkZWMnXVxuY29uc3QgSU1GX0NPTE9OUyA9IFsxOSwgMjJdXG5cbmNvbnN0IEFTQ1RJTUVfU1BBQ0VTID0gWzMsIDcsIDEwLCAxOV1cblxuY29uc3QgUkZDODUwX0RBWVMgPSBbJ21vbmRheScsICd0dWVzZGF5JywgJ3dlZG5lc2RheScsICd0aHVyc2RheScsICdmcmlkYXknLCAnc2F0dXJkYXknLCAnc3VuZGF5J11cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MTEwLmh0bWwjbmFtZS1kYXRlLXRpbWUtZm9ybWF0c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlXG4gKiBAcGFyYW0ge0RhdGV9IFtub3ddXG4gKiBAcmV0dXJucyB7RGF0ZSB8IHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VIdHRwRGF0ZSAoZGF0ZSwgbm93KSB7XG4gIC8vIFN1biwgMDYgTm92IDE5OTQgMDg6NDk6MzcgR01UICAgIDsgSU1GLWZpeGRhdGVcbiAgLy8gU3VuIE5vdiAgNiAwODo0OTozNyAxOTk0ICAgICAgICAgOyBBTlNJIEMncyBhc2N0aW1lKCkgZm9ybWF0XG4gIC8vIFN1bmRheSwgMDYtTm92LTk0IDA4OjQ5OjM3IEdNVCAgIDsgb2Jzb2xldGUgUkZDIDg1MCBmb3JtYXRcblxuICBkYXRlID0gZGF0ZS50b0xvd2VyQ2FzZSgpXG5cbiAgc3dpdGNoIChkYXRlWzNdKSB7XG4gICAgY2FzZSAnLCc6IHJldHVybiBwYXJzZUltZkRhdGUoZGF0ZSlcbiAgICBjYXNlICcgJzogcmV0dXJuIHBhcnNlQXNjVGltZURhdGUoZGF0ZSlcbiAgICBkZWZhdWx0OiByZXR1cm4gcGFyc2VSZmM4NTBEYXRlKGRhdGUsIG5vdylcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9odHRwd2cub3JnL3NwZWNzL3JmYzkxMTAuaHRtbCNwcmVmZXJyZWQuZGF0ZS5mb3JtYXRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0ZVxuICogQHJldHVybnMge0RhdGUgfCB1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlSW1mRGF0ZSAoZGF0ZSkge1xuICBpZiAoZGF0ZS5sZW5ndGggIT09IDI5KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgaWYgKCFkYXRlLmVuZHNXaXRoKCdnbXQnKSkge1xuICAgIC8vIFVuc3VwcG9ydGVkIHRpbWV6b25lXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgZm9yIChjb25zdCBzcGFjZUlueCBvZiBJTUZfU1BBQ0VTKSB7XG4gICAgaWYgKGRhdGVbc3BhY2VJbnhdICE9PSAnICcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IGNvbG9uSWR4IG9mIElNRl9DT0xPTlMpIHtcbiAgICBpZiAoZGF0ZVtjb2xvbklkeF0gIT09ICc6Jykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRheU5hbWUgPSBkYXRlLnN1YnN0cmluZygwLCAzKVxuICBpZiAoIUlNRl9EQVlTLmluY2x1ZGVzKGRheU5hbWUpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgY29uc3QgZGF5U3RyaW5nID0gZGF0ZS5zdWJzdHJpbmcoNSwgNylcbiAgY29uc3QgZGF5ID0gTnVtYmVyLnBhcnNlSW50KGRheVN0cmluZylcbiAgaWYgKGlzTmFOKGRheSkgfHwgKGRheSA8IDEwICYmIGRheVN0cmluZ1swXSAhPT0gJzAnKSkge1xuICAgIC8vIE5vdCBhIG51bWJlciwgMCwgb3IgaXQncyBsZXNzIHRoYW4gMTAgYW5kIGRpZG4ndCBzdGFydCB3aXRoIGEgMFxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IG1vbnRoID0gZGF0ZS5zdWJzdHJpbmcoOCwgMTEpXG4gIGNvbnN0IG1vbnRoSWR4ID0gSU1GX01PTlRIUy5pbmRleE9mKG1vbnRoKVxuICBpZiAobW9udGhJZHggPT09IC0xKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgY29uc3QgeWVhciA9IE51bWJlci5wYXJzZUludChkYXRlLnN1YnN0cmluZygxMiwgMTYpKVxuICBpZiAoaXNOYU4oeWVhcikpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBjb25zdCBob3VyU3RyaW5nID0gZGF0ZS5zdWJzdHJpbmcoMTcsIDE5KVxuICBjb25zdCBob3VyID0gTnVtYmVyLnBhcnNlSW50KGhvdXJTdHJpbmcpXG4gIGlmIChpc05hTihob3VyKSB8fCAoaG91ciA8IDEwICYmIGhvdXJTdHJpbmdbMF0gIT09ICcwJykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBjb25zdCBtaW51dGVTdHJpbmcgPSBkYXRlLnN1YnN0cmluZygyMCwgMjIpXG4gIGNvbnN0IG1pbnV0ZSA9IE51bWJlci5wYXJzZUludChtaW51dGVTdHJpbmcpXG4gIGlmIChpc05hTihtaW51dGUpIHx8IChtaW51dGUgPCAxMCAmJiBtaW51dGVTdHJpbmdbMF0gIT09ICcwJykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBjb25zdCBzZWNvbmRTdHJpbmcgPSBkYXRlLnN1YnN0cmluZygyMywgMjUpXG4gIGNvbnN0IHNlY29uZCA9IE51bWJlci5wYXJzZUludChzZWNvbmRTdHJpbmcpXG4gIGlmIChpc05hTihzZWNvbmQpIHx8IChzZWNvbmQgPCAxMCAmJiBzZWNvbmRTdHJpbmdbMF0gIT09ICcwJykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGhJZHgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9odHRwd2cub3JnL3NwZWNzL3JmYzkxMTAuaHRtbCNvYnNvbGV0ZS5kYXRlLmZvcm1hdHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0ZVxuICogQHJldHVybnMge0RhdGUgfCB1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXNjVGltZURhdGUgKGRhdGUpIHtcbiAgLy8gVGhpcyBpcyBhc3N1bWVkIHRvIGJlIGluIFVUQ1xuXG4gIGlmIChkYXRlLmxlbmd0aCAhPT0gMjQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBmb3IgKGNvbnN0IHNwYWNlSWR4IG9mIEFTQ1RJTUVfU1BBQ0VTKSB7XG4gICAgaWYgKGRhdGVbc3BhY2VJZHhdICE9PSAnICcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICBjb25zdCBkYXlOYW1lID0gZGF0ZS5zdWJzdHJpbmcoMCwgMylcbiAgaWYgKCFJTUZfREFZUy5pbmNsdWRlcyhkYXlOYW1lKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IG1vbnRoID0gZGF0ZS5zdWJzdHJpbmcoNCwgNylcbiAgY29uc3QgbW9udGhJZHggPSBJTUZfTU9OVEhTLmluZGV4T2YobW9udGgpXG4gIGlmIChtb250aElkeCA9PT0gLTEpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBjb25zdCBkYXlTdHJpbmcgPSBkYXRlLnN1YnN0cmluZyg4LCAxMClcbiAgY29uc3QgZGF5ID0gTnVtYmVyLnBhcnNlSW50KGRheVN0cmluZylcbiAgaWYgKGlzTmFOKGRheSkgfHwgKGRheSA8IDEwICYmIGRheVN0cmluZ1swXSAhPT0gJyAnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IGhvdXJTdHJpbmcgPSBkYXRlLnN1YnN0cmluZygxMSwgMTMpXG4gIGNvbnN0IGhvdXIgPSBOdW1iZXIucGFyc2VJbnQoaG91clN0cmluZylcbiAgaWYgKGlzTmFOKGhvdXIpIHx8IChob3VyIDwgMTAgJiYgaG91clN0cmluZ1swXSAhPT0gJzAnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IG1pbnV0ZVN0cmluZyA9IGRhdGUuc3Vic3RyaW5nKDE0LCAxNilcbiAgY29uc3QgbWludXRlID0gTnVtYmVyLnBhcnNlSW50KG1pbnV0ZVN0cmluZylcbiAgaWYgKGlzTmFOKG1pbnV0ZSkgfHwgKG1pbnV0ZSA8IDEwICYmIG1pbnV0ZVN0cmluZ1swXSAhPT0gJzAnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IHNlY29uZFN0cmluZyA9IGRhdGUuc3Vic3RyaW5nKDE3LCAxOSlcbiAgY29uc3Qgc2Vjb25kID0gTnVtYmVyLnBhcnNlSW50KHNlY29uZFN0cmluZylcbiAgaWYgKGlzTmFOKHNlY29uZCkgfHwgKHNlY29uZCA8IDEwICYmIHNlY29uZFN0cmluZ1swXSAhPT0gJzAnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IHllYXIgPSBOdW1iZXIucGFyc2VJbnQoZGF0ZS5zdWJzdHJpbmcoMjAsIDI0KSlcbiAgaWYgKGlzTmFOKHllYXIpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoSWR4LCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaHR0cHdnLm9yZy9zcGVjcy9yZmM5MTEwLmh0bWwjb2Jzb2xldGUuZGF0ZS5mb3JtYXRzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGVcbiAqIEBwYXJhbSB7RGF0ZX0gW25vd11cbiAqIEByZXR1cm5zIHtEYXRlIHwgdW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBwYXJzZVJmYzg1MERhdGUgKGRhdGUsIG5vdyA9IG5ldyBEYXRlKCkpIHtcbiAgaWYgKCFkYXRlLmVuZHNXaXRoKCdnbXQnKSkge1xuICAgIC8vIFVuc3VwcG9ydGVkIHRpbWV6b25lXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgY29uc3QgY29tbWFJbmRleCA9IGRhdGUuaW5kZXhPZignLCcpXG4gIGlmIChjb21tYUluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICgoZGF0ZS5sZW5ndGggLSBjb21tYUluZGV4IC0gMSkgIT09IDIzKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgY29uc3QgZGF5TmFtZSA9IGRhdGUuc3Vic3RyaW5nKDAsIGNvbW1hSW5kZXgpXG4gIGlmICghUkZDODUwX0RBWVMuaW5jbHVkZXMoZGF5TmFtZSkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoXG4gICAgZGF0ZVtjb21tYUluZGV4ICsgMV0gIT09ICcgJyB8fFxuICAgIGRhdGVbY29tbWFJbmRleCArIDRdICE9PSAnLScgfHxcbiAgICBkYXRlW2NvbW1hSW5kZXggKyA4XSAhPT0gJy0nIHx8XG4gICAgZGF0ZVtjb21tYUluZGV4ICsgMTFdICE9PSAnICcgfHxcbiAgICBkYXRlW2NvbW1hSW5kZXggKyAxNF0gIT09ICc6JyB8fFxuICAgIGRhdGVbY29tbWFJbmRleCArIDE3XSAhPT0gJzonIHx8XG4gICAgZGF0ZVtjb21tYUluZGV4ICsgMjBdICE9PSAnICdcbiAgKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgY29uc3QgZGF5U3RyaW5nID0gZGF0ZS5zdWJzdHJpbmcoY29tbWFJbmRleCArIDIsIGNvbW1hSW5kZXggKyA0KVxuICBjb25zdCBkYXkgPSBOdW1iZXIucGFyc2VJbnQoZGF5U3RyaW5nKVxuICBpZiAoaXNOYU4oZGF5KSB8fCAoZGF5IDwgMTAgJiYgZGF5U3RyaW5nWzBdICE9PSAnMCcpKSB7XG4gICAgLy8gTm90IGEgbnVtYmVyLCBvciBpdCdzIGxlc3MgdGhhbiAxMCBhbmQgZGlkbid0IHN0YXJ0IHdpdGggYSAwXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgY29uc3QgbW9udGggPSBkYXRlLnN1YnN0cmluZyhjb21tYUluZGV4ICsgNSwgY29tbWFJbmRleCArIDgpXG4gIGNvbnN0IG1vbnRoSWR4ID0gSU1GX01PTlRIUy5pbmRleE9mKG1vbnRoKVxuICBpZiAobW9udGhJZHggPT09IC0xKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gQXMgb2YgdGhpcyBwb2ludCB5ZWFyIGlzIGp1c3QgdGhlIGRlY2FkZSAoaS5lLiA5NClcbiAgbGV0IHllYXIgPSBOdW1iZXIucGFyc2VJbnQoZGF0ZS5zdWJzdHJpbmcoY29tbWFJbmRleCArIDksIGNvbW1hSW5kZXggKyAxMSkpXG4gIGlmIChpc05hTih5ZWFyKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IGN1cnJlbnRZZWFyID0gbm93LmdldFVUQ0Z1bGxZZWFyKClcbiAgY29uc3QgY3VycmVudERlY2FkZSA9IGN1cnJlbnRZZWFyICUgMTAwXG4gIGNvbnN0IGN1cnJlbnRDZW50dXJ5ID0gTWF0aC5mbG9vcihjdXJyZW50WWVhciAvIDEwMClcblxuICBpZiAoeWVhciA+IGN1cnJlbnREZWNhZGUgJiYgeWVhciAtIGN1cnJlbnREZWNhZGUgPj0gNTApIHtcbiAgICAvLyBPdmVyIDUwIHllYXJzIGluIGZ1dHVyZSwgZ28gdG8gcHJldmlvdXMgY2VudHVyeVxuICAgIHllYXIgKz0gKGN1cnJlbnRDZW50dXJ5IC0gMSkgKiAxMDBcbiAgfSBlbHNlIHtcbiAgICB5ZWFyICs9IGN1cnJlbnRDZW50dXJ5ICogMTAwXG4gIH1cblxuICBjb25zdCBob3VyU3RyaW5nID0gZGF0ZS5zdWJzdHJpbmcoY29tbWFJbmRleCArIDEyLCBjb21tYUluZGV4ICsgMTQpXG4gIGNvbnN0IGhvdXIgPSBOdW1iZXIucGFyc2VJbnQoaG91clN0cmluZylcbiAgaWYgKGlzTmFOKGhvdXIpIHx8IChob3VyIDwgMTAgJiYgaG91clN0cmluZ1swXSAhPT0gJzAnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IG1pbnV0ZVN0cmluZyA9IGRhdGUuc3Vic3RyaW5nKGNvbW1hSW5kZXggKyAxNSwgY29tbWFJbmRleCArIDE3KVxuICBjb25zdCBtaW51dGUgPSBOdW1iZXIucGFyc2VJbnQobWludXRlU3RyaW5nKVxuICBpZiAoaXNOYU4obWludXRlKSB8fCAobWludXRlIDwgMTAgJiYgbWludXRlU3RyaW5nWzBdICE9PSAnMCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgY29uc3Qgc2Vjb25kU3RyaW5nID0gZGF0ZS5zdWJzdHJpbmcoY29tbWFJbmRleCArIDE4LCBjb21tYUluZGV4ICsgMjApXG4gIGNvbnN0IHNlY29uZCA9IE51bWJlci5wYXJzZUludChzZWNvbmRTdHJpbmcpXG4gIGlmIChpc05hTihzZWNvbmQpIHx8IChzZWNvbmQgPCAxMCAmJiBzZWNvbmRTdHJpbmdbMF0gIT09ICcwJykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGhJZHgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2VIdHRwRGF0ZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/util/date.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/util/stats.js":
/*!***********************************************!*\
  !*** ./node_modules/undici/lib/util/stats.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  kConnected,\n  kPending,\n  kRunning,\n  kSize,\n  kFree,\n  kQueued\n} = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\nclass ClientStats {\n  constructor (client) {\n    this.connected = client[kConnected]\n    this.pending = client[kPending]\n    this.running = client[kRunning]\n    this.size = client[kSize]\n  }\n}\n\nclass PoolStats {\n  constructor (pool) {\n    this.connected = pool[kConnected]\n    this.free = pool[kFree]\n    this.pending = pool[kPending]\n    this.queued = pool[kQueued]\n    this.running = pool[kRunning]\n    this.size = pool[kSize]\n  }\n}\n\nmodule.exports = { ClientStats, PoolStats }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL3N0YXRzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsd0VBQWlCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL3N0YXRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIGtDb25uZWN0ZWQsXG4gIGtQZW5kaW5nLFxuICBrUnVubmluZyxcbiAga1NpemUsXG4gIGtGcmVlLFxuICBrUXVldWVkXG59ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcblxuY2xhc3MgQ2xpZW50U3RhdHMge1xuICBjb25zdHJ1Y3RvciAoY2xpZW50KSB7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBjbGllbnRba0Nvbm5lY3RlZF1cbiAgICB0aGlzLnBlbmRpbmcgPSBjbGllbnRba1BlbmRpbmddXG4gICAgdGhpcy5ydW5uaW5nID0gY2xpZW50W2tSdW5uaW5nXVxuICAgIHRoaXMuc2l6ZSA9IGNsaWVudFtrU2l6ZV1cbiAgfVxufVxuXG5jbGFzcyBQb29sU3RhdHMge1xuICBjb25zdHJ1Y3RvciAocG9vbCkge1xuICAgIHRoaXMuY29ubmVjdGVkID0gcG9vbFtrQ29ubmVjdGVkXVxuICAgIHRoaXMuZnJlZSA9IHBvb2xba0ZyZWVdXG4gICAgdGhpcy5wZW5kaW5nID0gcG9vbFtrUGVuZGluZ11cbiAgICB0aGlzLnF1ZXVlZCA9IHBvb2xba1F1ZXVlZF1cbiAgICB0aGlzLnJ1bm5pbmcgPSBwb29sW2tSdW5uaW5nXVxuICAgIHRoaXMuc2l6ZSA9IHBvb2xba1NpemVdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IENsaWVudFN0YXRzLCBQb29sU3RhdHMgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/util/stats.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/util/timers.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/util/timers.js ***!
  \************************************************/
/***/ ((module) => {

eval("\n\n/**\n * This module offers an optimized timer implementation designed for scenarios\n * where high precision is not critical.\n *\n * The timer achieves faster performance by using a low-resolution approach,\n * with an accuracy target of within 500ms. This makes it particularly useful\n * for timers with delays of 1 second or more, where exact timing is less\n * crucial.\n *\n * It's important to note that Node.js timers are inherently imprecise, as\n * delays can occur due to the event loop being blocked by other operations.\n * Consequently, timers may trigger later than their scheduled time.\n */\n\n/**\n * The fastNow variable contains the internal fast timer clock value.\n *\n * @type {number}\n */\nlet fastNow = 0\n\n/**\n * RESOLUTION_MS represents the target resolution time in milliseconds.\n *\n * @type {number}\n * @default 1000\n */\nconst RESOLUTION_MS = 1e3\n\n/**\n * TICK_MS defines the desired interval in milliseconds between each tick.\n * The target value is set to half the resolution time, minus 1 ms, to account\n * for potential event loop overhead.\n *\n * @type {number}\n * @default 499\n */\nconst TICK_MS = (RESOLUTION_MS >> 1) - 1\n\n/**\n * fastNowTimeout is a Node.js timer used to manage and process\n * the FastTimers stored in the `fastTimers` array.\n *\n * @type {NodeJS.Timeout}\n */\nlet fastNowTimeout\n\n/**\n * The kFastTimer symbol is used to identify FastTimer instances.\n *\n * @type {Symbol}\n */\nconst kFastTimer = Symbol('kFastTimer')\n\n/**\n * The fastTimers array contains all active FastTimers.\n *\n * @type {FastTimer[]}\n */\nconst fastTimers = []\n\n/**\n * These constants represent the various states of a FastTimer.\n */\n\n/**\n * The `NOT_IN_LIST` constant indicates that the FastTimer is not included\n * in the `fastTimers` array. Timers with this status will not be processed\n * during the next tick by the `onTick` function.\n *\n * A FastTimer can be re-added to the `fastTimers` array by invoking the\n * `refresh` method on the FastTimer instance.\n *\n * @type {-2}\n */\nconst NOT_IN_LIST = -2\n\n/**\n * The `TO_BE_CLEARED` constant indicates that the FastTimer is scheduled\n * for removal from the `fastTimers` array. A FastTimer in this state will\n * be removed in the next tick by the `onTick` function and will no longer\n * be processed.\n *\n * This status is also set when the `clear` method is called on the FastTimer instance.\n *\n * @type {-1}\n */\nconst TO_BE_CLEARED = -1\n\n/**\n * The `PENDING` constant signifies that the FastTimer is awaiting processing\n * in the next tick by the `onTick` function. Timers with this status will have\n * their `_idleStart` value set and their status updated to `ACTIVE` in the next tick.\n *\n * @type {0}\n */\nconst PENDING = 0\n\n/**\n * The `ACTIVE` constant indicates that the FastTimer is active and waiting\n * for its timer to expire. During the next tick, the `onTick` function will\n * check if the timer has expired, and if so, it will execute the associated callback.\n *\n * @type {1}\n */\nconst ACTIVE = 1\n\n/**\n * The onTick function processes the fastTimers array.\n *\n * @returns {void}\n */\nfunction onTick () {\n  /**\n   * Increment the fastNow value by the TICK_MS value, despite the actual time\n   * that has passed since the last tick. This approach ensures independence\n   * from the system clock and delays caused by a blocked event loop.\n   *\n   * @type {number}\n   */\n  fastNow += TICK_MS\n\n  /**\n   * The `idx` variable is used to iterate over the `fastTimers` array.\n   * Expired timers are removed by replacing them with the last element in the array.\n   * Consequently, `idx` is only incremented when the current element is not removed.\n   *\n   * @type {number}\n   */\n  let idx = 0\n\n  /**\n   * The len variable will contain the length of the fastTimers array\n   * and will be decremented when a FastTimer should be removed from the\n   * fastTimers array.\n   *\n   * @type {number}\n   */\n  let len = fastTimers.length\n\n  while (idx < len) {\n    /**\n     * @type {FastTimer}\n     */\n    const timer = fastTimers[idx]\n\n    // If the timer is in the ACTIVE state and the timer has expired, it will\n    // be processed in the next tick.\n    if (timer._state === PENDING) {\n      // Set the _idleStart value to the fastNow value minus the TICK_MS value\n      // to account for the time the timer was in the PENDING state.\n      timer._idleStart = fastNow - TICK_MS\n      timer._state = ACTIVE\n    } else if (\n      timer._state === ACTIVE &&\n      fastNow >= timer._idleStart + timer._idleTimeout\n    ) {\n      timer._state = TO_BE_CLEARED\n      timer._idleStart = -1\n      timer._onTimeout(timer._timerArg)\n    }\n\n    if (timer._state === TO_BE_CLEARED) {\n      timer._state = NOT_IN_LIST\n\n      // Move the last element to the current index and decrement len if it is\n      // not the only element in the array.\n      if (--len !== 0) {\n        fastTimers[idx] = fastTimers[len]\n      }\n    } else {\n      ++idx\n    }\n  }\n\n  // Set the length of the fastTimers array to the new length and thus\n  // removing the excess FastTimers elements from the array.\n  fastTimers.length = len\n\n  // If there are still active FastTimers in the array, refresh the Timer.\n  // If there are no active FastTimers, the timer will be refreshed again\n  // when a new FastTimer is instantiated.\n  if (fastTimers.length !== 0) {\n    refreshTimeout()\n  }\n}\n\nfunction refreshTimeout () {\n  // If the fastNowTimeout is already set and the Timer has the refresh()-\n  // method available, call it to refresh the timer.\n  // Some timer objects returned by setTimeout may not have a .refresh()\n  // method (e.g. mocked timers in tests).\n  if (fastNowTimeout?.refresh) {\n    fastNowTimeout.refresh()\n    // fastNowTimeout is not instantiated yet or refresh is not availabe,\n    // create a new Timer.\n  } else {\n    clearTimeout(fastNowTimeout)\n    fastNowTimeout = setTimeout(onTick, TICK_MS)\n    // If the Timer has an unref method, call it to allow the process to exit,\n    // if there are no other active handles. When using fake timers or mocked\n    // environments (like Jest), .unref() may not be defined,\n    fastNowTimeout?.unref()\n  }\n}\n\n/**\n * The `FastTimer` class is a data structure designed to store and manage\n * timer information.\n */\nclass FastTimer {\n  [kFastTimer] = true\n\n  /**\n   * The state of the timer, which can be one of the following:\n   * - NOT_IN_LIST (-2)\n   * - TO_BE_CLEARED (-1)\n   * - PENDING (0)\n   * - ACTIVE (1)\n   *\n   * @type {-2|-1|0|1}\n   * @private\n   */\n  _state = NOT_IN_LIST\n\n  /**\n   * The number of milliseconds to wait before calling the callback.\n   *\n   * @type {number}\n   * @private\n   */\n  _idleTimeout = -1\n\n  /**\n   * The time in milliseconds when the timer was started. This value is used to\n   * calculate when the timer should expire.\n   *\n   * @type {number}\n   * @default -1\n   * @private\n   */\n  _idleStart = -1\n\n  /**\n   * The function to be executed when the timer expires.\n   * @type {Function}\n   * @private\n   */\n  _onTimeout\n\n  /**\n   * The argument to be passed to the callback when the timer expires.\n   *\n   * @type {*}\n   * @private\n   */\n  _timerArg\n\n  /**\n   * @constructor\n   * @param {Function} callback A function to be executed after the timer\n   * expires.\n   * @param {number} delay The time, in milliseconds that the timer should wait\n   * before the specified function or code is executed.\n   * @param {*} arg\n   */\n  constructor (callback, delay, arg) {\n    this._onTimeout = callback\n    this._idleTimeout = delay\n    this._timerArg = arg\n\n    this.refresh()\n  }\n\n  /**\n   * Sets the timer's start time to the current time, and reschedules the timer\n   * to call its callback at the previously specified duration adjusted to the\n   * current time.\n   * Using this on a timer that has already called its callback will reactivate\n   * the timer.\n   *\n   * @returns {void}\n   */\n  refresh () {\n    // In the special case that the timer is not in the list of active timers,\n    // add it back to the array to be processed in the next tick by the onTick\n    // function.\n    if (this._state === NOT_IN_LIST) {\n      fastTimers.push(this)\n    }\n\n    // If the timer is the only active timer, refresh the fastNowTimeout for\n    // better resolution.\n    if (!fastNowTimeout || fastTimers.length === 1) {\n      refreshTimeout()\n    }\n\n    // Setting the state to PENDING will cause the timer to be reset in the\n    // next tick by the onTick function.\n    this._state = PENDING\n  }\n\n  /**\n   * The `clear` method cancels the timer, preventing it from executing.\n   *\n   * @returns {void}\n   * @private\n   */\n  clear () {\n    // Set the state to TO_BE_CLEARED to mark the timer for removal in the next\n    // tick by the onTick function.\n    this._state = TO_BE_CLEARED\n\n    // Reset the _idleStart value to -1 to indicate that the timer is no longer\n    // active.\n    this._idleStart = -1\n  }\n}\n\n/**\n * This module exports a setTimeout and clearTimeout function that can be\n * used as a drop-in replacement for the native functions.\n */\nmodule.exports = {\n  /**\n   * The setTimeout() method sets a timer which executes a function once the\n   * timer expires.\n   * @param {Function} callback A function to be executed after the timer\n   * expires.\n   * @param {number} delay The time, in milliseconds that the timer should\n   * wait before the specified function or code is executed.\n   * @param {*} [arg] An optional argument to be passed to the callback function\n   * when the timer expires.\n   * @returns {NodeJS.Timeout|FastTimer}\n   */\n  setTimeout (callback, delay, arg) {\n    // If the delay is less than or equal to the RESOLUTION_MS value return a\n    // native Node.js Timer instance.\n    return delay <= RESOLUTION_MS\n      ? setTimeout(callback, delay, arg)\n      : new FastTimer(callback, delay, arg)\n  },\n  /**\n   * The clearTimeout method cancels an instantiated Timer previously created\n   * by calling setTimeout.\n   *\n   * @param {NodeJS.Timeout|FastTimer} timeout\n   */\n  clearTimeout (timeout) {\n    // If the timeout is a FastTimer, call its own clear method.\n    if (timeout[kFastTimer]) {\n      /**\n       * @type {FastTimer}\n       */\n      timeout.clear()\n      // Otherwise it is an instance of a native NodeJS.Timeout, so call the\n      // Node.js native clearTimeout function.\n    } else {\n      clearTimeout(timeout)\n    }\n  },\n  /**\n   * The setFastTimeout() method sets a fastTimer which executes a function once\n   * the timer expires.\n   * @param {Function} callback A function to be executed after the timer\n   * expires.\n   * @param {number} delay The time, in milliseconds that the timer should\n   * wait before the specified function or code is executed.\n   * @param {*} [arg] An optional argument to be passed to the callback function\n   * when the timer expires.\n   * @returns {FastTimer}\n   */\n  setFastTimeout (callback, delay, arg) {\n    return new FastTimer(callback, delay, arg)\n  },\n  /**\n   * The clearTimeout method cancels an instantiated FastTimer previously\n   * created by calling setFastTimeout.\n   *\n   * @param {FastTimer} timeout\n   */\n  clearFastTimeout (timeout) {\n    timeout.clear()\n  },\n  /**\n   * The now method returns the value of the internal fast timer clock.\n   *\n   * @returns {number}\n   */\n  now () {\n    return fastNow\n  },\n  /**\n   * Trigger the onTick function to process the fastTimers array.\n   * Exported for testing purposes only.\n   * Marking as deprecated to discourage any use outside of testing.\n   * @deprecated\n   * @param {number} [delay=0] The delay in milliseconds to add to the now value.\n   */\n  tick (delay = 0) {\n    fastNow += delay - RESOLUTION_MS + 1\n    onTick()\n    onTick()\n  },\n  /**\n   * Reset FastTimers.\n   * Exported for testing purposes only.\n   * Marking as deprecated to discourage any use outside of testing.\n   * @deprecated\n   */\n  reset () {\n    fastNow = 0\n    fastTimers.length = 0\n    clearTimeout(fastNowTimeout)\n    fastNowTimeout = null\n  },\n  /**\n   * Exporting for testing purposes only.\n   * Marking as deprecated to discourage any use outside of testing.\n   * @deprecated\n   */\n  kFastTimer\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL3RpbWVycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLEdBQUc7QUFDaEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL3RpbWVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBvZmZlcnMgYW4gb3B0aW1pemVkIHRpbWVyIGltcGxlbWVudGF0aW9uIGRlc2lnbmVkIGZvciBzY2VuYXJpb3NcbiAqIHdoZXJlIGhpZ2ggcHJlY2lzaW9uIGlzIG5vdCBjcml0aWNhbC5cbiAqXG4gKiBUaGUgdGltZXIgYWNoaWV2ZXMgZmFzdGVyIHBlcmZvcm1hbmNlIGJ5IHVzaW5nIGEgbG93LXJlc29sdXRpb24gYXBwcm9hY2gsXG4gKiB3aXRoIGFuIGFjY3VyYWN5IHRhcmdldCBvZiB3aXRoaW4gNTAwbXMuIFRoaXMgbWFrZXMgaXQgcGFydGljdWxhcmx5IHVzZWZ1bFxuICogZm9yIHRpbWVycyB3aXRoIGRlbGF5cyBvZiAxIHNlY29uZCBvciBtb3JlLCB3aGVyZSBleGFjdCB0aW1pbmcgaXMgbGVzc1xuICogY3J1Y2lhbC5cbiAqXG4gKiBJdCdzIGltcG9ydGFudCB0byBub3RlIHRoYXQgTm9kZS5qcyB0aW1lcnMgYXJlIGluaGVyZW50bHkgaW1wcmVjaXNlLCBhc1xuICogZGVsYXlzIGNhbiBvY2N1ciBkdWUgdG8gdGhlIGV2ZW50IGxvb3AgYmVpbmcgYmxvY2tlZCBieSBvdGhlciBvcGVyYXRpb25zLlxuICogQ29uc2VxdWVudGx5LCB0aW1lcnMgbWF5IHRyaWdnZXIgbGF0ZXIgdGhhbiB0aGVpciBzY2hlZHVsZWQgdGltZS5cbiAqL1xuXG4vKipcbiAqIFRoZSBmYXN0Tm93IHZhcmlhYmxlIGNvbnRhaW5zIHRoZSBpbnRlcm5hbCBmYXN0IHRpbWVyIGNsb2NrIHZhbHVlLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmxldCBmYXN0Tm93ID0gMFxuXG4vKipcbiAqIFJFU09MVVRJT05fTVMgcmVwcmVzZW50cyB0aGUgdGFyZ2V0IHJlc29sdXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0IDEwMDBcbiAqL1xuY29uc3QgUkVTT0xVVElPTl9NUyA9IDFlM1xuXG4vKipcbiAqIFRJQ0tfTVMgZGVmaW5lcyB0aGUgZGVzaXJlZCBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMgYmV0d2VlbiBlYWNoIHRpY2suXG4gKiBUaGUgdGFyZ2V0IHZhbHVlIGlzIHNldCB0byBoYWxmIHRoZSByZXNvbHV0aW9uIHRpbWUsIG1pbnVzIDEgbXMsIHRvIGFjY291bnRcbiAqIGZvciBwb3RlbnRpYWwgZXZlbnQgbG9vcCBvdmVyaGVhZC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHQgNDk5XG4gKi9cbmNvbnN0IFRJQ0tfTVMgPSAoUkVTT0xVVElPTl9NUyA+PiAxKSAtIDFcblxuLyoqXG4gKiBmYXN0Tm93VGltZW91dCBpcyBhIE5vZGUuanMgdGltZXIgdXNlZCB0byBtYW5hZ2UgYW5kIHByb2Nlc3NcbiAqIHRoZSBGYXN0VGltZXJzIHN0b3JlZCBpbiB0aGUgYGZhc3RUaW1lcnNgIGFycmF5LlxuICpcbiAqIEB0eXBlIHtOb2RlSlMuVGltZW91dH1cbiAqL1xubGV0IGZhc3ROb3dUaW1lb3V0XG5cbi8qKlxuICogVGhlIGtGYXN0VGltZXIgc3ltYm9sIGlzIHVzZWQgdG8gaWRlbnRpZnkgRmFzdFRpbWVyIGluc3RhbmNlcy5cbiAqXG4gKiBAdHlwZSB7U3ltYm9sfVxuICovXG5jb25zdCBrRmFzdFRpbWVyID0gU3ltYm9sKCdrRmFzdFRpbWVyJylcblxuLyoqXG4gKiBUaGUgZmFzdFRpbWVycyBhcnJheSBjb250YWlucyBhbGwgYWN0aXZlIEZhc3RUaW1lcnMuXG4gKlxuICogQHR5cGUge0Zhc3RUaW1lcltdfVxuICovXG5jb25zdCBmYXN0VGltZXJzID0gW11cblxuLyoqXG4gKiBUaGVzZSBjb25zdGFudHMgcmVwcmVzZW50IHRoZSB2YXJpb3VzIHN0YXRlcyBvZiBhIEZhc3RUaW1lci5cbiAqL1xuXG4vKipcbiAqIFRoZSBgTk9UX0lOX0xJU1RgIGNvbnN0YW50IGluZGljYXRlcyB0aGF0IHRoZSBGYXN0VGltZXIgaXMgbm90IGluY2x1ZGVkXG4gKiBpbiB0aGUgYGZhc3RUaW1lcnNgIGFycmF5LiBUaW1lcnMgd2l0aCB0aGlzIHN0YXR1cyB3aWxsIG5vdCBiZSBwcm9jZXNzZWRcbiAqIGR1cmluZyB0aGUgbmV4dCB0aWNrIGJ5IHRoZSBgb25UaWNrYCBmdW5jdGlvbi5cbiAqXG4gKiBBIEZhc3RUaW1lciBjYW4gYmUgcmUtYWRkZWQgdG8gdGhlIGBmYXN0VGltZXJzYCBhcnJheSBieSBpbnZva2luZyB0aGVcbiAqIGByZWZyZXNoYCBtZXRob2Qgb24gdGhlIEZhc3RUaW1lciBpbnN0YW5jZS5cbiAqXG4gKiBAdHlwZSB7LTJ9XG4gKi9cbmNvbnN0IE5PVF9JTl9MSVNUID0gLTJcblxuLyoqXG4gKiBUaGUgYFRPX0JFX0NMRUFSRURgIGNvbnN0YW50IGluZGljYXRlcyB0aGF0IHRoZSBGYXN0VGltZXIgaXMgc2NoZWR1bGVkXG4gKiBmb3IgcmVtb3ZhbCBmcm9tIHRoZSBgZmFzdFRpbWVyc2AgYXJyYXkuIEEgRmFzdFRpbWVyIGluIHRoaXMgc3RhdGUgd2lsbFxuICogYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCB0aWNrIGJ5IHRoZSBgb25UaWNrYCBmdW5jdGlvbiBhbmQgd2lsbCBubyBsb25nZXJcbiAqIGJlIHByb2Nlc3NlZC5cbiAqXG4gKiBUaGlzIHN0YXR1cyBpcyBhbHNvIHNldCB3aGVuIHRoZSBgY2xlYXJgIG1ldGhvZCBpcyBjYWxsZWQgb24gdGhlIEZhc3RUaW1lciBpbnN0YW5jZS5cbiAqXG4gKiBAdHlwZSB7LTF9XG4gKi9cbmNvbnN0IFRPX0JFX0NMRUFSRUQgPSAtMVxuXG4vKipcbiAqIFRoZSBgUEVORElOR2AgY29uc3RhbnQgc2lnbmlmaWVzIHRoYXQgdGhlIEZhc3RUaW1lciBpcyBhd2FpdGluZyBwcm9jZXNzaW5nXG4gKiBpbiB0aGUgbmV4dCB0aWNrIGJ5IHRoZSBgb25UaWNrYCBmdW5jdGlvbi4gVGltZXJzIHdpdGggdGhpcyBzdGF0dXMgd2lsbCBoYXZlXG4gKiB0aGVpciBgX2lkbGVTdGFydGAgdmFsdWUgc2V0IGFuZCB0aGVpciBzdGF0dXMgdXBkYXRlZCB0byBgQUNUSVZFYCBpbiB0aGUgbmV4dCB0aWNrLlxuICpcbiAqIEB0eXBlIHswfVxuICovXG5jb25zdCBQRU5ESU5HID0gMFxuXG4vKipcbiAqIFRoZSBgQUNUSVZFYCBjb25zdGFudCBpbmRpY2F0ZXMgdGhhdCB0aGUgRmFzdFRpbWVyIGlzIGFjdGl2ZSBhbmQgd2FpdGluZ1xuICogZm9yIGl0cyB0aW1lciB0byBleHBpcmUuIER1cmluZyB0aGUgbmV4dCB0aWNrLCB0aGUgYG9uVGlja2AgZnVuY3Rpb24gd2lsbFxuICogY2hlY2sgaWYgdGhlIHRpbWVyIGhhcyBleHBpcmVkLCBhbmQgaWYgc28sIGl0IHdpbGwgZXhlY3V0ZSB0aGUgYXNzb2NpYXRlZCBjYWxsYmFjay5cbiAqXG4gKiBAdHlwZSB7MX1cbiAqL1xuY29uc3QgQUNUSVZFID0gMVxuXG4vKipcbiAqIFRoZSBvblRpY2sgZnVuY3Rpb24gcHJvY2Vzc2VzIHRoZSBmYXN0VGltZXJzIGFycmF5LlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBvblRpY2sgKCkge1xuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSBmYXN0Tm93IHZhbHVlIGJ5IHRoZSBUSUNLX01TIHZhbHVlLCBkZXNwaXRlIHRoZSBhY3R1YWwgdGltZVxuICAgKiB0aGF0IGhhcyBwYXNzZWQgc2luY2UgdGhlIGxhc3QgdGljay4gVGhpcyBhcHByb2FjaCBlbnN1cmVzIGluZGVwZW5kZW5jZVxuICAgKiBmcm9tIHRoZSBzeXN0ZW0gY2xvY2sgYW5kIGRlbGF5cyBjYXVzZWQgYnkgYSBibG9ja2VkIGV2ZW50IGxvb3AuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBmYXN0Tm93ICs9IFRJQ0tfTVNcblxuICAvKipcbiAgICogVGhlIGBpZHhgIHZhcmlhYmxlIGlzIHVzZWQgdG8gaXRlcmF0ZSBvdmVyIHRoZSBgZmFzdFRpbWVyc2AgYXJyYXkuXG4gICAqIEV4cGlyZWQgdGltZXJzIGFyZSByZW1vdmVkIGJ5IHJlcGxhY2luZyB0aGVtIHdpdGggdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkuXG4gICAqIENvbnNlcXVlbnRseSwgYGlkeGAgaXMgb25seSBpbmNyZW1lbnRlZCB3aGVuIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgbm90IHJlbW92ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBsZXQgaWR4ID0gMFxuXG4gIC8qKlxuICAgKiBUaGUgbGVuIHZhcmlhYmxlIHdpbGwgY29udGFpbiB0aGUgbGVuZ3RoIG9mIHRoZSBmYXN0VGltZXJzIGFycmF5XG4gICAqIGFuZCB3aWxsIGJlIGRlY3JlbWVudGVkIHdoZW4gYSBGYXN0VGltZXIgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSB0aGVcbiAgICogZmFzdFRpbWVycyBhcnJheS5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGxldCBsZW4gPSBmYXN0VGltZXJzLmxlbmd0aFxuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RmFzdFRpbWVyfVxuICAgICAqL1xuICAgIGNvbnN0IHRpbWVyID0gZmFzdFRpbWVyc1tpZHhdXG5cbiAgICAvLyBJZiB0aGUgdGltZXIgaXMgaW4gdGhlIEFDVElWRSBzdGF0ZSBhbmQgdGhlIHRpbWVyIGhhcyBleHBpcmVkLCBpdCB3aWxsXG4gICAgLy8gYmUgcHJvY2Vzc2VkIGluIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKHRpbWVyLl9zdGF0ZSA9PT0gUEVORElORykge1xuICAgICAgLy8gU2V0IHRoZSBfaWRsZVN0YXJ0IHZhbHVlIHRvIHRoZSBmYXN0Tm93IHZhbHVlIG1pbnVzIHRoZSBUSUNLX01TIHZhbHVlXG4gICAgICAvLyB0byBhY2NvdW50IGZvciB0aGUgdGltZSB0aGUgdGltZXIgd2FzIGluIHRoZSBQRU5ESU5HIHN0YXRlLlxuICAgICAgdGltZXIuX2lkbGVTdGFydCA9IGZhc3ROb3cgLSBUSUNLX01TXG4gICAgICB0aW1lci5fc3RhdGUgPSBBQ1RJVkVcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGltZXIuX3N0YXRlID09PSBBQ1RJVkUgJiZcbiAgICAgIGZhc3ROb3cgPj0gdGltZXIuX2lkbGVTdGFydCArIHRpbWVyLl9pZGxlVGltZW91dFxuICAgICkge1xuICAgICAgdGltZXIuX3N0YXRlID0gVE9fQkVfQ0xFQVJFRFxuICAgICAgdGltZXIuX2lkbGVTdGFydCA9IC0xXG4gICAgICB0aW1lci5fb25UaW1lb3V0KHRpbWVyLl90aW1lckFyZylcbiAgICB9XG5cbiAgICBpZiAodGltZXIuX3N0YXRlID09PSBUT19CRV9DTEVBUkVEKSB7XG4gICAgICB0aW1lci5fc3RhdGUgPSBOT1RfSU5fTElTVFxuXG4gICAgICAvLyBNb3ZlIHRoZSBsYXN0IGVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgaW5kZXggYW5kIGRlY3JlbWVudCBsZW4gaWYgaXQgaXNcbiAgICAgIC8vIG5vdCB0aGUgb25seSBlbGVtZW50IGluIHRoZSBhcnJheS5cbiAgICAgIGlmICgtLWxlbiAhPT0gMCkge1xuICAgICAgICBmYXN0VGltZXJzW2lkeF0gPSBmYXN0VGltZXJzW2xlbl1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKytpZHhcbiAgICB9XG4gIH1cblxuICAvLyBTZXQgdGhlIGxlbmd0aCBvZiB0aGUgZmFzdFRpbWVycyBhcnJheSB0byB0aGUgbmV3IGxlbmd0aCBhbmQgdGh1c1xuICAvLyByZW1vdmluZyB0aGUgZXhjZXNzIEZhc3RUaW1lcnMgZWxlbWVudHMgZnJvbSB0aGUgYXJyYXkuXG4gIGZhc3RUaW1lcnMubGVuZ3RoID0gbGVuXG5cbiAgLy8gSWYgdGhlcmUgYXJlIHN0aWxsIGFjdGl2ZSBGYXN0VGltZXJzIGluIHRoZSBhcnJheSwgcmVmcmVzaCB0aGUgVGltZXIuXG4gIC8vIElmIHRoZXJlIGFyZSBubyBhY3RpdmUgRmFzdFRpbWVycywgdGhlIHRpbWVyIHdpbGwgYmUgcmVmcmVzaGVkIGFnYWluXG4gIC8vIHdoZW4gYSBuZXcgRmFzdFRpbWVyIGlzIGluc3RhbnRpYXRlZC5cbiAgaWYgKGZhc3RUaW1lcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgcmVmcmVzaFRpbWVvdXQoKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlZnJlc2hUaW1lb3V0ICgpIHtcbiAgLy8gSWYgdGhlIGZhc3ROb3dUaW1lb3V0IGlzIGFscmVhZHkgc2V0IGFuZCB0aGUgVGltZXIgaGFzIHRoZSByZWZyZXNoKCktXG4gIC8vIG1ldGhvZCBhdmFpbGFibGUsIGNhbGwgaXQgdG8gcmVmcmVzaCB0aGUgdGltZXIuXG4gIC8vIFNvbWUgdGltZXIgb2JqZWN0cyByZXR1cm5lZCBieSBzZXRUaW1lb3V0IG1heSBub3QgaGF2ZSBhIC5yZWZyZXNoKClcbiAgLy8gbWV0aG9kIChlLmcuIG1vY2tlZCB0aW1lcnMgaW4gdGVzdHMpLlxuICBpZiAoZmFzdE5vd1RpbWVvdXQ/LnJlZnJlc2gpIHtcbiAgICBmYXN0Tm93VGltZW91dC5yZWZyZXNoKClcbiAgICAvLyBmYXN0Tm93VGltZW91dCBpcyBub3QgaW5zdGFudGlhdGVkIHlldCBvciByZWZyZXNoIGlzIG5vdCBhdmFpbGFiZSxcbiAgICAvLyBjcmVhdGUgYSBuZXcgVGltZXIuXG4gIH0gZWxzZSB7XG4gICAgY2xlYXJUaW1lb3V0KGZhc3ROb3dUaW1lb3V0KVxuICAgIGZhc3ROb3dUaW1lb3V0ID0gc2V0VGltZW91dChvblRpY2ssIFRJQ0tfTVMpXG4gICAgLy8gSWYgdGhlIFRpbWVyIGhhcyBhbiB1bnJlZiBtZXRob2QsIGNhbGwgaXQgdG8gYWxsb3cgdGhlIHByb2Nlc3MgdG8gZXhpdCxcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gb3RoZXIgYWN0aXZlIGhhbmRsZXMuIFdoZW4gdXNpbmcgZmFrZSB0aW1lcnMgb3IgbW9ja2VkXG4gICAgLy8gZW52aXJvbm1lbnRzIChsaWtlIEplc3QpLCAudW5yZWYoKSBtYXkgbm90IGJlIGRlZmluZWQsXG4gICAgZmFzdE5vd1RpbWVvdXQ/LnVucmVmKClcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBgRmFzdFRpbWVyYCBjbGFzcyBpcyBhIGRhdGEgc3RydWN0dXJlIGRlc2lnbmVkIHRvIHN0b3JlIGFuZCBtYW5hZ2VcbiAqIHRpbWVyIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBGYXN0VGltZXIge1xuICBba0Zhc3RUaW1lcl0gPSB0cnVlXG5cbiAgLyoqXG4gICAqIFRoZSBzdGF0ZSBvZiB0aGUgdGltZXIsIHdoaWNoIGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICogLSBOT1RfSU5fTElTVCAoLTIpXG4gICAqIC0gVE9fQkVfQ0xFQVJFRCAoLTEpXG4gICAqIC0gUEVORElORyAoMClcbiAgICogLSBBQ1RJVkUgKDEpXG4gICAqXG4gICAqIEB0eXBlIHstMnwtMXwwfDF9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc3RhdGUgPSBOT1RfSU5fTElTVFxuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBjYWxsaW5nIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pZGxlVGltZW91dCA9IC0xXG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB3aGVuIHRoZSB0aW1lciB3YXMgc3RhcnRlZC4gVGhpcyB2YWx1ZSBpcyB1c2VkIHRvXG4gICAqIGNhbGN1bGF0ZSB3aGVuIHRoZSB0aW1lciBzaG91bGQgZXhwaXJlLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAtMVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2lkbGVTdGFydCA9IC0xXG5cbiAgLyoqXG4gICAqIFRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSB0aW1lciBleHBpcmVzLlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25UaW1lb3V0XG5cbiAgLyoqXG4gICAqIFRoZSBhcmd1bWVudCB0byBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIHdoZW4gdGhlIHRpbWVyIGV4cGlyZXMuXG4gICAqXG4gICAqIEB0eXBlIHsqfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RpbWVyQXJnXG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSB0aW1lclxuICAgKiBleHBpcmVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgVGhlIHRpbWUsIGluIG1pbGxpc2Vjb25kcyB0aGF0IHRoZSB0aW1lciBzaG91bGQgd2FpdFxuICAgKiBiZWZvcmUgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBvciBjb2RlIGlzIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0geyp9IGFyZ1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGNhbGxiYWNrLCBkZWxheSwgYXJnKSB7XG4gICAgdGhpcy5fb25UaW1lb3V0ID0gY2FsbGJhY2tcbiAgICB0aGlzLl9pZGxlVGltZW91dCA9IGRlbGF5XG4gICAgdGhpcy5fdGltZXJBcmcgPSBhcmdcblxuICAgIHRoaXMucmVmcmVzaCgpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGltZXIncyBzdGFydCB0aW1lIHRvIHRoZSBjdXJyZW50IHRpbWUsIGFuZCByZXNjaGVkdWxlcyB0aGUgdGltZXJcbiAgICogdG8gY2FsbCBpdHMgY2FsbGJhY2sgYXQgdGhlIHByZXZpb3VzbHkgc3BlY2lmaWVkIGR1cmF0aW9uIGFkanVzdGVkIHRvIHRoZVxuICAgKiBjdXJyZW50IHRpbWUuXG4gICAqIFVzaW5nIHRoaXMgb24gYSB0aW1lciB0aGF0IGhhcyBhbHJlYWR5IGNhbGxlZCBpdHMgY2FsbGJhY2sgd2lsbCByZWFjdGl2YXRlXG4gICAqIHRoZSB0aW1lci5cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICByZWZyZXNoICgpIHtcbiAgICAvLyBJbiB0aGUgc3BlY2lhbCBjYXNlIHRoYXQgdGhlIHRpbWVyIGlzIG5vdCBpbiB0aGUgbGlzdCBvZiBhY3RpdmUgdGltZXJzLFxuICAgIC8vIGFkZCBpdCBiYWNrIHRvIHRoZSBhcnJheSB0byBiZSBwcm9jZXNzZWQgaW4gdGhlIG5leHQgdGljayBieSB0aGUgb25UaWNrXG4gICAgLy8gZnVuY3Rpb24uXG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBOT1RfSU5fTElTVCkge1xuICAgICAgZmFzdFRpbWVycy5wdXNoKHRoaXMpXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHRpbWVyIGlzIHRoZSBvbmx5IGFjdGl2ZSB0aW1lciwgcmVmcmVzaCB0aGUgZmFzdE5vd1RpbWVvdXQgZm9yXG4gICAgLy8gYmV0dGVyIHJlc29sdXRpb24uXG4gICAgaWYgKCFmYXN0Tm93VGltZW91dCB8fCBmYXN0VGltZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmVmcmVzaFRpbWVvdXQoKVxuICAgIH1cblxuICAgIC8vIFNldHRpbmcgdGhlIHN0YXRlIHRvIFBFTkRJTkcgd2lsbCBjYXVzZSB0aGUgdGltZXIgdG8gYmUgcmVzZXQgaW4gdGhlXG4gICAgLy8gbmV4dCB0aWNrIGJ5IHRoZSBvblRpY2sgZnVuY3Rpb24uXG4gICAgdGhpcy5fc3RhdGUgPSBQRU5ESU5HXG4gIH1cblxuICAvKipcbiAgICogVGhlIGBjbGVhcmAgbWV0aG9kIGNhbmNlbHMgdGhlIHRpbWVyLCBwcmV2ZW50aW5nIGl0IGZyb20gZXhlY3V0aW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNsZWFyICgpIHtcbiAgICAvLyBTZXQgdGhlIHN0YXRlIHRvIFRPX0JFX0NMRUFSRUQgdG8gbWFyayB0aGUgdGltZXIgZm9yIHJlbW92YWwgaW4gdGhlIG5leHRcbiAgICAvLyB0aWNrIGJ5IHRoZSBvblRpY2sgZnVuY3Rpb24uXG4gICAgdGhpcy5fc3RhdGUgPSBUT19CRV9DTEVBUkVEXG5cbiAgICAvLyBSZXNldCB0aGUgX2lkbGVTdGFydCB2YWx1ZSB0byAtMSB0byBpbmRpY2F0ZSB0aGF0IHRoZSB0aW1lciBpcyBubyBsb25nZXJcbiAgICAvLyBhY3RpdmUuXG4gICAgdGhpcy5faWRsZVN0YXJ0ID0gLTFcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGV4cG9ydHMgYSBzZXRUaW1lb3V0IGFuZCBjbGVhclRpbWVvdXQgZnVuY3Rpb24gdGhhdCBjYW4gYmVcbiAqIHVzZWQgYXMgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciB0aGUgbmF0aXZlIGZ1bmN0aW9ucy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBUaGUgc2V0VGltZW91dCgpIG1ldGhvZCBzZXRzIGEgdGltZXIgd2hpY2ggZXhlY3V0ZXMgYSBmdW5jdGlvbiBvbmNlIHRoZVxuICAgKiB0aW1lciBleHBpcmVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSB0aW1lclxuICAgKiBleHBpcmVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgVGhlIHRpbWUsIGluIG1pbGxpc2Vjb25kcyB0aGF0IHRoZSB0aW1lciBzaG91bGRcbiAgICogd2FpdCBiZWZvcmUgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBvciBjb2RlIGlzIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0geyp9IFthcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICogd2hlbiB0aGUgdGltZXIgZXhwaXJlcy5cbiAgICogQHJldHVybnMge05vZGVKUy5UaW1lb3V0fEZhc3RUaW1lcn1cbiAgICovXG4gIHNldFRpbWVvdXQgKGNhbGxiYWNrLCBkZWxheSwgYXJnKSB7XG4gICAgLy8gSWYgdGhlIGRlbGF5IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgUkVTT0xVVElPTl9NUyB2YWx1ZSByZXR1cm4gYVxuICAgIC8vIG5hdGl2ZSBOb2RlLmpzIFRpbWVyIGluc3RhbmNlLlxuICAgIHJldHVybiBkZWxheSA8PSBSRVNPTFVUSU9OX01TXG4gICAgICA/IHNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5LCBhcmcpXG4gICAgICA6IG5ldyBGYXN0VGltZXIoY2FsbGJhY2ssIGRlbGF5LCBhcmcpXG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgY2xlYXJUaW1lb3V0IG1ldGhvZCBjYW5jZWxzIGFuIGluc3RhbnRpYXRlZCBUaW1lciBwcmV2aW91c2x5IGNyZWF0ZWRcbiAgICogYnkgY2FsbGluZyBzZXRUaW1lb3V0LlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGVKUy5UaW1lb3V0fEZhc3RUaW1lcn0gdGltZW91dFxuICAgKi9cbiAgY2xlYXJUaW1lb3V0ICh0aW1lb3V0KSB7XG4gICAgLy8gSWYgdGhlIHRpbWVvdXQgaXMgYSBGYXN0VGltZXIsIGNhbGwgaXRzIG93biBjbGVhciBtZXRob2QuXG4gICAgaWYgKHRpbWVvdXRba0Zhc3RUaW1lcl0pIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0Zhc3RUaW1lcn1cbiAgICAgICAqL1xuICAgICAgdGltZW91dC5jbGVhcigpXG4gICAgICAvLyBPdGhlcndpc2UgaXQgaXMgYW4gaW5zdGFuY2Ugb2YgYSBuYXRpdmUgTm9kZUpTLlRpbWVvdXQsIHNvIGNhbGwgdGhlXG4gICAgICAvLyBOb2RlLmpzIG5hdGl2ZSBjbGVhclRpbWVvdXQgZnVuY3Rpb24uXG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBzZXRGYXN0VGltZW91dCgpIG1ldGhvZCBzZXRzIGEgZmFzdFRpbWVyIHdoaWNoIGV4ZWN1dGVzIGEgZnVuY3Rpb24gb25jZVxuICAgKiB0aGUgdGltZXIgZXhwaXJlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciB0aGUgdGltZXJcbiAgICogZXhwaXJlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IFRoZSB0aW1lLCBpbiBtaWxsaXNlY29uZHMgdGhhdCB0aGUgdGltZXIgc2hvdWxkXG4gICAqIHdhaXQgYmVmb3JlIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gb3IgY29kZSBpcyBleGVjdXRlZC5cbiAgICogQHBhcmFtIHsqfSBbYXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqIHdoZW4gdGhlIHRpbWVyIGV4cGlyZXMuXG4gICAqIEByZXR1cm5zIHtGYXN0VGltZXJ9XG4gICAqL1xuICBzZXRGYXN0VGltZW91dCAoY2FsbGJhY2ssIGRlbGF5LCBhcmcpIHtcbiAgICByZXR1cm4gbmV3IEZhc3RUaW1lcihjYWxsYmFjaywgZGVsYXksIGFyZylcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBjbGVhclRpbWVvdXQgbWV0aG9kIGNhbmNlbHMgYW4gaW5zdGFudGlhdGVkIEZhc3RUaW1lciBwcmV2aW91c2x5XG4gICAqIGNyZWF0ZWQgYnkgY2FsbGluZyBzZXRGYXN0VGltZW91dC5cbiAgICpcbiAgICogQHBhcmFtIHtGYXN0VGltZXJ9IHRpbWVvdXRcbiAgICovXG4gIGNsZWFyRmFzdFRpbWVvdXQgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsZWFyKClcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBub3cgbWV0aG9kIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBpbnRlcm5hbCBmYXN0IHRpbWVyIGNsb2NrLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgbm93ICgpIHtcbiAgICByZXR1cm4gZmFzdE5vd1xuICB9LFxuICAvKipcbiAgICogVHJpZ2dlciB0aGUgb25UaWNrIGZ1bmN0aW9uIHRvIHByb2Nlc3MgdGhlIGZhc3RUaW1lcnMgYXJyYXkuXG4gICAqIEV4cG9ydGVkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG4gICAqIE1hcmtpbmcgYXMgZGVwcmVjYXRlZCB0byBkaXNjb3VyYWdlIGFueSB1c2Ugb3V0c2lkZSBvZiB0ZXN0aW5nLlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdIFRoZSBkZWxheSBpbiBtaWxsaXNlY29uZHMgdG8gYWRkIHRvIHRoZSBub3cgdmFsdWUuXG4gICAqL1xuICB0aWNrIChkZWxheSA9IDApIHtcbiAgICBmYXN0Tm93ICs9IGRlbGF5IC0gUkVTT0xVVElPTl9NUyArIDFcbiAgICBvblRpY2soKVxuICAgIG9uVGljaygpXG4gIH0sXG4gIC8qKlxuICAgKiBSZXNldCBGYXN0VGltZXJzLlxuICAgKiBFeHBvcnRlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuICAgKiBNYXJraW5nIGFzIGRlcHJlY2F0ZWQgdG8gZGlzY291cmFnZSBhbnkgdXNlIG91dHNpZGUgb2YgdGVzdGluZy5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHJlc2V0ICgpIHtcbiAgICBmYXN0Tm93ID0gMFxuICAgIGZhc3RUaW1lcnMubGVuZ3RoID0gMFxuICAgIGNsZWFyVGltZW91dChmYXN0Tm93VGltZW91dClcbiAgICBmYXN0Tm93VGltZW91dCA9IG51bGxcbiAgfSxcbiAgLyoqXG4gICAqIEV4cG9ydGluZyBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuICAgKiBNYXJraW5nIGFzIGRlcHJlY2F0ZWQgdG8gZGlzY291cmFnZSBhbnkgdXNlIG91dHNpZGUgb2YgdGVzdGluZy5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGtGYXN0VGltZXJcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/util/timers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cache/cache.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/cache.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { urlEquals, getFieldValues } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/cache/util.js\")\nconst { kEnumerableProperty, isDisturbed } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { cloneResponse, fromInnerResponse, getResponseState } = __webpack_require__(/*! ../fetch/response */ \"(rsc)/./node_modules/undici/lib/web/fetch/response.js\")\nconst { Request, fromInnerRequest, getRequestState } = __webpack_require__(/*! ../fetch/request */ \"(rsc)/./node_modules/undici/lib/web/fetch/request.js\")\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(rsc)/./node_modules/undici/lib/web/fetch/index.js\")\nconst { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation\n * @typedef {Object} CacheBatchOperation\n * @property {'delete' | 'put'} type\n * @property {any} request\n * @property {any} response\n * @property {import('../../types/cache').CacheQueryOptions} options\n */\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list\n * @typedef {[any, any][]} requestResponseList\n */\n\nclass Cache {\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list\n   * @type {requestResponseList}\n   */\n  #relevantRequestResponseList\n\n  constructor () {\n    if (arguments[0] !== kConstruct) {\n      webidl.illegalConstructor()\n    }\n\n    webidl.util.markAsUncloneable(this)\n    this.#relevantRequestResponseList = arguments[1]\n  }\n\n  async match (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.match'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request, prefix, 'request')\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    const p = this.#internalMatchAll(request, options, 1)\n\n    if (p.length === 0) {\n      return\n    }\n\n    return p[0]\n  }\n\n  async matchAll (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.matchAll'\n    if (request !== undefined) request = webidl.converters.RequestInfo(request, prefix, 'request')\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    return this.#internalMatchAll(request, options)\n  }\n\n  async add (request) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.add'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request, prefix, 'request')\n\n    // 1.\n    const requests = [request]\n\n    // 2.\n    const responseArrayPromise = this.addAll(requests)\n\n    // 3.\n    return await responseArrayPromise\n  }\n\n  async addAll (requests) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.addAll'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    // 1.\n    const responsePromises = []\n\n    // 2.\n    const requestList = []\n\n    // 3.\n    for (let request of requests) {\n      if (request === undefined) {\n        throw webidl.errors.conversionFailed({\n          prefix,\n          argument: 'Argument 1',\n          types: ['undefined is not allowed']\n        })\n      }\n\n      request = webidl.converters.RequestInfo(request)\n\n      if (typeof request === 'string') {\n        continue\n      }\n\n      // 3.1\n      const r = getRequestState(request)\n\n      // 3.2\n      if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {\n        throw webidl.errors.exception({\n          header: prefix,\n          message: 'Expected http/s scheme when method is not GET.'\n        })\n      }\n    }\n\n    // 4.\n    /** @type {ReturnType<typeof fetching>[]} */\n    const fetchControllers = []\n\n    // 5.\n    for (const request of requests) {\n      // 5.1\n      const r = getRequestState(new Request(request))\n\n      // 5.2\n      if (!urlIsHttpHttpsScheme(r.url)) {\n        throw webidl.errors.exception({\n          header: prefix,\n          message: 'Expected http/s scheme.'\n        })\n      }\n\n      // 5.4\n      r.initiator = 'fetch'\n      r.destination = 'subresource'\n\n      // 5.5\n      requestList.push(r)\n\n      // 5.6\n      const responsePromise = createDeferredPromise()\n\n      // 5.7\n      fetchControllers.push(fetching({\n        request: r,\n        processResponse (response) {\n          // 1.\n          if (response.type === 'error' || response.status === 206 || response.status < 200 || response.status > 299) {\n            responsePromise.reject(webidl.errors.exception({\n              header: 'Cache.addAll',\n              message: 'Received an invalid status code or the request failed.'\n            }))\n          } else if (response.headersList.contains('vary')) { // 2.\n            // 2.1\n            const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n            // 2.2\n            for (const fieldValue of fieldValues) {\n              // 2.2.1\n              if (fieldValue === '*') {\n                responsePromise.reject(webidl.errors.exception({\n                  header: 'Cache.addAll',\n                  message: 'invalid vary field value'\n                }))\n\n                for (const controller of fetchControllers) {\n                  controller.abort()\n                }\n\n                return\n              }\n            }\n          }\n        },\n        processResponseEndOfBody (response) {\n          // 1.\n          if (response.aborted) {\n            responsePromise.reject(new DOMException('aborted', 'AbortError'))\n            return\n          }\n\n          // 2.\n          responsePromise.resolve(response)\n        }\n      }))\n\n      // 5.8\n      responsePromises.push(responsePromise.promise)\n    }\n\n    // 6.\n    const p = Promise.all(responsePromises)\n\n    // 7.\n    const responses = await p\n\n    // 7.1\n    const operations = []\n\n    // 7.2\n    let index = 0\n\n    // 7.3\n    for (const response of responses) {\n      // 7.3.1\n      /** @type {CacheBatchOperation} */\n      const operation = {\n        type: 'put', // 7.3.2\n        request: requestList[index], // 7.3.3\n        response // 7.3.4\n      }\n\n      operations.push(operation) // 7.3.5\n\n      index++ // 7.3.6\n    }\n\n    // 7.5\n    const cacheJobPromise = createDeferredPromise()\n\n    // 7.6.1\n    let errorData = null\n\n    // 7.6.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 7.6.3\n    queueMicrotask(() => {\n      // 7.6.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve(undefined)\n      } else {\n        // 7.6.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    // 7.7\n    return cacheJobPromise.promise\n  }\n\n  async put (request, response) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.put'\n    webidl.argumentLengthCheck(arguments, 2, prefix)\n\n    request = webidl.converters.RequestInfo(request, prefix, 'request')\n    response = webidl.converters.Response(response, prefix, 'response')\n\n    // 1.\n    let innerRequest = null\n\n    // 2.\n    if (webidl.is.Request(request)) {\n      innerRequest = getRequestState(request)\n    } else { // 3.\n      innerRequest = getRequestState(new Request(request))\n    }\n\n    // 4.\n    if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Expected an http/s scheme when method is not GET'\n      })\n    }\n\n    // 5.\n    const innerResponse = getResponseState(response)\n\n    // 6.\n    if (innerResponse.status === 206) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Got 206 status'\n      })\n    }\n\n    // 7.\n    if (innerResponse.headersList.contains('vary')) {\n      // 7.1.\n      const fieldValues = getFieldValues(innerResponse.headersList.get('vary'))\n\n      // 7.2.\n      for (const fieldValue of fieldValues) {\n        // 7.2.1\n        if (fieldValue === '*') {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: 'Got * vary field value'\n          })\n        }\n      }\n    }\n\n    // 8.\n    if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Response body is locked or disturbed'\n      })\n    }\n\n    // 9.\n    const clonedResponse = cloneResponse(innerResponse)\n\n    // 10.\n    const bodyReadPromise = createDeferredPromise()\n\n    // 11.\n    if (innerResponse.body != null) {\n      // 11.1\n      const stream = innerResponse.body.stream\n\n      // 11.2\n      const reader = stream.getReader()\n\n      // 11.3\n      readAllBytes(reader, bodyReadPromise.resolve, bodyReadPromise.reject)\n    } else {\n      bodyReadPromise.resolve(undefined)\n    }\n\n    // 12.\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    // 13.\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'put', // 14.\n      request: innerRequest, // 15.\n      response: clonedResponse // 16.\n    }\n\n    // 17.\n    operations.push(operation)\n\n    // 19.\n    const bytes = await bodyReadPromise.promise\n\n    if (clonedResponse.body != null) {\n      clonedResponse.body.source = bytes\n    }\n\n    // 19.1\n    const cacheJobPromise = createDeferredPromise()\n\n    // 19.2.1\n    let errorData = null\n\n    // 19.2.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 19.2.3\n    queueMicrotask(() => {\n      // 19.2.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve()\n      } else { // 19.2.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  async delete (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.delete'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request, prefix, 'request')\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    /**\n     * @type {Request}\n     */\n    let r = null\n\n    if (webidl.is.Request(request)) {\n      r = getRequestState(request)\n\n      if (r.method !== 'GET' && !options.ignoreMethod) {\n        return false\n      }\n    } else {\n      assert(typeof request === 'string')\n\n      r = getRequestState(new Request(request))\n    }\n\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'delete',\n      request: r,\n      options\n    }\n\n    operations.push(operation)\n\n    const cacheJobPromise = createDeferredPromise()\n\n    let errorData = null\n    let requestResponses\n\n    try {\n      requestResponses = this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    queueMicrotask(() => {\n      if (errorData === null) {\n        cacheJobPromise.resolve(!!requestResponses?.length)\n      } else {\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys\n   * @param {any} request\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @returns {Promise<readonly Request[]>}\n   */\n  async keys (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.keys'\n\n    if (request !== undefined) request = webidl.converters.RequestInfo(request, prefix, 'request')\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      // 2.1\n      if (webidl.is.Request(request)) {\n        // 2.1.1\n        r = getRequestState(request)\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') { // 2.2\n        r = getRequestState(new Request(request))\n      }\n    }\n\n    // 4.\n    const promise = createDeferredPromise()\n\n    // 5.\n    // 5.1\n    const requests = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        // 5.2.1.1\n        requests.push(requestResponse[0])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        // 5.3.2.1\n        requests.push(requestResponse[0])\n      }\n    }\n\n    // 5.4\n    queueMicrotask(() => {\n      // 5.4.1\n      const requestList = []\n\n      // 5.4.2\n      for (const request of requests) {\n        const requestObject = fromInnerRequest(\n          request,\n          undefined,\n          new AbortController().signal,\n          'immutable'\n        )\n        // 5.4.2.1\n        requestList.push(requestObject)\n      }\n\n      // 5.4.3\n      promise.resolve(Object.freeze(requestList))\n    })\n\n    return promise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm\n   * @param {CacheBatchOperation[]} operations\n   * @returns {requestResponseList}\n   */\n  #batchCacheOperations (operations) {\n    // 1.\n    const cache = this.#relevantRequestResponseList\n\n    // 2.\n    const backupCache = [...cache]\n\n    // 3.\n    const addedItems = []\n\n    // 4.1\n    const resultList = []\n\n    try {\n      // 4.2\n      for (const operation of operations) {\n        // 4.2.1\n        if (operation.type !== 'delete' && operation.type !== 'put') {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'operation type does not match \"delete\" or \"put\"'\n          })\n        }\n\n        // 4.2.2\n        if (operation.type === 'delete' && operation.response != null) {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'delete operation should not have an associated response'\n          })\n        }\n\n        // 4.2.3\n        if (this.#queryCache(operation.request, operation.options, addedItems).length) {\n          throw new DOMException('???', 'InvalidStateError')\n        }\n\n        // 4.2.4\n        let requestResponses\n\n        // 4.2.5\n        if (operation.type === 'delete') {\n          // 4.2.5.1\n          requestResponses = this.#queryCache(operation.request, operation.options)\n\n          // TODO: the spec is wrong, this is needed to pass WPTs\n          if (requestResponses.length === 0) {\n            return []\n          }\n\n          // 4.2.5.2\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.5.2.1\n            cache.splice(idx, 1)\n          }\n        } else if (operation.type === 'put') { // 4.2.6\n          // 4.2.6.1\n          if (operation.response == null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'put operation should have an associated response'\n            })\n          }\n\n          // 4.2.6.2\n          const r = operation.request\n\n          // 4.2.6.3\n          if (!urlIsHttpHttpsScheme(r.url)) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'expected http or https scheme'\n            })\n          }\n\n          // 4.2.6.4\n          if (r.method !== 'GET') {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'not get method'\n            })\n          }\n\n          // 4.2.6.5\n          if (operation.options != null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'options must not be defined'\n            })\n          }\n\n          // 4.2.6.6\n          requestResponses = this.#queryCache(operation.request)\n\n          // 4.2.6.7\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.6.7.1\n            cache.splice(idx, 1)\n          }\n\n          // 4.2.6.8\n          cache.push([operation.request, operation.response])\n\n          // 4.2.6.10\n          addedItems.push([operation.request, operation.response])\n        }\n\n        // 4.2.7\n        resultList.push([operation.request, operation.response])\n      }\n\n      // 4.3\n      return resultList\n    } catch (e) { // 5.\n      // 5.1\n      this.#relevantRequestResponseList.length = 0\n\n      // 5.2\n      this.#relevantRequestResponseList = backupCache\n\n      // 5.3\n      throw e\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#query-cache\n   * @param {any} requestQuery\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @param {requestResponseList} targetStorage\n   * @returns {requestResponseList}\n   */\n  #queryCache (requestQuery, options, targetStorage) {\n    /** @type {requestResponseList} */\n    const resultList = []\n\n    const storage = targetStorage ?? this.#relevantRequestResponseList\n\n    for (const requestResponse of storage) {\n      const [cachedRequest, cachedResponse] = requestResponse\n      if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {\n        resultList.push(requestResponse)\n      }\n    }\n\n    return resultList\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\n   * @param {any} requestQuery\n   * @param {any} request\n   * @param {any | null} response\n   * @param {import('../../types/cache').CacheQueryOptions | undefined} options\n   * @returns {boolean}\n   */\n  #requestMatchesCachedItem (requestQuery, request, response = null, options) {\n    // if (options?.ignoreMethod === false && request.method === 'GET') {\n    //   return false\n    // }\n\n    const queryURL = new URL(requestQuery.url)\n\n    const cachedURL = new URL(request.url)\n\n    if (options?.ignoreSearch) {\n      cachedURL.search = ''\n\n      queryURL.search = ''\n    }\n\n    if (!urlEquals(queryURL, cachedURL, true)) {\n      return false\n    }\n\n    if (\n      response == null ||\n      options?.ignoreVary ||\n      !response.headersList.contains('vary')\n    ) {\n      return true\n    }\n\n    const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n    for (const fieldValue of fieldValues) {\n      if (fieldValue === '*') {\n        return false\n      }\n\n      const requestValue = request.headersList.get(fieldValue)\n      const queryValue = requestQuery.headersList.get(fieldValue)\n\n      // If one has the header and the other doesn't, or one has\n      // a different value than the other, return false\n      if (requestValue !== queryValue) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  #internalMatchAll (request, options, maxResponses = Infinity) {\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      if (webidl.is.Request(request)) {\n        // 2.1.1\n        r = getRequestState(request)\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') {\n        // 2.2.1\n        r = getRequestState(new Request(request))\n      }\n    }\n\n    // 5.\n    // 5.1\n    const responses = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        responses.push(requestResponse[1])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        responses.push(requestResponse[1])\n      }\n    }\n\n    // 5.4\n    // We don't implement CORs so we don't need to loop over the responses, yay!\n\n    // 5.5.1\n    const responseList = []\n\n    // 5.5.2\n    for (const response of responses) {\n      // 5.5.2.1\n      const responseObject = fromInnerResponse(response, 'immutable')\n\n      responseList.push(responseObject.clone())\n\n      if (responseList.length >= maxResponses) {\n        break\n      }\n    }\n\n    // 6.\n    return Object.freeze(responseList)\n  }\n}\n\nObject.defineProperties(Cache.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'Cache',\n    configurable: true\n  },\n  match: kEnumerableProperty,\n  matchAll: kEnumerableProperty,\n  add: kEnumerableProperty,\n  addAll: kEnumerableProperty,\n  put: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  keys: kEnumerableProperty\n})\n\nconst cacheQueryOptionConverters = [\n  {\n    key: 'ignoreSearch',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'ignoreMethod',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'ignoreVary',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  }\n]\n\nwebidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters)\n\nwebidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([\n  ...cacheQueryOptionConverters,\n  {\n    key: 'cacheName',\n    converter: webidl.converters.DOMString\n  }\n])\n\nwebidl.converters.Response = webidl.interfaceConverter(\n  webidl.is.Response,\n  'Response'\n)\n\nwebidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(\n  webidl.converters.RequestInfo\n)\n\nmodule.exports = {\n  Cache\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvY2FjaGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQywyRUFBb0I7QUFDbkQsUUFBUSw0QkFBNEIsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQ3RELFFBQVEsbUNBQW1DLEVBQUUsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDdEUsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzRUFBVztBQUN0QyxRQUFRLHFEQUFxRCxFQUFFLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQzFGLFFBQVEsNkNBQTZDLEVBQUUsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDakYsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDN0MsUUFBUSw0REFBNEQsRUFBRSxtQkFBTyxDQUFDLHdFQUFlO0FBQzdGLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFcEM7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLEtBQUs7QUFDbkIsY0FBYyxLQUFLO0FBQ25CLGNBQWMsK0NBQStDO0FBQzdEOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9jYWNoZS9jYWNoZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBrQ29uc3RydWN0IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyB1cmxFcXVhbHMsIGdldEZpZWxkVmFsdWVzIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5LCBpc0Rpc3R1cmJlZCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi93ZWJpZGwnKVxuY29uc3QgeyBjbG9uZVJlc3BvbnNlLCBmcm9tSW5uZXJSZXNwb25zZSwgZ2V0UmVzcG9uc2VTdGF0ZSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvcmVzcG9uc2UnKVxuY29uc3QgeyBSZXF1ZXN0LCBmcm9tSW5uZXJSZXF1ZXN0LCBnZXRSZXF1ZXN0U3RhdGUgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3JlcXVlc3QnKVxuY29uc3QgeyBmZXRjaGluZyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvaW5kZXgnKVxuY29uc3QgeyB1cmxJc0h0dHBIdHRwc1NjaGVtZSwgY3JlYXRlRGVmZXJyZWRQcm9taXNlLCByZWFkQWxsQnl0ZXMgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3V0aWwnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2Rmbi1jYWNoZS1iYXRjaC1vcGVyYXRpb25cbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhY2hlQmF0Y2hPcGVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7J2RlbGV0ZScgfCAncHV0J30gdHlwZVxuICogQHByb3BlcnR5IHthbnl9IHJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7YW55fSByZXNwb25zZVxuICogQHByb3BlcnR5IHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlJykuQ2FjaGVRdWVyeU9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2Rmbi1yZXF1ZXN0LXJlc3BvbnNlLWxpc3RcbiAqIEB0eXBlZGVmIHtbYW55LCBhbnldW119IHJlcXVlc3RSZXNwb25zZUxpc3RcbiAqL1xuXG5jbGFzcyBDYWNoZSB7XG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkZm4tcmVsZXZhbnQtcmVxdWVzdC1yZXNwb25zZS1saXN0XG4gICAqIEB0eXBlIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdFxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdICE9PSBrQ29uc3RydWN0KSB7XG4gICAgICB3ZWJpZGwuaWxsZWdhbENvbnN0cnVjdG9yKClcbiAgICB9XG5cbiAgICB3ZWJpZGwudXRpbC5tYXJrQXNVbmNsb25lYWJsZSh0aGlzKVxuICAgIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdCA9IGFyZ3VtZW50c1sxXVxuICB9XG5cbiAgYXN5bmMgbWF0Y2ggKHJlcXVlc3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlLm1hdGNoJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QsIHByZWZpeCwgJ3JlcXVlc3QnKVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zLCBwcmVmaXgsICdvcHRpb25zJylcblxuICAgIGNvbnN0IHAgPSB0aGlzLiNpbnRlcm5hbE1hdGNoQWxsKHJlcXVlc3QsIG9wdGlvbnMsIDEpXG5cbiAgICBpZiAocC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJldHVybiBwWzBdXG4gIH1cblxuICBhc3luYyBtYXRjaEFsbCAocmVxdWVzdCA9IHVuZGVmaW5lZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGUubWF0Y2hBbGwnXG4gICAgaWYgKHJlcXVlc3QgIT09IHVuZGVmaW5lZCkgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QsIHByZWZpeCwgJ3JlcXVlc3QnKVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zLCBwcmVmaXgsICdvcHRpb25zJylcblxuICAgIHJldHVybiB0aGlzLiNpbnRlcm5hbE1hdGNoQWxsKHJlcXVlc3QsIG9wdGlvbnMpXG4gIH1cblxuICBhc3luYyBhZGQgKHJlcXVlc3QpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZS5hZGQnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdCwgcHJlZml4LCAncmVxdWVzdCcpXG5cbiAgICAvLyAxLlxuICAgIGNvbnN0IHJlcXVlc3RzID0gW3JlcXVlc3RdXG5cbiAgICAvLyAyLlxuICAgIGNvbnN0IHJlc3BvbnNlQXJyYXlQcm9taXNlID0gdGhpcy5hZGRBbGwocmVxdWVzdHMpXG5cbiAgICAvLyAzLlxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZUFycmF5UHJvbWlzZVxuICB9XG5cbiAgYXN5bmMgYWRkQWxsIChyZXF1ZXN0cykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlLmFkZEFsbCdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIC8vIDEuXG4gICAgY29uc3QgcmVzcG9uc2VQcm9taXNlcyA9IFtdXG5cbiAgICAvLyAyLlxuICAgIGNvbnN0IHJlcXVlc3RMaXN0ID0gW11cblxuICAgIC8vIDMuXG4gICAgZm9yIChsZXQgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgaWYgKHJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICBhcmd1bWVudDogJ0FyZ3VtZW50IDEnLFxuICAgICAgICAgIHR5cGVzOiBbJ3VuZGVmaW5lZCBpcyBub3QgYWxsb3dlZCddXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuXG4gICAgICBpZiAodHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDMuMVxuICAgICAgY29uc3QgciA9IGdldFJlcXVlc3RTdGF0ZShyZXF1ZXN0KVxuXG4gICAgICAvLyAzLjJcbiAgICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUoci51cmwpIHx8IHIubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGVkIGh0dHAvcyBzY2hlbWUgd2hlbiBtZXRob2QgaXMgbm90IEdFVC4nXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC5cbiAgICAvKiogQHR5cGUge1JldHVyblR5cGU8dHlwZW9mIGZldGNoaW5nPltdfSAqL1xuICAgIGNvbnN0IGZldGNoQ29udHJvbGxlcnMgPSBbXVxuXG4gICAgLy8gNS5cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgcmVxdWVzdHMpIHtcbiAgICAgIC8vIDUuMVxuICAgICAgY29uc3QgciA9IGdldFJlcXVlc3RTdGF0ZShuZXcgUmVxdWVzdChyZXF1ZXN0KSlcblxuICAgICAgLy8gNS4yXG4gICAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKHIudXJsKSkge1xuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGVkIGh0dHAvcyBzY2hlbWUuJ1xuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyA1LjRcbiAgICAgIHIuaW5pdGlhdG9yID0gJ2ZldGNoJ1xuICAgICAgci5kZXN0aW5hdGlvbiA9ICdzdWJyZXNvdXJjZSdcblxuICAgICAgLy8gNS41XG4gICAgICByZXF1ZXN0TGlzdC5wdXNoKHIpXG5cbiAgICAgIC8vIDUuNlxuICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgICAgLy8gNS43XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLnB1c2goZmV0Y2hpbmcoe1xuICAgICAgICByZXF1ZXN0OiByLFxuICAgICAgICBwcm9jZXNzUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgLy8gMS5cbiAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJyB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNiB8fCByZXNwb25zZS5zdGF0dXMgPCAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID4gMjk5KSB7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuYWRkQWxsJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ1JlY2VpdmVkIGFuIGludmFsaWQgc3RhdHVzIGNvZGUgb3IgdGhlIHJlcXVlc3QgZmFpbGVkLidcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3ZhcnknKSkgeyAvLyAyLlxuICAgICAgICAgICAgLy8gMi4xXG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkVmFsdWVzKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgndmFyeScpKVxuXG4gICAgICAgICAgICAvLyAyLjJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGRWYWx1ZSBvZiBmaWVsZFZhbHVlcykge1xuICAgICAgICAgICAgICAvLyAyLjIuMVxuICAgICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdCh3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS5hZGRBbGwnLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2ludmFsaWQgdmFyeSBmaWVsZCB2YWx1ZSdcbiAgICAgICAgICAgICAgICB9KSlcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiBmZXRjaENvbnRyb2xsZXJzKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IChyZXNwb25zZSkge1xuICAgICAgICAgIC8vIDEuXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3QobmV3IERPTUV4Y2VwdGlvbignYWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAyLlxuICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKVxuICAgICAgICB9XG4gICAgICB9KSlcblxuICAgICAgLy8gNS44XG4gICAgICByZXNwb25zZVByb21pc2VzLnB1c2gocmVzcG9uc2VQcm9taXNlLnByb21pc2UpXG4gICAgfVxuXG4gICAgLy8gNi5cbiAgICBjb25zdCBwID0gUHJvbWlzZS5hbGwocmVzcG9uc2VQcm9taXNlcylcblxuICAgIC8vIDcuXG4gICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgcFxuXG4gICAgLy8gNy4xXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdXG5cbiAgICAvLyA3LjJcbiAgICBsZXQgaW5kZXggPSAwXG5cbiAgICAvLyA3LjNcbiAgICBmb3IgKGNvbnN0IHJlc3BvbnNlIG9mIHJlc3BvbnNlcykge1xuICAgICAgLy8gNy4zLjFcbiAgICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbn0gKi9cbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgICAgdHlwZTogJ3B1dCcsIC8vIDcuMy4yXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RMaXN0W2luZGV4XSwgLy8gNy4zLjNcbiAgICAgICAgcmVzcG9uc2UgLy8gNy4zLjRcbiAgICAgIH1cblxuICAgICAgb3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbikgLy8gNy4zLjVcblxuICAgICAgaW5kZXgrKyAvLyA3LjMuNlxuICAgIH1cblxuICAgIC8vIDcuNVxuICAgIGNvbnN0IGNhY2hlSm9iUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyA3LjYuMVxuICAgIGxldCBlcnJvckRhdGEgPSBudWxsXG5cbiAgICAvLyA3LjYuMlxuICAgIHRyeSB7XG4gICAgICB0aGlzLiNiYXRjaENhY2hlT3BlcmF0aW9ucyhvcGVyYXRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yRGF0YSA9IGVcbiAgICB9XG5cbiAgICAvLyA3LjYuM1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIC8vIDcuNi4zLjFcbiAgICAgIGlmIChlcnJvckRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gNy42LjMuMlxuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVqZWN0KGVycm9yRGF0YSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gNy43XG4gICAgcmV0dXJuIGNhY2hlSm9iUHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICBhc3luYyBwdXQgKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGUucHV0J1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgcHJlZml4KVxuXG4gICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QsIHByZWZpeCwgJ3JlcXVlc3QnKVxuICAgIHJlc3BvbnNlID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVzcG9uc2UocmVzcG9uc2UsIHByZWZpeCwgJ3Jlc3BvbnNlJylcblxuICAgIC8vIDEuXG4gICAgbGV0IGlubmVyUmVxdWVzdCA9IG51bGxcblxuICAgIC8vIDIuXG4gICAgaWYgKHdlYmlkbC5pcy5SZXF1ZXN0KHJlcXVlc3QpKSB7XG4gICAgICBpbm5lclJlcXVlc3QgPSBnZXRSZXF1ZXN0U3RhdGUocmVxdWVzdClcbiAgICB9IGVsc2UgeyAvLyAzLlxuICAgICAgaW5uZXJSZXF1ZXN0ID0gZ2V0UmVxdWVzdFN0YXRlKG5ldyBSZXF1ZXN0KHJlcXVlc3QpKVxuICAgIH1cblxuICAgIC8vIDQuXG4gICAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShpbm5lclJlcXVlc3QudXJsKSB8fCBpbm5lclJlcXVlc3QubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGVkIGFuIGh0dHAvcyBzY2hlbWUgd2hlbiBtZXRob2QgaXMgbm90IEdFVCdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gNS5cbiAgICBjb25zdCBpbm5lclJlc3BvbnNlID0gZ2V0UmVzcG9uc2VTdGF0ZShyZXNwb25zZSlcblxuICAgIC8vIDYuXG4gICAgaWYgKGlubmVyUmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6ICdHb3QgMjA2IHN0YXR1cydcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gNy5cbiAgICBpZiAoaW5uZXJSZXNwb25zZS5oZWFkZXJzTGlzdC5jb250YWlucygndmFyeScpKSB7XG4gICAgICAvLyA3LjEuXG4gICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkVmFsdWVzKGlubmVyUmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCd2YXJ5JykpXG5cbiAgICAgIC8vIDcuMi5cbiAgICAgIGZvciAoY29uc3QgZmllbGRWYWx1ZSBvZiBmaWVsZFZhbHVlcykge1xuICAgICAgICAvLyA3LjIuMVxuICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJyonKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgICAgICBtZXNzYWdlOiAnR290ICogdmFyeSBmaWVsZCB2YWx1ZSdcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gOC5cbiAgICBpZiAoaW5uZXJSZXNwb25zZS5ib2R5ICYmIChpc0Rpc3R1cmJlZChpbm5lclJlc3BvbnNlLmJvZHkuc3RyZWFtKSB8fCBpbm5lclJlc3BvbnNlLmJvZHkuc3RyZWFtLmxvY2tlZCkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6ICdSZXNwb25zZSBib2R5IGlzIGxvY2tlZCBvciBkaXN0dXJiZWQnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDkuXG4gICAgY29uc3QgY2xvbmVkUmVzcG9uc2UgPSBjbG9uZVJlc3BvbnNlKGlubmVyUmVzcG9uc2UpXG5cbiAgICAvLyAxMC5cbiAgICBjb25zdCBib2R5UmVhZFByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgLy8gMTEuXG4gICAgaWYgKGlubmVyUmVzcG9uc2UuYm9keSAhPSBudWxsKSB7XG4gICAgICAvLyAxMS4xXG4gICAgICBjb25zdCBzdHJlYW0gPSBpbm5lclJlc3BvbnNlLmJvZHkuc3RyZWFtXG5cbiAgICAgIC8vIDExLjJcbiAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKVxuXG4gICAgICAvLyAxMS4zXG4gICAgICByZWFkQWxsQnl0ZXMocmVhZGVyLCBib2R5UmVhZFByb21pc2UucmVzb2x2ZSwgYm9keVJlYWRQcm9taXNlLnJlamVjdClcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keVJlYWRQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKVxuICAgIH1cblxuICAgIC8vIDEyLlxuICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbltdfSAqL1xuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbXVxuXG4gICAgLy8gMTMuXG4gICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9ufSAqL1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgIHR5cGU6ICdwdXQnLCAvLyAxNC5cbiAgICAgIHJlcXVlc3Q6IGlubmVyUmVxdWVzdCwgLy8gMTUuXG4gICAgICByZXNwb25zZTogY2xvbmVkUmVzcG9uc2UgLy8gMTYuXG4gICAgfVxuXG4gICAgLy8gMTcuXG4gICAgb3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbilcblxuICAgIC8vIDE5LlxuICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgYm9keVJlYWRQcm9taXNlLnByb21pc2VcblxuICAgIGlmIChjbG9uZWRSZXNwb25zZS5ib2R5ICE9IG51bGwpIHtcbiAgICAgIGNsb25lZFJlc3BvbnNlLmJvZHkuc291cmNlID0gYnl0ZXNcbiAgICB9XG5cbiAgICAvLyAxOS4xXG4gICAgY29uc3QgY2FjaGVKb2JQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgIC8vIDE5LjIuMVxuICAgIGxldCBlcnJvckRhdGEgPSBudWxsXG5cbiAgICAvLyAxOS4yLjJcbiAgICB0cnkge1xuICAgICAgdGhpcy4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMob3BlcmF0aW9ucylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvckRhdGEgPSBlXG4gICAgfVxuXG4gICAgLy8gMTkuMi4zXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgLy8gMTkuMi4zLjFcbiAgICAgIGlmIChlcnJvckRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfSBlbHNlIHsgLy8gMTkuMi4zLjJcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlamVjdChlcnJvckRhdGEpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBjYWNoZUpvYlByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgYXN5bmMgZGVsZXRlIChyZXF1ZXN0LCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZS5kZWxldGUnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdCwgcHJlZml4LCAncmVxdWVzdCcpXG4gICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNhY2hlUXVlcnlPcHRpb25zKG9wdGlvbnMsIHByZWZpeCwgJ29wdGlvbnMnKVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1JlcXVlc3R9XG4gICAgICovXG4gICAgbGV0IHIgPSBudWxsXG5cbiAgICBpZiAod2ViaWRsLmlzLlJlcXVlc3QocmVxdWVzdCkpIHtcbiAgICAgIHIgPSBnZXRSZXF1ZXN0U3RhdGUocmVxdWVzdClcblxuICAgICAgaWYgKHIubWV0aG9kICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5pZ25vcmVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydCh0eXBlb2YgcmVxdWVzdCA9PT0gJ3N0cmluZycpXG5cbiAgICAgIHIgPSBnZXRSZXF1ZXN0U3RhdGUobmV3IFJlcXVlc3QocmVxdWVzdCkpXG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9uW119ICovXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdXG5cbiAgICAvKiogQHR5cGUge0NhY2hlQmF0Y2hPcGVyYXRpb259ICovXG4gICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgdHlwZTogJ2RlbGV0ZScsXG4gICAgICByZXF1ZXN0OiByLFxuICAgICAgb3B0aW9uc1xuICAgIH1cblxuICAgIG9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pXG5cbiAgICBjb25zdCBjYWNoZUpvYlByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgbGV0IGVycm9yRGF0YSA9IG51bGxcbiAgICBsZXQgcmVxdWVzdFJlc3BvbnNlc1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNiYXRjaENhY2hlT3BlcmF0aW9ucyhvcGVyYXRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yRGF0YSA9IGVcbiAgICB9XG5cbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICBpZiAoZXJyb3JEYXRhID09PSBudWxsKSB7XG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZXNvbHZlKCEhcmVxdWVzdFJlc3BvbnNlcz8ubGVuZ3RoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlamVjdChlcnJvckRhdGEpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBjYWNoZUpvYlByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2RvbS1jYWNoZS1rZXlzXG4gICAqIEBwYXJhbSB7YW55fSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZScpLkNhY2hlUXVlcnlPcHRpb25zfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHJlYWRvbmx5IFJlcXVlc3RbXT59XG4gICAqL1xuICBhc3luYyBrZXlzIChyZXF1ZXN0ID0gdW5kZWZpbmVkLCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZS5rZXlzJ1xuXG4gICAgaWYgKHJlcXVlc3QgIT09IHVuZGVmaW5lZCkgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QsIHByZWZpeCwgJ3JlcXVlc3QnKVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zLCBwcmVmaXgsICdvcHRpb25zJylcblxuICAgIC8vIDEuXG4gICAgbGV0IHIgPSBudWxsXG5cbiAgICAvLyAyLlxuICAgIGlmIChyZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDIuMVxuICAgICAgaWYgKHdlYmlkbC5pcy5SZXF1ZXN0KHJlcXVlc3QpKSB7XG4gICAgICAgIC8vIDIuMS4xXG4gICAgICAgIHIgPSBnZXRSZXF1ZXN0U3RhdGUocmVxdWVzdClcblxuICAgICAgICAvLyAyLjEuMlxuICAgICAgICBpZiAoci5tZXRob2QgIT09ICdHRVQnICYmICFvcHRpb25zLmlnbm9yZU1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0ID09PSAnc3RyaW5nJykgeyAvLyAyLjJcbiAgICAgICAgciA9IGdldFJlcXVlc3RTdGF0ZShuZXcgUmVxdWVzdChyZXF1ZXN0KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LlxuICAgIGNvbnN0IHByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgLy8gNS5cbiAgICAvLyA1LjFcbiAgICBjb25zdCByZXF1ZXN0cyA9IFtdXG5cbiAgICAvLyA1LjJcbiAgICBpZiAocmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyA1LjIuMVxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0KSB7XG4gICAgICAgIC8vIDUuMi4xLjFcbiAgICAgICAgcmVxdWVzdHMucHVzaChyZXF1ZXN0UmVzcG9uc2VbMF0pXG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gNS4zXG4gICAgICAvLyA1LjMuMVxuICAgICAgY29uc3QgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI3F1ZXJ5Q2FjaGUociwgb3B0aW9ucylcblxuICAgICAgLy8gNS4zLjJcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHJlcXVlc3RSZXNwb25zZXMpIHtcbiAgICAgICAgLy8gNS4zLjIuMVxuICAgICAgICByZXF1ZXN0cy5wdXNoKHJlcXVlc3RSZXNwb25zZVswXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LjRcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAvLyA1LjQuMVxuICAgICAgY29uc3QgcmVxdWVzdExpc3QgPSBbXVxuXG4gICAgICAvLyA1LjQuMlxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RPYmplY3QgPSBmcm9tSW5uZXJSZXF1ZXN0KFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIG5ldyBBYm9ydENvbnRyb2xsZXIoKS5zaWduYWwsXG4gICAgICAgICAgJ2ltbXV0YWJsZSdcbiAgICAgICAgKVxuICAgICAgICAvLyA1LjQuMi4xXG4gICAgICAgIHJlcXVlc3RMaXN0LnB1c2gocmVxdWVzdE9iamVjdClcbiAgICAgIH1cblxuICAgICAgLy8gNS40LjNcbiAgICAgIHByb21pc2UucmVzb2x2ZShPYmplY3QuZnJlZXplKHJlcXVlc3RMaXN0KSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2JhdGNoLWNhY2hlLW9wZXJhdGlvbnMtYWxnb3JpdGhtXG4gICAqIEBwYXJhbSB7Q2FjaGVCYXRjaE9wZXJhdGlvbltdfSBvcGVyYXRpb25zXG4gICAqIEByZXR1cm5zIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI2JhdGNoQ2FjaGVPcGVyYXRpb25zIChvcGVyYXRpb25zKSB7XG4gICAgLy8gMS5cbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdFxuXG4gICAgLy8gMi5cbiAgICBjb25zdCBiYWNrdXBDYWNoZSA9IFsuLi5jYWNoZV1cblxuICAgIC8vIDMuXG4gICAgY29uc3QgYWRkZWRJdGVtcyA9IFtdXG5cbiAgICAvLyA0LjFcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW11cblxuICAgIHRyeSB7XG4gICAgICAvLyA0LjJcbiAgICAgIGZvciAoY29uc3Qgb3BlcmF0aW9uIG9mIG9wZXJhdGlvbnMpIHtcbiAgICAgICAgLy8gNC4yLjFcbiAgICAgICAgaWYgKG9wZXJhdGlvbi50eXBlICE9PSAnZGVsZXRlJyAmJiBvcGVyYXRpb24udHlwZSAhPT0gJ3B1dCcpIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ29wZXJhdGlvbiB0eXBlIGRvZXMgbm90IG1hdGNoIFwiZGVsZXRlXCIgb3IgXCJwdXRcIidcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4yLjJcbiAgICAgICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSAnZGVsZXRlJyAmJiBvcGVyYXRpb24ucmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICBtZXNzYWdlOiAnZGVsZXRlIG9wZXJhdGlvbiBzaG91bGQgbm90IGhhdmUgYW4gYXNzb2NpYXRlZCByZXNwb25zZSdcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4yLjNcbiAgICAgICAgaWYgKHRoaXMuI3F1ZXJ5Q2FjaGUob3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5vcHRpb25zLCBhZGRlZEl0ZW1zKS5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCc/Pz8nLCAnSW52YWxpZFN0YXRlRXJyb3InKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4yLjRcbiAgICAgICAgbGV0IHJlcXVlc3RSZXNwb25zZXNcblxuICAgICAgICAvLyA0LjIuNVxuICAgICAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgLy8gNC4yLjUuMVxuICAgICAgICAgIHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNxdWVyeUNhY2hlKG9wZXJhdGlvbi5yZXF1ZXN0LCBvcGVyYXRpb24ub3B0aW9ucylcblxuICAgICAgICAgIC8vIFRPRE86IHRoZSBzcGVjIGlzIHdyb25nLCB0aGlzIGlzIG5lZWRlZCB0byBwYXNzIFdQVHNcbiAgICAgICAgICBpZiAocmVxdWVzdFJlc3BvbnNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi41LjJcbiAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiByZXF1ZXN0UmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBjYWNoZS5pbmRleE9mKHJlcXVlc3RSZXNwb25zZSlcbiAgICAgICAgICAgIGFzc2VydChpZHggIT09IC0xKVxuXG4gICAgICAgICAgICAvLyA0LjIuNS4yLjFcbiAgICAgICAgICAgIGNhY2hlLnNwbGljZShpZHgsIDEpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi50eXBlID09PSAncHV0JykgeyAvLyA0LjIuNlxuICAgICAgICAgIC8vIDQuMi42LjFcbiAgICAgICAgICBpZiAob3BlcmF0aW9uLnJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ3B1dCBvcGVyYXRpb24gc2hvdWxkIGhhdmUgYW4gYXNzb2NpYXRlZCByZXNwb25zZSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjYuMlxuICAgICAgICAgIGNvbnN0IHIgPSBvcGVyYXRpb24ucmVxdWVzdFxuXG4gICAgICAgICAgLy8gNC4yLjYuM1xuICAgICAgICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUoci51cmwpKSB7XG4gICAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdleHBlY3RlZCBodHRwIG9yIGh0dHBzIHNjaGVtZSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjYuNFxuICAgICAgICAgIGlmIChyLm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ25vdCBnZXQgbWV0aG9kJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi41XG4gICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ29wdGlvbnMgbXVzdCBub3QgYmUgZGVmaW5lZCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjYuNlxuICAgICAgICAgIHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNxdWVyeUNhY2hlKG9wZXJhdGlvbi5yZXF1ZXN0KVxuXG4gICAgICAgICAgLy8gNC4yLjYuN1xuICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHJlcXVlc3RSZXNwb25zZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGNhY2hlLmluZGV4T2YocmVxdWVzdFJlc3BvbnNlKVxuICAgICAgICAgICAgYXNzZXJ0KGlkeCAhPT0gLTEpXG5cbiAgICAgICAgICAgIC8vIDQuMi42LjcuMVxuICAgICAgICAgICAgY2FjaGUuc3BsaWNlKGlkeCwgMSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi44XG4gICAgICAgICAgY2FjaGUucHVzaChbb3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5yZXNwb25zZV0pXG5cbiAgICAgICAgICAvLyA0LjIuNi4xMFxuICAgICAgICAgIGFkZGVkSXRlbXMucHVzaChbb3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5yZXNwb25zZV0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LjIuN1xuICAgICAgICByZXN1bHRMaXN0LnB1c2goW29wZXJhdGlvbi5yZXF1ZXN0LCBvcGVyYXRpb24ucmVzcG9uc2VdKVxuICAgICAgfVxuXG4gICAgICAvLyA0LjNcbiAgICAgIHJldHVybiByZXN1bHRMaXN0XG4gICAgfSBjYXRjaCAoZSkgeyAvLyA1LlxuICAgICAgLy8gNS4xXG4gICAgICB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QubGVuZ3RoID0gMFxuXG4gICAgICAvLyA1LjJcbiAgICAgIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdCA9IGJhY2t1cENhY2hlXG5cbiAgICAgIC8vIDUuM1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNxdWVyeS1jYWNoZVxuICAgKiBAcGFyYW0ge2FueX0gcmVxdWVzdFF1ZXJ5XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZScpLkNhY2hlUXVlcnlPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7cmVxdWVzdFJlc3BvbnNlTGlzdH0gdGFyZ2V0U3RvcmFnZVxuICAgKiBAcmV0dXJucyB7cmVxdWVzdFJlc3BvbnNlTGlzdH1cbiAgICovXG4gICNxdWVyeUNhY2hlIChyZXF1ZXN0UXVlcnksIG9wdGlvbnMsIHRhcmdldFN0b3JhZ2UpIHtcbiAgICAvKiogQHR5cGUge3JlcXVlc3RSZXNwb25zZUxpc3R9ICovXG4gICAgY29uc3QgcmVzdWx0TGlzdCA9IFtdXG5cbiAgICBjb25zdCBzdG9yYWdlID0gdGFyZ2V0U3RvcmFnZSA/PyB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3RcblxuICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHN0b3JhZ2UpIHtcbiAgICAgIGNvbnN0IFtjYWNoZWRSZXF1ZXN0LCBjYWNoZWRSZXNwb25zZV0gPSByZXF1ZXN0UmVzcG9uc2VcbiAgICAgIGlmICh0aGlzLiNyZXF1ZXN0TWF0Y2hlc0NhY2hlZEl0ZW0ocmVxdWVzdFF1ZXJ5LCBjYWNoZWRSZXF1ZXN0LCBjYWNoZWRSZXNwb25zZSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKHJlcXVlc3RSZXNwb25zZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0TGlzdFxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI3JlcXVlc3QtbWF0Y2hlcy1jYWNoZWQtaXRlbS1hbGdvcml0aG1cbiAgICogQHBhcmFtIHthbnl9IHJlcXVlc3RRdWVyeVxuICAgKiBAcGFyYW0ge2FueX0gcmVxdWVzdFxuICAgKiBAcGFyYW0ge2FueSB8IG51bGx9IHJlc3BvbnNlXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZScpLkNhY2hlUXVlcnlPcHRpb25zIHwgdW5kZWZpbmVkfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgI3JlcXVlc3RNYXRjaGVzQ2FjaGVkSXRlbSAocmVxdWVzdFF1ZXJ5LCByZXF1ZXN0LCByZXNwb25zZSA9IG51bGwsIG9wdGlvbnMpIHtcbiAgICAvLyBpZiAob3B0aW9ucz8uaWdub3JlTWV0aG9kID09PSBmYWxzZSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAvLyAgIHJldHVybiBmYWxzZVxuICAgIC8vIH1cblxuICAgIGNvbnN0IHF1ZXJ5VVJMID0gbmV3IFVSTChyZXF1ZXN0UXVlcnkudXJsKVxuXG4gICAgY29uc3QgY2FjaGVkVVJMID0gbmV3IFVSTChyZXF1ZXN0LnVybClcblxuICAgIGlmIChvcHRpb25zPy5pZ25vcmVTZWFyY2gpIHtcbiAgICAgIGNhY2hlZFVSTC5zZWFyY2ggPSAnJ1xuXG4gICAgICBxdWVyeVVSTC5zZWFyY2ggPSAnJ1xuICAgIH1cblxuICAgIGlmICghdXJsRXF1YWxzKHF1ZXJ5VVJMLCBjYWNoZWRVUkwsIHRydWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICByZXNwb25zZSA9PSBudWxsIHx8XG4gICAgICBvcHRpb25zPy5pZ25vcmVWYXJ5IHx8XG4gICAgICAhcmVzcG9uc2UuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3ZhcnknKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkVmFsdWVzKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgndmFyeScpKVxuXG4gICAgZm9yIChjb25zdCBmaWVsZFZhbHVlIG9mIGZpZWxkVmFsdWVzKSB7XG4gICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJyonKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXF1ZXN0VmFsdWUgPSByZXF1ZXN0LmhlYWRlcnNMaXN0LmdldChmaWVsZFZhbHVlKVxuICAgICAgY29uc3QgcXVlcnlWYWx1ZSA9IHJlcXVlc3RRdWVyeS5oZWFkZXJzTGlzdC5nZXQoZmllbGRWYWx1ZSlcblxuICAgICAgLy8gSWYgb25lIGhhcyB0aGUgaGVhZGVyIGFuZCB0aGUgb3RoZXIgZG9lc24ndCwgb3Igb25lIGhhc1xuICAgICAgLy8gYSBkaWZmZXJlbnQgdmFsdWUgdGhhbiB0aGUgb3RoZXIsIHJldHVybiBmYWxzZVxuICAgICAgaWYgKHJlcXVlc3RWYWx1ZSAhPT0gcXVlcnlWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgI2ludGVybmFsTWF0Y2hBbGwgKHJlcXVlc3QsIG9wdGlvbnMsIG1heFJlc3BvbnNlcyA9IEluZmluaXR5KSB7XG4gICAgLy8gMS5cbiAgICBsZXQgciA9IG51bGxcblxuICAgIC8vIDIuXG4gICAgaWYgKHJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHdlYmlkbC5pcy5SZXF1ZXN0KHJlcXVlc3QpKSB7XG4gICAgICAgIC8vIDIuMS4xXG4gICAgICAgIHIgPSBnZXRSZXF1ZXN0U3RhdGUocmVxdWVzdClcblxuICAgICAgICAvLyAyLjEuMlxuICAgICAgICBpZiAoci5tZXRob2QgIT09ICdHRVQnICYmICFvcHRpb25zLmlnbm9yZU1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyAyLjIuMVxuICAgICAgICByID0gZ2V0UmVxdWVzdFN0YXRlKG5ldyBSZXF1ZXN0KHJlcXVlc3QpKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuXG4gICAgLy8gNS4xXG4gICAgY29uc3QgcmVzcG9uc2VzID0gW11cblxuICAgIC8vIDUuMlxuICAgIGlmIChyZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDUuMi4xXG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QpIHtcbiAgICAgICAgcmVzcG9uc2VzLnB1c2gocmVxdWVzdFJlc3BvbnNlWzFdKVxuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIDUuM1xuICAgICAgLy8gNS4zLjFcbiAgICAgIGNvbnN0IHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNxdWVyeUNhY2hlKHIsIG9wdGlvbnMpXG5cbiAgICAgIC8vIDUuMy4yXG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiByZXF1ZXN0UmVzcG9uc2VzKSB7XG4gICAgICAgIHJlc3BvbnNlcy5wdXNoKHJlcXVlc3RSZXNwb25zZVsxXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LjRcbiAgICAvLyBXZSBkb24ndCBpbXBsZW1lbnQgQ09ScyBzbyB3ZSBkb24ndCBuZWVkIHRvIGxvb3Agb3ZlciB0aGUgcmVzcG9uc2VzLCB5YXkhXG5cbiAgICAvLyA1LjUuMVxuICAgIGNvbnN0IHJlc3BvbnNlTGlzdCA9IFtdXG5cbiAgICAvLyA1LjUuMlxuICAgIGZvciAoY29uc3QgcmVzcG9uc2Ugb2YgcmVzcG9uc2VzKSB7XG4gICAgICAvLyA1LjUuMi4xXG4gICAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IGZyb21Jbm5lclJlc3BvbnNlKHJlc3BvbnNlLCAnaW1tdXRhYmxlJylcblxuICAgICAgcmVzcG9uc2VMaXN0LnB1c2gocmVzcG9uc2VPYmplY3QuY2xvbmUoKSlcblxuICAgICAgaWYgKHJlc3BvbnNlTGlzdC5sZW5ndGggPj0gbWF4UmVzcG9uc2VzKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNi5cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyZXNwb25zZUxpc3QpXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2FjaGUucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdDYWNoZScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIG1hdGNoOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBtYXRjaEFsbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYWRkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBhZGRBbGw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHB1dDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZGVsZXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBrZXlzOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG5jb25zdCBjYWNoZVF1ZXJ5T3B0aW9uQ29udmVydGVycyA9IFtcbiAge1xuICAgIGtleTogJ2lnbm9yZVNlYXJjaCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2lnbm9yZU1ldGhvZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2lnbm9yZVZhcnknLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH1cbl1cblxud2ViaWRsLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihjYWNoZVF1ZXJ5T3B0aW9uQ29udmVydGVycylcblxud2ViaWRsLmNvbnZlcnRlcnMuTXVsdGlDYWNoZVF1ZXJ5T3B0aW9ucyA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgLi4uY2FjaGVRdWVyeU9wdGlvbkNvbnZlcnRlcnMsXG4gIHtcbiAgICBrZXk6ICdjYWNoZU5hbWUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgd2ViaWRsLmlzLlJlc3BvbnNlLFxuICAnUmVzcG9uc2UnXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxSZXF1ZXN0SW5mbz4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm9cbilcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENhY2hlXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cache/cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cache/cachestorage.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/cachestorage.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Cache } = __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/undici/lib/web/cache/cache.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\nclass CacheStorage {\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map\n   * @type {Map<string, import('./cache').requestResponseList}\n   */\n  #caches = new Map()\n\n  constructor () {\n    if (arguments[0] !== kConstruct) {\n      webidl.illegalConstructor()\n    }\n\n    webidl.util.markAsUncloneable(this)\n  }\n\n  async match (request, options = {}) {\n    webidl.brandCheck(this, CacheStorage)\n    webidl.argumentLengthCheck(arguments, 1, 'CacheStorage.match')\n\n    request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.MultiCacheQueryOptions(options)\n\n    // 1.\n    if (options.cacheName != null) {\n      // 1.1.1.1\n      if (this.#caches.has(options.cacheName)) {\n        // 1.1.1.1.1\n        const cacheList = this.#caches.get(options.cacheName)\n        const cache = new Cache(kConstruct, cacheList)\n\n        return await cache.match(request, options)\n      }\n    } else { // 2.\n      // 2.2\n      for (const cacheList of this.#caches.values()) {\n        const cache = new Cache(kConstruct, cacheList)\n\n        // 2.2.1.2\n        const response = await cache.match(request, options)\n\n        if (response !== undefined) {\n          return response\n        }\n      }\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-has\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */\n  async has (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n\n    const prefix = 'CacheStorage.has'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName')\n\n    // 2.1.1\n    // 2.2\n    return this.#caches.has(cacheName)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open\n   * @param {string} cacheName\n   * @returns {Promise<Cache>}\n   */\n  async open (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n\n    const prefix = 'CacheStorage.open'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName')\n\n    // 2.1\n    if (this.#caches.has(cacheName)) {\n      // await caches.open('v1') !== await caches.open('v1')\n\n      // 2.1.1\n      const cache = this.#caches.get(cacheName)\n\n      // 2.1.1.1\n      return new Cache(kConstruct, cache)\n    }\n\n    // 2.2\n    const cache = []\n\n    // 2.3\n    this.#caches.set(cacheName, cache)\n\n    // 2.4\n    return new Cache(kConstruct, cache)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */\n  async delete (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n\n    const prefix = 'CacheStorage.delete'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName')\n\n    return this.#caches.delete(cacheName)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys\n   * @returns {Promise<string[]>}\n   */\n  async keys () {\n    webidl.brandCheck(this, CacheStorage)\n\n    // 2.1\n    const keys = this.#caches.keys()\n\n    // 2.2\n    return [...keys]\n  }\n}\n\nObject.defineProperties(CacheStorage.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'CacheStorage',\n    configurable: true\n  },\n  match: kEnumerableProperty,\n  has: kEnumerableProperty,\n  open: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  keys: kEnumerableProperty\n})\n\nmodule.exports = {\n  CacheStorage\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvY2FjaGVzdG9yYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsUUFBUSxFQUFFLG1CQUFPLENBQUMsbUVBQVM7QUFDbkMsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzRUFBVztBQUN0QyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQ3pELFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsMkVBQW9COztBQUVuRDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9jYWNoZS9jYWNoZXN0b3JhZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQ2FjaGUgfSA9IHJlcXVpcmUoJy4vY2FjaGUnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL3dlYmlkbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvc3ltYm9scycpXG5cbmNsYXNzIENhY2hlU3RvcmFnZSB7XG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkZm4tcmVsZXZhbnQtbmFtZS10by1jYWNoZS1tYXBcbiAgICogQHR5cGUge01hcDxzdHJpbmcsIGltcG9ydCgnLi9jYWNoZScpLnJlcXVlc3RSZXNwb25zZUxpc3R9XG4gICAqL1xuICAjY2FjaGVzID0gbmV3IE1hcCgpXG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gIT09IGtDb25zdHJ1Y3QpIHtcbiAgICAgIHdlYmlkbC5pbGxlZ2FsQ29uc3RydWN0b3IoKVxuICAgIH1cblxuICAgIHdlYmlkbC51dGlsLm1hcmtBc1VuY2xvbmVhYmxlKHRoaXMpXG4gIH1cblxuICBhc3luYyBtYXRjaCAocmVxdWVzdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGVTdG9yYWdlKVxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ0NhY2hlU3RvcmFnZS5tYXRjaCcpXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdClcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuTXVsdGlDYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zKVxuXG4gICAgLy8gMS5cbiAgICBpZiAob3B0aW9ucy5jYWNoZU5hbWUgIT0gbnVsbCkge1xuICAgICAgLy8gMS4xLjEuMVxuICAgICAgaWYgKHRoaXMuI2NhY2hlcy5oYXMob3B0aW9ucy5jYWNoZU5hbWUpKSB7XG4gICAgICAgIC8vIDEuMS4xLjEuMVxuICAgICAgICBjb25zdCBjYWNoZUxpc3QgPSB0aGlzLiNjYWNoZXMuZ2V0KG9wdGlvbnMuY2FjaGVOYW1lKVxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBDYWNoZShrQ29uc3RydWN0LCBjYWNoZUxpc3QpXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IGNhY2hlLm1hdGNoKHJlcXVlc3QsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gMi5cbiAgICAgIC8vIDIuMlxuICAgICAgZm9yIChjb25zdCBjYWNoZUxpc3Qgb2YgdGhpcy4jY2FjaGVzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IENhY2hlKGtDb25zdHJ1Y3QsIGNhY2hlTGlzdClcblxuICAgICAgICAvLyAyLjIuMS4yXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FjaGUubWF0Y2gocmVxdWVzdCwgb3B0aW9ucylcblxuICAgICAgICBpZiAocmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2NhY2hlLXN0b3JhZ2UtaGFzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyBoYXMgKGNhY2hlTmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZVN0b3JhZ2UuaGFzJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgY2FjaGVOYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKGNhY2hlTmFtZSwgcHJlZml4LCAnY2FjaGVOYW1lJylcblxuICAgIC8vIDIuMS4xXG4gICAgLy8gMi4yXG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlcy5oYXMoY2FjaGVOYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2RvbS1jYWNoZXN0b3JhZ2Utb3BlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlPn1cbiAgICovXG4gIGFzeW5jIG9wZW4gKGNhY2hlTmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZVN0b3JhZ2Uub3BlbidcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIGNhY2hlTmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhjYWNoZU5hbWUsIHByZWZpeCwgJ2NhY2hlTmFtZScpXG5cbiAgICAvLyAyLjFcbiAgICBpZiAodGhpcy4jY2FjaGVzLmhhcyhjYWNoZU5hbWUpKSB7XG4gICAgICAvLyBhd2FpdCBjYWNoZXMub3BlbigndjEnKSAhPT0gYXdhaXQgY2FjaGVzLm9wZW4oJ3YxJylcblxuICAgICAgLy8gMi4xLjFcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy4jY2FjaGVzLmdldChjYWNoZU5hbWUpXG5cbiAgICAgIC8vIDIuMS4xLjFcbiAgICAgIHJldHVybiBuZXcgQ2FjaGUoa0NvbnN0cnVjdCwgY2FjaGUpXG4gICAgfVxuXG4gICAgLy8gMi4yXG4gICAgY29uc3QgY2FjaGUgPSBbXVxuXG4gICAgLy8gMi4zXG4gICAgdGhpcy4jY2FjaGVzLnNldChjYWNoZU5hbWUsIGNhY2hlKVxuXG4gICAgLy8gMi40XG4gICAgcmV0dXJuIG5ldyBDYWNoZShrQ29uc3RydWN0LCBjYWNoZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNjYWNoZS1zdG9yYWdlLWRlbGV0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlIChjYWNoZU5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZVN0b3JhZ2UpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGVTdG9yYWdlLmRlbGV0ZSdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIGNhY2hlTmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhjYWNoZU5hbWUsIHByZWZpeCwgJ2NhY2hlTmFtZScpXG5cbiAgICByZXR1cm4gdGhpcy4jY2FjaGVzLmRlbGV0ZShjYWNoZU5hbWUpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jY2FjaGUtc3RvcmFnZS1rZXlzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn1cbiAgICovXG4gIGFzeW5jIGtleXMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcblxuICAgIC8vIDIuMVxuICAgIGNvbnN0IGtleXMgPSB0aGlzLiNjYWNoZXMua2V5cygpXG5cbiAgICAvLyAyLjJcbiAgICByZXR1cm4gWy4uLmtleXNdXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2FjaGVTdG9yYWdlLnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnQ2FjaGVTdG9yYWdlJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgbWF0Y2g6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGhhczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb3Blbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZGVsZXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBrZXlzOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2FjaGVTdG9yYWdlXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cache/cachestorage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cache/util.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { isValidHeaderName } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\n\n/**\n * @see https://url.spec.whatwg.org/#concept-url-equals\n * @param {URL} A\n * @param {URL} B\n * @param {boolean | undefined} excludeFragment\n * @returns {boolean}\n */\nfunction urlEquals (A, B, excludeFragment = false) {\n  const serializedA = URLSerializer(A, excludeFragment)\n\n  const serializedB = URLSerializer(B, excludeFragment)\n\n  return serializedA === serializedB\n}\n\n/**\n * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262\n * @param {string} header\n */\nfunction getFieldValues (header) {\n  assert(header !== null)\n\n  const values = []\n\n  for (let value of header.split(',')) {\n    value = value.trim()\n\n    if (isValidHeaderName(value)) {\n      values.push(value)\n    }\n  }\n\n  return values\n}\n\nmodule.exports = {\n  urlEquals,\n  getFieldValues\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLGdGQUFtQjtBQUNyRCxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsd0VBQWU7O0FBRXJEO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2NhY2hlL3V0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgVVJMU2VyaWFsaXplciB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZGF0YS11cmwnKVxuY29uc3QgeyBpc1ZhbGlkSGVhZGVyTmFtZSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvdXRpbCcpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtdXJsLWVxdWFsc1xuICogQHBhcmFtIHtVUkx9IEFcbiAqIEBwYXJhbSB7VVJMfSBCXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCB1bmRlZmluZWR9IGV4Y2x1ZGVGcmFnbWVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHVybEVxdWFscyAoQSwgQiwgZXhjbHVkZUZyYWdtZW50ID0gZmFsc2UpIHtcbiAgY29uc3Qgc2VyaWFsaXplZEEgPSBVUkxTZXJpYWxpemVyKEEsIGV4Y2x1ZGVGcmFnbWVudClcblxuICBjb25zdCBzZXJpYWxpemVkQiA9IFVSTFNlcmlhbGl6ZXIoQiwgZXhjbHVkZUZyYWdtZW50KVxuXG4gIHJldHVybiBzZXJpYWxpemVkQSA9PT0gc2VyaWFsaXplZEJcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJvbWl1bS9jaHJvbWl1bS9ibG9iLzY5NGQyMGQxMzRjYjU1M2Q4ZDg5ZTU1MDBiOTE0ODAxMmIxYmEyOTkvY29udGVudC9icm93c2VyL2NhY2hlX3N0b3JhZ2UvY2FjaGVfc3RvcmFnZV9jYWNoZS5jYyNMMjYwLUwyNjJcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkZXJcbiAqL1xuZnVuY3Rpb24gZ2V0RmllbGRWYWx1ZXMgKGhlYWRlcikge1xuICBhc3NlcnQoaGVhZGVyICE9PSBudWxsKVxuXG4gIGNvbnN0IHZhbHVlcyA9IFtdXG5cbiAgZm9yIChsZXQgdmFsdWUgb2YgaGVhZGVyLnNwbGl0KCcsJykpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKVxuXG4gICAgaWYgKGlzVmFsaWRIZWFkZXJOYW1lKHZhbHVlKSkge1xuICAgICAgdmFsdWVzLnB1c2godmFsdWUpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlc1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdXJsRXF1YWxzLFxuICBnZXRGaWVsZFZhbHVlc1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cache/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cookies/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/constants.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("\n\n// https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size\nconst maxAttributeValueSize = 1024\n\n// https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size\nconst maxNameValuePairSize = 4096\n\nmodule.exports = {\n  maxAttributeValueSize,\n  maxNameValuePairSize\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9jb29raWVzL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI2Nvb2tpZS1tYXhpbXVtLWF0dHJpYnV0ZS12YWx1ZS1zaXplXG5jb25zdCBtYXhBdHRyaWJ1dGVWYWx1ZVNpemUgPSAxMDI0XG5cbi8vIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vY29va2llLXN0b3JlLyNjb29raWUtbWF4aW11bS1uYW1lLXZhbHVlLXBhaXItc2l6ZVxuY29uc3QgbWF4TmFtZVZhbHVlUGFpclNpemUgPSA0MDk2XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtYXhBdHRyaWJ1dGVWYWx1ZVNpemUsXG4gIG1heE5hbWVWYWx1ZVBhaXJTaXplXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cookies/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cookies/index.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { parseSetCookie } = __webpack_require__(/*! ./parse */ \"(rsc)/./node_modules/undici/lib/web/cookies/parse.js\")\nconst { stringify } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/cookies/util.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { Headers } = __webpack_require__(/*! ../fetch/headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\")\n\nconst brandChecks = webidl.brandCheckMultiple([Headers, globalThis.Headers].filter(Boolean))\n\n/**\n * @typedef {Object} Cookie\n * @property {string} name\n * @property {string} value\n * @property {Date|number} [expires]\n * @property {number} [maxAge]\n * @property {string} [domain]\n * @property {string} [path]\n * @property {boolean} [secure]\n * @property {boolean} [httpOnly]\n * @property {'Strict'|'Lax'|'None'} [sameSite]\n * @property {string[]} [unparsed]\n */\n\n/**\n * @param {Headers} headers\n * @returns {Record<string, string>}\n */\nfunction getCookies (headers) {\n  webidl.argumentLengthCheck(arguments, 1, 'getCookies')\n\n  brandChecks(headers)\n\n  const cookie = headers.get('cookie')\n\n  /** @type {Record<string, string>} */\n  const out = {}\n\n  if (!cookie) {\n    return out\n  }\n\n  for (const piece of cookie.split(';')) {\n    const [name, ...value] = piece.split('=')\n\n    out[name.trim()] = value.join('=')\n  }\n\n  return out\n}\n\n/**\n * @param {Headers} headers\n * @param {string} name\n * @param {{ path?: string, domain?: string }|undefined} attributes\n * @returns {void}\n */\nfunction deleteCookie (headers, name, attributes) {\n  brandChecks(headers)\n\n  const prefix = 'deleteCookie'\n  webidl.argumentLengthCheck(arguments, 2, prefix)\n\n  name = webidl.converters.DOMString(name, prefix, 'name')\n  attributes = webidl.converters.DeleteCookieAttributes(attributes)\n\n  // Matches behavior of\n  // https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278\n  setCookie(headers, {\n    name,\n    value: '',\n    expires: new Date(0),\n    ...attributes\n  })\n}\n\n/**\n * @param {Headers} headers\n * @returns {Cookie[]}\n */\nfunction getSetCookies (headers) {\n  webidl.argumentLengthCheck(arguments, 1, 'getSetCookies')\n\n  brandChecks(headers)\n\n  const cookies = headers.getSetCookie()\n\n  if (!cookies) {\n    return []\n  }\n\n  return cookies.map((pair) => parseSetCookie(pair))\n}\n\n/**\n * Parses a cookie string\n * @param {string} cookie\n */\nfunction parseCookie (cookie) {\n  cookie = webidl.converters.DOMString(cookie)\n\n  return parseSetCookie(cookie)\n}\n\n/**\n * @param {Headers} headers\n * @param {Cookie} cookie\n * @returns {void}\n */\nfunction setCookie (headers, cookie) {\n  webidl.argumentLengthCheck(arguments, 2, 'setCookie')\n\n  brandChecks(headers)\n\n  cookie = webidl.converters.Cookie(cookie)\n\n  const str = stringify(cookie)\n\n  if (str) {\n    headers.append('set-cookie', str, true)\n  }\n}\n\nwebidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'path',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'domain',\n    defaultValue: () => null\n  }\n])\n\nwebidl.converters.Cookie = webidl.dictionaryConverter([\n  {\n    converter: webidl.converters.DOMString,\n    key: 'name'\n  },\n  {\n    converter: webidl.converters.DOMString,\n    key: 'value'\n  },\n  {\n    converter: webidl.nullableConverter((value) => {\n      if (typeof value === 'number') {\n        return webidl.converters['unsigned long long'](value)\n      }\n\n      return new Date(value)\n    }),\n    key: 'expires',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters['long long']),\n    key: 'maxAge',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'domain',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'path',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.boolean),\n    key: 'secure',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.boolean),\n    key: 'httpOnly',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.converters.USVString,\n    key: 'sameSite',\n    allowedValues: ['Strict', 'Lax', 'None']\n  },\n  {\n    converter: webidl.sequenceConverter(webidl.converters.DOMString),\n    key: 'unparsed',\n    defaultValue: () => new Array(0)\n  }\n])\n\nmodule.exports = {\n  getCookies,\n  deleteCookie,\n  getSetCookies,\n  setCookie,\n  parseCookie\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMscUVBQVM7QUFDNUMsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxtRUFBUTtBQUN0QyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNFQUFXO0FBQ3RDLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsOEVBQWtCOztBQUU5Qzs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsYUFBYTtBQUMzQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsdUJBQXVCO0FBQ3JDLGNBQWMsVUFBVTtBQUN4Qjs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGFBQWEsd0JBQXdCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixhQUFhLGdDQUFnQyxZQUFZO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBwYXJzZVNldENvb2tpZSB9ID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB7IHN0cmluZ2lmeSB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi93ZWJpZGwnKVxuY29uc3QgeyBIZWFkZXJzIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9oZWFkZXJzJylcblxuY29uc3QgYnJhbmRDaGVja3MgPSB3ZWJpZGwuYnJhbmRDaGVja011bHRpcGxlKFtIZWFkZXJzLCBnbG9iYWxUaGlzLkhlYWRlcnNdLmZpbHRlcihCb29sZWFuKSlcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb29raWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmFsdWVcbiAqIEBwcm9wZXJ0eSB7RGF0ZXxudW1iZXJ9IFtleHBpcmVzXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhBZ2VdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2RvbWFpbl1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGF0aF1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NlY3VyZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2h0dHBPbmx5XVxuICogQHByb3BlcnR5IHsnU3RyaWN0J3wnTGF4J3wnTm9uZSd9IFtzYW1lU2l0ZV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFt1bnBhcnNlZF1cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7SGVhZGVyc30gaGVhZGVyc1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGdldENvb2tpZXMgKGhlYWRlcnMpIHtcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnZ2V0Q29va2llcycpXG5cbiAgYnJhbmRDaGVja3MoaGVhZGVycylcblxuICBjb25zdCBjb29raWUgPSBoZWFkZXJzLmdldCgnY29va2llJylcblxuICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59ICovXG4gIGNvbnN0IG91dCA9IHt9XG5cbiAgaWYgKCFjb29raWUpIHtcbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBmb3IgKGNvbnN0IHBpZWNlIG9mIGNvb2tpZS5zcGxpdCgnOycpKSB7XG4gICAgY29uc3QgW25hbWUsIC4uLnZhbHVlXSA9IHBpZWNlLnNwbGl0KCc9JylcblxuICAgIG91dFtuYW1lLnRyaW0oKV0gPSB2YWx1ZS5qb2luKCc9JylcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3sgcGF0aD86IHN0cmluZywgZG9tYWluPzogc3RyaW5nIH18dW5kZWZpbmVkfSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZGVsZXRlQ29va2llIChoZWFkZXJzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gIGJyYW5kQ2hlY2tzKGhlYWRlcnMpXG5cbiAgY29uc3QgcHJlZml4ID0gJ2RlbGV0ZUNvb2tpZSdcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCBwcmVmaXgpXG5cbiAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcbiAgYXR0cmlidXRlcyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRlbGV0ZUNvb2tpZUF0dHJpYnV0ZXMoYXR0cmlidXRlcylcblxuICAvLyBNYXRjaGVzIGJlaGF2aW9yIG9mXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZW5vbGFuZC9kZW5vX3N0ZC9ibG9iLzYzODI3YjE2MzMwYjgyNDg5YTA0NjE0MDI3YzMzYjc5MDRlMDhiZTUvaHR0cC9jb29raWUudHMjTDI3OFxuICBzZXRDb29raWUoaGVhZGVycywge1xuICAgIG5hbWUsXG4gICAgdmFsdWU6ICcnLFxuICAgIGV4cGlyZXM6IG5ldyBEYXRlKDApLFxuICAgIC4uLmF0dHJpYnV0ZXNcbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnNcbiAqIEByZXR1cm5zIHtDb29raWVbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2V0Q29va2llcyAoaGVhZGVycykge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdnZXRTZXRDb29raWVzJylcblxuICBicmFuZENoZWNrcyhoZWFkZXJzKVxuXG4gIGNvbnN0IGNvb2tpZXMgPSBoZWFkZXJzLmdldFNldENvb2tpZSgpXG5cbiAgaWYgKCFjb29raWVzKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICByZXR1cm4gY29va2llcy5tYXAoKHBhaXIpID0+IHBhcnNlU2V0Q29va2llKHBhaXIpKVxufVxuXG4vKipcbiAqIFBhcnNlcyBhIGNvb2tpZSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb29raWVcbiAqL1xuZnVuY3Rpb24gcGFyc2VDb29raWUgKGNvb2tpZSkge1xuICBjb29raWUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoY29va2llKVxuXG4gIHJldHVybiBwYXJzZVNldENvb2tpZShjb29raWUpXG59XG5cbi8qKlxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzXG4gKiBAcGFyYW0ge0Nvb2tpZX0gY29va2llXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gc2V0Q29va2llIChoZWFkZXJzLCBjb29raWUpIHtcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCAnc2V0Q29va2llJylcblxuICBicmFuZENoZWNrcyhoZWFkZXJzKVxuXG4gIGNvb2tpZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNvb2tpZShjb29raWUpXG5cbiAgY29uc3Qgc3RyID0gc3RyaW5naWZ5KGNvb2tpZSlcblxuICBpZiAoc3RyKSB7XG4gICAgaGVhZGVycy5hcHBlbmQoJ3NldC1jb29raWUnLCBzdHIsIHRydWUpXG4gIH1cbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuRGVsZXRlQ29va2llQXR0cmlidXRlcyA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyksXG4gICAga2V5OiAncGF0aCcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcpLFxuICAgIGtleTogJ2RvbWFpbicsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkNvb2tpZSA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGtleTogJ25hbWUnXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBrZXk6ICd2YWx1ZSdcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nIGxvbmcnXSh2YWx1ZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKVxuICAgIH0pLFxuICAgIGtleTogJ2V4cGlyZXMnLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnNbJ2xvbmcgbG9uZyddKSxcbiAgICBrZXk6ICdtYXhBZ2UnLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICdkb21haW4nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICdwYXRoJyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4pLFxuICAgIGtleTogJ3NlY3VyZScsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ib29sZWFuKSxcbiAgICBrZXk6ICdodHRwT25seScsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyxcbiAgICBrZXk6ICdzYW1lU2l0ZScsXG4gICAgYWxsb3dlZFZhbHVlczogWydTdHJpY3QnLCAnTGF4JywgJ05vbmUnXVxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICd1bnBhcnNlZCcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBuZXcgQXJyYXkoMClcbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvb2tpZXMsXG4gIGRlbGV0ZUNvb2tpZSxcbiAgZ2V0U2V0Q29va2llcyxcbiAgc2V0Q29va2llLFxuICBwYXJzZUNvb2tpZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cookies/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cookies/parse.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/parse.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { maxNameValuePairSize, maxAttributeValueSize } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/cookies/constants.js\")\nconst { isCTLExcludingHtab } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/cookies/util.js\")\nconst { collectASequenceOfCodePointsFast } = __webpack_require__(/*! ../fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { unescape } = __webpack_require__(/*! node:querystring */ \"node:querystring\")\n\n/**\n * @description Parses the field-value attributes of a set-cookie header string.\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} header\n * @returns {import('./index').Cookie|null} if the header is invalid, null will be returned\n */\nfunction parseSetCookie (header) {\n  // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F\n  //    character (CTL characters excluding HTAB): Abort these steps and\n  //    ignore the set-cookie-string entirely.\n  if (isCTLExcludingHtab(header)) {\n    return null\n  }\n\n  let nameValuePair = ''\n  let unparsedAttributes = ''\n  let name = ''\n  let value = ''\n\n  // 2. If the set-cookie-string contains a %x3B (\";\") character:\n  if (header.includes(';')) {\n    // 1. The name-value-pair string consists of the characters up to,\n    //    but not including, the first %x3B (\";\"), and the unparsed-\n    //    attributes consist of the remainder of the set-cookie-string\n    //    (including the %x3B (\";\") in question).\n    const position = { position: 0 }\n\n    nameValuePair = collectASequenceOfCodePointsFast(';', header, position)\n    unparsedAttributes = header.slice(position.position)\n  } else {\n    // Otherwise:\n\n    // 1. The name-value-pair string consists of all the characters\n    //    contained in the set-cookie-string, and the unparsed-\n    //    attributes is the empty string.\n    nameValuePair = header\n  }\n\n  // 3. If the name-value-pair string lacks a %x3D (\"=\") character, then\n  //    the name string is empty, and the value string is the value of\n  //    name-value-pair.\n  if (!nameValuePair.includes('=')) {\n    value = nameValuePair\n  } else {\n    //    Otherwise, the name string consists of the characters up to, but\n    //    not including, the first %x3D (\"=\") character, and the (possibly\n    //    empty) value string consists of the characters after the first\n    //    %x3D (\"=\") character.\n    const position = { position: 0 }\n    name = collectASequenceOfCodePointsFast(\n      '=',\n      nameValuePair,\n      position\n    )\n    value = nameValuePair.slice(position.position + 1)\n  }\n\n  // 4. Remove any leading or trailing WSP characters from the name\n  //    string and the value string.\n  name = name.trim()\n  value = value.trim()\n\n  // 5. If the sum of the lengths of the name string and the value string\n  //    is more than 4096 octets, abort these steps and ignore the set-\n  //    cookie-string entirely.\n  if (name.length + value.length > maxNameValuePairSize) {\n    return null\n  }\n\n  // 6. The cookie-name is the name string, and the cookie-value is the\n  //    value string.\n  // https://datatracker.ietf.org/doc/html/rfc6265\n  // To maximize compatibility with user agents, servers that wish to\n  // store arbitrary data in a cookie-value SHOULD encode that data, for\n  // example, using Base64 [RFC4648].\n  return {\n    name, value: unescape(value), ...parseUnparsedAttributes(unparsedAttributes)\n  }\n}\n\n/**\n * Parses the remaining attributes of a set-cookie header\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} unparsedAttributes\n * @param {Object.<string, unknown>} [cookieAttributeList={}]\n */\nfunction parseUnparsedAttributes (unparsedAttributes, cookieAttributeList = {}) {\n  // 1. If the unparsed-attributes string is empty, skip the rest of\n  //    these steps.\n  if (unparsedAttributes.length === 0) {\n    return cookieAttributeList\n  }\n\n  // 2. Discard the first character of the unparsed-attributes (which\n  //    will be a %x3B (\";\") character).\n  assert(unparsedAttributes[0] === ';')\n  unparsedAttributes = unparsedAttributes.slice(1)\n\n  let cookieAv = ''\n\n  // 3. If the remaining unparsed-attributes contains a %x3B (\";\")\n  //    character:\n  if (unparsedAttributes.includes(';')) {\n    // 1. Consume the characters of the unparsed-attributes up to, but\n    //    not including, the first %x3B (\";\") character.\n    cookieAv = collectASequenceOfCodePointsFast(\n      ';',\n      unparsedAttributes,\n      { position: 0 }\n    )\n    unparsedAttributes = unparsedAttributes.slice(cookieAv.length)\n  } else {\n    // Otherwise:\n\n    // 1. Consume the remainder of the unparsed-attributes.\n    cookieAv = unparsedAttributes\n    unparsedAttributes = ''\n  }\n\n  // Let the cookie-av string be the characters consumed in this step.\n\n  let attributeName = ''\n  let attributeValue = ''\n\n  // 4. If the cookie-av string contains a %x3D (\"=\") character:\n  if (cookieAv.includes('=')) {\n    // 1. The (possibly empty) attribute-name string consists of the\n    //    characters up to, but not including, the first %x3D (\"=\")\n    //    character, and the (possibly empty) attribute-value string\n    //    consists of the characters after the first %x3D (\"=\")\n    //    character.\n    const position = { position: 0 }\n\n    attributeName = collectASequenceOfCodePointsFast(\n      '=',\n      cookieAv,\n      position\n    )\n    attributeValue = cookieAv.slice(position.position + 1)\n  } else {\n    // Otherwise:\n\n    // 1. The attribute-name string consists of the entire cookie-av\n    //    string, and the attribute-value string is empty.\n    attributeName = cookieAv\n  }\n\n  // 5. Remove any leading or trailing WSP characters from the attribute-\n  //    name string and the attribute-value string.\n  attributeName = attributeName.trim()\n  attributeValue = attributeValue.trim()\n\n  // 6. If the attribute-value is longer than 1024 octets, ignore the\n  //    cookie-av string and return to Step 1 of this algorithm.\n  if (attributeValue.length > maxAttributeValueSize) {\n    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n  }\n\n  // 7. Process the attribute-name and attribute-value according to the\n  //    requirements in the following subsections.  (Notice that\n  //    attributes with unrecognized attribute-names are ignored.)\n  const attributeNameLowercase = attributeName.toLowerCase()\n\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1\n  // If the attribute-name case-insensitively matches the string\n  // \"Expires\", the user agent MUST process the cookie-av as follows.\n  if (attributeNameLowercase === 'expires') {\n    // 1. Let the expiry-time be the result of parsing the attribute-value\n    //    as cookie-date (see Section 5.1.1).\n    const expiryTime = new Date(attributeValue)\n\n    // 2. If the attribute-value failed to parse as a cookie date, ignore\n    //    the cookie-av.\n\n    cookieAttributeList.expires = expiryTime\n  } else if (attributeNameLowercase === 'max-age') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2\n    // If the attribute-name case-insensitively matches the string \"Max-\n    // Age\", the user agent MUST process the cookie-av as follows.\n\n    // 1. If the first character of the attribute-value is not a DIGIT or a\n    //    \"-\" character, ignore the cookie-av.\n    const charCode = attributeValue.charCodeAt(0)\n\n    if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 2. If the remainder of attribute-value contains a non-DIGIT\n    //    character, ignore the cookie-av.\n    if (!/^\\d+$/.test(attributeValue)) {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 3. Let delta-seconds be the attribute-value converted to an integer.\n    const deltaSeconds = Number(attributeValue)\n\n    // 4. Let cookie-age-limit be the maximum age of the cookie (which\n    //    SHOULD be 400 days or less, see Section 4.1.2.2).\n\n    // 5. Set delta-seconds to the smaller of its present value and cookie-\n    //    age-limit.\n    // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)\n\n    // 6. If delta-seconds is less than or equal to zero (0), let expiry-\n    //    time be the earliest representable date and time.  Otherwise, let\n    //    the expiry-time be the current date and time plus delta-seconds\n    //    seconds.\n    // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds\n\n    // 7. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Max-Age and an attribute-value of expiry-time.\n    cookieAttributeList.maxAge = deltaSeconds\n  } else if (attributeNameLowercase === 'domain') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3\n    // If the attribute-name case-insensitively matches the string \"Domain\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. Let cookie-domain be the attribute-value.\n    let cookieDomain = attributeValue\n\n    // 2. If cookie-domain starts with %x2E (\".\"), let cookie-domain be\n    //    cookie-domain without its leading %x2E (\".\").\n    if (cookieDomain[0] === '.') {\n      cookieDomain = cookieDomain.slice(1)\n    }\n\n    // 3. Convert the cookie-domain to lower case.\n    cookieDomain = cookieDomain.toLowerCase()\n\n    // 4. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Domain and an attribute-value of cookie-domain.\n    cookieAttributeList.domain = cookieDomain\n  } else if (attributeNameLowercase === 'path') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4\n    // If the attribute-name case-insensitively matches the string \"Path\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. If the attribute-value is empty or if the first character of the\n    //    attribute-value is not %x2F (\"/\"):\n    let cookiePath = ''\n    if (attributeValue.length === 0 || attributeValue[0] !== '/') {\n      // 1. Let cookie-path be the default-path.\n      cookiePath = '/'\n    } else {\n      // Otherwise:\n\n      // 1. Let cookie-path be the attribute-value.\n      cookiePath = attributeValue\n    }\n\n    // 2. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Path and an attribute-value of cookie-path.\n    cookieAttributeList.path = cookiePath\n  } else if (attributeNameLowercase === 'secure') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5\n    // If the attribute-name case-insensitively matches the string \"Secure\",\n    // the user agent MUST append an attribute to the cookie-attribute-list\n    // with an attribute-name of Secure and an empty attribute-value.\n\n    cookieAttributeList.secure = true\n  } else if (attributeNameLowercase === 'httponly') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6\n    // If the attribute-name case-insensitively matches the string\n    // \"HttpOnly\", the user agent MUST append an attribute to the cookie-\n    // attribute-list with an attribute-name of HttpOnly and an empty\n    // attribute-value.\n\n    cookieAttributeList.httpOnly = true\n  } else if (attributeNameLowercase === 'samesite') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7\n    // If the attribute-name case-insensitively matches the string\n    // \"SameSite\", the user agent MUST process the cookie-av as follows:\n\n    // 1. Let enforcement be \"Default\".\n    let enforcement = 'Default'\n\n    const attributeValueLowercase = attributeValue.toLowerCase()\n    // 2. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"None\", set enforcement to \"None\".\n    if (attributeValueLowercase.includes('none')) {\n      enforcement = 'None'\n    }\n\n    // 3. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Strict\", set enforcement to \"Strict\".\n    if (attributeValueLowercase.includes('strict')) {\n      enforcement = 'Strict'\n    }\n\n    // 4. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Lax\", set enforcement to \"Lax\".\n    if (attributeValueLowercase.includes('lax')) {\n      enforcement = 'Lax'\n    }\n\n    // 5. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of \"SameSite\" and an attribute-value of\n    //    enforcement.\n    cookieAttributeList.sameSite = enforcement\n  } else {\n    cookieAttributeList.unparsed ??= []\n\n    cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`)\n  }\n\n  // 8. Return to Step 1 of this algorithm.\n  return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n}\n\nmodule.exports = {\n  parseSetCookie,\n  parseUnparsedAttributes\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9wYXJzZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLDhDQUE4QyxFQUFFLG1CQUFPLENBQUMsNkVBQWE7QUFDN0UsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLG1FQUFRO0FBQy9DLFFBQVEsbUNBQW1DLEVBQUUsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDeEUsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsMENBQWtCOztBQUUvQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQsd0JBQXdCO0FBQ3hCO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsaUNBQWlDO0FBQ2pDLHVCQUF1Qjs7QUFFdkIsdURBQXVEO0FBQ3ZEO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsMEJBQTBCLHVCQUF1QjtBQUM1RDtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCLHFDQUFxQztBQUNyQzs7QUFFQTs7QUFFQSxnRUFBZ0U7QUFDaEU7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEseUNBQXlDLGNBQWMsR0FBRyxlQUFlO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9wYXJzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBtYXhOYW1lVmFsdWVQYWlyU2l6ZSwgbWF4QXR0cmlidXRlVmFsdWVTaXplIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGlzQ1RMRXhjbHVkaW5nSHRhYiB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGEtdXJsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgdW5lc2NhcGUgfSA9IHJlcXVpcmUoJ25vZGU6cXVlcnlzdHJpbmcnKVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBQYXJzZXMgdGhlIGZpZWxkLXZhbHVlIGF0dHJpYnV0ZXMgb2YgYSBzZXQtY29va2llIGhlYWRlciBzdHJpbmcuXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjRcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkZXJcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW5kZXgnKS5Db29raWV8bnVsbH0gaWYgdGhlIGhlYWRlciBpcyBpbnZhbGlkLCBudWxsIHdpbGwgYmUgcmV0dXJuZWRcbiAqL1xuZnVuY3Rpb24gcGFyc2VTZXRDb29raWUgKGhlYWRlcikge1xuICAvLyAxLiBJZiB0aGUgc2V0LWNvb2tpZS1zdHJpbmcgY29udGFpbnMgYSAleDAwLTA4IC8gJXgwQS0xRiAvICV4N0ZcbiAgLy8gICAgY2hhcmFjdGVyIChDVEwgY2hhcmFjdGVycyBleGNsdWRpbmcgSFRBQik6IEFib3J0IHRoZXNlIHN0ZXBzIGFuZFxuICAvLyAgICBpZ25vcmUgdGhlIHNldC1jb29raWUtc3RyaW5nIGVudGlyZWx5LlxuICBpZiAoaXNDVExFeGNsdWRpbmdIdGFiKGhlYWRlcikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IG5hbWVWYWx1ZVBhaXIgPSAnJ1xuICBsZXQgdW5wYXJzZWRBdHRyaWJ1dGVzID0gJydcbiAgbGV0IG5hbWUgPSAnJ1xuICBsZXQgdmFsdWUgPSAnJ1xuXG4gIC8vIDIuIElmIHRoZSBzZXQtY29va2llLXN0cmluZyBjb250YWlucyBhICV4M0IgKFwiO1wiKSBjaGFyYWN0ZXI6XG4gIGlmIChoZWFkZXIuaW5jbHVkZXMoJzsnKSkge1xuICAgIC8vIDEuIFRoZSBuYW1lLXZhbHVlLXBhaXIgc3RyaW5nIGNvbnNpc3RzIG9mIHRoZSBjaGFyYWN0ZXJzIHVwIHRvLFxuICAgIC8vICAgIGJ1dCBub3QgaW5jbHVkaW5nLCB0aGUgZmlyc3QgJXgzQiAoXCI7XCIpLCBhbmQgdGhlIHVucGFyc2VkLVxuICAgIC8vICAgIGF0dHJpYnV0ZXMgY29uc2lzdCBvZiB0aGUgcmVtYWluZGVyIG9mIHRoZSBzZXQtY29va2llLXN0cmluZ1xuICAgIC8vICAgIChpbmNsdWRpbmcgdGhlICV4M0IgKFwiO1wiKSBpbiBxdWVzdGlvbikuXG4gICAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAgIG5hbWVWYWx1ZVBhaXIgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCgnOycsIGhlYWRlciwgcG9zaXRpb24pXG4gICAgdW5wYXJzZWRBdHRyaWJ1dGVzID0gaGVhZGVyLnNsaWNlKHBvc2l0aW9uLnBvc2l0aW9uKVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIFRoZSBuYW1lLXZhbHVlLXBhaXIgc3RyaW5nIGNvbnNpc3RzIG9mIGFsbCB0aGUgY2hhcmFjdGVyc1xuICAgIC8vICAgIGNvbnRhaW5lZCBpbiB0aGUgc2V0LWNvb2tpZS1zdHJpbmcsIGFuZCB0aGUgdW5wYXJzZWQtXG4gICAgLy8gICAgYXR0cmlidXRlcyBpcyB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIG5hbWVWYWx1ZVBhaXIgPSBoZWFkZXJcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBuYW1lLXZhbHVlLXBhaXIgc3RyaW5nIGxhY2tzIGEgJXgzRCAoXCI9XCIpIGNoYXJhY3RlciwgdGhlblxuICAvLyAgICB0aGUgbmFtZSBzdHJpbmcgaXMgZW1wdHksIGFuZCB0aGUgdmFsdWUgc3RyaW5nIGlzIHRoZSB2YWx1ZSBvZlxuICAvLyAgICBuYW1lLXZhbHVlLXBhaXIuXG4gIGlmICghbmFtZVZhbHVlUGFpci5pbmNsdWRlcygnPScpKSB7XG4gICAgdmFsdWUgPSBuYW1lVmFsdWVQYWlyXG4gIH0gZWxzZSB7XG4gICAgLy8gICAgT3RoZXJ3aXNlLCB0aGUgbmFtZSBzdHJpbmcgY29uc2lzdHMgb2YgdGhlIGNoYXJhY3RlcnMgdXAgdG8sIGJ1dFxuICAgIC8vICAgIG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNEIChcIj1cIikgY2hhcmFjdGVyLCBhbmQgdGhlIChwb3NzaWJseVxuICAgIC8vICAgIGVtcHR5KSB2YWx1ZSBzdHJpbmcgY29uc2lzdHMgb2YgdGhlIGNoYXJhY3RlcnMgYWZ0ZXIgdGhlIGZpcnN0XG4gICAgLy8gICAgJXgzRCAoXCI9XCIpIGNoYXJhY3Rlci5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuICAgIG5hbWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICc9JyxcbiAgICAgIG5hbWVWYWx1ZVBhaXIsXG4gICAgICBwb3NpdGlvblxuICAgIClcbiAgICB2YWx1ZSA9IG5hbWVWYWx1ZVBhaXIuc2xpY2UocG9zaXRpb24ucG9zaXRpb24gKyAxKVxuICB9XG5cbiAgLy8gNC4gUmVtb3ZlIGFueSBsZWFkaW5nIG9yIHRyYWlsaW5nIFdTUCBjaGFyYWN0ZXJzIGZyb20gdGhlIG5hbWVcbiAgLy8gICAgc3RyaW5nIGFuZCB0aGUgdmFsdWUgc3RyaW5nLlxuICBuYW1lID0gbmFtZS50cmltKClcbiAgdmFsdWUgPSB2YWx1ZS50cmltKClcblxuICAvLyA1LiBJZiB0aGUgc3VtIG9mIHRoZSBsZW5ndGhzIG9mIHRoZSBuYW1lIHN0cmluZyBhbmQgdGhlIHZhbHVlIHN0cmluZ1xuICAvLyAgICBpcyBtb3JlIHRoYW4gNDA5NiBvY3RldHMsIGFib3J0IHRoZXNlIHN0ZXBzIGFuZCBpZ25vcmUgdGhlIHNldC1cbiAgLy8gICAgY29va2llLXN0cmluZyBlbnRpcmVseS5cbiAgaWYgKG5hbWUubGVuZ3RoICsgdmFsdWUubGVuZ3RoID4gbWF4TmFtZVZhbHVlUGFpclNpemUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gNi4gVGhlIGNvb2tpZS1uYW1lIGlzIHRoZSBuYW1lIHN0cmluZywgYW5kIHRoZSBjb29raWUtdmFsdWUgaXMgdGhlXG4gIC8vICAgIHZhbHVlIHN0cmluZy5cbiAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2MjY1XG4gIC8vIFRvIG1heGltaXplIGNvbXBhdGliaWxpdHkgd2l0aCB1c2VyIGFnZW50cywgc2VydmVycyB0aGF0IHdpc2ggdG9cbiAgLy8gc3RvcmUgYXJiaXRyYXJ5IGRhdGEgaW4gYSBjb29raWUtdmFsdWUgU0hPVUxEIGVuY29kZSB0aGF0IGRhdGEsIGZvclxuICAvLyBleGFtcGxlLCB1c2luZyBCYXNlNjQgW1JGQzQ2NDhdLlxuICByZXR1cm4ge1xuICAgIG5hbWUsIHZhbHVlOiB1bmVzY2FwZSh2YWx1ZSksIC4uLnBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzKHVucGFyc2VkQXR0cmlidXRlcylcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgcmVtYWluaW5nIGF0dHJpYnV0ZXMgb2YgYSBzZXQtY29va2llIGhlYWRlclxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40XG4gKiBAcGFyYW0ge3N0cmluZ30gdW5wYXJzZWRBdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCB1bmtub3duPn0gW2Nvb2tpZUF0dHJpYnV0ZUxpc3Q9e31dXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzICh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QgPSB7fSkge1xuICAvLyAxLiBJZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcyBzdHJpbmcgaXMgZW1wdHksIHNraXAgdGhlIHJlc3Qgb2ZcbiAgLy8gICAgdGhlc2Ugc3RlcHMuXG4gIGlmICh1bnBhcnNlZEF0dHJpYnV0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNvb2tpZUF0dHJpYnV0ZUxpc3RcbiAgfVxuXG4gIC8vIDIuIERpc2NhcmQgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcyAod2hpY2hcbiAgLy8gICAgd2lsbCBiZSBhICV4M0IgKFwiO1wiKSBjaGFyYWN0ZXIpLlxuICBhc3NlcnQodW5wYXJzZWRBdHRyaWJ1dGVzWzBdID09PSAnOycpXG4gIHVucGFyc2VkQXR0cmlidXRlcyA9IHVucGFyc2VkQXR0cmlidXRlcy5zbGljZSgxKVxuXG4gIGxldCBjb29raWVBdiA9ICcnXG5cbiAgLy8gMy4gSWYgdGhlIHJlbWFpbmluZyB1bnBhcnNlZC1hdHRyaWJ1dGVzIGNvbnRhaW5zIGEgJXgzQiAoXCI7XCIpXG4gIC8vICAgIGNoYXJhY3RlcjpcbiAgaWYgKHVucGFyc2VkQXR0cmlidXRlcy5pbmNsdWRlcygnOycpKSB7XG4gICAgLy8gMS4gQ29uc3VtZSB0aGUgY2hhcmFjdGVycyBvZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcyB1cCB0bywgYnV0XG4gICAgLy8gICAgbm90IGluY2x1ZGluZywgdGhlIGZpcnN0ICV4M0IgKFwiO1wiKSBjaGFyYWN0ZXIuXG4gICAgY29va2llQXYgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICc7JyxcbiAgICAgIHVucGFyc2VkQXR0cmlidXRlcyxcbiAgICAgIHsgcG9zaXRpb246IDAgfVxuICAgIClcbiAgICB1bnBhcnNlZEF0dHJpYnV0ZXMgPSB1bnBhcnNlZEF0dHJpYnV0ZXMuc2xpY2UoY29va2llQXYubGVuZ3RoKVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIENvbnN1bWUgdGhlIHJlbWFpbmRlciBvZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcy5cbiAgICBjb29raWVBdiA9IHVucGFyc2VkQXR0cmlidXRlc1xuICAgIHVucGFyc2VkQXR0cmlidXRlcyA9ICcnXG4gIH1cblxuICAvLyBMZXQgdGhlIGNvb2tpZS1hdiBzdHJpbmcgYmUgdGhlIGNoYXJhY3RlcnMgY29uc3VtZWQgaW4gdGhpcyBzdGVwLlxuXG4gIGxldCBhdHRyaWJ1dGVOYW1lID0gJydcbiAgbGV0IGF0dHJpYnV0ZVZhbHVlID0gJydcblxuICAvLyA0LiBJZiB0aGUgY29va2llLWF2IHN0cmluZyBjb250YWlucyBhICV4M0QgKFwiPVwiKSBjaGFyYWN0ZXI6XG4gIGlmIChjb29raWVBdi5pbmNsdWRlcygnPScpKSB7XG4gICAgLy8gMS4gVGhlIChwb3NzaWJseSBlbXB0eSkgYXR0cmlidXRlLW5hbWUgc3RyaW5nIGNvbnNpc3RzIG9mIHRoZVxuICAgIC8vICAgIGNoYXJhY3RlcnMgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCB0aGUgZmlyc3QgJXgzRCAoXCI9XCIpXG4gICAgLy8gICAgY2hhcmFjdGVyLCBhbmQgdGhlIChwb3NzaWJseSBlbXB0eSkgYXR0cmlidXRlLXZhbHVlIHN0cmluZ1xuICAgIC8vICAgIGNvbnNpc3RzIG9mIHRoZSBjaGFyYWN0ZXJzIGFmdGVyIHRoZSBmaXJzdCAleDNEIChcIj1cIilcbiAgICAvLyAgICBjaGFyYWN0ZXIuXG4gICAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAgIGF0dHJpYnV0ZU5hbWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICc9JyxcbiAgICAgIGNvb2tpZUF2LFxuICAgICAgcG9zaXRpb25cbiAgICApXG4gICAgYXR0cmlidXRlVmFsdWUgPSBjb29raWVBdi5zbGljZShwb3NpdGlvbi5wb3NpdGlvbiArIDEpXG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gVGhlIGF0dHJpYnV0ZS1uYW1lIHN0cmluZyBjb25zaXN0cyBvZiB0aGUgZW50aXJlIGNvb2tpZS1hdlxuICAgIC8vICAgIHN0cmluZywgYW5kIHRoZSBhdHRyaWJ1dGUtdmFsdWUgc3RyaW5nIGlzIGVtcHR5LlxuICAgIGF0dHJpYnV0ZU5hbWUgPSBjb29raWVBdlxuICB9XG5cbiAgLy8gNS4gUmVtb3ZlIGFueSBsZWFkaW5nIG9yIHRyYWlsaW5nIFdTUCBjaGFyYWN0ZXJzIGZyb20gdGhlIGF0dHJpYnV0ZS1cbiAgLy8gICAgbmFtZSBzdHJpbmcgYW5kIHRoZSBhdHRyaWJ1dGUtdmFsdWUgc3RyaW5nLlxuICBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZS50cmltKClcbiAgYXR0cmlidXRlVmFsdWUgPSBhdHRyaWJ1dGVWYWx1ZS50cmltKClcblxuICAvLyA2LiBJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIGxvbmdlciB0aGFuIDEwMjQgb2N0ZXRzLCBpZ25vcmUgdGhlXG4gIC8vICAgIGNvb2tpZS1hdiBzdHJpbmcgYW5kIHJldHVybiB0byBTdGVwIDEgb2YgdGhpcyBhbGdvcml0aG0uXG4gIGlmIChhdHRyaWJ1dGVWYWx1ZS5sZW5ndGggPiBtYXhBdHRyaWJ1dGVWYWx1ZVNpemUpIHtcbiAgICByZXR1cm4gcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXModW5wYXJzZWRBdHRyaWJ1dGVzLCBjb29raWVBdHRyaWJ1dGVMaXN0KVxuICB9XG5cbiAgLy8gNy4gUHJvY2VzcyB0aGUgYXR0cmlidXRlLW5hbWUgYW5kIGF0dHJpYnV0ZS12YWx1ZSBhY2NvcmRpbmcgdG8gdGhlXG4gIC8vICAgIHJlcXVpcmVtZW50cyBpbiB0aGUgZm9sbG93aW5nIHN1YnNlY3Rpb25zLiAgKE5vdGljZSB0aGF0XG4gIC8vICAgIGF0dHJpYnV0ZXMgd2l0aCB1bnJlY29nbml6ZWQgYXR0cmlidXRlLW5hbWVzIGFyZSBpZ25vcmVkLilcbiAgY29uc3QgYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKVxuXG4gIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuMVxuICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZ1xuICAvLyBcIkV4cGlyZXNcIiwgdGhlIHVzZXIgYWdlbnQgTVVTVCBwcm9jZXNzIHRoZSBjb29raWUtYXYgYXMgZm9sbG93cy5cbiAgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdleHBpcmVzJykge1xuICAgIC8vIDEuIExldCB0aGUgZXhwaXJ5LXRpbWUgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHRoZSBhdHRyaWJ1dGUtdmFsdWVcbiAgICAvLyAgICBhcyBjb29raWUtZGF0ZSAoc2VlIFNlY3Rpb24gNS4xLjEpLlxuICAgIGNvbnN0IGV4cGlyeVRpbWUgPSBuZXcgRGF0ZShhdHRyaWJ1dGVWYWx1ZSlcblxuICAgIC8vIDIuIElmIHRoZSBhdHRyaWJ1dGUtdmFsdWUgZmFpbGVkIHRvIHBhcnNlIGFzIGEgY29va2llIGRhdGUsIGlnbm9yZVxuICAgIC8vICAgIHRoZSBjb29raWUtYXYuXG5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LmV4cGlyZXMgPSBleHBpcnlUaW1lXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ21heC1hZ2UnKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC4yXG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmcgXCJNYXgtXG4gICAgLy8gQWdlXCIsIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3MuXG5cbiAgICAvLyAxLiBJZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBhdHRyaWJ1dGUtdmFsdWUgaXMgbm90IGEgRElHSVQgb3IgYVxuICAgIC8vICAgIFwiLVwiIGNoYXJhY3RlciwgaWdub3JlIHRoZSBjb29raWUtYXYuXG4gICAgY29uc3QgY2hhckNvZGUgPSBhdHRyaWJ1dGVWYWx1ZS5jaGFyQ29kZUF0KDApXG5cbiAgICBpZiAoKGNoYXJDb2RlIDwgNDggfHwgY2hhckNvZGUgPiA1NykgJiYgYXR0cmlidXRlVmFsdWVbMF0gIT09ICctJykge1xuICAgICAgcmV0dXJuIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzKHVucGFyc2VkQXR0cmlidXRlcywgY29va2llQXR0cmlidXRlTGlzdClcbiAgICB9XG5cbiAgICAvLyAyLiBJZiB0aGUgcmVtYWluZGVyIG9mIGF0dHJpYnV0ZS12YWx1ZSBjb250YWlucyBhIG5vbi1ESUdJVFxuICAgIC8vICAgIGNoYXJhY3RlciwgaWdub3JlIHRoZSBjb29raWUtYXYuXG4gICAgaWYgKCEvXlxcZCskLy50ZXN0KGF0dHJpYnV0ZVZhbHVlKSkge1xuICAgICAgcmV0dXJuIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzKHVucGFyc2VkQXR0cmlidXRlcywgY29va2llQXR0cmlidXRlTGlzdClcbiAgICB9XG5cbiAgICAvLyAzLiBMZXQgZGVsdGEtc2Vjb25kcyBiZSB0aGUgYXR0cmlidXRlLXZhbHVlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyLlxuICAgIGNvbnN0IGRlbHRhU2Vjb25kcyA9IE51bWJlcihhdHRyaWJ1dGVWYWx1ZSlcblxuICAgIC8vIDQuIExldCBjb29raWUtYWdlLWxpbWl0IGJlIHRoZSBtYXhpbXVtIGFnZSBvZiB0aGUgY29va2llICh3aGljaFxuICAgIC8vICAgIFNIT1VMRCBiZSA0MDAgZGF5cyBvciBsZXNzLCBzZWUgU2VjdGlvbiA0LjEuMi4yKS5cblxuICAgIC8vIDUuIFNldCBkZWx0YS1zZWNvbmRzIHRvIHRoZSBzbWFsbGVyIG9mIGl0cyBwcmVzZW50IHZhbHVlIGFuZCBjb29raWUtXG4gICAgLy8gICAgYWdlLWxpbWl0LlxuICAgIC8vIGRlbHRhU2Vjb25kcyA9IE1hdGgubWluKGRlbHRhU2Vjb25kcyAqIDEwMDAsIG1heEV4cGlyZXNNcylcblxuICAgIC8vIDYuIElmIGRlbHRhLXNlY29uZHMgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHplcm8gKDApLCBsZXQgZXhwaXJ5LVxuICAgIC8vICAgIHRpbWUgYmUgdGhlIGVhcmxpZXN0IHJlcHJlc2VudGFibGUgZGF0ZSBhbmQgdGltZS4gIE90aGVyd2lzZSwgbGV0XG4gICAgLy8gICAgdGhlIGV4cGlyeS10aW1lIGJlIHRoZSBjdXJyZW50IGRhdGUgYW5kIHRpbWUgcGx1cyBkZWx0YS1zZWNvbmRzXG4gICAgLy8gICAgc2Vjb25kcy5cbiAgICAvLyBjb25zdCBleHBpcnlUaW1lID0gZGVsdGFTZWNvbmRzIDw9IDAgPyBEYXRlLm5vdygpIDogRGF0ZS5ub3coKSArIGRlbHRhU2Vjb25kc1xuXG4gICAgLy8gNy4gQXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0IHdpdGggYW5cbiAgICAvLyAgICBhdHRyaWJ1dGUtbmFtZSBvZiBNYXgtQWdlIGFuZCBhbiBhdHRyaWJ1dGUtdmFsdWUgb2YgZXhwaXJ5LXRpbWUuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5tYXhBZ2UgPSBkZWx0YVNlY29uZHNcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnZG9tYWluJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuM1xuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nIFwiRG9tYWluXCIsXG4gICAgLy8gdGhlIHVzZXIgYWdlbnQgTVVTVCBwcm9jZXNzIHRoZSBjb29raWUtYXYgYXMgZm9sbG93cy5cblxuICAgIC8vIDEuIExldCBjb29raWUtZG9tYWluIGJlIHRoZSBhdHRyaWJ1dGUtdmFsdWUuXG4gICAgbGV0IGNvb2tpZURvbWFpbiA9IGF0dHJpYnV0ZVZhbHVlXG5cbiAgICAvLyAyLiBJZiBjb29raWUtZG9tYWluIHN0YXJ0cyB3aXRoICV4MkUgKFwiLlwiKSwgbGV0IGNvb2tpZS1kb21haW4gYmVcbiAgICAvLyAgICBjb29raWUtZG9tYWluIHdpdGhvdXQgaXRzIGxlYWRpbmcgJXgyRSAoXCIuXCIpLlxuICAgIGlmIChjb29raWVEb21haW5bMF0gPT09ICcuJykge1xuICAgICAgY29va2llRG9tYWluID0gY29va2llRG9tYWluLnNsaWNlKDEpXG4gICAgfVxuXG4gICAgLy8gMy4gQ29udmVydCB0aGUgY29va2llLWRvbWFpbiB0byBsb3dlciBjYXNlLlxuICAgIGNvb2tpZURvbWFpbiA9IGNvb2tpZURvbWFpbi50b0xvd2VyQ2FzZSgpXG5cbiAgICAvLyA0LiBBcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3Qgd2l0aCBhblxuICAgIC8vICAgIGF0dHJpYnV0ZS1uYW1lIG9mIERvbWFpbiBhbmQgYW4gYXR0cmlidXRlLXZhbHVlIG9mIGNvb2tpZS1kb21haW4uXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5kb21haW4gPSBjb29raWVEb21haW5cbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAncGF0aCcpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjRcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZyBcIlBhdGhcIixcbiAgICAvLyB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzLlxuXG4gICAgLy8gMS4gSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBlbXB0eSBvciBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZVxuICAgIC8vICAgIGF0dHJpYnV0ZS12YWx1ZSBpcyBub3QgJXgyRiAoXCIvXCIpOlxuICAgIGxldCBjb29raWVQYXRoID0gJydcbiAgICBpZiAoYXR0cmlidXRlVmFsdWUubGVuZ3RoID09PSAwIHx8IGF0dHJpYnV0ZVZhbHVlWzBdICE9PSAnLycpIHtcbiAgICAgIC8vIDEuIExldCBjb29raWUtcGF0aCBiZSB0aGUgZGVmYXVsdC1wYXRoLlxuICAgICAgY29va2llUGF0aCA9ICcvJ1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2U6XG5cbiAgICAgIC8vIDEuIExldCBjb29raWUtcGF0aCBiZSB0aGUgYXR0cmlidXRlLXZhbHVlLlxuICAgICAgY29va2llUGF0aCA9IGF0dHJpYnV0ZVZhbHVlXG4gICAgfVxuXG4gICAgLy8gMi4gQXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0IHdpdGggYW5cbiAgICAvLyAgICBhdHRyaWJ1dGUtbmFtZSBvZiBQYXRoIGFuZCBhbiBhdHRyaWJ1dGUtdmFsdWUgb2YgY29va2llLXBhdGguXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5wYXRoID0gY29va2llUGF0aFxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdzZWN1cmUnKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC41XG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmcgXCJTZWN1cmVcIixcbiAgICAvLyB0aGUgdXNlciBhZ2VudCBNVVNUIGFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdFxuICAgIC8vIHdpdGggYW4gYXR0cmlidXRlLW5hbWUgb2YgU2VjdXJlIGFuZCBhbiBlbXB0eSBhdHRyaWJ1dGUtdmFsdWUuXG5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnNlY3VyZSA9IHRydWVcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnaHR0cG9ubHknKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC42XG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmdcbiAgICAvLyBcIkh0dHBPbmx5XCIsIHRoZSB1c2VyIGFnZW50IE1VU1QgYXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLVxuICAgIC8vIGF0dHJpYnV0ZS1saXN0IHdpdGggYW4gYXR0cmlidXRlLW5hbWUgb2YgSHR0cE9ubHkgYW5kIGFuIGVtcHR5XG4gICAgLy8gYXR0cmlidXRlLXZhbHVlLlxuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5odHRwT25seSA9IHRydWVcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnc2FtZXNpdGUnKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC43XG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmdcbiAgICAvLyBcIlNhbWVTaXRlXCIsIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3M6XG5cbiAgICAvLyAxLiBMZXQgZW5mb3JjZW1lbnQgYmUgXCJEZWZhdWx0XCIuXG4gICAgbGV0IGVuZm9yY2VtZW50ID0gJ0RlZmF1bHQnXG5cbiAgICBjb25zdCBhdHRyaWJ1dGVWYWx1ZUxvd2VyY2FzZSA9IGF0dHJpYnV0ZVZhbHVlLnRvTG93ZXJDYXNlKClcbiAgICAvLyAyLiBJZiBjb29raWUtYXYncyBhdHRyaWJ1dGUtdmFsdWUgaXMgYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvclxuICAgIC8vICAgIFwiTm9uZVwiLCBzZXQgZW5mb3JjZW1lbnQgdG8gXCJOb25lXCIuXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlTG93ZXJjYXNlLmluY2x1ZGVzKCdub25lJykpIHtcbiAgICAgIGVuZm9yY2VtZW50ID0gJ05vbmUnXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgY29va2llLWF2J3MgYXR0cmlidXRlLXZhbHVlIGlzIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3JcbiAgICAvLyAgICBcIlN0cmljdFwiLCBzZXQgZW5mb3JjZW1lbnQgdG8gXCJTdHJpY3RcIi5cbiAgICBpZiAoYXR0cmlidXRlVmFsdWVMb3dlcmNhc2UuaW5jbHVkZXMoJ3N0cmljdCcpKSB7XG4gICAgICBlbmZvcmNlbWVudCA9ICdTdHJpY3QnXG4gICAgfVxuXG4gICAgLy8gNC4gSWYgY29va2llLWF2J3MgYXR0cmlidXRlLXZhbHVlIGlzIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3JcbiAgICAvLyAgICBcIkxheFwiLCBzZXQgZW5mb3JjZW1lbnQgdG8gXCJMYXhcIi5cbiAgICBpZiAoYXR0cmlidXRlVmFsdWVMb3dlcmNhc2UuaW5jbHVkZXMoJ2xheCcpKSB7XG4gICAgICBlbmZvcmNlbWVudCA9ICdMYXgnXG4gICAgfVxuXG4gICAgLy8gNS4gQXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0IHdpdGggYW5cbiAgICAvLyAgICBhdHRyaWJ1dGUtbmFtZSBvZiBcIlNhbWVTaXRlXCIgYW5kIGFuIGF0dHJpYnV0ZS12YWx1ZSBvZlxuICAgIC8vICAgIGVuZm9yY2VtZW50LlxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3Quc2FtZVNpdGUgPSBlbmZvcmNlbWVudFxuICB9IGVsc2Uge1xuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QudW5wYXJzZWQgPz89IFtdXG5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnVucGFyc2VkLnB1c2goYCR7YXR0cmlidXRlTmFtZX09JHthdHRyaWJ1dGVWYWx1ZX1gKVxuICB9XG5cbiAgLy8gOC4gUmV0dXJuIHRvIFN0ZXAgMSBvZiB0aGlzIGFsZ29yaXRobS5cbiAgcmV0dXJuIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzKHVucGFyc2VkQXR0cmlidXRlcywgY29va2llQXR0cmlidXRlTGlzdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlU2V0Q29va2llLFxuICBwYXJzZVVucGFyc2VkQXR0cmlidXRlc1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cookies/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cookies/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/util.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nfunction isCTLExcludingHtab (value) {\n  for (let i = 0; i < value.length; ++i) {\n    const code = value.charCodeAt(i)\n\n    if (\n      (code >= 0x00 && code <= 0x08) ||\n      (code >= 0x0A && code <= 0x1F) ||\n      code === 0x7F\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n CHAR           = <any US-ASCII character (octets 0 - 127)>\n token          = 1*<any CHAR except CTLs or separators>\n separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                | \",\" | \";\" | \":\" | \"\\\" | <\">\n                | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                | \"{\" | \"}\" | SP | HT\n * @param {string} name\n */\nfunction validateCookieName (name) {\n  for (let i = 0; i < name.length; ++i) {\n    const code = name.charCodeAt(i)\n\n    if (\n      code < 0x21 || // exclude CTLs (0-31), SP and HT\n      code > 0x7E || // exclude non-ascii and DEL\n      code === 0x22 || // \"\n      code === 0x28 || // (\n      code === 0x29 || // )\n      code === 0x3C || // <\n      code === 0x3E || // >\n      code === 0x40 || // @\n      code === 0x2C || // ,\n      code === 0x3B || // ;\n      code === 0x3A || // :\n      code === 0x5C || // \\\n      code === 0x2F || // /\n      code === 0x5B || // [\n      code === 0x5D || // ]\n      code === 0x3F || // ?\n      code === 0x3D || // =\n      code === 0x7B || // {\n      code === 0x7D // }\n    ) {\n      throw new Error('Invalid cookie name')\n    }\n  }\n}\n\n/**\n cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n                       ; US-ASCII characters excluding CTLs,\n                       ; whitespace DQUOTE, comma, semicolon,\n                       ; and backslash\n * @param {string} value\n */\nfunction validateCookieValue (value) {\n  let len = value.length\n  let i = 0\n\n  // if the value is wrapped in DQUOTE\n  if (value[0] === '\"') {\n    if (len === 1 || value[len - 1] !== '\"') {\n      throw new Error('Invalid cookie value')\n    }\n    --len\n    ++i\n  }\n\n  while (i < len) {\n    const code = value.charCodeAt(i++)\n\n    if (\n      code < 0x21 || // exclude CTLs (0-31)\n      code > 0x7E || // non-ascii and DEL (127)\n      code === 0x22 || // \"\n      code === 0x2C || // ,\n      code === 0x3B || // ;\n      code === 0x5C // \\\n    ) {\n      throw new Error('Invalid cookie value')\n    }\n  }\n}\n\n/**\n * path-value        = <any CHAR except CTLs or \";\">\n * @param {string} path\n */\nfunction validateCookiePath (path) {\n  for (let i = 0; i < path.length; ++i) {\n    const code = path.charCodeAt(i)\n\n    if (\n      code < 0x20 || // exclude CTLs (0-31)\n      code === 0x7F || // DEL\n      code === 0x3B // ;\n    ) {\n      throw new Error('Invalid cookie path')\n    }\n  }\n}\n\n/**\n * I have no idea why these values aren't allowed to be honest,\n * but Deno tests these. - Khafra\n * @param {string} domain\n */\nfunction validateCookieDomain (domain) {\n  if (\n    domain.startsWith('-') ||\n    domain.endsWith('.') ||\n    domain.endsWith('-')\n  ) {\n    throw new Error('Invalid cookie domain')\n  }\n}\n\nconst IMFDays = [\n  'Sun', 'Mon', 'Tue', 'Wed',\n  'Thu', 'Fri', 'Sat'\n]\n\nconst IMFMonths = [\n  'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'\n]\n\nconst IMFPaddedNumbers = Array(61).fill(0).map((_, i) => i.toString().padStart(2, '0'))\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1\n * @param {number|Date} date\n  IMF-fixdate  = day-name \",\" SP date1 SP time-of-day SP GMT\n  ; fixed length/zone/capitalization subset of the format\n  ; see Section 3.3 of [RFC5322]\n\n  day-name     = %x4D.6F.6E ; \"Mon\", case-sensitive\n              / %x54.75.65 ; \"Tue\", case-sensitive\n              / %x57.65.64 ; \"Wed\", case-sensitive\n              / %x54.68.75 ; \"Thu\", case-sensitive\n              / %x46.72.69 ; \"Fri\", case-sensitive\n              / %x53.61.74 ; \"Sat\", case-sensitive\n              / %x53.75.6E ; \"Sun\", case-sensitive\n  date1        = day SP month SP year\n                  ; e.g., 02 Jun 1982\n\n  day          = 2DIGIT\n  month        = %x4A.61.6E ; \"Jan\", case-sensitive\n              / %x46.65.62 ; \"Feb\", case-sensitive\n              / %x4D.61.72 ; \"Mar\", case-sensitive\n              / %x41.70.72 ; \"Apr\", case-sensitive\n              / %x4D.61.79 ; \"May\", case-sensitive\n              / %x4A.75.6E ; \"Jun\", case-sensitive\n              / %x4A.75.6C ; \"Jul\", case-sensitive\n              / %x41.75.67 ; \"Aug\", case-sensitive\n              / %x53.65.70 ; \"Sep\", case-sensitive\n              / %x4F.63.74 ; \"Oct\", case-sensitive\n              / %x4E.6F.76 ; \"Nov\", case-sensitive\n              / %x44.65.63 ; \"Dec\", case-sensitive\n  year         = 4DIGIT\n\n  GMT          = %x47.4D.54 ; \"GMT\", case-sensitive\n\n  time-of-day  = hour \":\" minute \":\" second\n              ; 00:00:00 - 23:59:60 (leap second)\n\n  hour         = 2DIGIT\n  minute       = 2DIGIT\n  second       = 2DIGIT\n */\nfunction toIMFDate (date) {\n  if (typeof date === 'number') {\n    date = new Date(date)\n  }\n\n  return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`\n}\n\n/**\n max-age-av        = \"Max-Age=\" non-zero-digit *DIGIT\n                       ; In practice, both expires-av and max-age-av\n                       ; are limited to dates representable by the\n                       ; user agent.\n * @param {number} maxAge\n */\nfunction validateCookieMaxAge (maxAge) {\n  if (maxAge < 0) {\n    throw new Error('Invalid cookie max-age')\n  }\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1\n * @param {import('./index').Cookie} cookie\n */\nfunction stringify (cookie) {\n  if (cookie.name.length === 0) {\n    return null\n  }\n\n  validateCookieName(cookie.name)\n  validateCookieValue(cookie.value)\n\n  const out = [`${cookie.name}=${cookie.value}`]\n\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2\n  if (cookie.name.startsWith('__Secure-')) {\n    cookie.secure = true\n  }\n\n  if (cookie.name.startsWith('__Host-')) {\n    cookie.secure = true\n    cookie.domain = null\n    cookie.path = '/'\n  }\n\n  if (cookie.secure) {\n    out.push('Secure')\n  }\n\n  if (cookie.httpOnly) {\n    out.push('HttpOnly')\n  }\n\n  if (typeof cookie.maxAge === 'number') {\n    validateCookieMaxAge(cookie.maxAge)\n    out.push(`Max-Age=${cookie.maxAge}`)\n  }\n\n  if (cookie.domain) {\n    validateCookieDomain(cookie.domain)\n    out.push(`Domain=${cookie.domain}`)\n  }\n\n  if (cookie.path) {\n    validateCookiePath(cookie.path)\n    out.push(`Path=${cookie.path}`)\n  }\n\n  if (cookie.expires && cookie.expires.toString() !== 'Invalid Date') {\n    out.push(`Expires=${toIMFDate(cookie.expires)}`)\n  }\n\n  if (cookie.sameSite) {\n    out.push(`SameSite=${cookie.sameSite}`)\n  }\n\n  for (const part of cookie.unparsed) {\n    if (!part.includes('=')) {\n      throw new Error('Invalid unparsed')\n    }\n\n    const [key, ...value] = part.split('=')\n\n    out.push(`${key.trim()}=${value.join('=')}`)\n  }\n\n  return out.join('; ')\n}\n\nmodule.exports = {\n  isCTLExcludingHtab,\n  validateCookieName,\n  validateCookiePath,\n  validateCookieValue,\n  toIMFDate,\n  stringify\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLG9CQUFvQixNQUFNO0FBQzFCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRCxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsSUFBSTtBQUNKLElBQUk7O0FBRUosOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSwwQkFBMEIsSUFBSSxxQ0FBcUMsRUFBRSwrQkFBK0IsRUFBRSx1QkFBdUIsRUFBRSxxQ0FBcUMsR0FBRyx1Q0FBdUMsR0FBRyx3Q0FBd0M7QUFDclE7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWSxHQUFHLGFBQWE7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDOztBQUVBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDs7QUFFQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLFdBQVcsR0FBRyxnQkFBZ0I7QUFDOUM7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2Nvb2tpZXMvdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0NUTEV4Y2x1ZGluZ0h0YWIgKHZhbHVlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChpKVxuXG4gICAgaWYgKFxuICAgICAgKGNvZGUgPj0gMHgwMCAmJiBjb2RlIDw9IDB4MDgpIHx8XG4gICAgICAoY29kZSA+PSAweDBBICYmIGNvZGUgPD0gMHgxRikgfHxcbiAgICAgIGNvZGUgPT09IDB4N0ZcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiBDSEFSICAgICAgICAgICA9IDxhbnkgVVMtQVNDSUkgY2hhcmFjdGVyIChvY3RldHMgMCAtIDEyNyk+XG4gdG9rZW4gICAgICAgICAgPSAxKjxhbnkgQ0hBUiBleGNlcHQgQ1RMcyBvciBzZXBhcmF0b3JzPlxuIHNlcGFyYXRvcnMgICAgID0gXCIoXCIgfCBcIilcIiB8IFwiPFwiIHwgXCI+XCIgfCBcIkBcIlxuICAgICAgICAgICAgICAgIHwgXCIsXCIgfCBcIjtcIiB8IFwiOlwiIHwgXCJcXFwiIHwgPFwiPlxuICAgICAgICAgICAgICAgIHwgXCIvXCIgfCBcIltcIiB8IFwiXVwiIHwgXCI/XCIgfCBcIj1cIlxuICAgICAgICAgICAgICAgIHwgXCJ7XCIgfCBcIn1cIiB8IFNQIHwgSFRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ29va2llTmFtZSAobmFtZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb2RlID0gbmFtZS5jaGFyQ29kZUF0KGkpXG5cbiAgICBpZiAoXG4gICAgICBjb2RlIDwgMHgyMSB8fCAvLyBleGNsdWRlIENUTHMgKDAtMzEpLCBTUCBhbmQgSFRcbiAgICAgIGNvZGUgPiAweDdFIHx8IC8vIGV4Y2x1ZGUgbm9uLWFzY2lpIGFuZCBERUxcbiAgICAgIGNvZGUgPT09IDB4MjIgfHwgLy8gXCJcbiAgICAgIGNvZGUgPT09IDB4MjggfHwgLy8gKFxuICAgICAgY29kZSA9PT0gMHgyOSB8fCAvLyApXG4gICAgICBjb2RlID09PSAweDNDIHx8IC8vIDxcbiAgICAgIGNvZGUgPT09IDB4M0UgfHwgLy8gPlxuICAgICAgY29kZSA9PT0gMHg0MCB8fCAvLyBAXG4gICAgICBjb2RlID09PSAweDJDIHx8IC8vICxcbiAgICAgIGNvZGUgPT09IDB4M0IgfHwgLy8gO1xuICAgICAgY29kZSA9PT0gMHgzQSB8fCAvLyA6XG4gICAgICBjb2RlID09PSAweDVDIHx8IC8vIFxcXG4gICAgICBjb2RlID09PSAweDJGIHx8IC8vIC9cbiAgICAgIGNvZGUgPT09IDB4NUIgfHwgLy8gW1xuICAgICAgY29kZSA9PT0gMHg1RCB8fCAvLyBdXG4gICAgICBjb2RlID09PSAweDNGIHx8IC8vID9cbiAgICAgIGNvZGUgPT09IDB4M0QgfHwgLy8gPVxuICAgICAgY29kZSA9PT0gMHg3QiB8fCAvLyB7XG4gICAgICBjb2RlID09PSAweDdEIC8vIH1cbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgbmFtZScpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuIGNvb2tpZS12YWx1ZSAgICAgID0gKmNvb2tpZS1vY3RldCAvICggRFFVT1RFICpjb29raWUtb2N0ZXQgRFFVT1RFIClcbiBjb29raWUtb2N0ZXQgICAgICA9ICV4MjEgLyAleDIzLTJCIC8gJXgyRC0zQSAvICV4M0MtNUIgLyAleDVELTdFXG4gICAgICAgICAgICAgICAgICAgICAgIDsgVVMtQVNDSUkgY2hhcmFjdGVycyBleGNsdWRpbmcgQ1RMcyxcbiAgICAgICAgICAgICAgICAgICAgICAgOyB3aGl0ZXNwYWNlIERRVU9URSwgY29tbWEsIHNlbWljb2xvbixcbiAgICAgICAgICAgICAgICAgICAgICAgOyBhbmQgYmFja3NsYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVWYWx1ZSAodmFsdWUpIHtcbiAgbGV0IGxlbiA9IHZhbHVlLmxlbmd0aFxuICBsZXQgaSA9IDBcblxuICAvLyBpZiB0aGUgdmFsdWUgaXMgd3JhcHBlZCBpbiBEUVVPVEVcbiAgaWYgKHZhbHVlWzBdID09PSAnXCInKSB7XG4gICAgaWYgKGxlbiA9PT0gMSB8fCB2YWx1ZVtsZW4gLSAxXSAhPT0gJ1wiJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSB2YWx1ZScpXG4gICAgfVxuICAgIC0tbGVuXG4gICAgKytpXG4gIH1cblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGNvbnN0IGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGkrKylcblxuICAgIGlmIChcbiAgICAgIGNvZGUgPCAweDIxIHx8IC8vIGV4Y2x1ZGUgQ1RMcyAoMC0zMSlcbiAgICAgIGNvZGUgPiAweDdFIHx8IC8vIG5vbi1hc2NpaSBhbmQgREVMICgxMjcpXG4gICAgICBjb2RlID09PSAweDIyIHx8IC8vIFwiXG4gICAgICBjb2RlID09PSAweDJDIHx8IC8vICxcbiAgICAgIGNvZGUgPT09IDB4M0IgfHwgLy8gO1xuICAgICAgY29kZSA9PT0gMHg1QyAvLyBcXFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSB2YWx1ZScpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogcGF0aC12YWx1ZSAgICAgICAgPSA8YW55IENIQVIgZXhjZXB0IENUTHMgb3IgXCI7XCI+XG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZVBhdGggKHBhdGgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKVxuXG4gICAgaWYgKFxuICAgICAgY29kZSA8IDB4MjAgfHwgLy8gZXhjbHVkZSBDVExzICgwLTMxKVxuICAgICAgY29kZSA9PT0gMHg3RiB8fCAvLyBERUxcbiAgICAgIGNvZGUgPT09IDB4M0IgLy8gO1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSBwYXRoJylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJIGhhdmUgbm8gaWRlYSB3aHkgdGhlc2UgdmFsdWVzIGFyZW4ndCBhbGxvd2VkIHRvIGJlIGhvbmVzdCxcbiAqIGJ1dCBEZW5vIHRlc3RzIHRoZXNlLiAtIEtoYWZyYVxuICogQHBhcmFtIHtzdHJpbmd9IGRvbWFpblxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZURvbWFpbiAoZG9tYWluKSB7XG4gIGlmIChcbiAgICBkb21haW4uc3RhcnRzV2l0aCgnLScpIHx8XG4gICAgZG9tYWluLmVuZHNXaXRoKCcuJykgfHxcbiAgICBkb21haW4uZW5kc1dpdGgoJy0nKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29va2llIGRvbWFpbicpXG4gIH1cbn1cblxuY29uc3QgSU1GRGF5cyA9IFtcbiAgJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsXG4gICdUaHUnLCAnRnJpJywgJ1NhdCdcbl1cblxuY29uc3QgSU1GTW9udGhzID0gW1xuICAnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLFxuICAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXG5dXG5cbmNvbnN0IElNRlBhZGRlZE51bWJlcnMgPSBBcnJheSg2MSkuZmlsbCgwKS5tYXAoKF8sIGkpID0+IGkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzEjc2VjdGlvbi03LjEuMS4xXG4gKiBAcGFyYW0ge251bWJlcnxEYXRlfSBkYXRlXG4gIElNRi1maXhkYXRlICA9IGRheS1uYW1lIFwiLFwiIFNQIGRhdGUxIFNQIHRpbWUtb2YtZGF5IFNQIEdNVFxuICA7IGZpeGVkIGxlbmd0aC96b25lL2NhcGl0YWxpemF0aW9uIHN1YnNldCBvZiB0aGUgZm9ybWF0XG4gIDsgc2VlIFNlY3Rpb24gMy4zIG9mIFtSRkM1MzIyXVxuXG4gIGRheS1uYW1lICAgICA9ICV4NEQuNkYuNkUgOyBcIk1vblwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NTQuNzUuNjUgOyBcIlR1ZVwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NTcuNjUuNjQgOyBcIldlZFwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NTQuNjguNzUgOyBcIlRodVwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NDYuNzIuNjkgOyBcIkZyaVwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NTMuNjEuNzQgOyBcIlNhdFwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NTMuNzUuNkUgOyBcIlN1blwiLCBjYXNlLXNlbnNpdGl2ZVxuICBkYXRlMSAgICAgICAgPSBkYXkgU1AgbW9udGggU1AgeWVhclxuICAgICAgICAgICAgICAgICAgOyBlLmcuLCAwMiBKdW4gMTk4MlxuXG4gIGRheSAgICAgICAgICA9IDJESUdJVFxuICBtb250aCAgICAgICAgPSAleDRBLjYxLjZFIDsgXCJKYW5cIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDQ2LjY1LjYyIDsgXCJGZWJcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDRELjYxLjcyIDsgXCJNYXJcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDQxLjcwLjcyIDsgXCJBcHJcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDRELjYxLjc5IDsgXCJNYXlcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDRBLjc1LjZFIDsgXCJKdW5cIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDRBLjc1LjZDIDsgXCJKdWxcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDQxLjc1LjY3IDsgXCJBdWdcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDUzLjY1LjcwIDsgXCJTZXBcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDRGLjYzLjc0IDsgXCJPY3RcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDRFLjZGLjc2IDsgXCJOb3ZcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDQ0LjY1LjYzIDsgXCJEZWNcIiwgY2FzZS1zZW5zaXRpdmVcbiAgeWVhciAgICAgICAgID0gNERJR0lUXG5cbiAgR01UICAgICAgICAgID0gJXg0Ny40RC41NCA7IFwiR01UXCIsIGNhc2Utc2Vuc2l0aXZlXG5cbiAgdGltZS1vZi1kYXkgID0gaG91ciBcIjpcIiBtaW51dGUgXCI6XCIgc2Vjb25kXG4gICAgICAgICAgICAgIDsgMDA6MDA6MDAgLSAyMzo1OTo2MCAobGVhcCBzZWNvbmQpXG5cbiAgaG91ciAgICAgICAgID0gMkRJR0lUXG4gIG1pbnV0ZSAgICAgICA9IDJESUdJVFxuICBzZWNvbmQgICAgICAgPSAyRElHSVRcbiAqL1xuZnVuY3Rpb24gdG9JTUZEYXRlIChkYXRlKSB7XG4gIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSlcbiAgfVxuXG4gIHJldHVybiBgJHtJTUZEYXlzW2RhdGUuZ2V0VVRDRGF5KCldfSwgJHtJTUZQYWRkZWROdW1iZXJzW2RhdGUuZ2V0VVRDRGF0ZSgpXX0gJHtJTUZNb250aHNbZGF0ZS5nZXRVVENNb250aCgpXX0gJHtkYXRlLmdldFVUQ0Z1bGxZZWFyKCl9ICR7SU1GUGFkZGVkTnVtYmVyc1tkYXRlLmdldFVUQ0hvdXJzKCldfToke0lNRlBhZGRlZE51bWJlcnNbZGF0ZS5nZXRVVENNaW51dGVzKCldfToke0lNRlBhZGRlZE51bWJlcnNbZGF0ZS5nZXRVVENTZWNvbmRzKCldfSBHTVRgXG59XG5cbi8qKlxuIG1heC1hZ2UtYXYgICAgICAgID0gXCJNYXgtQWdlPVwiIG5vbi16ZXJvLWRpZ2l0ICpESUdJVFxuICAgICAgICAgICAgICAgICAgICAgICA7IEluIHByYWN0aWNlLCBib3RoIGV4cGlyZXMtYXYgYW5kIG1heC1hZ2UtYXZcbiAgICAgICAgICAgICAgICAgICAgICAgOyBhcmUgbGltaXRlZCB0byBkYXRlcyByZXByZXNlbnRhYmxlIGJ5IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICA7IHVzZXIgYWdlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4QWdlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ29va2llTWF4QWdlIChtYXhBZ2UpIHtcbiAgaWYgKG1heEFnZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29va2llIG1heC1hZ2UnKVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjI2NSNzZWN0aW9uLTQuMS4xXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLkNvb2tpZX0gY29va2llXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeSAoY29va2llKSB7XG4gIGlmIChjb29raWUubmFtZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdmFsaWRhdGVDb29raWVOYW1lKGNvb2tpZS5uYW1lKVxuICB2YWxpZGF0ZUNvb2tpZVZhbHVlKGNvb2tpZS52YWx1ZSlcblxuICBjb25zdCBvdXQgPSBbYCR7Y29va2llLm5hbWV9PSR7Y29va2llLnZhbHVlfWBdXG5cbiAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtY29va2llLXByZWZpeGVzLTAwI3NlY3Rpb24tMy4xXG4gIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLWNvb2tpZS1wcmVmaXhlcy0wMCNzZWN0aW9uLTMuMlxuICBpZiAoY29va2llLm5hbWUuc3RhcnRzV2l0aCgnX19TZWN1cmUtJykpIHtcbiAgICBjb29raWUuc2VjdXJlID0gdHJ1ZVxuICB9XG5cbiAgaWYgKGNvb2tpZS5uYW1lLnN0YXJ0c1dpdGgoJ19fSG9zdC0nKSkge1xuICAgIGNvb2tpZS5zZWN1cmUgPSB0cnVlXG4gICAgY29va2llLmRvbWFpbiA9IG51bGxcbiAgICBjb29raWUucGF0aCA9ICcvJ1xuICB9XG5cbiAgaWYgKGNvb2tpZS5zZWN1cmUpIHtcbiAgICBvdXQucHVzaCgnU2VjdXJlJylcbiAgfVxuXG4gIGlmIChjb29raWUuaHR0cE9ubHkpIHtcbiAgICBvdXQucHVzaCgnSHR0cE9ubHknKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb29raWUubWF4QWdlID09PSAnbnVtYmVyJykge1xuICAgIHZhbGlkYXRlQ29va2llTWF4QWdlKGNvb2tpZS5tYXhBZ2UpXG4gICAgb3V0LnB1c2goYE1heC1BZ2U9JHtjb29raWUubWF4QWdlfWApXG4gIH1cblxuICBpZiAoY29va2llLmRvbWFpbikge1xuICAgIHZhbGlkYXRlQ29va2llRG9tYWluKGNvb2tpZS5kb21haW4pXG4gICAgb3V0LnB1c2goYERvbWFpbj0ke2Nvb2tpZS5kb21haW59YClcbiAgfVxuXG4gIGlmIChjb29raWUucGF0aCkge1xuICAgIHZhbGlkYXRlQ29va2llUGF0aChjb29raWUucGF0aClcbiAgICBvdXQucHVzaChgUGF0aD0ke2Nvb2tpZS5wYXRofWApXG4gIH1cblxuICBpZiAoY29va2llLmV4cGlyZXMgJiYgY29va2llLmV4cGlyZXMudG9TdHJpbmcoKSAhPT0gJ0ludmFsaWQgRGF0ZScpIHtcbiAgICBvdXQucHVzaChgRXhwaXJlcz0ke3RvSU1GRGF0ZShjb29raWUuZXhwaXJlcyl9YClcbiAgfVxuXG4gIGlmIChjb29raWUuc2FtZVNpdGUpIHtcbiAgICBvdXQucHVzaChgU2FtZVNpdGU9JHtjb29raWUuc2FtZVNpdGV9YClcbiAgfVxuXG4gIGZvciAoY29uc3QgcGFydCBvZiBjb29raWUudW5wYXJzZWQpIHtcbiAgICBpZiAoIXBhcnQuaW5jbHVkZXMoJz0nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVucGFyc2VkJylcbiAgICB9XG5cbiAgICBjb25zdCBba2V5LCAuLi52YWx1ZV0gPSBwYXJ0LnNwbGl0KCc9JylcblxuICAgIG91dC5wdXNoKGAke2tleS50cmltKCl9PSR7dmFsdWUuam9pbignPScpfWApXG4gIH1cblxuICByZXR1cm4gb3V0LmpvaW4oJzsgJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQ1RMRXhjbHVkaW5nSHRhYixcbiAgdmFsaWRhdGVDb29raWVOYW1lLFxuICB2YWxpZGF0ZUNvb2tpZVBhdGgsXG4gIHZhbGlkYXRlQ29va2llVmFsdWUsXG4gIHRvSU1GRGF0ZSxcbiAgc3RyaW5naWZ5XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cookies/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js":
/*!***********************************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/eventsource-stream.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { isASCIINumber, isValidLastEventId } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/eventsource/util.js\")\n\n/**\n * @type {number[]} BOM\n */\nconst BOM = [0xEF, 0xBB, 0xBF]\n/**\n * @type {10} LF\n */\nconst LF = 0x0A\n/**\n * @type {13} CR\n */\nconst CR = 0x0D\n/**\n * @type {58} COLON\n */\nconst COLON = 0x3A\n/**\n * @type {32} SPACE\n */\nconst SPACE = 0x20\n\n/**\n * @typedef {object} EventSourceStreamEvent\n * @type {object}\n * @property {string} [event] The event type.\n * @property {string} [data] The data of the message.\n * @property {string} [id] A unique ID for the event.\n * @property {string} [retry] The reconnection time, in milliseconds.\n */\n\n/**\n * @typedef eventSourceSettings\n * @type {object}\n * @property {string} [lastEventId] The last event ID received from the server.\n * @property {string} [origin] The origin of the event source.\n * @property {number} [reconnectionTime] The reconnection time, in milliseconds.\n */\n\nclass EventSourceStream extends Transform {\n  /**\n   * @type {eventSourceSettings}\n   */\n  state\n\n  /**\n   * Leading byte-order-mark check.\n   * @type {boolean}\n   */\n  checkBOM = true\n\n  /**\n   * @type {boolean}\n   */\n  crlfCheck = false\n\n  /**\n   * @type {boolean}\n   */\n  eventEndCheck = false\n\n  /**\n   * @type {Buffer|null}\n   */\n  buffer = null\n\n  pos = 0\n\n  event = {\n    data: undefined,\n    event: undefined,\n    id: undefined,\n    retry: undefined\n  }\n\n  /**\n   * @param {object} options\n   * @param {boolean} [options.readableObjectMode]\n   * @param {eventSourceSettings} [options.eventSourceSettings]\n   * @param {(chunk: any, encoding?: BufferEncoding | undefined) => boolean} [options.push]\n   */\n  constructor (options = {}) {\n    // Enable object mode as EventSourceStream emits objects of shape\n    // EventSourceStreamEvent\n    options.readableObjectMode = true\n\n    super(options)\n\n    this.state = options.eventSourceSettings || {}\n    if (options.push) {\n      this.push = options.push\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {string} _encoding\n   * @param {Function} callback\n   * @returns {void}\n   */\n  _transform (chunk, _encoding, callback) {\n    if (chunk.length === 0) {\n      callback()\n      return\n    }\n\n    // Cache the chunk in the buffer, as the data might not be complete while\n    // processing it\n    // TODO: Investigate if there is a more performant way to handle\n    // incoming chunks\n    // see: https://github.com/nodejs/undici/issues/2630\n    if (this.buffer) {\n      this.buffer = Buffer.concat([this.buffer, chunk])\n    } else {\n      this.buffer = chunk\n    }\n\n    // Strip leading byte-order-mark if we opened the stream and started\n    // the processing of the incoming data\n    if (this.checkBOM) {\n      switch (this.buffer.length) {\n        case 1:\n          // Check if the first byte is the same as the first byte of the BOM\n          if (this.buffer[0] === BOM[0]) {\n            // If it is, we need to wait for more data\n            callback()\n            return\n          }\n          // Set the checkBOM flag to false as we don't need to check for the\n          // BOM anymore\n          this.checkBOM = false\n\n          // The buffer only contains one byte so we need to wait for more data\n          callback()\n          return\n        case 2:\n          // Check if the first two bytes are the same as the first two bytes\n          // of the BOM\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1]\n          ) {\n            // If it is, we need to wait for more data, because the third byte\n            // is needed to determine if it is the BOM or not\n            callback()\n            return\n          }\n\n          // Set the checkBOM flag to false as we don't need to check for the\n          // BOM anymore\n          this.checkBOM = false\n          break\n        case 3:\n          // Check if the first three bytes are the same as the first three\n          // bytes of the BOM\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1] &&\n            this.buffer[2] === BOM[2]\n          ) {\n            // If it is, we can drop the buffered data, as it is only the BOM\n            this.buffer = Buffer.alloc(0)\n            // Set the checkBOM flag to false as we don't need to check for the\n            // BOM anymore\n            this.checkBOM = false\n\n            // Await more data\n            callback()\n            return\n          }\n          // If it is not the BOM, we can start processing the data\n          this.checkBOM = false\n          break\n        default:\n          // The buffer is longer than 3 bytes, so we can drop the BOM if it is\n          // present\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1] &&\n            this.buffer[2] === BOM[2]\n          ) {\n            // Remove the BOM from the buffer\n            this.buffer = this.buffer.subarray(3)\n          }\n\n          // Set the checkBOM flag to false as we don't need to check for the\n          this.checkBOM = false\n          break\n      }\n    }\n\n    while (this.pos < this.buffer.length) {\n      // If the previous line ended with an end-of-line, we need to check\n      // if the next character is also an end-of-line.\n      if (this.eventEndCheck) {\n        // If the the current character is an end-of-line, then the event\n        // is finished and we can process it\n\n        // If the previous line ended with a carriage return, we need to\n        // check if the current character is a line feed and remove it\n        // from the buffer.\n        if (this.crlfCheck) {\n          // If the current character is a line feed, we can remove it\n          // from the buffer and reset the crlfCheck flag\n          if (this.buffer[this.pos] === LF) {\n            this.buffer = this.buffer.subarray(this.pos + 1)\n            this.pos = 0\n            this.crlfCheck = false\n\n            // It is possible that the line feed is not the end of the\n            // event. We need to check if the next character is an\n            // end-of-line character to determine if the event is\n            // finished. We simply continue the loop to check the next\n            // character.\n\n            // As we removed the line feed from the buffer and set the\n            // crlfCheck flag to false, we basically don't make any\n            // distinction between a line feed and a carriage return.\n            continue\n          }\n          this.crlfCheck = false\n        }\n\n        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n          // If the current character is a carriage return, we need to\n          // set the crlfCheck flag to true, as we need to check if the\n          // next character is a line feed so we can remove it from the\n          // buffer\n          if (this.buffer[this.pos] === CR) {\n            this.crlfCheck = true\n          }\n\n          this.buffer = this.buffer.subarray(this.pos + 1)\n          this.pos = 0\n          if (\n            this.event.data !== undefined || this.event.event || this.event.id || this.event.retry) {\n            this.processEvent(this.event)\n          }\n          this.clearEvent()\n          continue\n        }\n        // If the current character is not an end-of-line, then the event\n        // is not finished and we have to reset the eventEndCheck flag\n        this.eventEndCheck = false\n        continue\n      }\n\n      // If the current character is an end-of-line, we can process the\n      // line\n      if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n        // If the current character is a carriage return, we need to\n        // set the crlfCheck flag to true, as we need to check if the\n        // next character is a line feed\n        if (this.buffer[this.pos] === CR) {\n          this.crlfCheck = true\n        }\n\n        // In any case, we can process the line as we reached an\n        // end-of-line character\n        this.parseLine(this.buffer.subarray(0, this.pos), this.event)\n\n        // Remove the processed line from the buffer\n        this.buffer = this.buffer.subarray(this.pos + 1)\n        // Reset the position as we removed the processed line from the buffer\n        this.pos = 0\n        // A line was processed and this could be the end of the event. We need\n        // to check if the next line is empty to determine if the event is\n        // finished.\n        this.eventEndCheck = true\n        continue\n      }\n\n      this.pos++\n    }\n\n    callback()\n  }\n\n  /**\n   * @param {Buffer} line\n   * @param {EventSourceStreamEvent} event\n   */\n  parseLine (line, event) {\n    // If the line is empty (a blank line)\n    // Dispatch the event, as defined below.\n    // This will be handled in the _transform method\n    if (line.length === 0) {\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:)\n    // Ignore the line.\n    const colonPosition = line.indexOf(COLON)\n    if (colonPosition === 0) {\n      return\n    }\n\n    let field = ''\n    let value = ''\n\n    // If the line contains a U+003A COLON character (:)\n    if (colonPosition !== -1) {\n      // Collect the characters on the line before the first U+003A COLON\n      // character (:), and let field be that string.\n      // TODO: Investigate if there is a more performant way to extract the\n      // field\n      // see: https://github.com/nodejs/undici/issues/2630\n      field = line.subarray(0, colonPosition).toString('utf8')\n\n      // Collect the characters on the line after the first U+003A COLON\n      // character (:), and let value be that string.\n      // If value starts with a U+0020 SPACE character, remove it from value.\n      let valueStart = colonPosition + 1\n      if (line[valueStart] === SPACE) {\n        ++valueStart\n      }\n      // TODO: Investigate if there is a more performant way to extract the\n      // value\n      // see: https://github.com/nodejs/undici/issues/2630\n      value = line.subarray(valueStart).toString('utf8')\n\n      // Otherwise, the string is not empty but does not contain a U+003A COLON\n      // character (:)\n    } else {\n      // Process the field using the steps described below, using the whole\n      // line as the field name, and the empty string as the field value.\n      field = line.toString('utf8')\n      value = ''\n    }\n\n    // Modify the event with the field name and value. The value is also\n    // decoded as UTF-8\n    switch (field) {\n      case 'data':\n        if (event[field] === undefined) {\n          event[field] = value\n        } else {\n          event[field] += `\\n${value}`\n        }\n        break\n      case 'retry':\n        if (isASCIINumber(value)) {\n          event[field] = value\n        }\n        break\n      case 'id':\n        if (isValidLastEventId(value)) {\n          event[field] = value\n        }\n        break\n      case 'event':\n        if (value.length > 0) {\n          event[field] = value\n        }\n        break\n    }\n  }\n\n  /**\n   * @param {EventSourceStreamEvent} event\n   */\n  processEvent (event) {\n    if (event.retry && isASCIINumber(event.retry)) {\n      this.state.reconnectionTime = parseInt(event.retry, 10)\n    }\n\n    if (event.id && isValidLastEventId(event.id)) {\n      this.state.lastEventId = event.id\n    }\n\n    // only dispatch event, when data is provided\n    if (event.data !== undefined) {\n      this.push({\n        type: event.event || 'message',\n        options: {\n          data: event.data,\n          lastEventId: this.state.lastEventId,\n          origin: this.state.origin\n        }\n      })\n    }\n  }\n\n  clearEvent () {\n    this.event = {\n      data: undefined,\n      event: undefined,\n      id: undefined,\n      retry: undefined\n    }\n  }\n}\n\nmodule.exports = {\n  EventSourceStream\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2Utc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMzQyxRQUFRLG9DQUFvQyxFQUFFLG1CQUFPLENBQUMsdUVBQVE7O0FBRTlEO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVTtBQUNWLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLHFCQUFxQjtBQUNsQyxhQUFhLGdFQUFnRTtBQUM3RTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2Utc3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgeyBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHsgaXNBU0NJSU51bWJlciwgaXNWYWxpZExhc3RFdmVudElkIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJbXX0gQk9NXG4gKi9cbmNvbnN0IEJPTSA9IFsweEVGLCAweEJCLCAweEJGXVxuLyoqXG4gKiBAdHlwZSB7MTB9IExGXG4gKi9cbmNvbnN0IExGID0gMHgwQVxuLyoqXG4gKiBAdHlwZSB7MTN9IENSXG4gKi9cbmNvbnN0IENSID0gMHgwRFxuLyoqXG4gKiBAdHlwZSB7NTh9IENPTE9OXG4gKi9cbmNvbnN0IENPTE9OID0gMHgzQVxuLyoqXG4gKiBAdHlwZSB7MzJ9IFNQQUNFXG4gKi9cbmNvbnN0IFNQQUNFID0gMHgyMFxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEV2ZW50U291cmNlU3RyZWFtRXZlbnRcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2V2ZW50XSBUaGUgZXZlbnQgdHlwZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZGF0YV0gVGhlIGRhdGEgb2YgdGhlIG1lc3NhZ2UuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2lkXSBBIHVuaXF1ZSBJRCBmb3IgdGhlIGV2ZW50LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtyZXRyeV0gVGhlIHJlY29ubmVjdGlvbiB0aW1lLCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBldmVudFNvdXJjZVNldHRpbmdzXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYXN0RXZlbnRJZF0gVGhlIGxhc3QgZXZlbnQgSUQgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcmlnaW5dIFRoZSBvcmlnaW4gb2YgdGhlIGV2ZW50IHNvdXJjZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVjb25uZWN0aW9uVGltZV0gVGhlIHJlY29ubmVjdGlvbiB0aW1lLCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cblxuY2xhc3MgRXZlbnRTb3VyY2VTdHJlYW0gZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICAvKipcbiAgICogQHR5cGUge2V2ZW50U291cmNlU2V0dGluZ3N9XG4gICAqL1xuICBzdGF0ZVxuXG4gIC8qKlxuICAgKiBMZWFkaW5nIGJ5dGUtb3JkZXItbWFyayBjaGVjay5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBjaGVja0JPTSA9IHRydWVcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBjcmxmQ2hlY2sgPSBmYWxzZVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGV2ZW50RW5kQ2hlY2sgPSBmYWxzZVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7QnVmZmVyfG51bGx9XG4gICAqL1xuICBidWZmZXIgPSBudWxsXG5cbiAgcG9zID0gMFxuXG4gIGV2ZW50ID0ge1xuICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICBldmVudDogdW5kZWZpbmVkLFxuICAgIGlkOiB1bmRlZmluZWQsXG4gICAgcmV0cnk6IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlXVxuICAgKiBAcGFyYW0ge2V2ZW50U291cmNlU2V0dGluZ3N9IFtvcHRpb25zLmV2ZW50U291cmNlU2V0dGluZ3NdXG4gICAqIEBwYXJhbSB7KGNodW5rOiBhbnksIGVuY29kaW5nPzogQnVmZmVyRW5jb2RpbmcgfCB1bmRlZmluZWQpID0+IGJvb2xlYW59IFtvcHRpb25zLnB1c2hdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gRW5hYmxlIG9iamVjdCBtb2RlIGFzIEV2ZW50U291cmNlU3RyZWFtIGVtaXRzIG9iamVjdHMgb2Ygc2hhcGVcbiAgICAvLyBFdmVudFNvdXJjZVN0cmVhbUV2ZW50XG4gICAgb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGUgPSB0cnVlXG5cbiAgICBzdXBlcihvcHRpb25zKVxuXG4gICAgdGhpcy5zdGF0ZSA9IG9wdGlvbnMuZXZlbnRTb3VyY2VTZXR0aW5ncyB8fCB7fVxuICAgIGlmIChvcHRpb25zLnB1c2gpIHtcbiAgICAgIHRoaXMucHVzaCA9IG9wdGlvbnMucHVzaFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAgICogQHBhcmFtIHtzdHJpbmd9IF9lbmNvZGluZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF90cmFuc2Zvcm0gKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGNodW5rLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FsbGJhY2soKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gQ2FjaGUgdGhlIGNodW5rIGluIHRoZSBidWZmZXIsIGFzIHRoZSBkYXRhIG1pZ2h0IG5vdCBiZSBjb21wbGV0ZSB3aGlsZVxuICAgIC8vIHByb2Nlc3NpbmcgaXRcbiAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB0aGVyZSBpcyBhIG1vcmUgcGVyZm9ybWFudCB3YXkgdG8gaGFuZGxlXG4gICAgLy8gaW5jb21pbmcgY2h1bmtzXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjYzMFxuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmJ1ZmZlciwgY2h1bmtdKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJ1ZmZlciA9IGNodW5rXG4gICAgfVxuXG4gICAgLy8gU3RyaXAgbGVhZGluZyBieXRlLW9yZGVyLW1hcmsgaWYgd2Ugb3BlbmVkIHRoZSBzdHJlYW0gYW5kIHN0YXJ0ZWRcbiAgICAvLyB0aGUgcHJvY2Vzc2luZyBvZiB0aGUgaW5jb21pbmcgZGF0YVxuICAgIGlmICh0aGlzLmNoZWNrQk9NKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpcnN0IGJ5dGUgaXMgdGhlIHNhbWUgYXMgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIEJPTVxuICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlclswXSA9PT0gQk9NWzBdKSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBpcywgd2UgbmVlZCB0byB3YWl0IGZvciBtb3JlIGRhdGFcbiAgICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTZXQgdGhlIGNoZWNrQk9NIGZsYWcgdG8gZmFsc2UgYXMgd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgdGhlXG4gICAgICAgICAgLy8gQk9NIGFueW1vcmVcbiAgICAgICAgICB0aGlzLmNoZWNrQk9NID0gZmFsc2VcblxuICAgICAgICAgIC8vIFRoZSBidWZmZXIgb25seSBjb250YWlucyBvbmUgYnl0ZSBzbyB3ZSBuZWVkIHRvIHdhaXQgZm9yIG1vcmUgZGF0YVxuICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCB0d28gYnl0ZXMgYXJlIHRoZSBzYW1lIGFzIHRoZSBmaXJzdCB0d28gYnl0ZXNcbiAgICAgICAgICAvLyBvZiB0aGUgQk9NXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5idWZmZXJbMF0gPT09IEJPTVswXSAmJlxuICAgICAgICAgICAgdGhpcy5idWZmZXJbMV0gPT09IEJPTVsxXVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMsIHdlIG5lZWQgdG8gd2FpdCBmb3IgbW9yZSBkYXRhLCBiZWNhdXNlIHRoZSB0aGlyZCBieXRlXG4gICAgICAgICAgICAvLyBpcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIHRoZSBCT00gb3Igbm90XG4gICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXQgdGhlIGNoZWNrQk9NIGZsYWcgdG8gZmFsc2UgYXMgd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgdGhlXG4gICAgICAgICAgLy8gQk9NIGFueW1vcmVcbiAgICAgICAgICB0aGlzLmNoZWNrQk9NID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpcnN0IHRocmVlIGJ5dGVzIGFyZSB0aGUgc2FtZSBhcyB0aGUgZmlyc3QgdGhyZWVcbiAgICAgICAgICAvLyBieXRlcyBvZiB0aGUgQk9NXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5idWZmZXJbMF0gPT09IEJPTVswXSAmJlxuICAgICAgICAgICAgdGhpcy5idWZmZXJbMV0gPT09IEJPTVsxXSAmJlxuICAgICAgICAgICAgdGhpcy5idWZmZXJbMl0gPT09IEJPTVsyXVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMsIHdlIGNhbiBkcm9wIHRoZSBidWZmZXJlZCBkYXRhLCBhcyBpdCBpcyBvbmx5IHRoZSBCT01cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmFsbG9jKDApXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGNoZWNrQk9NIGZsYWcgdG8gZmFsc2UgYXMgd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgdGhlXG4gICAgICAgICAgICAvLyBCT00gYW55bW9yZVxuICAgICAgICAgICAgdGhpcy5jaGVja0JPTSA9IGZhbHNlXG5cbiAgICAgICAgICAgIC8vIEF3YWl0IG1vcmUgZGF0YVxuICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIGl0IGlzIG5vdCB0aGUgQk9NLCB3ZSBjYW4gc3RhcnQgcHJvY2Vzc2luZyB0aGUgZGF0YVxuICAgICAgICAgIHRoaXMuY2hlY2tCT00gPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gVGhlIGJ1ZmZlciBpcyBsb25nZXIgdGhhbiAzIGJ5dGVzLCBzbyB3ZSBjYW4gZHJvcCB0aGUgQk9NIGlmIGl0IGlzXG4gICAgICAgICAgLy8gcHJlc2VudFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzBdID09PSBCT01bMF0gJiZcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzFdID09PSBCT01bMV0gJiZcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzJdID09PSBCT01bMl1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgQk9NIGZyb20gdGhlIGJ1ZmZlclxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheSgzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNldCB0aGUgY2hlY2tCT00gZmxhZyB0byBmYWxzZSBhcyB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIGZvciB0aGVcbiAgICAgICAgICB0aGlzLmNoZWNrQk9NID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGxpbmUgZW5kZWQgd2l0aCBhbiBlbmQtb2YtbGluZSwgd2UgbmVlZCB0byBjaGVja1xuICAgICAgLy8gaWYgdGhlIG5leHQgY2hhcmFjdGVyIGlzIGFsc28gYW4gZW5kLW9mLWxpbmUuXG4gICAgICBpZiAodGhpcy5ldmVudEVuZENoZWNrKSB7XG4gICAgICAgIC8vIElmIHRoZSB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgYW4gZW5kLW9mLWxpbmUsIHRoZW4gdGhlIGV2ZW50XG4gICAgICAgIC8vIGlzIGZpbmlzaGVkIGFuZCB3ZSBjYW4gcHJvY2VzcyBpdFxuXG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBsaW5lIGVuZGVkIHdpdGggYSBjYXJyaWFnZSByZXR1cm4sIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGEgbGluZSBmZWVkIGFuZCByZW1vdmUgaXRcbiAgICAgICAgLy8gZnJvbSB0aGUgYnVmZmVyLlxuICAgICAgICBpZiAodGhpcy5jcmxmQ2hlY2spIHtcbiAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgYSBsaW5lIGZlZWQsIHdlIGNhbiByZW1vdmUgaXRcbiAgICAgICAgICAvLyBmcm9tIHRoZSBidWZmZXIgYW5kIHJlc2V0IHRoZSBjcmxmQ2hlY2sgZmxhZ1xuICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IExGKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMucG9zICsgMSlcbiAgICAgICAgICAgIHRoaXMucG9zID0gMFxuICAgICAgICAgICAgdGhpcy5jcmxmQ2hlY2sgPSBmYWxzZVxuXG4gICAgICAgICAgICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBsaW5lIGZlZWQgaXMgbm90IHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAvLyBldmVudC4gV2UgbmVlZCB0byBjaGVjayBpZiB0aGUgbmV4dCBjaGFyYWN0ZXIgaXMgYW5cbiAgICAgICAgICAgIC8vIGVuZC1vZi1saW5lIGNoYXJhY3RlciB0byBkZXRlcm1pbmUgaWYgdGhlIGV2ZW50IGlzXG4gICAgICAgICAgICAvLyBmaW5pc2hlZC4gV2Ugc2ltcGx5IGNvbnRpbnVlIHRoZSBsb29wIHRvIGNoZWNrIHRoZSBuZXh0XG4gICAgICAgICAgICAvLyBjaGFyYWN0ZXIuXG5cbiAgICAgICAgICAgIC8vIEFzIHdlIHJlbW92ZWQgdGhlIGxpbmUgZmVlZCBmcm9tIHRoZSBidWZmZXIgYW5kIHNldCB0aGVcbiAgICAgICAgICAgIC8vIGNybGZDaGVjayBmbGFnIHRvIGZhbHNlLCB3ZSBiYXNpY2FsbHkgZG9uJ3QgbWFrZSBhbnlcbiAgICAgICAgICAgIC8vIGRpc3RpbmN0aW9uIGJldHdlZW4gYSBsaW5lIGZlZWQgYW5kIGEgY2FycmlhZ2UgcmV0dXJuLlxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jcmxmQ2hlY2sgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gTEYgfHwgdGhpcy5idWZmZXJbdGhpcy5wb3NdID09PSBDUikge1xuICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBhIGNhcnJpYWdlIHJldHVybiwgd2UgbmVlZCB0b1xuICAgICAgICAgIC8vIHNldCB0aGUgY3JsZkNoZWNrIGZsYWcgdG8gdHJ1ZSwgYXMgd2UgbmVlZCB0byBjaGVjayBpZiB0aGVcbiAgICAgICAgICAvLyBuZXh0IGNoYXJhY3RlciBpcyBhIGxpbmUgZmVlZCBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGZyb20gdGhlXG4gICAgICAgICAgLy8gYnVmZmVyXG4gICAgICAgICAgaWYgKHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gQ1IpIHtcbiAgICAgICAgICAgIHRoaXMuY3JsZkNoZWNrID0gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3ViYXJyYXkodGhpcy5wb3MgKyAxKVxuICAgICAgICAgIHRoaXMucG9zID0gMFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuZXZlbnQuZGF0YSAhPT0gdW5kZWZpbmVkIHx8IHRoaXMuZXZlbnQuZXZlbnQgfHwgdGhpcy5ldmVudC5pZCB8fCB0aGlzLmV2ZW50LnJldHJ5KSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NFdmVudCh0aGlzLmV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNsZWFyRXZlbnQoKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIG5vdCBhbiBlbmQtb2YtbGluZSwgdGhlbiB0aGUgZXZlbnRcbiAgICAgICAgLy8gaXMgbm90IGZpbmlzaGVkIGFuZCB3ZSBoYXZlIHRvIHJlc2V0IHRoZSBldmVudEVuZENoZWNrIGZsYWdcbiAgICAgICAgdGhpcy5ldmVudEVuZENoZWNrID0gZmFsc2VcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGFuIGVuZC1vZi1saW5lLCB3ZSBjYW4gcHJvY2VzcyB0aGVcbiAgICAgIC8vIGxpbmVcbiAgICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IExGIHx8IHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gQ1IpIHtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGEgY2FycmlhZ2UgcmV0dXJuLCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHNldCB0aGUgY3JsZkNoZWNrIGZsYWcgdG8gdHJ1ZSwgYXMgd2UgbmVlZCB0byBjaGVjayBpZiB0aGVcbiAgICAgICAgLy8gbmV4dCBjaGFyYWN0ZXIgaXMgYSBsaW5lIGZlZWRcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gQ1IpIHtcbiAgICAgICAgICB0aGlzLmNybGZDaGVjayA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluIGFueSBjYXNlLCB3ZSBjYW4gcHJvY2VzcyB0aGUgbGluZSBhcyB3ZSByZWFjaGVkIGFuXG4gICAgICAgIC8vIGVuZC1vZi1saW5lIGNoYXJhY3RlclxuICAgICAgICB0aGlzLnBhcnNlTGluZSh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvcyksIHRoaXMuZXZlbnQpXG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBwcm9jZXNzZWQgbGluZSBmcm9tIHRoZSBidWZmZXJcbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheSh0aGlzLnBvcyArIDEpXG4gICAgICAgIC8vIFJlc2V0IHRoZSBwb3NpdGlvbiBhcyB3ZSByZW1vdmVkIHRoZSBwcm9jZXNzZWQgbGluZSBmcm9tIHRoZSBidWZmZXJcbiAgICAgICAgdGhpcy5wb3MgPSAwXG4gICAgICAgIC8vIEEgbGluZSB3YXMgcHJvY2Vzc2VkIGFuZCB0aGlzIGNvdWxkIGJlIHRoZSBlbmQgb2YgdGhlIGV2ZW50LiBXZSBuZWVkXG4gICAgICAgIC8vIHRvIGNoZWNrIGlmIHRoZSBuZXh0IGxpbmUgaXMgZW1wdHkgdG8gZGV0ZXJtaW5lIGlmIHRoZSBldmVudCBpc1xuICAgICAgICAvLyBmaW5pc2hlZC5cbiAgICAgICAgdGhpcy5ldmVudEVuZENoZWNrID0gdHJ1ZVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB0aGlzLnBvcysrXG4gICAgfVxuXG4gICAgY2FsbGJhY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBsaW5lXG4gICAqIEBwYXJhbSB7RXZlbnRTb3VyY2VTdHJlYW1FdmVudH0gZXZlbnRcbiAgICovXG4gIHBhcnNlTGluZSAobGluZSwgZXZlbnQpIHtcbiAgICAvLyBJZiB0aGUgbGluZSBpcyBlbXB0eSAoYSBibGFuayBsaW5lKVxuICAgIC8vIERpc3BhdGNoIHRoZSBldmVudCwgYXMgZGVmaW5lZCBiZWxvdy5cbiAgICAvLyBUaGlzIHdpbGwgYmUgaGFuZGxlZCBpbiB0aGUgX3RyYW5zZm9ybSBtZXRob2RcbiAgICBpZiAobGluZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsaW5lIHN0YXJ0cyB3aXRoIGEgVSswMDNBIENPTE9OIGNoYXJhY3RlciAoOilcbiAgICAvLyBJZ25vcmUgdGhlIGxpbmUuXG4gICAgY29uc3QgY29sb25Qb3NpdGlvbiA9IGxpbmUuaW5kZXhPZihDT0xPTilcbiAgICBpZiAoY29sb25Qb3NpdGlvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGZpZWxkID0gJydcbiAgICBsZXQgdmFsdWUgPSAnJ1xuXG4gICAgLy8gSWYgdGhlIGxpbmUgY29udGFpbnMgYSBVKzAwM0EgQ09MT04gY2hhcmFjdGVyICg6KVxuICAgIGlmIChjb2xvblBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgLy8gQ29sbGVjdCB0aGUgY2hhcmFjdGVycyBvbiB0aGUgbGluZSBiZWZvcmUgdGhlIGZpcnN0IFUrMDAzQSBDT0xPTlxuICAgICAgLy8gY2hhcmFjdGVyICg6KSwgYW5kIGxldCBmaWVsZCBiZSB0aGF0IHN0cmluZy5cbiAgICAgIC8vIFRPRE86IEludmVzdGlnYXRlIGlmIHRoZXJlIGlzIGEgbW9yZSBwZXJmb3JtYW50IHdheSB0byBleHRyYWN0IHRoZVxuICAgICAgLy8gZmllbGRcbiAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzI2MzBcbiAgICAgIGZpZWxkID0gbGluZS5zdWJhcnJheSgwLCBjb2xvblBvc2l0aW9uKS50b1N0cmluZygndXRmOCcpXG5cbiAgICAgIC8vIENvbGxlY3QgdGhlIGNoYXJhY3RlcnMgb24gdGhlIGxpbmUgYWZ0ZXIgdGhlIGZpcnN0IFUrMDAzQSBDT0xPTlxuICAgICAgLy8gY2hhcmFjdGVyICg6KSwgYW5kIGxldCB2YWx1ZSBiZSB0aGF0IHN0cmluZy5cbiAgICAgIC8vIElmIHZhbHVlIHN0YXJ0cyB3aXRoIGEgVSswMDIwIFNQQUNFIGNoYXJhY3RlciwgcmVtb3ZlIGl0IGZyb20gdmFsdWUuXG4gICAgICBsZXQgdmFsdWVTdGFydCA9IGNvbG9uUG9zaXRpb24gKyAxXG4gICAgICBpZiAobGluZVt2YWx1ZVN0YXJ0XSA9PT0gU1BBQ0UpIHtcbiAgICAgICAgKyt2YWx1ZVN0YXJ0XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB0aGVyZSBpcyBhIG1vcmUgcGVyZm9ybWFudCB3YXkgdG8gZXh0cmFjdCB0aGVcbiAgICAgIC8vIHZhbHVlXG4gICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yNjMwXG4gICAgICB2YWx1ZSA9IGxpbmUuc3ViYXJyYXkodmFsdWVTdGFydCkudG9TdHJpbmcoJ3V0ZjgnKVxuXG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSBzdHJpbmcgaXMgbm90IGVtcHR5IGJ1dCBkb2VzIG5vdCBjb250YWluIGEgVSswMDNBIENPTE9OXG4gICAgICAvLyBjaGFyYWN0ZXIgKDopXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByb2Nlc3MgdGhlIGZpZWxkIHVzaW5nIHRoZSBzdGVwcyBkZXNjcmliZWQgYmVsb3csIHVzaW5nIHRoZSB3aG9sZVxuICAgICAgLy8gbGluZSBhcyB0aGUgZmllbGQgbmFtZSwgYW5kIHRoZSBlbXB0eSBzdHJpbmcgYXMgdGhlIGZpZWxkIHZhbHVlLlxuICAgICAgZmllbGQgPSBsaW5lLnRvU3RyaW5nKCd1dGY4JylcbiAgICAgIHZhbHVlID0gJydcbiAgICB9XG5cbiAgICAvLyBNb2RpZnkgdGhlIGV2ZW50IHdpdGggdGhlIGZpZWxkIG5hbWUgYW5kIHZhbHVlLiBUaGUgdmFsdWUgaXMgYWxzb1xuICAgIC8vIGRlY29kZWQgYXMgVVRGLThcbiAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICBjYXNlICdkYXRhJzpcbiAgICAgICAgaWYgKGV2ZW50W2ZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXZlbnRbZmllbGRdID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudFtmaWVsZF0gKz0gYFxcbiR7dmFsdWV9YFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdyZXRyeSc6XG4gICAgICAgIGlmIChpc0FTQ0lJTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgIGV2ZW50W2ZpZWxkXSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2lkJzpcbiAgICAgICAgaWYgKGlzVmFsaWRMYXN0RXZlbnRJZCh2YWx1ZSkpIHtcbiAgICAgICAgICBldmVudFtmaWVsZF0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdldmVudCc6XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZXZlbnRbZmllbGRdID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50U291cmNlU3RyZWFtRXZlbnR9IGV2ZW50XG4gICAqL1xuICBwcm9jZXNzRXZlbnQgKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnJldHJ5ICYmIGlzQVNDSUlOdW1iZXIoZXZlbnQucmV0cnkpKSB7XG4gICAgICB0aGlzLnN0YXRlLnJlY29ubmVjdGlvblRpbWUgPSBwYXJzZUludChldmVudC5yZXRyeSwgMTApXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LmlkICYmIGlzVmFsaWRMYXN0RXZlbnRJZChldmVudC5pZCkpIHtcbiAgICAgIHRoaXMuc3RhdGUubGFzdEV2ZW50SWQgPSBldmVudC5pZFxuICAgIH1cblxuICAgIC8vIG9ubHkgZGlzcGF0Y2ggZXZlbnQsIHdoZW4gZGF0YSBpcyBwcm92aWRlZFxuICAgIGlmIChldmVudC5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGV2ZW50LmV2ZW50IHx8ICdtZXNzYWdlJyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEsXG4gICAgICAgICAgbGFzdEV2ZW50SWQ6IHRoaXMuc3RhdGUubGFzdEV2ZW50SWQsXG4gICAgICAgICAgb3JpZ2luOiB0aGlzLnN0YXRlLm9yaWdpblxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGNsZWFyRXZlbnQgKCkge1xuICAgIHRoaXMuZXZlbnQgPSB7XG4gICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICBldmVudDogdW5kZWZpbmVkLFxuICAgICAgaWQ6IHVuZGVmaW5lZCxcbiAgICAgIHJldHJ5OiB1bmRlZmluZWRcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEV2ZW50U291cmNlU3RyZWFtXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/eventsource/eventsource.js":
/*!****************************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/eventsource.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { pipeline } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { fetching } = __webpack_require__(/*! ../fetch */ \"(rsc)/./node_modules/undici/lib/web/fetch/index.js\")\nconst { makeRequest } = __webpack_require__(/*! ../fetch/request */ \"(rsc)/./node_modules/undici/lib/web/fetch/request.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { EventSourceStream } = __webpack_require__(/*! ./eventsource-stream */ \"(rsc)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js\")\nconst { parseMIMEType } = __webpack_require__(/*! ../fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { createFastMessageEvent } = __webpack_require__(/*! ../websocket/events */ \"(rsc)/./node_modules/undici/lib/web/websocket/events.js\")\nconst { isNetworkError } = __webpack_require__(/*! ../fetch/response */ \"(rsc)/./node_modules/undici/lib/web/fetch/response.js\")\nconst { delay } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/eventsource/util.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { environmentSettingsObject } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\n\nlet experimentalWarned = false\n\n/**\n * A reconnection time, in milliseconds. This must initially be an implementation-defined value,\n * probably in the region of a few seconds.\n *\n * In Comparison:\n * - Chrome uses 3000ms.\n * - Deno uses 5000ms.\n *\n * @type {3000}\n */\nconst defaultReconnectionTime = 3000\n\n/**\n * The readyState attribute represents the state of the connection.\n * @typedef ReadyState\n * @type {0|1|2}\n * @readonly\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#dom-eventsource-readystate-dev\n */\n\n/**\n * The connection has not yet been established, or it was closed and the user\n * agent is reconnecting.\n * @type {0}\n */\nconst CONNECTING = 0\n\n/**\n * The user agent has an open connection and is dispatching events as it\n * receives them.\n * @type {1}\n */\nconst OPEN = 1\n\n/**\n * The connection is not open, and the user agent is not trying to reconnect.\n * @type {2}\n */\nconst CLOSED = 2\n\n/**\n * Requests for the element will have their mode set to \"cors\" and their credentials mode set to \"same-origin\".\n * @type {'anonymous'}\n */\nconst ANONYMOUS = 'anonymous'\n\n/**\n * Requests for the element will have their mode set to \"cors\" and their credentials mode set to \"include\".\n * @type {'use-credentials'}\n */\nconst USE_CREDENTIALS = 'use-credentials'\n\n/**\n * The EventSource interface is used to receive server-sent events. It\n * connects to a server over HTTP and receives events in text/event-stream\n * format without closing the connection.\n * @extends {EventTarget}\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events\n * @api public\n */\nclass EventSource extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    message: null\n  }\n\n  #url\n  #withCredentials = false\n\n  /**\n   * @type {ReadyState}\n   */\n  #readyState = CONNECTING\n\n  #request = null\n  #controller = null\n\n  #dispatcher\n\n  /**\n   * @type {import('./eventsource-stream').eventSourceSettings}\n   */\n  #state\n\n  /**\n   * Creates a new EventSource object.\n   * @param {string} url\n   * @param {EventSourceInit} [eventSourceInitDict={}]\n   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface\n   */\n  constructor (url, eventSourceInitDict = {}) {\n    // 1. Let ev be a new EventSource object.\n    super()\n\n    webidl.util.markAsUncloneable(this)\n\n    const prefix = 'EventSource constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    if (!experimentalWarned) {\n      experimentalWarned = true\n      process.emitWarning('EventSource is experimental, expect them to change at any time.', {\n        code: 'UNDICI-ES'\n      })\n    }\n\n    url = webidl.converters.USVString(url)\n    eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, 'eventSourceInitDict')\n\n    this.#dispatcher = eventSourceInitDict.dispatcher\n    this.#state = {\n      lastEventId: '',\n      reconnectionTime: defaultReconnectionTime\n    }\n\n    // 2. Let settings be ev's relevant settings object.\n    // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object\n    const settings = environmentSettingsObject\n\n    let urlRecord\n\n    try {\n      // 3. Let urlRecord be the result of encoding-parsing a URL given url, relative to settings.\n      urlRecord = new URL(url, settings.settingsObject.baseUrl)\n      this.#state.origin = urlRecord.origin\n    } catch (e) {\n      // 4. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError')\n    }\n\n    // 5. Set ev's url to urlRecord.\n    this.#url = urlRecord.href\n\n    // 6. Let corsAttributeState be Anonymous.\n    let corsAttributeState = ANONYMOUS\n\n    // 7. If the value of eventSourceInitDict's withCredentials member is true,\n    // then set corsAttributeState to Use Credentials and set ev's\n    // withCredentials attribute to true.\n    if (eventSourceInitDict.withCredentials === true) {\n      corsAttributeState = USE_CREDENTIALS\n      this.#withCredentials = true\n    }\n\n    // 8. Let request be the result of creating a potential-CORS request given\n    // urlRecord, the empty string, and corsAttributeState.\n    const initRequest = {\n      redirect: 'follow',\n      keepalive: true,\n      // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes\n      mode: 'cors',\n      credentials: corsAttributeState === 'anonymous'\n        ? 'same-origin'\n        : 'omit',\n      referrer: 'no-referrer'\n    }\n\n    // 9. Set request's client to settings.\n    initRequest.client = environmentSettingsObject.settingsObject\n\n    // 10. User agents may set (`Accept`, `text/event-stream`) in request's header list.\n    initRequest.headersList = [['accept', { name: 'accept', value: 'text/event-stream' }]]\n\n    // 11. Set request's cache mode to \"no-store\".\n    initRequest.cache = 'no-store'\n\n    // 12. Set request's initiator type to \"other\".\n    initRequest.initiator = 'other'\n\n    initRequest.urlList = [new URL(this.#url)]\n\n    // 13. Set ev's request to request.\n    this.#request = makeRequest(initRequest)\n\n    this.#connect()\n  }\n\n  /**\n   * Returns the state of this EventSource object's connection. It can have the\n   * values described below.\n   * @returns {ReadyState}\n   * @readonly\n   */\n  get readyState () {\n    return this.#readyState\n  }\n\n  /**\n   * Returns the URL providing the event stream.\n   * @readonly\n   * @returns {string}\n   */\n  get url () {\n    return this.#url\n  }\n\n  /**\n   * Returns a boolean indicating whether the EventSource object was\n   * instantiated with CORS credentials set (true), or not (false, the default).\n   */\n  get withCredentials () {\n    return this.#withCredentials\n  }\n\n  #connect () {\n    if (this.#readyState === CLOSED) return\n\n    this.#readyState = CONNECTING\n\n    const fetchParams = {\n      request: this.#request,\n      dispatcher: this.#dispatcher\n    }\n\n    // 14. Let processEventSourceEndOfBody given response res be the following step: if res is not a network error, then reestablish the connection.\n    const processEventSourceEndOfBody = (response) => {\n      if (!isNetworkError(response)) {\n        return this.#reconnect()\n      }\n    }\n\n    // 15. Fetch request, with processResponseEndOfBody set to processEventSourceEndOfBody...\n    fetchParams.processResponseEndOfBody = processEventSourceEndOfBody\n\n    // and processResponse set to the following steps given response res:\n    fetchParams.processResponse = (response) => {\n      // 1. If res is an aborted network error, then fail the connection.\n\n      if (isNetworkError(response)) {\n        // 1. When a user agent is to fail the connection, the user agent\n        // must queue a task which, if the readyState attribute is set to a\n        // value other than CLOSED, sets the readyState attribute to CLOSED\n        // and fires an event named error at the EventSource object. Once the\n        // user agent has failed the connection, it does not attempt to\n        // reconnect.\n        if (response.aborted) {\n          this.close()\n          this.dispatchEvent(new Event('error'))\n          return\n          // 2. Otherwise, if res is a network error, then reestablish the\n          // connection, unless the user agent knows that to be futile, in\n          // which case the user agent may fail the connection.\n        } else {\n          this.#reconnect()\n          return\n        }\n      }\n\n      // 3. Otherwise, if res's status is not 200, or if res's `Content-Type`\n      // is not `text/event-stream`, then fail the connection.\n      const contentType = response.headersList.get('content-type', true)\n      const mimeType = contentType !== null ? parseMIMEType(contentType) : 'failure'\n      const contentTypeValid = mimeType !== 'failure' && mimeType.essence === 'text/event-stream'\n      if (\n        response.status !== 200 ||\n        contentTypeValid === false\n      ) {\n        this.close()\n        this.dispatchEvent(new Event('error'))\n        return\n      }\n\n      // 4. Otherwise, announce the connection and interpret res's body\n      // line by line.\n\n      // When a user agent is to announce the connection, the user agent\n      // must queue a task which, if the readyState attribute is set to a\n      // value other than CLOSED, sets the readyState attribute to OPEN\n      // and fires an event named open at the EventSource object.\n      // @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model\n      this.#readyState = OPEN\n      this.dispatchEvent(new Event('open'))\n\n      // If redirected to a different origin, set the origin to the new origin.\n      this.#state.origin = response.urlList[response.urlList.length - 1].origin\n\n      const eventSourceStream = new EventSourceStream({\n        eventSourceSettings: this.#state,\n        push: (event) => {\n          this.dispatchEvent(createFastMessageEvent(\n            event.type,\n            event.options\n          ))\n        }\n      })\n\n      pipeline(response.body.stream,\n        eventSourceStream,\n        (error) => {\n          if (\n            error?.aborted === false\n          ) {\n            this.close()\n            this.dispatchEvent(new Event('error'))\n          }\n        })\n    }\n\n    this.#controller = fetching(fetchParams)\n  }\n\n  /**\n   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model\n   * @returns {Promise<void>}\n   */\n  async #reconnect () {\n    // When a user agent is to reestablish the connection, the user agent must\n    // run the following steps. These steps are run in parallel, not as part of\n    // a task. (The tasks that it queues, of course, are run like normal tasks\n    // and not themselves in parallel.)\n\n    // 1. Queue a task to run the following steps:\n\n    //   1. If the readyState attribute is set to CLOSED, abort the task.\n    if (this.#readyState === CLOSED) return\n\n    //   2. Set the readyState attribute to CONNECTING.\n    this.#readyState = CONNECTING\n\n    //   3. Fire an event named error at the EventSource object.\n    this.dispatchEvent(new Event('error'))\n\n    // 2. Wait a delay equal to the reconnection time of the event source.\n    await delay(this.#state.reconnectionTime)\n\n    // 5. Queue a task to run the following steps:\n\n    //   1. If the EventSource object's readyState attribute is not set to\n    //      CONNECTING, then return.\n    if (this.#readyState !== CONNECTING) return\n\n    //   2. Let request be the EventSource object's request.\n    //   3. If the EventSource object's last event ID string is not the empty\n    //      string, then:\n    //      1. Let lastEventIDValue be the EventSource object's last event ID\n    //         string, encoded as UTF-8.\n    //      2. Set (`Last-Event-ID`, lastEventIDValue) in request's header\n    //         list.\n    if (this.#state.lastEventId.length) {\n      this.#request.headersList.set('last-event-id', this.#state.lastEventId, true)\n    }\n\n    //   4. Fetch request and process the response obtained in this fashion, if any, as described earlier in this section.\n    this.#connect()\n  }\n\n  /**\n   * Closes the connection, if any, and sets the readyState attribute to\n   * CLOSED.\n   */\n  close () {\n    webidl.brandCheck(this, EventSource)\n\n    if (this.#readyState === CLOSED) return\n    this.#readyState = CLOSED\n    this.#controller.abort()\n    this.#request = null\n  }\n\n  get onopen () {\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.open = fn\n      this.addEventListener('open', fn)\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onmessage () {\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.message = fn\n      this.addEventListener('message', fn)\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get onerror () {\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this.#events.error = null\n    }\n  }\n}\n\nconst constantsPropertyDescriptors = {\n  CONNECTING: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: CONNECTING,\n    writable: false\n  },\n  OPEN: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: OPEN,\n    writable: false\n  },\n  CLOSED: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: CLOSED,\n    writable: false\n  }\n}\n\nObject.defineProperties(EventSource, constantsPropertyDescriptors)\nObject.defineProperties(EventSource.prototype, constantsPropertyDescriptors)\n\nObject.defineProperties(EventSource.prototype, {\n  close: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  url: kEnumerableProperty,\n  withCredentials: kEnumerableProperty\n})\n\nwebidl.converters.EventSourceInitDict = webidl.dictionaryConverter([\n  {\n    key: 'withCredentials',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'dispatcher', // undici only\n    converter: webidl.converters.any\n  }\n])\n\nmodule.exports = {\n  EventSource,\n  defaultReconnectionTime\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLG9FQUFVO0FBQ3ZDLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsOEVBQWtCO0FBQ2xELFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0VBQVc7QUFDdEMsUUFBUSxvQkFBb0IsRUFBRSxtQkFBTyxDQUFDLG1HQUFzQjtBQUM1RCxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQ3JELFFBQVEseUJBQXlCLEVBQUUsbUJBQU8sQ0FBQyxvRkFBcUI7QUFDaEUsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLGdGQUFtQjtBQUN0RCxRQUFRLFFBQVEsRUFBRSxtQkFBTyxDQUFDLHVFQUFRO0FBQ2xDLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDekQsUUFBUSw0QkFBNEIsRUFBRSxtQkFBTyxDQUFDLHdFQUFlOztBQUU3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsaUJBQWlCLHVCQUF1QjtBQUNyRDtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsNENBQTRDOztBQUV4RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcGlwZWxpbmUgfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHsgZmV0Y2hpbmcgfSA9IHJlcXVpcmUoJy4uL2ZldGNoJylcbmNvbnN0IHsgbWFrZVJlcXVlc3QgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3JlcXVlc3QnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL3dlYmlkbCcpXG5jb25zdCB7IEV2ZW50U291cmNlU3RyZWFtIH0gPSByZXF1aXJlKCcuL2V2ZW50c291cmNlLXN0cmVhbScpXG5jb25zdCB7IHBhcnNlTUlNRVR5cGUgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGEtdXJsJylcbmNvbnN0IHsgY3JlYXRlRmFzdE1lc3NhZ2VFdmVudCB9ID0gcmVxdWlyZSgnLi4vd2Vic29ja2V0L2V2ZW50cycpXG5jb25zdCB7IGlzTmV0d29ya0Vycm9yIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9yZXNwb25zZScpXG5jb25zdCB7IGRlbGF5IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC91dGlsJylcblxubGV0IGV4cGVyaW1lbnRhbFdhcm5lZCA9IGZhbHNlXG5cbi8qKlxuICogQSByZWNvbm5lY3Rpb24gdGltZSwgaW4gbWlsbGlzZWNvbmRzLiBUaGlzIG11c3QgaW5pdGlhbGx5IGJlIGFuIGltcGxlbWVudGF0aW9uLWRlZmluZWQgdmFsdWUsXG4gKiBwcm9iYWJseSBpbiB0aGUgcmVnaW9uIG9mIGEgZmV3IHNlY29uZHMuXG4gKlxuICogSW4gQ29tcGFyaXNvbjpcbiAqIC0gQ2hyb21lIHVzZXMgMzAwMG1zLlxuICogLSBEZW5vIHVzZXMgNTAwMG1zLlxuICpcbiAqIEB0eXBlIHszMDAwfVxuICovXG5jb25zdCBkZWZhdWx0UmVjb25uZWN0aW9uVGltZSA9IDMwMDBcblxuLyoqXG4gKiBUaGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIGNvbm5lY3Rpb24uXG4gKiBAdHlwZWRlZiBSZWFkeVN0YXRlXG4gKiBAdHlwZSB7MHwxfDJ9XG4gKiBAcmVhZG9ubHlcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWwjZG9tLWV2ZW50c291cmNlLXJlYWR5c3RhdGUtZGV2XG4gKi9cblxuLyoqXG4gKiBUaGUgY29ubmVjdGlvbiBoYXMgbm90IHlldCBiZWVuIGVzdGFibGlzaGVkLCBvciBpdCB3YXMgY2xvc2VkIGFuZCB0aGUgdXNlclxuICogYWdlbnQgaXMgcmVjb25uZWN0aW5nLlxuICogQHR5cGUgezB9XG4gKi9cbmNvbnN0IENPTk5FQ1RJTkcgPSAwXG5cbi8qKlxuICogVGhlIHVzZXIgYWdlbnQgaGFzIGFuIG9wZW4gY29ubmVjdGlvbiBhbmQgaXMgZGlzcGF0Y2hpbmcgZXZlbnRzIGFzIGl0XG4gKiByZWNlaXZlcyB0aGVtLlxuICogQHR5cGUgezF9XG4gKi9cbmNvbnN0IE9QRU4gPSAxXG5cbi8qKlxuICogVGhlIGNvbm5lY3Rpb24gaXMgbm90IG9wZW4sIGFuZCB0aGUgdXNlciBhZ2VudCBpcyBub3QgdHJ5aW5nIHRvIHJlY29ubmVjdC5cbiAqIEB0eXBlIHsyfVxuICovXG5jb25zdCBDTE9TRUQgPSAyXG5cbi8qKlxuICogUmVxdWVzdHMgZm9yIHRoZSBlbGVtZW50IHdpbGwgaGF2ZSB0aGVpciBtb2RlIHNldCB0byBcImNvcnNcIiBhbmQgdGhlaXIgY3JlZGVudGlhbHMgbW9kZSBzZXQgdG8gXCJzYW1lLW9yaWdpblwiLlxuICogQHR5cGUgeydhbm9ueW1vdXMnfVxuICovXG5jb25zdCBBTk9OWU1PVVMgPSAnYW5vbnltb3VzJ1xuXG4vKipcbiAqIFJlcXVlc3RzIGZvciB0aGUgZWxlbWVudCB3aWxsIGhhdmUgdGhlaXIgbW9kZSBzZXQgdG8gXCJjb3JzXCIgYW5kIHRoZWlyIGNyZWRlbnRpYWxzIG1vZGUgc2V0IHRvIFwiaW5jbHVkZVwiLlxuICogQHR5cGUgeyd1c2UtY3JlZGVudGlhbHMnfVxuICovXG5jb25zdCBVU0VfQ1JFREVOVElBTFMgPSAndXNlLWNyZWRlbnRpYWxzJ1xuXG4vKipcbiAqIFRoZSBFdmVudFNvdXJjZSBpbnRlcmZhY2UgaXMgdXNlZCB0byByZWNlaXZlIHNlcnZlci1zZW50IGV2ZW50cy4gSXRcbiAqIGNvbm5lY3RzIHRvIGEgc2VydmVyIG92ZXIgSFRUUCBhbmQgcmVjZWl2ZXMgZXZlbnRzIGluIHRleHQvZXZlbnQtc3RyZWFtXG4gKiBmb3JtYXQgd2l0aG91dCBjbG9zaW5nIHRoZSBjb25uZWN0aW9uLlxuICogQGV4dGVuZHMge0V2ZW50VGFyZ2V0fVxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZXJ2ZXItc2VudC1ldmVudHMuaHRtbCNzZXJ2ZXItc2VudC1ldmVudHNcbiAqIEBhcGkgcHVibGljXG4gKi9cbmNsYXNzIEV2ZW50U291cmNlIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAjZXZlbnRzID0ge1xuICAgIG9wZW46IG51bGwsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgbWVzc2FnZTogbnVsbFxuICB9XG5cbiAgI3VybFxuICAjd2l0aENyZWRlbnRpYWxzID0gZmFsc2VcblxuICAvKipcbiAgICogQHR5cGUge1JlYWR5U3RhdGV9XG4gICAqL1xuICAjcmVhZHlTdGF0ZSA9IENPTk5FQ1RJTkdcblxuICAjcmVxdWVzdCA9IG51bGxcbiAgI2NvbnRyb2xsZXIgPSBudWxsXG5cbiAgI2Rpc3BhdGNoZXJcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnLi9ldmVudHNvdXJjZS1zdHJlYW0nKS5ldmVudFNvdXJjZVNldHRpbmdzfVxuICAgKi9cbiAgI3N0YXRlXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRXZlbnRTb3VyY2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7RXZlbnRTb3VyY2VJbml0fSBbZXZlbnRTb3VyY2VJbml0RGljdD17fV1cbiAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZXJ2ZXItc2VudC1ldmVudHMuaHRtbCN0aGUtZXZlbnRzb3VyY2UtaW50ZXJmYWNlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodXJsLCBldmVudFNvdXJjZUluaXREaWN0ID0ge30pIHtcbiAgICAvLyAxLiBMZXQgZXYgYmUgYSBuZXcgRXZlbnRTb3VyY2Ugb2JqZWN0LlxuICAgIHN1cGVyKClcblxuICAgIHdlYmlkbC51dGlsLm1hcmtBc1VuY2xvbmVhYmxlKHRoaXMpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnRXZlbnRTb3VyY2UgY29uc3RydWN0b3InXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBpZiAoIWV4cGVyaW1lbnRhbFdhcm5lZCkge1xuICAgICAgZXhwZXJpbWVudGFsV2FybmVkID0gdHJ1ZVxuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZygnRXZlbnRTb3VyY2UgaXMgZXhwZXJpbWVudGFsLCBleHBlY3QgdGhlbSB0byBjaGFuZ2UgYXQgYW55IHRpbWUuJywge1xuICAgICAgICBjb2RlOiAnVU5ESUNJLUVTJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICB1cmwgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodXJsKVxuICAgIGV2ZW50U291cmNlSW5pdERpY3QgPSB3ZWJpZGwuY29udmVydGVycy5FdmVudFNvdXJjZUluaXREaWN0KGV2ZW50U291cmNlSW5pdERpY3QsIHByZWZpeCwgJ2V2ZW50U291cmNlSW5pdERpY3QnKVxuXG4gICAgdGhpcy4jZGlzcGF0Y2hlciA9IGV2ZW50U291cmNlSW5pdERpY3QuZGlzcGF0Y2hlclxuICAgIHRoaXMuI3N0YXRlID0ge1xuICAgICAgbGFzdEV2ZW50SWQ6ICcnLFxuICAgICAgcmVjb25uZWN0aW9uVGltZTogZGVmYXVsdFJlY29ubmVjdGlvblRpbWVcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgc2V0dGluZ3MgYmUgZXYncyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI2Vudmlyb25tZW50LXNldHRpbmdzLW9iamVjdFxuICAgIGNvbnN0IHNldHRpbmdzID0gZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdFxuXG4gICAgbGV0IHVybFJlY29yZFxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIDMuIExldCB1cmxSZWNvcmQgYmUgdGhlIHJlc3VsdCBvZiBlbmNvZGluZy1wYXJzaW5nIGEgVVJMIGdpdmVuIHVybCwgcmVsYXRpdmUgdG8gc2V0dGluZ3MuXG4gICAgICB1cmxSZWNvcmQgPSBuZXcgVVJMKHVybCwgc2V0dGluZ3Muc2V0dGluZ3NPYmplY3QuYmFzZVVybClcbiAgICAgIHRoaXMuI3N0YXRlLm9yaWdpbiA9IHVybFJlY29yZC5vcmlnaW5cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyA0LiBJZiB1cmxSZWNvcmQgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFwiU3ludGF4RXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGUsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gNS4gU2V0IGV2J3MgdXJsIHRvIHVybFJlY29yZC5cbiAgICB0aGlzLiN1cmwgPSB1cmxSZWNvcmQuaHJlZlxuXG4gICAgLy8gNi4gTGV0IGNvcnNBdHRyaWJ1dGVTdGF0ZSBiZSBBbm9ueW1vdXMuXG4gICAgbGV0IGNvcnNBdHRyaWJ1dGVTdGF0ZSA9IEFOT05ZTU9VU1xuXG4gICAgLy8gNy4gSWYgdGhlIHZhbHVlIG9mIGV2ZW50U291cmNlSW5pdERpY3QncyB3aXRoQ3JlZGVudGlhbHMgbWVtYmVyIGlzIHRydWUsXG4gICAgLy8gdGhlbiBzZXQgY29yc0F0dHJpYnV0ZVN0YXRlIHRvIFVzZSBDcmVkZW50aWFscyBhbmQgc2V0IGV2J3NcbiAgICAvLyB3aXRoQ3JlZGVudGlhbHMgYXR0cmlidXRlIHRvIHRydWUuXG4gICAgaWYgKGV2ZW50U291cmNlSW5pdERpY3Qud2l0aENyZWRlbnRpYWxzID09PSB0cnVlKSB7XG4gICAgICBjb3JzQXR0cmlidXRlU3RhdGUgPSBVU0VfQ1JFREVOVElBTFNcbiAgICAgIHRoaXMuI3dpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICB9XG5cbiAgICAvLyA4LiBMZXQgcmVxdWVzdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgcG90ZW50aWFsLUNPUlMgcmVxdWVzdCBnaXZlblxuICAgIC8vIHVybFJlY29yZCwgdGhlIGVtcHR5IHN0cmluZywgYW5kIGNvcnNBdHRyaWJ1dGVTdGF0ZS5cbiAgICBjb25zdCBpbml0UmVxdWVzdCA9IHtcbiAgICAgIHJlZGlyZWN0OiAnZm9sbG93JyxcbiAgICAgIGtlZXBhbGl2ZTogdHJ1ZSxcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdXJscy1hbmQtZmV0Y2hpbmcuaHRtbCNjb3JzLXNldHRpbmdzLWF0dHJpYnV0ZXNcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgIGNyZWRlbnRpYWxzOiBjb3JzQXR0cmlidXRlU3RhdGUgPT09ICdhbm9ueW1vdXMnXG4gICAgICAgID8gJ3NhbWUtb3JpZ2luJ1xuICAgICAgICA6ICdvbWl0JyxcbiAgICAgIHJlZmVycmVyOiAnbm8tcmVmZXJyZXInXG4gICAgfVxuXG4gICAgLy8gOS4gU2V0IHJlcXVlc3QncyBjbGllbnQgdG8gc2V0dGluZ3MuXG4gICAgaW5pdFJlcXVlc3QuY2xpZW50ID0gZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdC5zZXR0aW5nc09iamVjdFxuXG4gICAgLy8gMTAuIFVzZXIgYWdlbnRzIG1heSBzZXQgKGBBY2NlcHRgLCBgdGV4dC9ldmVudC1zdHJlYW1gKSBpbiByZXF1ZXN0J3MgaGVhZGVyIGxpc3QuXG4gICAgaW5pdFJlcXVlc3QuaGVhZGVyc0xpc3QgPSBbWydhY2NlcHQnLCB7IG5hbWU6ICdhY2NlcHQnLCB2YWx1ZTogJ3RleHQvZXZlbnQtc3RyZWFtJyB9XV1cblxuICAgIC8vIDExLiBTZXQgcmVxdWVzdCdzIGNhY2hlIG1vZGUgdG8gXCJuby1zdG9yZVwiLlxuICAgIGluaXRSZXF1ZXN0LmNhY2hlID0gJ25vLXN0b3JlJ1xuXG4gICAgLy8gMTIuIFNldCByZXF1ZXN0J3MgaW5pdGlhdG9yIHR5cGUgdG8gXCJvdGhlclwiLlxuICAgIGluaXRSZXF1ZXN0LmluaXRpYXRvciA9ICdvdGhlcidcblxuICAgIGluaXRSZXF1ZXN0LnVybExpc3QgPSBbbmV3IFVSTCh0aGlzLiN1cmwpXVxuXG4gICAgLy8gMTMuIFNldCBldidzIHJlcXVlc3QgdG8gcmVxdWVzdC5cbiAgICB0aGlzLiNyZXF1ZXN0ID0gbWFrZVJlcXVlc3QoaW5pdFJlcXVlc3QpXG5cbiAgICB0aGlzLiNjb25uZWN0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSBvZiB0aGlzIEV2ZW50U291cmNlIG9iamVjdCdzIGNvbm5lY3Rpb24uIEl0IGNhbiBoYXZlIHRoZVxuICAgKiB2YWx1ZXMgZGVzY3JpYmVkIGJlbG93LlxuICAgKiBAcmV0dXJucyB7UmVhZHlTdGF0ZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcmVhZHlTdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWR5U3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBVUkwgcHJvdmlkaW5nIHRoZSBldmVudCBzdHJlYW0uXG4gICAqIEByZWFkb25seVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHVybCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VybFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgRXZlbnRTb3VyY2Ugb2JqZWN0IHdhc1xuICAgKiBpbnN0YW50aWF0ZWQgd2l0aCBDT1JTIGNyZWRlbnRpYWxzIHNldCAodHJ1ZSksIG9yIG5vdCAoZmFsc2UsIHRoZSBkZWZhdWx0KS5cbiAgICovXG4gIGdldCB3aXRoQ3JlZGVudGlhbHMgKCkge1xuICAgIHJldHVybiB0aGlzLiN3aXRoQ3JlZGVudGlhbHNcbiAgfVxuXG4gICNjb25uZWN0ICgpIHtcbiAgICBpZiAodGhpcy4jcmVhZHlTdGF0ZSA9PT0gQ0xPU0VEKSByZXR1cm5cblxuICAgIHRoaXMuI3JlYWR5U3RhdGUgPSBDT05ORUNUSU5HXG5cbiAgICBjb25zdCBmZXRjaFBhcmFtcyA9IHtcbiAgICAgIHJlcXVlc3Q6IHRoaXMuI3JlcXVlc3QsXG4gICAgICBkaXNwYXRjaGVyOiB0aGlzLiNkaXNwYXRjaGVyXG4gICAgfVxuXG4gICAgLy8gMTQuIExldCBwcm9jZXNzRXZlbnRTb3VyY2VFbmRPZkJvZHkgZ2l2ZW4gcmVzcG9uc2UgcmVzIGJlIHRoZSBmb2xsb3dpbmcgc3RlcDogaWYgcmVzIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IsIHRoZW4gcmVlc3RhYmxpc2ggdGhlIGNvbm5lY3Rpb24uXG4gICAgY29uc3QgcHJvY2Vzc0V2ZW50U291cmNlRW5kT2ZCb2R5ID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAoIWlzTmV0d29ya0Vycm9yKHJlc3BvbnNlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcmVjb25uZWN0KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAxNS4gRmV0Y2ggcmVxdWVzdCwgd2l0aCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgc2V0IHRvIHByb2Nlc3NFdmVudFNvdXJjZUVuZE9mQm9keS4uLlxuICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSA9IHByb2Nlc3NFdmVudFNvdXJjZUVuZE9mQm9keVxuXG4gICAgLy8gYW5kIHByb2Nlc3NSZXNwb25zZSBzZXQgdG8gdGhlIGZvbGxvd2luZyBzdGVwcyBnaXZlbiByZXNwb25zZSByZXM6XG4gICAgZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICAvLyAxLiBJZiByZXMgaXMgYW4gYWJvcnRlZCBuZXR3b3JrIGVycm9yLCB0aGVuIGZhaWwgdGhlIGNvbm5lY3Rpb24uXG5cbiAgICAgIGlmIChpc05ldHdvcmtFcnJvcihyZXNwb25zZSkpIHtcbiAgICAgICAgLy8gMS4gV2hlbiBhIHVzZXIgYWdlbnQgaXMgdG8gZmFpbCB0aGUgY29ubmVjdGlvbiwgdGhlIHVzZXIgYWdlbnRcbiAgICAgICAgLy8gbXVzdCBxdWV1ZSBhIHRhc2sgd2hpY2gsIGlmIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYVxuICAgICAgICAvLyB2YWx1ZSBvdGhlciB0aGFuIENMT1NFRCwgc2V0cyB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgdG8gQ0xPU0VEXG4gICAgICAgIC8vIGFuZCBmaXJlcyBhbiBldmVudCBuYW1lZCBlcnJvciBhdCB0aGUgRXZlbnRTb3VyY2Ugb2JqZWN0LiBPbmNlIHRoZVxuICAgICAgICAvLyB1c2VyIGFnZW50IGhhcyBmYWlsZWQgdGhlIGNvbm5lY3Rpb24sIGl0IGRvZXMgbm90IGF0dGVtcHQgdG9cbiAgICAgICAgLy8gcmVjb25uZWN0LlxuICAgICAgICBpZiAocmVzcG9uc2UuYWJvcnRlZCkge1xuICAgICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Vycm9yJykpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgLy8gMi4gT3RoZXJ3aXNlLCBpZiByZXMgaXMgYSBuZXR3b3JrIGVycm9yLCB0aGVuIHJlZXN0YWJsaXNoIHRoZVxuICAgICAgICAgIC8vIGNvbm5lY3Rpb24sIHVubGVzcyB0aGUgdXNlciBhZ2VudCBrbm93cyB0aGF0IHRvIGJlIGZ1dGlsZSwgaW5cbiAgICAgICAgICAvLyB3aGljaCBjYXNlIHRoZSB1c2VyIGFnZW50IG1heSBmYWlsIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuI3JlY29ubmVjdCgpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gMy4gT3RoZXJ3aXNlLCBpZiByZXMncyBzdGF0dXMgaXMgbm90IDIwMCwgb3IgaWYgcmVzJ3MgYENvbnRlbnQtVHlwZWBcbiAgICAgIC8vIGlzIG5vdCBgdGV4dC9ldmVudC1zdHJlYW1gLCB0aGVuIGZhaWwgdGhlIGNvbm5lY3Rpb24uXG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnY29udGVudC10eXBlJywgdHJ1ZSlcbiAgICAgIGNvbnN0IG1pbWVUeXBlID0gY29udGVudFR5cGUgIT09IG51bGwgPyBwYXJzZU1JTUVUeXBlKGNvbnRlbnRUeXBlKSA6ICdmYWlsdXJlJ1xuICAgICAgY29uc3QgY29udGVudFR5cGVWYWxpZCA9IG1pbWVUeXBlICE9PSAnZmFpbHVyZScgJiYgbWltZVR5cGUuZXNzZW5jZSA9PT0gJ3RleHQvZXZlbnQtc3RyZWFtJ1xuICAgICAgaWYgKFxuICAgICAgICByZXNwb25zZS5zdGF0dXMgIT09IDIwMCB8fFxuICAgICAgICBjb250ZW50VHlwZVZhbGlkID09PSBmYWxzZVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNC4gT3RoZXJ3aXNlLCBhbm5vdW5jZSB0aGUgY29ubmVjdGlvbiBhbmQgaW50ZXJwcmV0IHJlcydzIGJvZHlcbiAgICAgIC8vIGxpbmUgYnkgbGluZS5cblxuICAgICAgLy8gV2hlbiBhIHVzZXIgYWdlbnQgaXMgdG8gYW5ub3VuY2UgdGhlIGNvbm5lY3Rpb24sIHRoZSB1c2VyIGFnZW50XG4gICAgICAvLyBtdXN0IHF1ZXVlIGEgdGFzayB3aGljaCwgaWYgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIGlzIHNldCB0byBhXG4gICAgICAvLyB2YWx1ZSBvdGhlciB0aGFuIENMT1NFRCwgc2V0cyB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgdG8gT1BFTlxuICAgICAgLy8gYW5kIGZpcmVzIGFuIGV2ZW50IG5hbWVkIG9wZW4gYXQgdGhlIEV2ZW50U291cmNlIG9iamVjdC5cbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWwjc3NlLXByb2Nlc3NpbmctbW9kZWxcbiAgICAgIHRoaXMuI3JlYWR5U3RhdGUgPSBPUEVOXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdvcGVuJykpXG5cbiAgICAgIC8vIElmIHJlZGlyZWN0ZWQgdG8gYSBkaWZmZXJlbnQgb3JpZ2luLCBzZXQgdGhlIG9yaWdpbiB0byB0aGUgbmV3IG9yaWdpbi5cbiAgICAgIHRoaXMuI3N0YXRlLm9yaWdpbiA9IHJlc3BvbnNlLnVybExpc3RbcmVzcG9uc2UudXJsTGlzdC5sZW5ndGggLSAxXS5vcmlnaW5cblxuICAgICAgY29uc3QgZXZlbnRTb3VyY2VTdHJlYW0gPSBuZXcgRXZlbnRTb3VyY2VTdHJlYW0oe1xuICAgICAgICBldmVudFNvdXJjZVNldHRpbmdzOiB0aGlzLiNzdGF0ZSxcbiAgICAgICAgcHVzaDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNyZWF0ZUZhc3RNZXNzYWdlRXZlbnQoXG4gICAgICAgICAgICBldmVudC50eXBlLFxuICAgICAgICAgICAgZXZlbnQub3B0aW9uc1xuICAgICAgICAgICkpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHBpcGVsaW5lKHJlc3BvbnNlLmJvZHkuc3RyZWFtLFxuICAgICAgICBldmVudFNvdXJjZVN0cmVhbSxcbiAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZXJyb3I/LmFib3J0ZWQgPT09IGZhbHNlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Vycm9yJykpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuI2NvbnRyb2xsZXIgPSBmZXRjaGluZyhmZXRjaFBhcmFtcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sI3NzZS1wcm9jZXNzaW5nLW1vZGVsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgI3JlY29ubmVjdCAoKSB7XG4gICAgLy8gV2hlbiBhIHVzZXIgYWdlbnQgaXMgdG8gcmVlc3RhYmxpc2ggdGhlIGNvbm5lY3Rpb24sIHRoZSB1c2VyIGFnZW50IG11c3RcbiAgICAvLyBydW4gdGhlIGZvbGxvd2luZyBzdGVwcy4gVGhlc2Ugc3RlcHMgYXJlIHJ1biBpbiBwYXJhbGxlbCwgbm90IGFzIHBhcnQgb2ZcbiAgICAvLyBhIHRhc2suIChUaGUgdGFza3MgdGhhdCBpdCBxdWV1ZXMsIG9mIGNvdXJzZSwgYXJlIHJ1biBsaWtlIG5vcm1hbCB0YXNrc1xuICAgIC8vIGFuZCBub3QgdGhlbXNlbHZlcyBpbiBwYXJhbGxlbC4pXG5cbiAgICAvLyAxLiBRdWV1ZSBhIHRhc2sgdG8gcnVuIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG5cbiAgICAvLyAgIDEuIElmIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSBpcyBzZXQgdG8gQ0xPU0VELCBhYm9ydCB0aGUgdGFzay5cbiAgICBpZiAodGhpcy4jcmVhZHlTdGF0ZSA9PT0gQ0xPU0VEKSByZXR1cm5cblxuICAgIC8vICAgMi4gU2V0IHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSB0byBDT05ORUNUSU5HLlxuICAgIHRoaXMuI3JlYWR5U3RhdGUgPSBDT05ORUNUSU5HXG5cbiAgICAvLyAgIDMuIEZpcmUgYW4gZXZlbnQgbmFtZWQgZXJyb3IgYXQgdGhlIEV2ZW50U291cmNlIG9iamVjdC5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKVxuXG4gICAgLy8gMi4gV2FpdCBhIGRlbGF5IGVxdWFsIHRvIHRoZSByZWNvbm5lY3Rpb24gdGltZSBvZiB0aGUgZXZlbnQgc291cmNlLlxuICAgIGF3YWl0IGRlbGF5KHRoaXMuI3N0YXRlLnJlY29ubmVjdGlvblRpbWUpXG5cbiAgICAvLyA1LiBRdWV1ZSBhIHRhc2sgdG8gcnVuIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG5cbiAgICAvLyAgIDEuIElmIHRoZSBFdmVudFNvdXJjZSBvYmplY3QncyByZWFkeVN0YXRlIGF0dHJpYnV0ZSBpcyBub3Qgc2V0IHRvXG4gICAgLy8gICAgICBDT05ORUNUSU5HLCB0aGVuIHJldHVybi5cbiAgICBpZiAodGhpcy4jcmVhZHlTdGF0ZSAhPT0gQ09OTkVDVElORykgcmV0dXJuXG5cbiAgICAvLyAgIDIuIExldCByZXF1ZXN0IGJlIHRoZSBFdmVudFNvdXJjZSBvYmplY3QncyByZXF1ZXN0LlxuICAgIC8vICAgMy4gSWYgdGhlIEV2ZW50U291cmNlIG9iamVjdCdzIGxhc3QgZXZlbnQgSUQgc3RyaW5nIGlzIG5vdCB0aGUgZW1wdHlcbiAgICAvLyAgICAgIHN0cmluZywgdGhlbjpcbiAgICAvLyAgICAgIDEuIExldCBsYXN0RXZlbnRJRFZhbHVlIGJlIHRoZSBFdmVudFNvdXJjZSBvYmplY3QncyBsYXN0IGV2ZW50IElEXG4gICAgLy8gICAgICAgICBzdHJpbmcsIGVuY29kZWQgYXMgVVRGLTguXG4gICAgLy8gICAgICAyLiBTZXQgKGBMYXN0LUV2ZW50LUlEYCwgbGFzdEV2ZW50SURWYWx1ZSkgaW4gcmVxdWVzdCdzIGhlYWRlclxuICAgIC8vICAgICAgICAgbGlzdC5cbiAgICBpZiAodGhpcy4jc3RhdGUubGFzdEV2ZW50SWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLiNyZXF1ZXN0LmhlYWRlcnNMaXN0LnNldCgnbGFzdC1ldmVudC1pZCcsIHRoaXMuI3N0YXRlLmxhc3RFdmVudElkLCB0cnVlKVxuICAgIH1cblxuICAgIC8vICAgNC4gRmV0Y2ggcmVxdWVzdCBhbmQgcHJvY2VzcyB0aGUgcmVzcG9uc2Ugb2J0YWluZWQgaW4gdGhpcyBmYXNoaW9uLCBpZiBhbnksIGFzIGRlc2NyaWJlZCBlYXJsaWVyIGluIHRoaXMgc2VjdGlvbi5cbiAgICB0aGlzLiNjb25uZWN0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24sIGlmIGFueSwgYW5kIHNldHMgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHRvXG4gICAqIENMT1NFRC5cbiAgICovXG4gIGNsb3NlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFdmVudFNvdXJjZSlcblxuICAgIGlmICh0aGlzLiNyZWFkeVN0YXRlID09PSBDTE9TRUQpIHJldHVyblxuICAgIHRoaXMuI3JlYWR5U3RhdGUgPSBDTE9TRURcbiAgICB0aGlzLiNjb250cm9sbGVyLmFib3J0KClcbiAgICB0aGlzLiNyZXF1ZXN0ID0gbnVsbFxuICB9XG5cbiAgZ2V0IG9ub3BlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5vcGVuXG4gIH1cblxuICBzZXQgb25vcGVuIChmbikge1xuICAgIGlmICh0aGlzLiNldmVudHMub3Blbikge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgdGhpcy4jZXZlbnRzLm9wZW4pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLm9wZW4gPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5vcGVuID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbm1lc3NhZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLiNldmVudHMubWVzc2FnZVxuICB9XG5cbiAgc2V0IG9ubWVzc2FnZSAoZm4pIHtcbiAgICBpZiAodGhpcy4jZXZlbnRzLm1lc3NhZ2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuI2V2ZW50cy5tZXNzYWdlKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5tZXNzYWdlID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMubWVzc2FnZSA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25lcnJvciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5lcnJvclxuICB9XG5cbiAgc2V0IG9uZXJyb3IgKGZuKSB7XG4gICAgaWYgKHRoaXMuI2V2ZW50cy5lcnJvcikge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuI2V2ZW50cy5lcnJvcilcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMuZXJyb3IgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMuZXJyb3IgPSBudWxsXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGNvbnN0YW50c1Byb3BlcnR5RGVzY3JpcHRvcnMgPSB7XG4gIENPTk5FQ1RJTkc6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBDT05ORUNUSU5HLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9LFxuICBPUEVOOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogT1BFTixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSxcbiAgQ0xPU0VEOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogQ0xPU0VELFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEV2ZW50U291cmNlLCBjb25zdGFudHNQcm9wZXJ0eURlc2NyaXB0b3JzKVxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRXZlbnRTb3VyY2UucHJvdG90eXBlLCBjb25zdGFudHNQcm9wZXJ0eURlc2NyaXB0b3JzKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFdmVudFNvdXJjZS5wcm90b3R5cGUsIHtcbiAgY2xvc2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9uZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ubWVzc2FnZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25vcGVuOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkeVN0YXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICB1cmw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHdpdGhDcmVkZW50aWFsczoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuRXZlbnRTb3VyY2VJbml0RGljdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ3dpdGhDcmVkZW50aWFscycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2Rpc3BhdGNoZXInLCAvLyB1bmRpY2kgb25seVxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55XG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFdmVudFNvdXJjZSxcbiAgZGVmYXVsdFJlY29ubmVjdGlvblRpbWVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/eventsource/eventsource.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/eventsource/util.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/util.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Checks if the given value is a valid LastEventId.\n * @param {string} value\n * @returns {boolean}\n */\nfunction isValidLastEventId (value) {\n  // LastEventId should not contain U+0000 NULL\n  return value.indexOf('\\u0000') === -1\n}\n\n/**\n * Checks if the given value is a base 10 digit.\n * @param {string} value\n * @returns {boolean}\n */\nfunction isASCIINumber (value) {\n  if (value.length === 0) return false\n  for (let i = 0; i < value.length; i++) {\n    if (value.charCodeAt(i) < 0x30 || value.charCodeAt(i) > 0x39) return false\n  }\n  return true\n}\n\n// https://github.com/nodejs/undici/issues/2664\nfunction delay (ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n\nmodule.exports = {\n  isValidLastEventId,\n  isASCIINumber,\n  delay\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgTGFzdEV2ZW50SWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkTGFzdEV2ZW50SWQgKHZhbHVlKSB7XG4gIC8vIExhc3RFdmVudElkIHNob3VsZCBub3QgY29udGFpbiBVKzAwMDAgTlVMTFxuICByZXR1cm4gdmFsdWUuaW5kZXhPZignXFx1MDAwMCcpID09PSAtMVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBiYXNlIDEwIGRpZ2l0LlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNBU0NJSU51bWJlciAodmFsdWUpIHtcbiAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodmFsdWUuY2hhckNvZGVBdChpKSA8IDB4MzAgfHwgdmFsdWUuY2hhckNvZGVBdChpKSA+IDB4MzkpIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yNjY0XG5mdW5jdGlvbiBkZWxheSAobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgc2V0VGltZW91dChyZXNvbHZlLCBtcylcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzVmFsaWRMYXN0RXZlbnRJZCxcbiAgaXNBU0NJSU51bWJlcixcbiAgZGVsYXlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/eventsource/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/body.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/body.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst util = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst {\n  ReadableStreamFrom,\n  readableStreamClose,\n  createDeferredPromise,\n  fullyReadBody,\n  extractMimeType,\n  utf8DecodeBytes\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { FormData, setFormDataState } = __webpack_require__(/*! ./formdata */ \"(rsc)/./node_modules/undici/lib/web/fetch/formdata.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { Blob } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { isErrored, isDisturbed } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { isArrayBuffer } = __webpack_require__(/*! node:util/types */ \"node:util/types\")\nconst { serializeAMimeType } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { multipartFormDataParser } = __webpack_require__(/*! ./formdata-parser */ \"(rsc)/./node_modules/undici/lib/web/fetch/formdata-parser.js\")\nlet random\n\ntry {\n  const crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\")\n  random = (max) => crypto.randomInt(0, max)\n} catch {\n  random = (max) => Math.floor(Math.random() * max)\n}\n\nconst textEncoder = new TextEncoder()\nfunction noop () {}\n\nconst hasFinalizationRegistry = globalThis.FinalizationRegistry\nlet streamRegistry\n\nif (hasFinalizationRegistry) {\n  streamRegistry = new FinalizationRegistry((weakRef) => {\n    const stream = weakRef.deref()\n    if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {\n      stream.cancel('Response object has been garbage collected').catch(noop)\n    }\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody (object, keepalive = false) {\n  // 1. Let stream be null.\n  let stream = null\n\n  // 2. If object is a ReadableStream object, then set stream to object.\n  if (webidl.is.ReadableStream(object)) {\n    stream = object\n  } else if (webidl.is.Blob(object)) {\n    // 3. Otherwise, if object is a Blob object, set stream to the\n    //    result of running objects get stream.\n    stream = object.stream()\n  } else {\n    // 4. Otherwise, set stream to a new ReadableStream object, and set\n    //    up stream with byte reading support.\n    stream = new ReadableStream({\n      async pull (controller) {\n        const buffer = typeof source === 'string' ? textEncoder.encode(source) : source\n\n        if (buffer.byteLength) {\n          controller.enqueue(buffer)\n        }\n\n        queueMicrotask(() => readableStreamClose(controller))\n      },\n      start () {},\n      type: 'bytes'\n    })\n  }\n\n  // 5. Assert: stream is a ReadableStream object.\n  assert(webidl.is.ReadableStream(stream))\n\n  // 6. Let action be null.\n  let action = null\n\n  // 7. Let source be null.\n  let source = null\n\n  // 8. Let length be null.\n  let length = null\n\n  // 9. Let type be null.\n  let type = null\n\n  // 10. Switch on object:\n  if (typeof object === 'string') {\n    // Set source to the UTF-8 encoding of object.\n    // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n    source = object\n\n    // Set type to `text/plain;charset=UTF-8`.\n    type = 'text/plain;charset=UTF-8'\n  } else if (webidl.is.URLSearchParams(object)) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with objects list.\n    source = object.toString()\n\n    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    type = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice())\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength))\n  } else if (webidl.is.FormData(object)) {\n    const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, '0')}`\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */\n    const escape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with objects entry list and UTF-8.\n    // - This ensures that the body is immutable and can't be changed afterwords\n    // - That the content-length is calculated in advance.\n    // - And that all parts are pre-encoded and ready to be sent.\n\n    const blobParts = []\n    const rn = new Uint8Array([13, 10]) // '\\r\\n'\n    length = 0\n    let hasUnknownSizeValue = false\n\n    for (const [name, value] of object) {\n      if (typeof value === 'string') {\n        const chunk = textEncoder.encode(prefix +\n          `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`)\n        blobParts.push(chunk)\n        length += chunk.byteLength\n      } else {\n        const chunk = textEncoder.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' +\n          `Content-Type: ${\n            value.type || 'application/octet-stream'\n          }\\r\\n\\r\\n`)\n        blobParts.push(chunk, value, rn)\n        if (typeof value.size === 'number') {\n          length += chunk.byteLength + value.size + rn.byteLength\n        } else {\n          hasUnknownSizeValue = true\n        }\n      }\n    }\n\n    // CRLF is appended to the body to function with legacy servers and match other implementations.\n    // https://github.com/curl/curl/blob/3434c6b46e682452973972e8313613dfa58cd690/lib/mime.c#L1029-L1030\n    // https://github.com/form-data/form-data/issues/63\n    const chunk = textEncoder.encode(`--${boundary}--\\r\\n`)\n    blobParts.push(chunk)\n    length += chunk.byteLength\n    if (hasUnknownSizeValue) {\n      length = null\n    }\n\n    // Set source to object.\n    source = object\n\n    action = async function * () {\n      for (const part of blobParts) {\n        if (part.stream) {\n          yield * part.stream()\n        } else {\n          yield part\n        }\n      }\n    }\n\n    // Set type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    type = `multipart/form-data; boundary=${boundary}`\n  } else if (webidl.is.Blob(object)) {\n    // Blob\n\n    // Set source to object.\n    source = object\n\n    // Set length to objects size.\n    length = object.size\n\n    // If objects type attribute is not the empty byte sequence, set\n    // type to its value.\n    if (object.type) {\n      type = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      webidl.is.ReadableStream(object) ? object : ReadableStreamFrom(object)\n  }\n\n  // 11. If source is a byte sequence, then set action to a\n  // step that returns source and length to sources length.\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source)\n  }\n\n  // 12. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator\n    stream = new ReadableStream({\n      async start () {\n        iterator = action(object)[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { value, done } = await iterator.next()\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close()\n            controller.byobRequest?.respond(0)\n          })\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            const buffer = new Uint8Array(value)\n            if (buffer.byteLength) {\n              controller.enqueue(buffer)\n            }\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      },\n      type: 'bytes'\n    })\n  }\n\n  // 13. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 14. Return (body, type).\n  return [body, type]\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody (object, keepalive = false) {\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (webidl.is.ReadableStream(object)) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'The body has already been consumed.')\n    // istanbul ignore next\n    assert(!object.locked, 'The stream is locked.')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (instance, body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let  out1, out2  be the result of teeing bodys stream.\n  const [out1, out2] = body.stream.tee()\n\n  if (hasFinalizationRegistry) {\n    streamRegistry.register(instance, new WeakRef(out1))\n  }\n\n  // 2. Set bodys stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  }\n}\n\nfunction throwIfAborted (state) {\n  if (state.aborted) {\n    throw new DOMException('The operation was aborted.', 'AbortError')\n  }\n}\n\nfunction bodyMixinMethods (instance, getInternalState) {\n  const methods = {\n    blob () {\n      // The blob() method steps are to return the result of\n      // running consume body with this and the following step\n      // given a byte sequence bytes: return a Blob whose\n      // contents are bytes and whose type attribute is thiss\n      // MIME type.\n      return consumeBody(this, (bytes) => {\n        let mimeType = bodyMimeType(getInternalState(this))\n\n        if (mimeType === null) {\n          mimeType = ''\n        } else if (mimeType) {\n          mimeType = serializeAMimeType(mimeType)\n        }\n\n        // Return a Blob whose contents are bytes and type attribute\n        // is mimeType.\n        return new Blob([bytes], { type: mimeType })\n      }, instance, getInternalState)\n    },\n\n    arrayBuffer () {\n      // The arrayBuffer() method steps are to return the result\n      // of running consume body with this and the following step\n      // given a byte sequence bytes: return a new ArrayBuffer\n      // whose contents are bytes.\n      return consumeBody(this, (bytes) => {\n        return new Uint8Array(bytes).buffer\n      }, instance, getInternalState)\n    },\n\n    text () {\n      // The text() method steps are to return the result of running\n      // consume body with this and UTF-8 decode.\n      return consumeBody(this, utf8DecodeBytes, instance, getInternalState)\n    },\n\n    json () {\n      // The json() method steps are to return the result of running\n      // consume body with this and parse JSON from bytes.\n      return consumeBody(this, parseJSONFromBytes, instance, getInternalState)\n    },\n\n    formData () {\n      // The formData() method steps are to return the result of running\n      // consume body with this and the following step given a byte sequence bytes:\n      return consumeBody(this, (value) => {\n        // 1. Let mimeType be the result of get the MIME type with this.\n        const mimeType = bodyMimeType(getInternalState(this))\n\n        // 2. If mimeType is non-null, then switch on mimeTypes essence and run\n        //    the corresponding steps:\n        if (mimeType !== null) {\n          switch (mimeType.essence) {\n            case 'multipart/form-data': {\n              // 1. ... [long step]\n              // 2. If that fails for some reason, then throw a TypeError.\n              const parsed = multipartFormDataParser(value, mimeType)\n\n              // 3. Return a new FormData object, appending each entry,\n              //    resulting from the parsing operation, to its entry list.\n              const fd = new FormData()\n              setFormDataState(fd, parsed)\n\n              return fd\n            }\n            case 'application/x-www-form-urlencoded': {\n              // 1. Let entries be the result of parsing bytes.\n              const entries = new URLSearchParams(value.toString())\n\n              // 2. If entries is failure, then throw a TypeError.\n\n              // 3. Return a new FormData object whose entry list is entries.\n              const fd = new FormData()\n\n              for (const [name, value] of entries) {\n                fd.append(name, value)\n              }\n\n              return fd\n            }\n          }\n        }\n\n        // 3. Throw a TypeError.\n        throw new TypeError(\n          'Content-Type was not one of \"multipart/form-data\" or \"application/x-www-form-urlencoded\".'\n        )\n      }, instance, getInternalState)\n    },\n\n    bytes () {\n      // The bytes() method steps are to return the result of running consume body\n      // with this and the following step given a byte sequence bytes: return the\n      // result of creating a Uint8Array from bytes in thiss relevant realm.\n      return consumeBody(this, (bytes) => {\n        return new Uint8Array(bytes)\n      }, instance, getInternalState)\n    }\n  }\n\n  return methods\n}\n\nfunction mixinBody (prototype, getInternalState) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype, getInternalState))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {any} object internal state\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {any} instance\n * @param {(target: any) => any} getInternalState\n */\nasync function consumeBody (object, convertBytesToJSValue, instance, getInternalState) {\n  webidl.brandCheck(object, instance)\n\n  const state = getInternalState(object)\n\n  // 1. If object is unusable, then return a promise rejected\n  //    with a TypeError.\n  if (bodyUnusable(state)) {\n    throw new TypeError('Body is unusable: Body has already been read')\n  }\n\n  throwIfAborted(state)\n\n  // 2. Let promise be a new promise.\n  const promise = createDeferredPromise()\n\n  // 3. Let errorSteps given error be to reject promise with error.\n  const errorSteps = (error) => promise.reject(error)\n\n  // 4. Let successSteps given a byte sequence data be to resolve\n  //    promise with the result of running convertBytesToJSValue\n  //    with data. If that threw an exception, then run errorSteps\n  //    with that exception.\n  const successSteps = (data) => {\n    try {\n      promise.resolve(convertBytesToJSValue(data))\n    } catch (e) {\n      errorSteps(e)\n    }\n  }\n\n  // 5. If objects body is null, then run successSteps with an\n  //    empty byte sequence.\n  if (state.body == null) {\n    successSteps(Buffer.allocUnsafe(0))\n    return promise.promise\n  }\n\n  // 6. Otherwise, fully read objects body given successSteps,\n  //    errorSteps, and objects relevant global object.\n  fullyReadBody(state.body, successSteps, errorSteps)\n\n  // 7. Return promise.\n  return promise.promise\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-unusable\n * @param {any} object internal state\n */\nfunction bodyUnusable (object) {\n  const body = object.body\n\n  // An object including the Body interface mixin is\n  // said to be unusable if its body is non-null and\n  // its bodys stream is disturbed or locked.\n  return body != null && (body.stream.locked || util.isDisturbed(body.stream))\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */\nfunction parseJSONFromBytes (bytes) {\n  return JSON.parse(utf8DecodeBytes(bytes))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {any} requestOrResponse internal state\n */\nfunction bodyMimeType (requestOrResponse) {\n  // 1. Let headers be null.\n  // 2. If requestOrResponse is a Request object, then set headers to requestOrResponses requests header list.\n  // 3. Otherwise, set headers to requestOrResponses responses header list.\n  /** @type {import('./headers').HeadersList} */\n  const headers = requestOrResponse.headersList\n\n  // 4. Let mimeType be the result of extracting a MIME type from headers.\n  const mimeType = extractMimeType(headers)\n\n  // 5. If mimeType is failure, then return null.\n  if (mimeType === 'failure') {\n    return null\n  }\n\n  // 6. Return mimeType.\n  return mimeType\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody,\n  streamRegistry,\n  hasFinalizationRegistry,\n  bodyUnusable\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvYm9keS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDcEIsUUFBUSw2QkFBNkIsRUFBRSxtQkFBTyxDQUFDLHlFQUFZO0FBQzNELFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0VBQVc7QUFDdEMsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN0QyxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSx5QkFBeUIsRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3hELFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyx3Q0FBaUI7QUFDbkQsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLHlFQUFZO0FBQ25ELFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQyx1RkFBbUI7QUFDL0Q7O0FBRUE7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN0QztBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxpQkFBaUI7QUFDakI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CLHVCQUF1QjtBQUN2QixJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzREFBc0Q7QUFDdEQsOENBQThDO0FBQzlDLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNkNBQTZDLEdBQUcsYUFBYSxvQkFBb0I7QUFDakYsd0JBQXdCLFNBQVM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRLGlDQUFpQztBQUN0RCxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNENBQTRDLFNBQVMsUUFBUSxpQ0FBaUM7QUFDOUYsMkJBQTJCLFlBQVksbUJBQW1CO0FBQzFEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLGlDQUFpQyxXQUFXLFNBQVM7QUFDckQsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25ELE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLDZCQUE2QjtBQUN4QyxXQUFXLEtBQUs7QUFDaEIsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQ0FBaUM7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9mZXRjaC9ib2R5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHtcbiAgUmVhZGFibGVTdHJlYW1Gcm9tLFxuICByZWFkYWJsZVN0cmVhbUNsb3NlLFxuICBjcmVhdGVEZWZlcnJlZFByb21pc2UsXG4gIGZ1bGx5UmVhZEJvZHksXG4gIGV4dHJhY3RNaW1lVHlwZSxcbiAgdXRmOERlY29kZUJ5dGVzXG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgRm9ybURhdGEsIHNldEZvcm1EYXRhU3RhdGUgfSA9IHJlcXVpcmUoJy4vZm9ybWRhdGEnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL3dlYmlkbCcpXG5jb25zdCB7IEJsb2IgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgaXNFcnJvcmVkLCBpc0Rpc3R1cmJlZCB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgeyBpc0FycmF5QnVmZmVyIH0gPSByZXF1aXJlKCdub2RlOnV0aWwvdHlwZXMnKVxuY29uc3QgeyBzZXJpYWxpemVBTWltZVR5cGUgfSA9IHJlcXVpcmUoJy4vZGF0YS11cmwnKVxuY29uc3QgeyBtdWx0aXBhcnRGb3JtRGF0YVBhcnNlciB9ID0gcmVxdWlyZSgnLi9mb3JtZGF0YS1wYXJzZXInKVxubGV0IHJhbmRvbVxuXG50cnkge1xuICBjb25zdCBjcnlwdG8gPSByZXF1aXJlKCdub2RlOmNyeXB0bycpXG4gIHJhbmRvbSA9IChtYXgpID0+IGNyeXB0by5yYW5kb21JbnQoMCwgbWF4KVxufSBjYXRjaCB7XG4gIHJhbmRvbSA9IChtYXgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heClcbn1cblxuY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5jb25zdCBoYXNGaW5hbGl6YXRpb25SZWdpc3RyeSA9IGdsb2JhbFRoaXMuRmluYWxpemF0aW9uUmVnaXN0cnlcbmxldCBzdHJlYW1SZWdpc3RyeVxuXG5pZiAoaGFzRmluYWxpemF0aW9uUmVnaXN0cnkpIHtcbiAgc3RyZWFtUmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKHdlYWtSZWYpID0+IHtcbiAgICBjb25zdCBzdHJlYW0gPSB3ZWFrUmVmLmRlcmVmKClcbiAgICBpZiAoc3RyZWFtICYmICFzdHJlYW0ubG9ja2VkICYmICFpc0Rpc3R1cmJlZChzdHJlYW0pICYmICFpc0Vycm9yZWQoc3RyZWFtKSkge1xuICAgICAgc3RyZWFtLmNhbmNlbCgnUmVzcG9uc2Ugb2JqZWN0IGhhcyBiZWVuIGdhcmJhZ2UgY29sbGVjdGVkJykuY2F0Y2gobm9vcClcbiAgICB9XG4gIH0pXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHlpbml0LWV4dHJhY3RcbmZ1bmN0aW9uIGV4dHJhY3RCb2R5IChvYmplY3QsIGtlZXBhbGl2ZSA9IGZhbHNlKSB7XG4gIC8vIDEuIExldCBzdHJlYW0gYmUgbnVsbC5cbiAgbGV0IHN0cmVhbSA9IG51bGxcblxuICAvLyAyLiBJZiBvYmplY3QgaXMgYSBSZWFkYWJsZVN0cmVhbSBvYmplY3QsIHRoZW4gc2V0IHN0cmVhbSB0byBvYmplY3QuXG4gIGlmICh3ZWJpZGwuaXMuUmVhZGFibGVTdHJlYW0ob2JqZWN0KSkge1xuICAgIHN0cmVhbSA9IG9iamVjdFxuICB9IGVsc2UgaWYgKHdlYmlkbC5pcy5CbG9iKG9iamVjdCkpIHtcbiAgICAvLyAzLiBPdGhlcndpc2UsIGlmIG9iamVjdCBpcyBhIEJsb2Igb2JqZWN0LCBzZXQgc3RyZWFtIHRvIHRoZVxuICAgIC8vICAgIHJlc3VsdCBvZiBydW5uaW5nIG9iamVjdOKAmXMgZ2V0IHN0cmVhbS5cbiAgICBzdHJlYW0gPSBvYmplY3Quc3RyZWFtKClcbiAgfSBlbHNlIHtcbiAgICAvLyA0LiBPdGhlcndpc2UsIHNldCBzdHJlYW0gdG8gYSBuZXcgUmVhZGFibGVTdHJlYW0gb2JqZWN0LCBhbmQgc2V0XG4gICAgLy8gICAgdXAgc3RyZWFtIHdpdGggYnl0ZSByZWFkaW5nIHN1cHBvcnQuXG4gICAgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIGFzeW5jIHB1bGwgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyB0ZXh0RW5jb2Rlci5lbmNvZGUoc291cmNlKSA6IHNvdXJjZVxuXG4gICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShidWZmZXIpXG4gICAgICAgIH1cblxuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiByZWFkYWJsZVN0cmVhbUNsb3NlKGNvbnRyb2xsZXIpKVxuICAgICAgfSxcbiAgICAgIHN0YXJ0ICgpIHt9LFxuICAgICAgdHlwZTogJ2J5dGVzJ1xuICAgIH0pXG4gIH1cblxuICAvLyA1LiBBc3NlcnQ6IHN0cmVhbSBpcyBhIFJlYWRhYmxlU3RyZWFtIG9iamVjdC5cbiAgYXNzZXJ0KHdlYmlkbC5pcy5SZWFkYWJsZVN0cmVhbShzdHJlYW0pKVxuXG4gIC8vIDYuIExldCBhY3Rpb24gYmUgbnVsbC5cbiAgbGV0IGFjdGlvbiA9IG51bGxcblxuICAvLyA3LiBMZXQgc291cmNlIGJlIG51bGwuXG4gIGxldCBzb3VyY2UgPSBudWxsXG5cbiAgLy8gOC4gTGV0IGxlbmd0aCBiZSBudWxsLlxuICBsZXQgbGVuZ3RoID0gbnVsbFxuXG4gIC8vIDkuIExldCB0eXBlIGJlIG51bGwuXG4gIGxldCB0eXBlID0gbnVsbFxuXG4gIC8vIDEwLiBTd2l0Y2ggb24gb2JqZWN0OlxuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBTZXQgc291cmNlIHRvIHRoZSBVVEYtOCBlbmNvZGluZyBvZiBvYmplY3QuXG4gICAgLy8gTm90ZTogc2V0dGluZyBzb3VyY2UgdG8gYSBVaW50OEFycmF5IGhlcmUgYnJlYWtzIHNvbWUgbW9ja2luZyBhc3N1bXB0aW9ucy5cbiAgICBzb3VyY2UgPSBvYmplY3RcblxuICAgIC8vIFNldCB0eXBlIHRvIGB0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThgLlxuICAgIHR5cGUgPSAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04J1xuICB9IGVsc2UgaWYgKHdlYmlkbC5pcy5VUkxTZWFyY2hQYXJhbXMob2JqZWN0KSkge1xuICAgIC8vIFVSTFNlYXJjaFBhcmFtc1xuXG4gICAgLy8gc3BlYyBzYXlzIHRvIHJ1biBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgb24gYm9keS5saXN0XG4gICAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBpbiBOb2RlLmpzIGFzIGFwYXJ0IG9mIGFuIFVSTFNlYXJjaFBhcmFtcyBpbnN0YW5jZSB0b1N0cmluZyBtZXRob2RcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2U0NmM2ODBiZjJiMjExYmJkNTJjZjk1OWNhMTdlZTk4YzdmNjU3ZjUvbGliL2ludGVybmFsL3VybC5qcyNMNDkwXG4gICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2U0NmM2ODBiZjJiMjExYmJkNTJjZjk1OWNhMTdlZTk4YzdmNjU3ZjUvbGliL2ludGVybmFsL3VybC5qcyNMMTEwMFxuXG4gICAgLy8gU2V0IHNvdXJjZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgdGhlIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBzZXJpYWxpemVyIHdpdGggb2JqZWN04oCZcyBsaXN0LlxuICAgIHNvdXJjZSA9IG9iamVjdC50b1N0cmluZygpXG5cbiAgICAvLyBTZXQgdHlwZSB0byBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLThgLlxuICAgIHR5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnXG4gIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihvYmplY3QpKSB7XG4gICAgLy8gQnVmZmVyU291cmNlL0FycmF5QnVmZmVyXG5cbiAgICAvLyBTZXQgc291cmNlIHRvIGEgY29weSBvZiB0aGUgYnl0ZXMgaGVsZCBieSBvYmplY3QuXG4gICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkob2JqZWN0LnNsaWNlKCkpXG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KG9iamVjdCkpIHtcbiAgICAvLyBCdWZmZXJTb3VyY2UvQXJyYXlCdWZmZXJWaWV3XG5cbiAgICAvLyBTZXQgc291cmNlIHRvIGEgY29weSBvZiB0aGUgYnl0ZXMgaGVsZCBieSBvYmplY3QuXG4gICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkob2JqZWN0LmJ1ZmZlci5zbGljZShvYmplY3QuYnl0ZU9mZnNldCwgb2JqZWN0LmJ5dGVPZmZzZXQgKyBvYmplY3QuYnl0ZUxlbmd0aCkpXG4gIH0gZWxzZSBpZiAod2ViaWRsLmlzLkZvcm1EYXRhKG9iamVjdCkpIHtcbiAgICBjb25zdCBib3VuZGFyeSA9IGAtLS0tZm9ybWRhdGEtdW5kaWNpLTAke2Ake3JhbmRvbSgxZTExKX1gLnBhZFN0YXJ0KDExLCAnMCcpfWBcbiAgICBjb25zdCBwcmVmaXggPSBgLS0ke2JvdW5kYXJ5fVxcclxcbkNvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YWBcblxuICAgIC8qISBmb3JtZGF0YS1wb2x5ZmlsbC4gTUlUIExpY2Vuc2UuIEppbW15IFfDpHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKi9cbiAgICBjb25zdCBlc2NhcGUgPSAoc3RyKSA9PlxuICAgICAgc3RyLnJlcGxhY2UoL1xcbi9nLCAnJTBBJykucmVwbGFjZSgvXFxyL2csICclMEQnKS5yZXBsYWNlKC9cIi9nLCAnJTIyJylcbiAgICBjb25zdCBub3JtYWxpemVMaW5lZmVlZHMgPSAodmFsdWUpID0+IHZhbHVlLnJlcGxhY2UoL1xccj9cXG58XFxyL2csICdcXHJcXG4nKVxuXG4gICAgLy8gU2V0IGFjdGlvbiB0byB0aGlzIHN0ZXA6IHJ1biB0aGUgbXVsdGlwYXJ0L2Zvcm0tZGF0YVxuICAgIC8vIGVuY29kaW5nIGFsZ29yaXRobSwgd2l0aCBvYmplY3TigJlzIGVudHJ5IGxpc3QgYW5kIFVURi04LlxuICAgIC8vIC0gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGJvZHkgaXMgaW1tdXRhYmxlIGFuZCBjYW4ndCBiZSBjaGFuZ2VkIGFmdGVyd29yZHNcbiAgICAvLyAtIFRoYXQgdGhlIGNvbnRlbnQtbGVuZ3RoIGlzIGNhbGN1bGF0ZWQgaW4gYWR2YW5jZS5cbiAgICAvLyAtIEFuZCB0aGF0IGFsbCBwYXJ0cyBhcmUgcHJlLWVuY29kZWQgYW5kIHJlYWR5IHRvIGJlIHNlbnQuXG5cbiAgICBjb25zdCBibG9iUGFydHMgPSBbXVxuICAgIGNvbnN0IHJuID0gbmV3IFVpbnQ4QXJyYXkoWzEzLCAxMF0pIC8vICdcXHJcXG4nXG4gICAgbGVuZ3RoID0gMFxuICAgIGxldCBoYXNVbmtub3duU2l6ZVZhbHVlID0gZmFsc2VcblxuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBvYmplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGNodW5rID0gdGV4dEVuY29kZXIuZW5jb2RlKHByZWZpeCArXG4gICAgICAgICAgYDsgbmFtZT1cIiR7ZXNjYXBlKG5vcm1hbGl6ZUxpbmVmZWVkcyhuYW1lKSl9XCJgICtcbiAgICAgICAgICBgXFxyXFxuXFxyXFxuJHtub3JtYWxpemVMaW5lZmVlZHModmFsdWUpfVxcclxcbmApXG4gICAgICAgIGJsb2JQYXJ0cy5wdXNoKGNodW5rKVxuICAgICAgICBsZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoYCR7cHJlZml4fTsgbmFtZT1cIiR7ZXNjYXBlKG5vcm1hbGl6ZUxpbmVmZWVkcyhuYW1lKSl9XCJgICtcbiAgICAgICAgICAodmFsdWUubmFtZSA/IGA7IGZpbGVuYW1lPVwiJHtlc2NhcGUodmFsdWUubmFtZSl9XCJgIDogJycpICsgJ1xcclxcbicgK1xuICAgICAgICAgIGBDb250ZW50LVR5cGU6ICR7XG4gICAgICAgICAgICB2YWx1ZS50eXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gICAgICAgICAgfVxcclxcblxcclxcbmApXG4gICAgICAgIGJsb2JQYXJ0cy5wdXNoKGNodW5rLCB2YWx1ZSwgcm4pXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBsZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aCArIHZhbHVlLnNpemUgKyBybi5ieXRlTGVuZ3RoXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFzVW5rbm93blNpemVWYWx1ZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENSTEYgaXMgYXBwZW5kZWQgdG8gdGhlIGJvZHkgdG8gZnVuY3Rpb24gd2l0aCBsZWdhY3kgc2VydmVycyBhbmQgbWF0Y2ggb3RoZXIgaW1wbGVtZW50YXRpb25zLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jdXJsL2N1cmwvYmxvYi8zNDM0YzZiNDZlNjgyNDUyOTczOTcyZTgzMTM2MTNkZmE1OGNkNjkwL2xpYi9taW1lLmMjTDEwMjktTDEwMzBcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZm9ybS1kYXRhL2Zvcm0tZGF0YS9pc3N1ZXMvNjNcbiAgICBjb25zdCBjaHVuayA9IHRleHRFbmNvZGVyLmVuY29kZShgLS0ke2JvdW5kYXJ5fS0tXFxyXFxuYClcbiAgICBibG9iUGFydHMucHVzaChjaHVuaylcbiAgICBsZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aFxuICAgIGlmIChoYXNVbmtub3duU2l6ZVZhbHVlKSB7XG4gICAgICBsZW5ndGggPSBudWxsXG4gICAgfVxuXG4gICAgLy8gU2V0IHNvdXJjZSB0byBvYmplY3QuXG4gICAgc291cmNlID0gb2JqZWN0XG5cbiAgICBhY3Rpb24gPSBhc3luYyBmdW5jdGlvbiAqICgpIHtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBibG9iUGFydHMpIHtcbiAgICAgICAgaWYgKHBhcnQuc3RyZWFtKSB7XG4gICAgICAgICAgeWllbGQgKiBwYXJ0LnN0cmVhbSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgcGFydFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IHR5cGUgdG8gYG11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PWAsXG4gICAgLy8gZm9sbG93ZWQgYnkgdGhlIG11bHRpcGFydC9mb3JtLWRhdGEgYm91bmRhcnkgc3RyaW5nIGdlbmVyYXRlZFxuICAgIC8vIGJ5IHRoZSBtdWx0aXBhcnQvZm9ybS1kYXRhIGVuY29kaW5nIGFsZ29yaXRobS5cbiAgICB0eXBlID0gYG11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PSR7Ym91bmRhcnl9YFxuICB9IGVsc2UgaWYgKHdlYmlkbC5pcy5CbG9iKG9iamVjdCkpIHtcbiAgICAvLyBCbG9iXG5cbiAgICAvLyBTZXQgc291cmNlIHRvIG9iamVjdC5cbiAgICBzb3VyY2UgPSBvYmplY3RcblxuICAgIC8vIFNldCBsZW5ndGggdG8gb2JqZWN04oCZcyBzaXplLlxuICAgIGxlbmd0aCA9IG9iamVjdC5zaXplXG5cbiAgICAvLyBJZiBvYmplY3TigJlzIHR5cGUgYXR0cmlidXRlIGlzIG5vdCB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZSwgc2V0XG4gICAgLy8gdHlwZSB0byBpdHMgdmFsdWUuXG4gICAgaWYgKG9iamVjdC50eXBlKSB7XG4gICAgICB0eXBlID0gb2JqZWN0LnR5cGVcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiBrZWVwYWxpdmUgaXMgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoa2VlcGFsaXZlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrZWVwYWxpdmUnKVxuICAgIH1cblxuICAgIC8vIElmIG9iamVjdCBpcyBkaXN0dXJiZWQgb3IgbG9ja2VkLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh1dGlsLmlzRGlzdHVyYmVkKG9iamVjdCkgfHwgb2JqZWN0LmxvY2tlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1Jlc3BvbnNlIGJvZHkgb2JqZWN0IHNob3VsZCBub3QgYmUgZGlzdHVyYmVkIG9yIGxvY2tlZCdcbiAgICAgIClcbiAgICB9XG5cbiAgICBzdHJlYW0gPVxuICAgICAgd2ViaWRsLmlzLlJlYWRhYmxlU3RyZWFtKG9iamVjdCkgPyBvYmplY3QgOiBSZWFkYWJsZVN0cmVhbUZyb20ob2JqZWN0KVxuICB9XG5cbiAgLy8gMTEuIElmIHNvdXJjZSBpcyBhIGJ5dGUgc2VxdWVuY2UsIHRoZW4gc2V0IGFjdGlvbiB0byBhXG4gIC8vIHN0ZXAgdGhhdCByZXR1cm5zIHNvdXJjZSBhbmQgbGVuZ3RoIHRvIHNvdXJjZeKAmXMgbGVuZ3RoLlxuICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgfHwgdXRpbC5pc0J1ZmZlcihzb3VyY2UpKSB7XG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc291cmNlKVxuICB9XG5cbiAgLy8gMTIuIElmIGFjdGlvbiBpcyBub24tbnVsbCwgdGhlbiBydW4gdGhlc2Ugc3RlcHMgaW4gaW4gcGFyYWxsZWw6XG4gIGlmIChhY3Rpb24gIT0gbnVsbCkge1xuICAgIC8vIFJ1biBhY3Rpb24uXG4gICAgbGV0IGl0ZXJhdG9yXG4gICAgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIGFzeW5jIHN0YXJ0ICgpIHtcbiAgICAgICAgaXRlcmF0b3IgPSBhY3Rpb24ob2JqZWN0KVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKVxuICAgICAgfSxcbiAgICAgIGFzeW5jIHB1bGwgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgLy8gV2hlbiBydW5uaW5nIGFjdGlvbiBpcyBkb25lLCBjbG9zZSBzdHJlYW0uXG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpXG4gICAgICAgICAgICBjb250cm9sbGVyLmJ5b2JSZXF1ZXN0Py5yZXNwb25kKDApXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXaGVuZXZlciBvbmUgb3IgbW9yZSBieXRlcyBhcmUgYXZhaWxhYmxlIGFuZCBzdHJlYW0gaXMgbm90IGVycm9yZWQsXG4gICAgICAgICAgLy8gZW5xdWV1ZSBhIFVpbnQ4QXJyYXkgd3JhcHBpbmcgYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyB0aGUgYXZhaWxhYmxlXG4gICAgICAgICAgLy8gYnl0ZXMgaW50byBzdHJlYW0uXG4gICAgICAgICAgaWYgKCFpc0Vycm9yZWQoc3RyZWFtKSkge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpXG4gICAgICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJ1ZmZlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZGVzaXJlZFNpemUgPiAwXG4gICAgICB9LFxuICAgICAgYXN5bmMgY2FuY2VsIChyZWFzb24pIHtcbiAgICAgICAgYXdhaXQgaXRlcmF0b3IucmV0dXJuKClcbiAgICAgIH0sXG4gICAgICB0eXBlOiAnYnl0ZXMnXG4gICAgfSlcbiAgfVxuXG4gIC8vIDEzLiBMZXQgYm9keSBiZSBhIGJvZHkgd2hvc2Ugc3RyZWFtIGlzIHN0cmVhbSwgc291cmNlIGlzIHNvdXJjZSxcbiAgLy8gYW5kIGxlbmd0aCBpcyBsZW5ndGguXG4gIGNvbnN0IGJvZHkgPSB7IHN0cmVhbSwgc291cmNlLCBsZW5ndGggfVxuXG4gIC8vIDE0LiBSZXR1cm4gKGJvZHksIHR5cGUpLlxuICByZXR1cm4gW2JvZHksIHR5cGVdXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5aW5pdC1zYWZlbHktZXh0cmFjdFxuZnVuY3Rpb24gc2FmZWx5RXh0cmFjdEJvZHkgKG9iamVjdCwga2VlcGFsaXZlID0gZmFsc2UpIHtcbiAgLy8gVG8gc2FmZWx5IGV4dHJhY3QgYSBib2R5IGFuZCBhIGBDb250ZW50LVR5cGVgIHZhbHVlIGZyb21cbiAgLy8gYSBieXRlIHNlcXVlbmNlIG9yIEJvZHlJbml0IG9iamVjdCBvYmplY3QsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBJZiBvYmplY3QgaXMgYSBSZWFkYWJsZVN0cmVhbSBvYmplY3QsIHRoZW46XG4gIGlmICh3ZWJpZGwuaXMuUmVhZGFibGVTdHJlYW0ob2JqZWN0KSkge1xuICAgIC8vIEFzc2VydDogb2JqZWN0IGlzIG5laXRoZXIgZGlzdHVyYmVkIG5vciBsb2NrZWQuXG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBhc3NlcnQoIXV0aWwuaXNEaXN0dXJiZWQob2JqZWN0KSwgJ1RoZSBib2R5IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQuJylcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIGFzc2VydCghb2JqZWN0LmxvY2tlZCwgJ1RoZSBzdHJlYW0gaXMgbG9ja2VkLicpXG4gIH1cblxuICAvLyAyLiBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgZXh0cmFjdGluZyBvYmplY3QuXG4gIHJldHVybiBleHRyYWN0Qm9keShvYmplY3QsIGtlZXBhbGl2ZSlcbn1cblxuZnVuY3Rpb24gY2xvbmVCb2R5IChpbnN0YW5jZSwgYm9keSkge1xuICAvLyBUbyBjbG9uZSBhIGJvZHkgYm9keSwgcnVuIHRoZXNlIHN0ZXBzOlxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktY2xvbmVcblxuICAvLyAxLiBMZXQgwqsgb3V0MSwgb3V0MiDCuyBiZSB0aGUgcmVzdWx0IG9mIHRlZWluZyBib2R54oCZcyBzdHJlYW0uXG4gIGNvbnN0IFtvdXQxLCBvdXQyXSA9IGJvZHkuc3RyZWFtLnRlZSgpXG5cbiAgaWYgKGhhc0ZpbmFsaXphdGlvblJlZ2lzdHJ5KSB7XG4gICAgc3RyZWFtUmVnaXN0cnkucmVnaXN0ZXIoaW5zdGFuY2UsIG5ldyBXZWFrUmVmKG91dDEpKVxuICB9XG5cbiAgLy8gMi4gU2V0IGJvZHnigJlzIHN0cmVhbSB0byBvdXQxLlxuICBib2R5LnN0cmVhbSA9IG91dDFcblxuICAvLyAzLiBSZXR1cm4gYSBib2R5IHdob3NlIHN0cmVhbSBpcyBvdXQyIGFuZCBvdGhlciBtZW1iZXJzIGFyZSBjb3BpZWQgZnJvbSBib2R5LlxuICByZXR1cm4ge1xuICAgIHN0cmVhbTogb3V0MixcbiAgICBsZW5ndGg6IGJvZHkubGVuZ3RoLFxuICAgIHNvdXJjZTogYm9keS5zb3VyY2VcbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd0lmQWJvcnRlZCAoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicsICdBYm9ydEVycm9yJylcbiAgfVxufVxuXG5mdW5jdGlvbiBib2R5TWl4aW5NZXRob2RzIChpbnN0YW5jZSwgZ2V0SW50ZXJuYWxTdGF0ZSkge1xuICBjb25zdCBtZXRob2RzID0ge1xuICAgIGJsb2IgKCkge1xuICAgICAgLy8gVGhlIGJsb2IoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mXG4gICAgICAvLyBydW5uaW5nIGNvbnN1bWUgYm9keSB3aXRoIHRoaXMgYW5kIHRoZSBmb2xsb3dpbmcgc3RlcFxuICAgICAgLy8gZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGJ5dGVzOiByZXR1cm4gYSBCbG9iIHdob3NlXG4gICAgICAvLyBjb250ZW50cyBhcmUgYnl0ZXMgYW5kIHdob3NlIHR5cGUgYXR0cmlidXRlIGlzIHRoaXPigJlzXG4gICAgICAvLyBNSU1FIHR5cGUuXG4gICAgICByZXR1cm4gY29uc3VtZUJvZHkodGhpcywgKGJ5dGVzKSA9PiB7XG4gICAgICAgIGxldCBtaW1lVHlwZSA9IGJvZHlNaW1lVHlwZShnZXRJbnRlcm5hbFN0YXRlKHRoaXMpKVxuXG4gICAgICAgIGlmIChtaW1lVHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG1pbWVUeXBlID0gJydcbiAgICAgICAgfSBlbHNlIGlmIChtaW1lVHlwZSkge1xuICAgICAgICAgIG1pbWVUeXBlID0gc2VyaWFsaXplQU1pbWVUeXBlKG1pbWVUeXBlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuIGEgQmxvYiB3aG9zZSBjb250ZW50cyBhcmUgYnl0ZXMgYW5kIHR5cGUgYXR0cmlidXRlXG4gICAgICAgIC8vIGlzIG1pbWVUeXBlLlxuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW2J5dGVzXSwgeyB0eXBlOiBtaW1lVHlwZSB9KVxuICAgICAgfSwgaW5zdGFuY2UsIGdldEludGVybmFsU3RhdGUpXG4gICAgfSxcblxuICAgIGFycmF5QnVmZmVyICgpIHtcbiAgICAgIC8vIFRoZSBhcnJheUJ1ZmZlcigpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHRcbiAgICAgIC8vIG9mIHJ1bm5pbmcgY29uc3VtZSBib2R5IHdpdGggdGhpcyBhbmQgdGhlIGZvbGxvd2luZyBzdGVwXG4gICAgICAvLyBnaXZlbiBhIGJ5dGUgc2VxdWVuY2UgYnl0ZXM6IHJldHVybiBhIG5ldyBBcnJheUJ1ZmZlclxuICAgICAgLy8gd2hvc2UgY29udGVudHMgYXJlIGJ5dGVzLlxuICAgICAgcmV0dXJuIGNvbnN1bWVCb2R5KHRoaXMsIChieXRlcykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlclxuICAgICAgfSwgaW5zdGFuY2UsIGdldEludGVybmFsU3RhdGUpXG4gICAgfSxcblxuICAgIHRleHQgKCkge1xuICAgICAgLy8gVGhlIHRleHQoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgIC8vIGNvbnN1bWUgYm9keSB3aXRoIHRoaXMgYW5kIFVURi04IGRlY29kZS5cbiAgICAgIHJldHVybiBjb25zdW1lQm9keSh0aGlzLCB1dGY4RGVjb2RlQnl0ZXMsIGluc3RhbmNlLCBnZXRJbnRlcm5hbFN0YXRlKVxuICAgIH0sXG5cbiAgICBqc29uICgpIHtcbiAgICAgIC8vIFRoZSBqc29uKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICAvLyBjb25zdW1lIGJvZHkgd2l0aCB0aGlzIGFuZCBwYXJzZSBKU09OIGZyb20gYnl0ZXMuXG4gICAgICByZXR1cm4gY29uc3VtZUJvZHkodGhpcywgcGFyc2VKU09ORnJvbUJ5dGVzLCBpbnN0YW5jZSwgZ2V0SW50ZXJuYWxTdGF0ZSlcbiAgICB9LFxuXG4gICAgZm9ybURhdGEgKCkge1xuICAgICAgLy8gVGhlIGZvcm1EYXRhKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICAvLyBjb25zdW1lIGJvZHkgd2l0aCB0aGlzIGFuZCB0aGUgZm9sbG93aW5nIHN0ZXAgZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGJ5dGVzOlxuICAgICAgcmV0dXJuIGNvbnN1bWVCb2R5KHRoaXMsICh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyAxLiBMZXQgbWltZVR5cGUgYmUgdGhlIHJlc3VsdCBvZiBnZXQgdGhlIE1JTUUgdHlwZSB3aXRoIHRoaXMuXG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gYm9keU1pbWVUeXBlKGdldEludGVybmFsU3RhdGUodGhpcykpXG5cbiAgICAgICAgLy8gMi4gSWYgbWltZVR5cGUgaXMgbm9uLW51bGwsIHRoZW4gc3dpdGNoIG9uIG1pbWVUeXBl4oCZcyBlc3NlbmNlIGFuZCBydW5cbiAgICAgICAgLy8gICAgdGhlIGNvcnJlc3BvbmRpbmcgc3RlcHM6XG4gICAgICAgIGlmIChtaW1lVHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAobWltZVR5cGUuZXNzZW5jZSkge1xuICAgICAgICAgICAgY2FzZSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc6IHtcbiAgICAgICAgICAgICAgLy8gMS4gLi4uIFtsb25nIHN0ZXBdXG4gICAgICAgICAgICAgIC8vIDIuIElmIHRoYXQgZmFpbHMgZm9yIHNvbWUgcmVhc29uLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBtdWx0aXBhcnRGb3JtRGF0YVBhcnNlcih2YWx1ZSwgbWltZVR5cGUpXG5cbiAgICAgICAgICAgICAgLy8gMy4gUmV0dXJuIGEgbmV3IEZvcm1EYXRhIG9iamVjdCwgYXBwZW5kaW5nIGVhY2ggZW50cnksXG4gICAgICAgICAgICAgIC8vICAgIHJlc3VsdGluZyBmcm9tIHRoZSBwYXJzaW5nIG9wZXJhdGlvbiwgdG8gaXRzIGVudHJ5IGxpc3QuXG4gICAgICAgICAgICAgIGNvbnN0IGZkID0gbmV3IEZvcm1EYXRhKClcbiAgICAgICAgICAgICAgc2V0Rm9ybURhdGFTdGF0ZShmZCwgcGFyc2VkKVxuXG4gICAgICAgICAgICAgIHJldHVybiBmZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzoge1xuICAgICAgICAgICAgICAvLyAxLiBMZXQgZW50cmllcyBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgYnl0ZXMuXG4gICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHZhbHVlLnRvU3RyaW5nKCkpXG5cbiAgICAgICAgICAgICAgLy8gMi4gSWYgZW50cmllcyBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuXG4gICAgICAgICAgICAgIC8vIDMuIFJldHVybiBhIG5ldyBGb3JtRGF0YSBvYmplY3Qgd2hvc2UgZW50cnkgbGlzdCBpcyBlbnRyaWVzLlxuICAgICAgICAgICAgICBjb25zdCBmZCA9IG5ldyBGb3JtRGF0YSgpXG5cbiAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBmZC5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gZmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBUaHJvdyBhIFR5cGVFcnJvci5cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnQ29udGVudC1UeXBlIHdhcyBub3Qgb25lIG9mIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIG9yIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIuJ1xuICAgICAgICApXG4gICAgICB9LCBpbnN0YW5jZSwgZ2V0SW50ZXJuYWxTdGF0ZSlcbiAgICB9LFxuXG4gICAgYnl0ZXMgKCkge1xuICAgICAgLy8gVGhlIGJ5dGVzKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIGNvbnN1bWUgYm9keVxuICAgICAgLy8gd2l0aCB0aGlzIGFuZCB0aGUgZm9sbG93aW5nIHN0ZXAgZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGJ5dGVzOiByZXR1cm4gdGhlXG4gICAgICAvLyByZXN1bHQgb2YgY3JlYXRpbmcgYSBVaW50OEFycmF5IGZyb20gYnl0ZXMgaW4gdGhpc+KAmXMgcmVsZXZhbnQgcmVhbG0uXG4gICAgICByZXR1cm4gY29uc3VtZUJvZHkodGhpcywgKGJ5dGVzKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcylcbiAgICAgIH0sIGluc3RhbmNlLCBnZXRJbnRlcm5hbFN0YXRlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZXRob2RzXG59XG5cbmZ1bmN0aW9uIG1peGluQm9keSAocHJvdG90eXBlLCBnZXRJbnRlcm5hbFN0YXRlKSB7XG4gIE9iamVjdC5hc3NpZ24ocHJvdG90eXBlLnByb3RvdHlwZSwgYm9keU1peGluTWV0aG9kcyhwcm90b3R5cGUsIGdldEludGVybmFsU3RhdGUpKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS1jb25zdW1lLWJvZHlcbiAqIEBwYXJhbSB7YW55fSBvYmplY3QgaW50ZXJuYWwgc3RhdGVcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duKSA9PiB1bmtub3dufSBjb252ZXJ0Qnl0ZXNUb0pTVmFsdWVcbiAqIEBwYXJhbSB7YW55fSBpbnN0YW5jZVxuICogQHBhcmFtIHsodGFyZ2V0OiBhbnkpID0+IGFueX0gZ2V0SW50ZXJuYWxTdGF0ZVxuICovXG5hc3luYyBmdW5jdGlvbiBjb25zdW1lQm9keSAob2JqZWN0LCBjb252ZXJ0Qnl0ZXNUb0pTVmFsdWUsIGluc3RhbmNlLCBnZXRJbnRlcm5hbFN0YXRlKSB7XG4gIHdlYmlkbC5icmFuZENoZWNrKG9iamVjdCwgaW5zdGFuY2UpXG5cbiAgY29uc3Qgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKG9iamVjdClcblxuICAvLyAxLiBJZiBvYmplY3QgaXMgdW51c2FibGUsIHRoZW4gcmV0dXJuIGEgcHJvbWlzZSByZWplY3RlZFxuICAvLyAgICB3aXRoIGEgVHlwZUVycm9yLlxuICBpZiAoYm9keVVudXNhYmxlKHN0YXRlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgaXMgdW51c2FibGU6IEJvZHkgaGFzIGFscmVhZHkgYmVlbiByZWFkJylcbiAgfVxuXG4gIHRocm93SWZBYm9ydGVkKHN0YXRlKVxuXG4gIC8vIDIuIExldCBwcm9taXNlIGJlIGEgbmV3IHByb21pc2UuXG4gIGNvbnN0IHByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gIC8vIDMuIExldCBlcnJvclN0ZXBzIGdpdmVuIGVycm9yIGJlIHRvIHJlamVjdCBwcm9taXNlIHdpdGggZXJyb3IuXG4gIGNvbnN0IGVycm9yU3RlcHMgPSAoZXJyb3IpID0+IHByb21pc2UucmVqZWN0KGVycm9yKVxuXG4gIC8vIDQuIExldCBzdWNjZXNzU3RlcHMgZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGRhdGEgYmUgdG8gcmVzb2x2ZVxuICAvLyAgICBwcm9taXNlIHdpdGggdGhlIHJlc3VsdCBvZiBydW5uaW5nIGNvbnZlcnRCeXRlc1RvSlNWYWx1ZVxuICAvLyAgICB3aXRoIGRhdGEuIElmIHRoYXQgdGhyZXcgYW4gZXhjZXB0aW9uLCB0aGVuIHJ1biBlcnJvclN0ZXBzXG4gIC8vICAgIHdpdGggdGhhdCBleGNlcHRpb24uXG4gIGNvbnN0IHN1Y2Nlc3NTdGVwcyA9IChkYXRhKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2UucmVzb2x2ZShjb252ZXJ0Qnl0ZXNUb0pTVmFsdWUoZGF0YSkpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JTdGVwcyhlKVxuICAgIH1cbiAgfVxuXG4gIC8vIDUuIElmIG9iamVjdOKAmXMgYm9keSBpcyBudWxsLCB0aGVuIHJ1biBzdWNjZXNzU3RlcHMgd2l0aCBhblxuICAvLyAgICBlbXB0eSBieXRlIHNlcXVlbmNlLlxuICBpZiAoc3RhdGUuYm9keSA9PSBudWxsKSB7XG4gICAgc3VjY2Vzc1N0ZXBzKEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKSlcbiAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICAvLyA2LiBPdGhlcndpc2UsIGZ1bGx5IHJlYWQgb2JqZWN04oCZcyBib2R5IGdpdmVuIHN1Y2Nlc3NTdGVwcyxcbiAgLy8gICAgZXJyb3JTdGVwcywgYW5kIG9iamVjdOKAmXMgcmVsZXZhbnQgZ2xvYmFsIG9iamVjdC5cbiAgZnVsbHlSZWFkQm9keShzdGF0ZS5ib2R5LCBzdWNjZXNzU3RlcHMsIGVycm9yU3RlcHMpXG5cbiAgLy8gNy4gUmV0dXJuIHByb21pc2UuXG4gIHJldHVybiBwcm9taXNlLnByb21pc2Vcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5LXVudXNhYmxlXG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0IGludGVybmFsIHN0YXRlXG4gKi9cbmZ1bmN0aW9uIGJvZHlVbnVzYWJsZSAob2JqZWN0KSB7XG4gIGNvbnN0IGJvZHkgPSBvYmplY3QuYm9keVxuXG4gIC8vIEFuIG9iamVjdCBpbmNsdWRpbmcgdGhlIEJvZHkgaW50ZXJmYWNlIG1peGluIGlzXG4gIC8vIHNhaWQgdG8gYmUgdW51c2FibGUgaWYgaXRzIGJvZHkgaXMgbm9uLW51bGwgYW5kXG4gIC8vIGl0cyBib2R54oCZcyBzdHJlYW0gaXMgZGlzdHVyYmVkIG9yIGxvY2tlZC5cbiAgcmV0dXJuIGJvZHkgIT0gbnVsbCAmJiAoYm9keS5zdHJlYW0ubG9ja2VkIHx8IHV0aWwuaXNEaXN0dXJiZWQoYm9keS5zdHJlYW0pKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3BhcnNlLWpzb24tYnl0ZXMtdG8tYS1qYXZhc2NyaXB0LXZhbHVlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSlNPTkZyb21CeXRlcyAoYnl0ZXMpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UodXRmOERlY29kZUJ5dGVzKGJ5dGVzKSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktbWltZS10eXBlXG4gKiBAcGFyYW0ge2FueX0gcmVxdWVzdE9yUmVzcG9uc2UgaW50ZXJuYWwgc3RhdGVcbiAqL1xuZnVuY3Rpb24gYm9keU1pbWVUeXBlIChyZXF1ZXN0T3JSZXNwb25zZSkge1xuICAvLyAxLiBMZXQgaGVhZGVycyBiZSBudWxsLlxuICAvLyAyLiBJZiByZXF1ZXN0T3JSZXNwb25zZSBpcyBhIFJlcXVlc3Qgb2JqZWN0LCB0aGVuIHNldCBoZWFkZXJzIHRvIHJlcXVlc3RPclJlc3BvbnNl4oCZcyByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgLy8gMy4gT3RoZXJ3aXNlLCBzZXQgaGVhZGVycyB0byByZXF1ZXN0T3JSZXNwb25zZeKAmXMgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAvKiogQHR5cGUge2ltcG9ydCgnLi9oZWFkZXJzJykuSGVhZGVyc0xpc3R9ICovXG4gIGNvbnN0IGhlYWRlcnMgPSByZXF1ZXN0T3JSZXNwb25zZS5oZWFkZXJzTGlzdFxuXG4gIC8vIDQuIExldCBtaW1lVHlwZSBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgYSBNSU1FIHR5cGUgZnJvbSBoZWFkZXJzLlxuICBjb25zdCBtaW1lVHlwZSA9IGV4dHJhY3RNaW1lVHlwZShoZWFkZXJzKVxuXG4gIC8vIDUuIElmIG1pbWVUeXBlIGlzIGZhaWx1cmUsIHRoZW4gcmV0dXJuIG51bGwuXG4gIGlmIChtaW1lVHlwZSA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIDYuIFJldHVybiBtaW1lVHlwZS5cbiAgcmV0dXJuIG1pbWVUeXBlXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBleHRyYWN0Qm9keSxcbiAgc2FmZWx5RXh0cmFjdEJvZHksXG4gIGNsb25lQm9keSxcbiAgbWl4aW5Cb2R5LFxuICBzdHJlYW1SZWdpc3RyeSxcbiAgaGFzRmluYWxpemF0aW9uUmVnaXN0cnksXG4gIGJvZHlVbnVzYWJsZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/body.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/constants.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/constants.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\n\nconst corsSafeListedMethods = /** @type {const} */ (['GET', 'HEAD', 'POST'])\nconst corsSafeListedMethodsSet = new Set(corsSafeListedMethods)\n\nconst nullBodyStatus = /** @type {const} */ ([101, 204, 205, 304])\n\nconst redirectStatus = /** @type {const} */ ([301, 302, 303, 307, 308])\nconst redirectStatusSet = new Set(redirectStatus)\n\n/**\n * @see https://fetch.spec.whatwg.org/#block-bad-port\n */\nconst badPorts = /** @type {const} */ ([\n  '1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79',\n  '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137',\n  '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532',\n  '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723',\n  '2049', '3659', '4045', '4190', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6679',\n  '6697', '10080'\n])\nconst badPortsSet = new Set(badPorts)\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#referrer-policy-header\n */\nconst referrerPolicyTokens = /** @type {const} */ ([\n  'no-referrer',\n  'no-referrer-when-downgrade',\n  'same-origin',\n  'origin',\n  'strict-origin',\n  'origin-when-cross-origin',\n  'strict-origin-when-cross-origin',\n  'unsafe-url'\n])\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#referrer-policies\n */\nconst referrerPolicy = /** @type {const} */ ([\n  '',\n  ...referrerPolicyTokens\n])\nconst referrerPolicyTokensSet = new Set(referrerPolicyTokens)\n\nconst requestRedirect = /** @type {const} */ (['follow', 'manual', 'error'])\n\nconst safeMethods = /** @type {const} */ (['GET', 'HEAD', 'OPTIONS', 'TRACE'])\nconst safeMethodsSet = new Set(safeMethods)\n\nconst requestMode = /** @type {const} */ (['navigate', 'same-origin', 'no-cors', 'cors'])\n\nconst requestCredentials = /** @type {const} */ (['omit', 'same-origin', 'include'])\n\nconst requestCache = /** @type {const} */ ([\n  'default',\n  'no-store',\n  'reload',\n  'no-cache',\n  'force-cache',\n  'only-if-cached'\n])\n\n/**\n * @see https://fetch.spec.whatwg.org/#request-body-header-name\n */\nconst requestBodyHeader = /** @type {const} */ ([\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-type',\n  // See https://github.com/nodejs/undici/issues/2021\n  // 'Content-Length' is a forbidden header name, which is typically\n  // removed in the Headers implementation. However, undici doesn't\n  // filter out headers, so we add it here.\n  'content-length'\n])\n\n/**\n * @see https://fetch.spec.whatwg.org/#enumdef-requestduplex\n */\nconst requestDuplex = /** @type {const} */ ([\n  'half'\n])\n\n/**\n * @see http://fetch.spec.whatwg.org/#forbidden-method\n */\nconst forbiddenMethods = /** @type {const} */ (['CONNECT', 'TRACE', 'TRACK'])\nconst forbiddenMethodsSet = new Set(forbiddenMethods)\n\nconst subresource = /** @type {const} */ ([\n  'audio',\n  'audioworklet',\n  'font',\n  'image',\n  'manifest',\n  'paintworklet',\n  'script',\n  'style',\n  'track',\n  'video',\n  'xslt',\n  ''\n])\nconst subresourceSet = new Set(subresource)\n\nmodule.exports = {\n  subresource,\n  forbiddenMethods,\n  requestBodyHeader,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache,\n  redirectStatus,\n  corsSafeListedMethods,\n  nullBodyStatus,\n  safeMethods,\n  badPorts,\n  requestDuplex,\n  subresourceSet,\n  badPortsSet,\n  redirectStatusSet,\n  corsSafeListedMethodsSet,\n  safeMethodsSet,\n  forbiddenMethodsSet,\n  referrerPolicyTokens: referrerPolicyTokensSet\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLHlDQUF5QyxPQUFPO0FBQ2hEOztBQUVBLGtDQUFrQyxPQUFPOztBQUV6QyxrQ0FBa0MsT0FBTztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsT0FBTzs7QUFFMUMsK0JBQStCLE9BQU87QUFDdEM7O0FBRUEsK0JBQStCLE9BQU87O0FBRXRDLHNDQUFzQyxPQUFPOztBQUU3QyxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDOztBQUVBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb3JzU2FmZUxpc3RlZE1ldGhvZHMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWydHRVQnLCAnSEVBRCcsICdQT1NUJ10pXG5jb25zdCBjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQgPSBuZXcgU2V0KGNvcnNTYWZlTGlzdGVkTWV0aG9kcylcblxuY29uc3QgbnVsbEJvZHlTdGF0dXMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWzEwMSwgMjA0LCAyMDUsIDMwNF0pXG5cbmNvbnN0IHJlZGlyZWN0U3RhdHVzID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF0pXG5jb25zdCByZWRpcmVjdFN0YXR1c1NldCA9IG5ldyBTZXQocmVkaXJlY3RTdGF0dXMpXG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYmxvY2stYmFkLXBvcnRcbiAqL1xuY29uc3QgYmFkUG9ydHMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuICAnMScsICc3JywgJzknLCAnMTEnLCAnMTMnLCAnMTUnLCAnMTcnLCAnMTknLCAnMjAnLCAnMjEnLCAnMjInLCAnMjMnLCAnMjUnLCAnMzcnLCAnNDInLCAnNDMnLCAnNTMnLCAnNjknLCAnNzcnLCAnNzknLFxuICAnODcnLCAnOTUnLCAnMTAxJywgJzEwMicsICcxMDMnLCAnMTA0JywgJzEwOScsICcxMTAnLCAnMTExJywgJzExMycsICcxMTUnLCAnMTE3JywgJzExOScsICcxMjMnLCAnMTM1JywgJzEzNycsXG4gICcxMzknLCAnMTQzJywgJzE2MScsICcxNzknLCAnMzg5JywgJzQyNycsICc0NjUnLCAnNTEyJywgJzUxMycsICc1MTQnLCAnNTE1JywgJzUyNicsICc1MzAnLCAnNTMxJywgJzUzMicsXG4gICc1NDAnLCAnNTQ4JywgJzU1NCcsICc1NTYnLCAnNTYzJywgJzU4NycsICc2MDEnLCAnNjM2JywgJzk4OScsICc5OTAnLCAnOTkzJywgJzk5NScsICcxNzE5JywgJzE3MjAnLCAnMTcyMycsXG4gICcyMDQ5JywgJzM2NTknLCAnNDA0NScsICc0MTkwJywgJzUwNjAnLCAnNTA2MScsICc2MDAwJywgJzY1NjYnLCAnNjY2NScsICc2NjY2JywgJzY2NjcnLCAnNjY2OCcsICc2NjY5JywgJzY2NzknLFxuICAnNjY5NycsICcxMDA4MCdcbl0pXG5jb25zdCBiYWRQb3J0c1NldCA9IG5ldyBTZXQoYmFkUG9ydHMpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jcmVmZXJyZXItcG9saWN5LWhlYWRlclxuICovXG5jb25zdCByZWZlcnJlclBvbGljeVRva2VucyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG4gICduby1yZWZlcnJlcicsXG4gICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZScsXG4gICdzYW1lLW9yaWdpbicsXG4gICdvcmlnaW4nLFxuICAnc3RyaWN0LW9yaWdpbicsXG4gICdvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nLFxuICAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbicsXG4gICd1bnNhZmUtdXJsJ1xuXSlcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNyZWZlcnJlci1wb2xpY2llc1xuICovXG5jb25zdCByZWZlcnJlclBvbGljeSA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG4gICcnLFxuICAuLi5yZWZlcnJlclBvbGljeVRva2Vuc1xuXSlcbmNvbnN0IHJlZmVycmVyUG9saWN5VG9rZW5zU2V0ID0gbmV3IFNldChyZWZlcnJlclBvbGljeVRva2VucylcblxuY29uc3QgcmVxdWVzdFJlZGlyZWN0ID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFsnZm9sbG93JywgJ21hbnVhbCcsICdlcnJvciddKVxuXG5jb25zdCBzYWZlTWV0aG9kcyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnVFJBQ0UnXSlcbmNvbnN0IHNhZmVNZXRob2RzU2V0ID0gbmV3IFNldChzYWZlTWV0aG9kcylcblxuY29uc3QgcmVxdWVzdE1vZGUgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWyduYXZpZ2F0ZScsICdzYW1lLW9yaWdpbicsICduby1jb3JzJywgJ2NvcnMnXSlcblxuY29uc3QgcmVxdWVzdENyZWRlbnRpYWxzID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFsnb21pdCcsICdzYW1lLW9yaWdpbicsICdpbmNsdWRlJ10pXG5cbmNvbnN0IHJlcXVlc3RDYWNoZSA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG4gICdkZWZhdWx0JyxcbiAgJ25vLXN0b3JlJyxcbiAgJ3JlbG9hZCcsXG4gICduby1jYWNoZScsXG4gICdmb3JjZS1jYWNoZScsXG4gICdvbmx5LWlmLWNhY2hlZCdcbl0pXG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdC1ib2R5LWhlYWRlci1uYW1lXG4gKi9cbmNvbnN0IHJlcXVlc3RCb2R5SGVhZGVyID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtcbiAgJ2NvbnRlbnQtZW5jb2RpbmcnLFxuICAnY29udGVudC1sYW5ndWFnZScsXG4gICdjb250ZW50LWxvY2F0aW9uJyxcbiAgJ2NvbnRlbnQtdHlwZScsXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjAyMVxuICAvLyAnQ29udGVudC1MZW5ndGgnIGlzIGEgZm9yYmlkZGVuIGhlYWRlciBuYW1lLCB3aGljaCBpcyB0eXBpY2FsbHlcbiAgLy8gcmVtb3ZlZCBpbiB0aGUgSGVhZGVycyBpbXBsZW1lbnRhdGlvbi4gSG93ZXZlciwgdW5kaWNpIGRvZXNuJ3RcbiAgLy8gZmlsdGVyIG91dCBoZWFkZXJzLCBzbyB3ZSBhZGQgaXQgaGVyZS5cbiAgJ2NvbnRlbnQtbGVuZ3RoJ1xuXSlcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNlbnVtZGVmLXJlcXVlc3RkdXBsZXhcbiAqL1xuY29uc3QgcmVxdWVzdER1cGxleCA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG4gICdoYWxmJ1xuXSlcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZvcmJpZGRlbi1tZXRob2RcbiAqL1xuY29uc3QgZm9yYmlkZGVuTWV0aG9kcyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbJ0NPTk5FQ1QnLCAnVFJBQ0UnLCAnVFJBQ0snXSlcbmNvbnN0IGZvcmJpZGRlbk1ldGhvZHNTZXQgPSBuZXcgU2V0KGZvcmJpZGRlbk1ldGhvZHMpXG5cbmNvbnN0IHN1YnJlc291cmNlID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtcbiAgJ2F1ZGlvJyxcbiAgJ2F1ZGlvd29ya2xldCcsXG4gICdmb250JyxcbiAgJ2ltYWdlJyxcbiAgJ21hbmlmZXN0JyxcbiAgJ3BhaW50d29ya2xldCcsXG4gICdzY3JpcHQnLFxuICAnc3R5bGUnLFxuICAndHJhY2snLFxuICAndmlkZW8nLFxuICAneHNsdCcsXG4gICcnXG5dKVxuY29uc3Qgc3VicmVzb3VyY2VTZXQgPSBuZXcgU2V0KHN1YnJlc291cmNlKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3VicmVzb3VyY2UsXG4gIGZvcmJpZGRlbk1ldGhvZHMsXG4gIHJlcXVlc3RCb2R5SGVhZGVyLFxuICByZWZlcnJlclBvbGljeSxcbiAgcmVxdWVzdFJlZGlyZWN0LFxuICByZXF1ZXN0TW9kZSxcbiAgcmVxdWVzdENyZWRlbnRpYWxzLFxuICByZXF1ZXN0Q2FjaGUsXG4gIHJlZGlyZWN0U3RhdHVzLFxuICBjb3JzU2FmZUxpc3RlZE1ldGhvZHMsXG4gIG51bGxCb2R5U3RhdHVzLFxuICBzYWZlTWV0aG9kcyxcbiAgYmFkUG9ydHMsXG4gIHJlcXVlc3REdXBsZXgsXG4gIHN1YnJlc291cmNlU2V0LFxuICBiYWRQb3J0c1NldCxcbiAgcmVkaXJlY3RTdGF0dXNTZXQsXG4gIGNvcnNTYWZlTGlzdGVkTWV0aG9kc1NldCxcbiAgc2FmZU1ldGhvZHNTZXQsXG4gIGZvcmJpZGRlbk1ldGhvZHNTZXQsXG4gIHJlZmVycmVyUG9saWN5VG9rZW5zOiByZWZlcnJlclBvbGljeVRva2Vuc1NldFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/data-url.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/data-url.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\nconst encoder = new TextEncoder()\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-token-code-point\n */\nconst HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\\-.^_|~A-Za-z0-9]+$/\nconst HTTP_WHITESPACE_REGEX = /[\\u000A\\u000D\\u0009\\u0020]/ // eslint-disable-line\nconst ASCII_WHITESPACE_REPLACE_REGEX = /[\\u0009\\u000A\\u000C\\u000D\\u0020]/g // eslint-disable-line\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n */\nconst HTTP_QUOTED_STRING_TOKENS = /^[\\u0009\\u0020-\\u007E\\u0080-\\u00FF]+$/ // eslint-disable-line\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor (dataURL) {\n  // 1. Assert: dataURLs scheme is \"data\".\n  assert(dataURL.protocol === 'data:')\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true)\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5)\n\n  // 4. Let position point at the start of input.\n  const position = { position: 0 }\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePointsFast(\n    ',',\n    input,\n    position\n  )\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length\n  mimeType = removeASCIIWhitespace(mimeType, true, true)\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 8. Advance position by 1.\n  position.position++\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1)\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  let body = stringPercentDecode(encodedBody)\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = isomorphicDecode(body)\n\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody)\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure'\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6)\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020)+$/, '')\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1)\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType)\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return { mimeType: mimeTypeRecord, body }\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer (url, excludeFragment = false) {\n  if (!excludeFragment) {\n    return url.href\n  }\n\n  const href = url.href\n  const hashLength = url.hash.length\n\n  const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength)\n\n  if (!hashLength && href.endsWith('#')) {\n    return serialized.slice(0, -1)\n  }\n\n  return serialized\n}\n\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePoints (condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = ''\n\n  // 2. While position doesnt point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position]\n\n    // 2. Advance position by 1.\n    position.position++\n  }\n\n  // 3. Return result.\n  return result\n}\n\n/**\n * A faster collectASequenceOfCodePoints that only works when comparing a single character.\n * @param {string} char\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePointsFast (char, input, position) {\n  const idx = input.indexOf(char, position.position)\n  const start = position.position\n\n  if (idx === -1) {\n    position.position = input.length\n    return input.slice(start)\n  }\n\n  position.position = idx\n  return input.slice(start, position.position)\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode (input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input)\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes)\n}\n\n/**\n * @param {number} byte\n */\nfunction isHexCharByte (byte) {\n  // 0-9 A-F a-f\n  return (byte >= 0x30 && byte <= 0x39) || (byte >= 0x41 && byte <= 0x46) || (byte >= 0x61 && byte <= 0x66)\n}\n\n/**\n * @param {number} byte\n */\nfunction hexByteToNumber (byte) {\n  return (\n    // 0-9\n    byte >= 0x30 && byte <= 0x39\n      ? (byte - 48)\n    // Convert to uppercase\n    // ((byte & 0xDF) - 65) + 10\n      : ((byte & 0xDF) - 55)\n  )\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode (input) {\n  const length = input.length\n  // 1. Let output be an empty byte sequence.\n  /** @type {Uint8Array} */\n  const output = new Uint8Array(length)\n  let j = 0\n  // 2. For each byte byte in input:\n  for (let i = 0; i < length; ++i) {\n    const byte = input[i]\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output[j++] = byte\n\n    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n    // after byte in input are not in the ranges\n    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n    // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n    // to output.\n    } else if (\n      byte === 0x25 &&\n      !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))\n    ) {\n      output[j++] = 0x25\n\n    // 3. Otherwise:\n    } else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      // 2. Append a byte whose value is bytePoint to output.\n      output[j++] = (hexByteToNumber(input[i + 1]) << 4) | hexByteToNumber(input[i + 2])\n\n      // 3. Skip the next two bytes in input.\n      i += 2\n    }\n  }\n\n  // 3. Return output.\n  return length === j ? output : output.subarray(0, j)\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType (input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = removeHTTPWhitespace(input, true, true)\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePointsFast(\n    '/',\n    input,\n    position\n  )\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {\n    return 'failure'\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePointsFast(\n    ';',\n    input,\n    position\n  )\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = removeHTTPWhitespace(subtype, false, true)\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {\n    return 'failure'\n  }\n\n  const typeLowercase = type.toLowerCase()\n  const subtypeLowercase = subtype.toLowerCase()\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: typeLowercase,\n    subtype: subtypeLowercase,\n    /** @type {Map<string, string>} */\n    parameters: new Map(),\n    // https://mimesniff.spec.whatwg.org/#mime-type-essence\n    essence: `${typeLowercase}/${subtypeLowercase}`\n  }\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n      // https://fetch.spec.whatwg.org/#http-whitespace\n      char => HTTP_WHITESPACE_REGEX.test(char),\n      input,\n      position\n    )\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(\n      (char) => char !== ';' && char !== '=',\n      input,\n      position\n    )\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase()\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      parameterValue = collectAnHTTPQuotedString(input, position, true)\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n    // 9. Otherwise:\n    } else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      parameterValue = removeHTTPWhitespace(parameterValue, false, true)\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeTypes parameters[parameterName] does not exist\n    // then set mimeTypes parameters[parameterName] to parameterValue.\n    if (\n      parameterName.length !== 0 &&\n      HTTP_TOKEN_CODEPOINTS.test(parameterName) &&\n      (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&\n      !mimeType.parameters.has(parameterName)\n    ) {\n      mimeType.parameters.set(parameterName, parameterValue)\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType\n}\n\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */\nfunction forgivingBase64 (data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, '')\n\n  let dataLength = data.length\n  // 2. If datas code point length divides by 4 leaving\n  // no remainder, then:\n  if (dataLength % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    if (data.charCodeAt(dataLength - 1) === 0x003D) {\n      --dataLength\n      if (data.charCodeAt(dataLength - 1) === 0x003D) {\n        --dataLength\n      }\n    }\n  }\n\n  // 3. If datas code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (dataLength % 4 === 1) {\n    return 'failure'\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {\n    return 'failure'\n  }\n\n  const buffer = Buffer.from(data, 'base64')\n  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean} [extractValue=false]\n */\nfunction collectAnHTTPQuotedString (input, position, extractValue = false) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position\n\n  // 2. Let value be the empty string.\n  let value = ''\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"')\n\n  // 4. Advance position by 1.\n  position.position++\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== '\\\\',\n      input,\n      position\n    )\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position]\n\n    // 4. Advance position by 1.\n    position.position++\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\'\n        break\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position]\n\n      // 3. Advance position by 1.\n      position.position++\n\n    // 6. Otherwise:\n    } else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"')\n\n      // 2. Break.\n      break\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position)\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */\nfunction serializeAMimeType (mimeType) {\n  assert(mimeType !== 'failure')\n  const { parameters, essence } = mimeType\n\n  // 1. Let serialization be the concatenation of mimeTypes\n  //    type, U+002F (/), and mimeTypes subtype.\n  let serialization = essence\n\n  // 2. For each name  value of mimeTypes parameters:\n  for (let [name, value] of parameters.entries()) {\n    // 1. Append U+003B (;) to serialization.\n    serialization += ';'\n\n    // 2. Append name to serialization.\n    serialization += name\n\n    // 3. Append U+003D (=) to serialization.\n    serialization += '='\n\n    // 4. If value does not solely contain HTTP token code\n    //    points or value is the empty string, then:\n    if (!HTTP_TOKEN_CODEPOINTS.test(value)) {\n      // 1. Precede each occurrence of U+0022 (\") or\n      //    U+005C (\\) in value with U+005C (\\).\n      value = value.replace(/(\\\\|\")/g, '\\\\$1')\n\n      // 2. Prepend U+0022 (\") to value.\n      value = '\"' + value\n\n      // 3. Append U+0022 (\") to value.\n      value += '\"'\n    }\n\n    // 5. Append value to serialization.\n    serialization += value\n  }\n\n  // 3. Return serialization.\n  return serialization\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {number} char\n */\nfunction isHTTPWhiteSpace (char) {\n  // \"\\r\\n\\t \"\n  return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x020\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} str\n * @param {boolean} [leading=true]\n * @param {boolean} [trailing=true]\n */\nfunction removeHTTPWhitespace (str, leading = true, trailing = true) {\n  return removeChars(str, leading, trailing, isHTTPWhiteSpace)\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n * @param {number} char\n */\nfunction isASCIIWhitespace (char) {\n  // \"\\r\\n\\t\\f \"\n  return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x00c || char === 0x020\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n * @param {string} str\n * @param {boolean} [leading=true]\n * @param {boolean} [trailing=true]\n */\nfunction removeASCIIWhitespace (str, leading = true, trailing = true) {\n  return removeChars(str, leading, trailing, isASCIIWhitespace)\n}\n\n/**\n * @param {string} str\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns\n */\nfunction removeChars (str, leading, trailing, predicate) {\n  let lead = 0\n  let trail = str.length - 1\n\n  if (leading) {\n    while (lead < str.length && predicate(str.charCodeAt(lead))) lead++\n  }\n\n  if (trailing) {\n    while (trail > 0 && predicate(str.charCodeAt(trail))) trail--\n  }\n\n  return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1)\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {Uint8Array} input\n * @returns {string}\n */\nfunction isomorphicDecode (input) {\n  // 1. To isomorphic decode a byte sequence input, return a string whose code point\n  //    length is equal to inputs length and whose code points have the same values\n  //    as the values of inputs bytes, in the same order.\n  const length = input.length\n  if ((2 << 15) - 1 > length) {\n    return String.fromCharCode.apply(null, input)\n  }\n  let result = ''; let i = 0\n  let addition = (2 << 15) - 1\n  while (i < length) {\n    if (i + addition > length) {\n      addition = length - i\n    }\n    result += String.fromCharCode.apply(null, input.subarray(i, i += addition))\n  }\n  return result\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#minimize-a-supported-mime-type\n * @param {Exclude<ReturnType<typeof parseMIMEType>, 'failure'>} mimeType\n */\nfunction minimizeSupportedMimeType (mimeType) {\n  switch (mimeType.essence) {\n    case 'application/ecmascript':\n    case 'application/javascript':\n    case 'application/x-ecmascript':\n    case 'application/x-javascript':\n    case 'text/ecmascript':\n    case 'text/javascript':\n    case 'text/javascript1.0':\n    case 'text/javascript1.1':\n    case 'text/javascript1.2':\n    case 'text/javascript1.3':\n    case 'text/javascript1.4':\n    case 'text/javascript1.5':\n    case 'text/jscript':\n    case 'text/livescript':\n    case 'text/x-ecmascript':\n    case 'text/x-javascript':\n      // 1. If mimeType is a JavaScript MIME type, then return \"text/javascript\".\n      return 'text/javascript'\n    case 'application/json':\n    case 'text/json':\n      // 2. If mimeType is a JSON MIME type, then return \"application/json\".\n      return 'application/json'\n    case 'image/svg+xml':\n      // 3. If mimeTypes essence is \"image/svg+xml\", then return \"image/svg+xml\".\n      return 'image/svg+xml'\n    case 'text/xml':\n    case 'application/xml':\n      // 4. If mimeType is an XML MIME type, then return \"application/xml\".\n      return 'application/xml'\n  }\n\n  // 2. If mimeType is a JSON MIME type, then return \"application/json\".\n  if (mimeType.subtype.endsWith('+json')) {\n    return 'application/json'\n  }\n\n  // 4. If mimeType is an XML MIME type, then return \"application/xml\".\n  if (mimeType.subtype.endsWith('+xml')) {\n    return 'application/xml'\n  }\n\n  // 5. If mimeType is supported by the user agent, then return mimeTypes essence.\n  // Technically, node doesn't support any mimetypes.\n\n  // 6. Return the empty string.\n  return ''\n}\n\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  collectASequenceOfCodePointsFast,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString,\n  serializeAMimeType,\n  removeChars,\n  removeHTTPWhitespace,\n  minimizeSupportedMimeType,\n  HTTP_TOKEN_CODEPOINTS,\n  isomorphicDecode\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZGF0YS11cmwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxRQUFRLFNBQVMsR0FBRztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEMsV0FBVyxRQUFRO0FBQ25CLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxzREFBc0Q7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvZmxpeGh1Yi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZGF0YS11cmwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcblxuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG5cbi8qKlxuICogQHNlZSBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtdG9rZW4tY29kZS1wb2ludFxuICovXG5jb25zdCBIVFRQX1RPS0VOX0NPREVQT0lOVFMgPSAvXlshIyQlJicqK1xcLS5eX3x+QS1aYS16MC05XSskL1xuY29uc3QgSFRUUF9XSElURVNQQUNFX1JFR0VYID0gL1tcXHUwMDBBXFx1MDAwRFxcdTAwMDlcXHUwMDIwXS8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuY29uc3QgQVNDSUlfV0hJVEVTUEFDRV9SRVBMQUNFX1JFR0VYID0gL1tcXHUwMDA5XFx1MDAwQVxcdTAwMENcXHUwMDBEXFx1MDAyMF0vZyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNodHRwLXF1b3RlZC1zdHJpbmctdG9rZW4tY29kZS1wb2ludFxuICovXG5jb25zdCBIVFRQX1FVT1RFRF9TVFJJTkdfVE9LRU5TID0gL15bXFx1MDAwOVxcdTAwMjAtXFx1MDA3RVxcdTAwODAtXFx1MDBGRl0rJC8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZGF0YS11cmwtcHJvY2Vzc29yXG4vKiogQHBhcmFtIHtVUkx9IGRhdGFVUkwgKi9cbmZ1bmN0aW9uIGRhdGFVUkxQcm9jZXNzb3IgKGRhdGFVUkwpIHtcbiAgLy8gMS4gQXNzZXJ0OiBkYXRhVVJM4oCZcyBzY2hlbWUgaXMgXCJkYXRhXCIuXG4gIGFzc2VydChkYXRhVVJMLnByb3RvY29sID09PSAnZGF0YTonKVxuXG4gIC8vIDIuIExldCBpbnB1dCBiZSB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgdGhlIFVSTFxuICAvLyBzZXJpYWxpemVyIG9uIGRhdGFVUkwgd2l0aCBleGNsdWRlIGZyYWdtZW50XG4gIC8vIHNldCB0byB0cnVlLlxuICBsZXQgaW5wdXQgPSBVUkxTZXJpYWxpemVyKGRhdGFVUkwsIHRydWUpXG5cbiAgLy8gMy4gUmVtb3ZlIHRoZSBsZWFkaW5nIFwiZGF0YTpcIiBzdHJpbmcgZnJvbSBpbnB1dC5cbiAgaW5wdXQgPSBpbnB1dC5zbGljZSg1KVxuXG4gIC8vIDQuIExldCBwb3NpdGlvbiBwb2ludCBhdCB0aGUgc3RhcnQgb2YgaW5wdXQuXG4gIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG5cbiAgLy8gNS4gTGV0IG1pbWVUeXBlIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhXG4gIC8vIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBlcXVhbFxuICAvLyB0byBVKzAwMkMgKCwpLCBnaXZlbiBwb3NpdGlvbi5cbiAgbGV0IG1pbWVUeXBlID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgJywnLFxuICAgIGlucHV0LFxuICAgIHBvc2l0aW9uXG4gIClcblxuICAvLyA2LiBTdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBBU0NJSSB3aGl0ZXNwYWNlXG4gIC8vIGZyb20gbWltZVR5cGUuXG4gIC8vIFVuZGljaSBpbXBsZW1lbnRhdGlvbiBub3RlOiB3ZSBuZWVkIHRvIHN0b3JlIHRoZVxuICAvLyBsZW5ndGggYmVjYXVzZSBpZiB0aGUgbWltZXR5cGUgaGFzIHNwYWNlcyByZW1vdmVkLFxuICAvLyB0aGUgd3JvbmcgYW1vdW50IHdpbGwgYmUgc2xpY2VkIGZyb20gdGhlIGlucHV0IGluXG4gIC8vIHN0ZXAgIzlcbiAgY29uc3QgbWltZVR5cGVMZW5ndGggPSBtaW1lVHlwZS5sZW5ndGhcbiAgbWltZVR5cGUgPSByZW1vdmVBU0NJSVdoaXRlc3BhY2UobWltZVR5cGUsIHRydWUsIHRydWUpXG5cbiAgLy8gNy4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuXG4gIC8vIHJldHVybiBmYWlsdXJlXG4gIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+PSBpbnB1dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA4LiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAvLyA5LiBMZXQgZW5jb2RlZEJvZHkgYmUgdGhlIHJlbWFpbmRlciBvZiBpbnB1dC5cbiAgY29uc3QgZW5jb2RlZEJvZHkgPSBpbnB1dC5zbGljZShtaW1lVHlwZUxlbmd0aCArIDEpXG5cbiAgLy8gMTAuIExldCBib2R5IGJlIHRoZSBwZXJjZW50LWRlY29kaW5nIG9mIGVuY29kZWRCb2R5LlxuICBsZXQgYm9keSA9IHN0cmluZ1BlcmNlbnREZWNvZGUoZW5jb2RlZEJvZHkpXG5cbiAgLy8gMTEuIElmIG1pbWVUeXBlIGVuZHMgd2l0aCBVKzAwM0IgKDspLCBmb2xsb3dlZCBieVxuICAvLyB6ZXJvIG9yIG1vcmUgVSswMDIwIFNQQUNFLCBmb2xsb3dlZCBieSBhbiBBU0NJSVxuICAvLyBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBcImJhc2U2NFwiLCB0aGVuOlxuICBpZiAoLzsoXFx1MDAyMCl7MCx9YmFzZTY0JC9pLnRlc3QobWltZVR5cGUpKSB7XG4gICAgLy8gMS4gTGV0IHN0cmluZ0JvZHkgYmUgdGhlIGlzb21vcnBoaWMgZGVjb2RlIG9mIGJvZHkuXG4gICAgY29uc3Qgc3RyaW5nQm9keSA9IGlzb21vcnBoaWNEZWNvZGUoYm9keSlcblxuICAgIC8vIDIuIFNldCBib2R5IHRvIHRoZSBmb3JnaXZpbmctYmFzZTY0IGRlY29kZSBvZlxuICAgIC8vIHN0cmluZ0JvZHkuXG4gICAgYm9keSA9IGZvcmdpdmluZ0Jhc2U2NChzdHJpbmdCb2R5KVxuXG4gICAgLy8gMy4gSWYgYm9keSBpcyBmYWlsdXJlLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICAgIGlmIChib2R5ID09PSAnZmFpbHVyZScpIHtcbiAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICB9XG5cbiAgICAvLyA0LiBSZW1vdmUgdGhlIGxhc3QgNiBjb2RlIHBvaW50cyBmcm9tIG1pbWVUeXBlLlxuICAgIG1pbWVUeXBlID0gbWltZVR5cGUuc2xpY2UoMCwgLTYpXG5cbiAgICAvLyA1LiBSZW1vdmUgdHJhaWxpbmcgVSswMDIwIFNQQUNFIGNvZGUgcG9pbnRzIGZyb20gbWltZVR5cGUsXG4gICAgLy8gaWYgYW55LlxuICAgIG1pbWVUeXBlID0gbWltZVR5cGUucmVwbGFjZSgvKFxcdTAwMjApKyQvLCAnJylcblxuICAgIC8vIDYuIFJlbW92ZSB0aGUgbGFzdCBVKzAwM0IgKDspIGNvZGUgcG9pbnQgZnJvbSBtaW1lVHlwZS5cbiAgICBtaW1lVHlwZSA9IG1pbWVUeXBlLnNsaWNlKDAsIC0xKVxuICB9XG5cbiAgLy8gMTIuIElmIG1pbWVUeXBlIHN0YXJ0cyB3aXRoIFUrMDAzQiAoOyksIHRoZW4gcHJlcGVuZFxuICAvLyBcInRleHQvcGxhaW5cIiB0byBtaW1lVHlwZS5cbiAgaWYgKG1pbWVUeXBlLnN0YXJ0c1dpdGgoJzsnKSkge1xuICAgIG1pbWVUeXBlID0gJ3RleHQvcGxhaW4nICsgbWltZVR5cGVcbiAgfVxuXG4gIC8vIDEzLiBMZXQgbWltZVR5cGVSZWNvcmQgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nXG4gIC8vIG1pbWVUeXBlLlxuICBsZXQgbWltZVR5cGVSZWNvcmQgPSBwYXJzZU1JTUVUeXBlKG1pbWVUeXBlKVxuXG4gIC8vIDE0LiBJZiBtaW1lVHlwZVJlY29yZCBpcyBmYWlsdXJlLCB0aGVuIHNldFxuICAvLyBtaW1lVHlwZVJlY29yZCB0byB0ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVNDSUkuXG4gIGlmIChtaW1lVHlwZVJlY29yZCA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgbWltZVR5cGVSZWNvcmQgPSBwYXJzZU1JTUVUeXBlKCd0ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVNDSUknKVxuICB9XG5cbiAgLy8gMTUuIFJldHVybiBhIG5ldyBkYXRhOiBVUkwgc3RydWN0IHdob3NlIE1JTUVcbiAgLy8gdHlwZSBpcyBtaW1lVHlwZVJlY29yZCBhbmQgYm9keSBpcyBib2R5LlxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZGF0YS11cmwtc3RydWN0XG4gIHJldHVybiB7IG1pbWVUeXBlOiBtaW1lVHlwZVJlY29yZCwgYm9keSB9XG59XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC11cmwtc2VyaWFsaXplclxuLyoqXG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4Y2x1ZGVGcmFnbWVudFxuICovXG5mdW5jdGlvbiBVUkxTZXJpYWxpemVyICh1cmwsIGV4Y2x1ZGVGcmFnbWVudCA9IGZhbHNlKSB7XG4gIGlmICghZXhjbHVkZUZyYWdtZW50KSB7XG4gICAgcmV0dXJuIHVybC5ocmVmXG4gIH1cblxuICBjb25zdCBocmVmID0gdXJsLmhyZWZcbiAgY29uc3QgaGFzaExlbmd0aCA9IHVybC5oYXNoLmxlbmd0aFxuXG4gIGNvbnN0IHNlcmlhbGl6ZWQgPSBoYXNoTGVuZ3RoID09PSAwID8gaHJlZiA6IGhyZWYuc3Vic3RyaW5nKDAsIGhyZWYubGVuZ3RoIC0gaGFzaExlbmd0aClcblxuICBpZiAoIWhhc2hMZW5ndGggJiYgaHJlZi5lbmRzV2l0aCgnIycpKSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQuc2xpY2UoMCwgLTEpXG4gIH1cblxuICByZXR1cm4gc2VyaWFsaXplZFxufVxuXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jY29sbGVjdC1hLXNlcXVlbmNlLW9mLWNvZGUtcG9pbnRzXG4vKipcbiAqIEBwYXJhbSB7KGNoYXI6IHN0cmluZykgPT4gYm9vbGVhbn0gY29uZGl0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMgKGNvbmRpdGlvbiwgaW5wdXQsIHBvc2l0aW9uKSB7XG4gIC8vIDEuIExldCByZXN1bHQgYmUgdGhlIGVtcHR5IHN0cmluZy5cbiAgbGV0IHJlc3VsdCA9ICcnXG5cbiAgLy8gMi4gV2hpbGUgcG9zaXRpb24gZG9lc27igJl0IHBvaW50IHBhc3QgdGhlIGVuZCBvZiBpbnB1dCBhbmQgdGhlXG4gIC8vIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0IG1lZXRzIHRoZSBjb25kaXRpb24gY29uZGl0aW9uOlxuICB3aGlsZSAocG9zaXRpb24ucG9zaXRpb24gPCBpbnB1dC5sZW5ndGggJiYgY29uZGl0aW9uKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSkpIHtcbiAgICAvLyAxLiBBcHBlbmQgdGhhdCBjb2RlIHBvaW50IHRvIHRoZSBlbmQgb2YgcmVzdWx0LlxuICAgIHJlc3VsdCArPSBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl1cblxuICAgIC8vIDIuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gcmVzdWx0LlxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogQSBmYXN0ZXIgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyB0aGF0IG9ubHkgd29ya3Mgd2hlbiBjb21wYXJpbmcgYSBzaW5nbGUgY2hhcmFjdGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QgKGNoYXIsIGlucHV0LCBwb3NpdGlvbikge1xuICBjb25zdCBpZHggPSBpbnB1dC5pbmRleE9mKGNoYXIsIHBvc2l0aW9uLnBvc2l0aW9uKVxuICBjb25zdCBzdGFydCA9IHBvc2l0aW9uLnBvc2l0aW9uXG5cbiAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICBwb3NpdGlvbi5wb3NpdGlvbiA9IGlucHV0Lmxlbmd0aFxuICAgIHJldHVybiBpbnB1dC5zbGljZShzdGFydClcbiAgfVxuXG4gIHBvc2l0aW9uLnBvc2l0aW9uID0gaWR4XG4gIHJldHVybiBpbnB1dC5zbGljZShzdGFydCwgcG9zaXRpb24ucG9zaXRpb24pXG59XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jc3RyaW5nLXBlcmNlbnQtZGVjb2RlXG4vKiogQHBhcmFtIHtzdHJpbmd9IGlucHV0ICovXG5mdW5jdGlvbiBzdHJpbmdQZXJjZW50RGVjb2RlIChpbnB1dCkge1xuICAvLyAxLiBMZXQgYnl0ZXMgYmUgdGhlIFVURi04IGVuY29kaW5nIG9mIGlucHV0LlxuICBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKGlucHV0KVxuXG4gIC8vIDIuIFJldHVybiB0aGUgcGVyY2VudC1kZWNvZGluZyBvZiBieXRlcy5cbiAgcmV0dXJuIHBlcmNlbnREZWNvZGUoYnl0ZXMpXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVcbiAqL1xuZnVuY3Rpb24gaXNIZXhDaGFyQnl0ZSAoYnl0ZSkge1xuICAvLyAwLTkgQS1GIGEtZlxuICByZXR1cm4gKGJ5dGUgPj0gMHgzMCAmJiBieXRlIDw9IDB4MzkpIHx8IChieXRlID49IDB4NDEgJiYgYnl0ZSA8PSAweDQ2KSB8fCAoYnl0ZSA+PSAweDYxICYmIGJ5dGUgPD0gMHg2Nilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZVxuICovXG5mdW5jdGlvbiBoZXhCeXRlVG9OdW1iZXIgKGJ5dGUpIHtcbiAgcmV0dXJuIChcbiAgICAvLyAwLTlcbiAgICBieXRlID49IDB4MzAgJiYgYnl0ZSA8PSAweDM5XG4gICAgICA/IChieXRlIC0gNDgpXG4gICAgLy8gQ29udmVydCB0byB1cHBlcmNhc2VcbiAgICAvLyAoKGJ5dGUgJiAweERGKSAtIDY1KSArIDEwXG4gICAgICA6ICgoYnl0ZSAmIDB4REYpIC0gNTUpXG4gIClcbn1cblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNwZXJjZW50LWRlY29kZVxuLyoqIEBwYXJhbSB7VWludDhBcnJheX0gaW5wdXQgKi9cbmZ1bmN0aW9uIHBlcmNlbnREZWNvZGUgKGlucHV0KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aFxuICAvLyAxLiBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IGJ5dGUgc2VxdWVuY2UuXG4gIC8qKiBAdHlwZSB7VWludDhBcnJheX0gKi9cbiAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBsZXQgaiA9IDBcbiAgLy8gMi4gRm9yIGVhY2ggYnl0ZSBieXRlIGluIGlucHV0OlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgYnl0ZSA9IGlucHV0W2ldXG5cbiAgICAvLyAxLiBJZiBieXRlIGlzIG5vdCAweDI1ICglKSwgdGhlbiBhcHBlbmQgYnl0ZSB0byBvdXRwdXQuXG4gICAgaWYgKGJ5dGUgIT09IDB4MjUpIHtcbiAgICAgIG91dHB1dFtqKytdID0gYnl0ZVxuXG4gICAgLy8gMi4gT3RoZXJ3aXNlLCBpZiBieXRlIGlzIDB4MjUgKCUpIGFuZCB0aGUgbmV4dCB0d28gYnl0ZXNcbiAgICAvLyBhZnRlciBieXRlIGluIGlucHV0IGFyZSBub3QgaW4gdGhlIHJhbmdlc1xuICAgIC8vIDB4MzAgKDApIHRvIDB4MzkgKDkpLCAweDQxIChBKSB0byAweDQ2IChGKSxcbiAgICAvLyBhbmQgMHg2MSAoYSkgdG8gMHg2NiAoZiksIGFsbCBpbmNsdXNpdmUsIGFwcGVuZCBieXRlXG4gICAgLy8gdG8gb3V0cHV0LlxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBieXRlID09PSAweDI1ICYmXG4gICAgICAhKGlzSGV4Q2hhckJ5dGUoaW5wdXRbaSArIDFdKSAmJiBpc0hleENoYXJCeXRlKGlucHV0W2kgKyAyXSkpXG4gICAgKSB7XG4gICAgICBvdXRwdXRbaisrXSA9IDB4MjVcblxuICAgIC8vIDMuIE90aGVyd2lzZTpcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMS4gTGV0IGJ5dGVQb2ludCBiZSB0aGUgdHdvIGJ5dGVzIGFmdGVyIGJ5dGUgaW4gaW5wdXQsXG4gICAgICAvLyBkZWNvZGVkLCBhbmQgdGhlbiBpbnRlcnByZXRlZCBhcyBoZXhhZGVjaW1hbCBudW1iZXIuXG4gICAgICAvLyAyLiBBcHBlbmQgYSBieXRlIHdob3NlIHZhbHVlIGlzIGJ5dGVQb2ludCB0byBvdXRwdXQuXG4gICAgICBvdXRwdXRbaisrXSA9IChoZXhCeXRlVG9OdW1iZXIoaW5wdXRbaSArIDFdKSA8PCA0KSB8IGhleEJ5dGVUb051bWJlcihpbnB1dFtpICsgMl0pXG5cbiAgICAgIC8vIDMuIFNraXAgdGhlIG5leHQgdHdvIGJ5dGVzIGluIGlucHV0LlxuICAgICAgaSArPSAyXG4gICAgfVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIG91dHB1dC5cbiAgcmV0dXJuIGxlbmd0aCA9PT0gaiA/IG91dHB1dCA6IG91dHB1dC5zdWJhcnJheSgwLCBqKVxufVxuXG4vLyBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI3BhcnNlLWEtbWltZS10eXBlXG4vKiogQHBhcmFtIHtzdHJpbmd9IGlucHV0ICovXG5mdW5jdGlvbiBwYXJzZU1JTUVUeXBlIChpbnB1dCkge1xuICAvLyAxLiBSZW1vdmUgYW55IGxlYWRpbmcgYW5kIHRyYWlsaW5nIEhUVFAgd2hpdGVzcGFjZVxuICAvLyBmcm9tIGlucHV0LlxuICBpbnB1dCA9IHJlbW92ZUhUVFBXaGl0ZXNwYWNlKGlucHV0LCB0cnVlLCB0cnVlKVxuXG4gIC8vIDIuIExldCBwb3NpdGlvbiBiZSBhIHBvc2l0aW9uIHZhcmlhYmxlIGZvciBpbnB1dCxcbiAgLy8gaW5pdGlhbGx5IHBvaW50aW5nIGF0IHRoZSBzdGFydCBvZiBpbnB1dC5cbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAvLyAzLiBMZXQgdHlwZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZVxuICAvLyBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgVSswMDJGICgvKSBmcm9tXG4gIC8vIGlucHV0LCBnaXZlbiBwb3NpdGlvbi5cbiAgY29uc3QgdHlwZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICcvJyxcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgLy8gNC4gSWYgdHlwZSBpcyB0aGUgZW1wdHkgc3RyaW5nIG9yIGRvZXMgbm90IHNvbGVseVxuICAvLyBjb250YWluIEhUVFAgdG9rZW4gY29kZSBwb2ludHMsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIC8vIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jaHR0cC10b2tlbi1jb2RlLXBvaW50XG4gIGlmICh0eXBlLmxlbmd0aCA9PT0gMCB8fCAhSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3QodHlwZSkpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA1LiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW4gcmV0dXJuXG4gIC8vIGZhaWx1cmVcbiAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID49IGlucHV0Lmxlbmd0aCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDYuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS4gKFRoaXMgc2tpcHMgcGFzdCBVKzAwMkYgKC8pLilcbiAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gIC8vIDcuIExldCBzdWJ0eXBlIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mXG4gIC8vIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBVKzAwM0IgKDspIGZyb20gaW5wdXQsIGdpdmVuXG4gIC8vIHBvc2l0aW9uLlxuICBsZXQgc3VidHlwZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICc7JyxcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgLy8gOC4gUmVtb3ZlIGFueSB0cmFpbGluZyBIVFRQIHdoaXRlc3BhY2UgZnJvbSBzdWJ0eXBlLlxuICBzdWJ0eXBlID0gcmVtb3ZlSFRUUFdoaXRlc3BhY2Uoc3VidHlwZSwgZmFsc2UsIHRydWUpXG5cbiAgLy8gOS4gSWYgc3VidHlwZSBpcyB0aGUgZW1wdHkgc3RyaW5nIG9yIGRvZXMgbm90IHNvbGVseVxuICAvLyBjb250YWluIEhUVFAgdG9rZW4gY29kZSBwb2ludHMsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChzdWJ0eXBlLmxlbmd0aCA9PT0gMCB8fCAhSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3Qoc3VidHlwZSkpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICBjb25zdCB0eXBlTG93ZXJjYXNlID0gdHlwZS50b0xvd2VyQ2FzZSgpXG4gIGNvbnN0IHN1YnR5cGVMb3dlcmNhc2UgPSBzdWJ0eXBlLnRvTG93ZXJDYXNlKClcblxuICAvLyAxMC4gTGV0IG1pbWVUeXBlIGJlIGEgbmV3IE1JTUUgdHlwZSByZWNvcmQgd2hvc2UgdHlwZVxuICAvLyBpcyB0eXBlLCBpbiBBU0NJSSBsb3dlcmNhc2UsIGFuZCBzdWJ0eXBlIGlzIHN1YnR5cGUsXG4gIC8vIGluIEFTQ0lJIGxvd2VyY2FzZS5cbiAgLy8gaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNtaW1lLXR5cGVcbiAgY29uc3QgbWltZVR5cGUgPSB7XG4gICAgdHlwZTogdHlwZUxvd2VyY2FzZSxcbiAgICBzdWJ0eXBlOiBzdWJ0eXBlTG93ZXJjYXNlLFxuICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICBwYXJhbWV0ZXJzOiBuZXcgTWFwKCksXG4gICAgLy8gaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNtaW1lLXR5cGUtZXNzZW5jZVxuICAgIGVzc2VuY2U6IGAke3R5cGVMb3dlcmNhc2V9LyR7c3VidHlwZUxvd2VyY2FzZX1gXG4gIH1cblxuICAvLyAxMS4gV2hpbGUgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBpbnB1dDpcbiAgd2hpbGUgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgLy8gMS4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLiAoVGhpcyBza2lwcyBwYXN0IFUrMDAzQiAoOykuKVxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAgIC8vIDIuIENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBIVFRQXG4gICAgLy8gd2hpdGVzcGFjZSBmcm9tIGlucHV0IGdpdmVuIHBvc2l0aW9uLlxuICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC13aGl0ZXNwYWNlXG4gICAgICBjaGFyID0+IEhUVFBfV0hJVEVTUEFDRV9SRUdFWC50ZXN0KGNoYXIpLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDMuIExldCBwYXJhbWV0ZXJOYW1lIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhXG4gICAgLy8gc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAzQiAoOylcbiAgICAvLyBvciBVKzAwM0QgKD0pIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICAgIGxldCBwYXJhbWV0ZXJOYW1lID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIChjaGFyKSA9PiBjaGFyICE9PSAnOycgJiYgY2hhciAhPT0gJz0nLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDQuIFNldCBwYXJhbWV0ZXJOYW1lIHRvIHBhcmFtZXRlck5hbWUsIGluIEFTQ0lJXG4gICAgLy8gbG93ZXJjYXNlLlxuICAgIHBhcmFtZXRlck5hbWUgPSBwYXJhbWV0ZXJOYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIC8vIDUuIElmIHBvc2l0aW9uIGlzIG5vdCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW46XG4gICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAvLyAxLiBJZiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgaXNcbiAgICAgIC8vIFUrMDAzQiAoOyksIHRoZW4gY29udGludWUuXG4gICAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAnOycpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLiAoVGhpcyBza2lwcyBwYXN0IFUrMDAzRCAoPSkuKVxuICAgICAgcG9zaXRpb24ucG9zaXRpb24rK1xuICAgIH1cblxuICAgIC8vIDYuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbiBicmVhay5cbiAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIC8vIDcuIExldCBwYXJhbWV0ZXJWYWx1ZSBiZSBudWxsLlxuICAgIGxldCBwYXJhbWV0ZXJWYWx1ZSA9IG51bGxcblxuICAgIC8vIDguIElmIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCBpc1xuICAgIC8vIFUrMDAyMiAoXCIpLCB0aGVuOlxuICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gPT09ICdcIicpIHtcbiAgICAgIC8vIDEuIFNldCBwYXJhbWV0ZXJWYWx1ZSB0byB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmdcbiAgICAgIC8vIGFuIEhUVFAgcXVvdGVkIHN0cmluZyBmcm9tIGlucHV0LCBnaXZlbiBwb3NpdGlvblxuICAgICAgLy8gYW5kIHRoZSBleHRyYWN0LXZhbHVlIGZsYWcuXG4gICAgICBwYXJhbWV0ZXJWYWx1ZSA9IGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcoaW5wdXQsIHBvc2l0aW9uLCB0cnVlKVxuXG4gICAgICAvLyAyLiBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90XG4gICAgICAvLyBVKzAwM0IgKDspIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAgICc7JyxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHBvc2l0aW9uXG4gICAgICApXG5cbiAgICAvLyA5LiBPdGhlcndpc2U6XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDEuIFNldCBwYXJhbWV0ZXJWYWx1ZSB0byB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmdcbiAgICAgIC8vIGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAzQiAoOylcbiAgICAgIC8vIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgcGFyYW1ldGVyVmFsdWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICAgJzsnLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgcG9zaXRpb25cbiAgICAgIClcblxuICAgICAgLy8gMi4gUmVtb3ZlIGFueSB0cmFpbGluZyBIVFRQIHdoaXRlc3BhY2UgZnJvbSBwYXJhbWV0ZXJWYWx1ZS5cbiAgICAgIHBhcmFtZXRlclZhbHVlID0gcmVtb3ZlSFRUUFdoaXRlc3BhY2UocGFyYW1ldGVyVmFsdWUsIGZhbHNlLCB0cnVlKVxuXG4gICAgICAvLyAzLiBJZiBwYXJhbWV0ZXJWYWx1ZSBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIGNvbnRpbnVlLlxuICAgICAgaWYgKHBhcmFtZXRlclZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDEwLiBJZiBhbGwgb2YgdGhlIGZvbGxvd2luZyBhcmUgdHJ1ZVxuICAgIC8vIC0gcGFyYW1ldGVyTmFtZSBpcyBub3QgdGhlIGVtcHR5IHN0cmluZ1xuICAgIC8vIC0gcGFyYW1ldGVyTmFtZSBzb2xlbHkgY29udGFpbnMgSFRUUCB0b2tlbiBjb2RlIHBvaW50c1xuICAgIC8vIC0gcGFyYW1ldGVyVmFsdWUgc29sZWx5IGNvbnRhaW5zIEhUVFAgcXVvdGVkLXN0cmluZyB0b2tlbiBjb2RlIHBvaW50c1xuICAgIC8vIC0gbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV0gZG9lcyBub3QgZXhpc3RcbiAgICAvLyB0aGVuIHNldCBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1twYXJhbWV0ZXJOYW1lXSB0byBwYXJhbWV0ZXJWYWx1ZS5cbiAgICBpZiAoXG4gICAgICBwYXJhbWV0ZXJOYW1lLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3QocGFyYW1ldGVyTmFtZSkgJiZcbiAgICAgIChwYXJhbWV0ZXJWYWx1ZS5sZW5ndGggPT09IDAgfHwgSFRUUF9RVU9URURfU1RSSU5HX1RPS0VOUy50ZXN0KHBhcmFtZXRlclZhbHVlKSkgJiZcbiAgICAgICFtaW1lVHlwZS5wYXJhbWV0ZXJzLmhhcyhwYXJhbWV0ZXJOYW1lKVxuICAgICkge1xuICAgICAgbWltZVR5cGUucGFyYW1ldGVycy5zZXQocGFyYW1ldGVyTmFtZSwgcGFyYW1ldGVyVmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLy8gMTIuIFJldHVybiBtaW1lVHlwZS5cbiAgcmV0dXJuIG1pbWVUeXBlXG59XG5cbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNmb3JnaXZpbmctYmFzZTY0LWRlY29kZVxuLyoqIEBwYXJhbSB7c3RyaW5nfSBkYXRhICovXG5mdW5jdGlvbiBmb3JnaXZpbmdCYXNlNjQgKGRhdGEpIHtcbiAgLy8gMS4gUmVtb3ZlIGFsbCBBU0NJSSB3aGl0ZXNwYWNlIGZyb20gZGF0YS5cbiAgZGF0YSA9IGRhdGEucmVwbGFjZShBU0NJSV9XSElURVNQQUNFX1JFUExBQ0VfUkVHRVgsICcnKVxuXG4gIGxldCBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGhcbiAgLy8gMi4gSWYgZGF0YeKAmXMgY29kZSBwb2ludCBsZW5ndGggZGl2aWRlcyBieSA0IGxlYXZpbmdcbiAgLy8gbm8gcmVtYWluZGVyLCB0aGVuOlxuICBpZiAoZGF0YUxlbmd0aCAlIDQgPT09IDApIHtcbiAgICAvLyAxLiBJZiBkYXRhIGVuZHMgd2l0aCBvbmUgb3IgdHdvIFUrMDAzRCAoPSkgY29kZSBwb2ludHMsXG4gICAgLy8gdGhlbiByZW1vdmUgdGhlbSBmcm9tIGRhdGEuXG4gICAgaWYgKGRhdGEuY2hhckNvZGVBdChkYXRhTGVuZ3RoIC0gMSkgPT09IDB4MDAzRCkge1xuICAgICAgLS1kYXRhTGVuZ3RoXG4gICAgICBpZiAoZGF0YS5jaGFyQ29kZUF0KGRhdGFMZW5ndGggLSAxKSA9PT0gMHgwMDNEKSB7XG4gICAgICAgIC0tZGF0YUxlbmd0aFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIDMuIElmIGRhdGHigJlzIGNvZGUgcG9pbnQgbGVuZ3RoIGRpdmlkZXMgYnkgNCBsZWF2aW5nXG4gIC8vIGEgcmVtYWluZGVyIG9mIDEsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChkYXRhTGVuZ3RoICUgNCA9PT0gMSkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDQuIElmIGRhdGEgY29udGFpbnMgYSBjb2RlIHBvaW50IHRoYXQgaXMgbm90IG9uZSBvZlxuICAvLyAgVSswMDJCICgrKVxuICAvLyAgVSswMDJGICgvKVxuICAvLyAgQVNDSUkgYWxwaGFudW1lcmljXG4gIC8vIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmICgvW14rLzAtOUEtWmEtel0vLnRlc3QoZGF0YS5sZW5ndGggPT09IGRhdGFMZW5ndGggPyBkYXRhIDogZGF0YS5zdWJzdHJpbmcoMCwgZGF0YUxlbmd0aCkpKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSwgJ2Jhc2U2NCcpXG4gIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIuYnVmZmVyLCBidWZmZXIuYnl0ZU9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb2xsZWN0LWFuLWh0dHAtcXVvdGVkLXN0cmluZ1xuLy8gdGVzdHM6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNleGFtcGxlLWh0dHAtcXVvdGVkLXN0cmluZ1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtleHRyYWN0VmFsdWU9ZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcgKGlucHV0LCBwb3NpdGlvbiwgZXh0cmFjdFZhbHVlID0gZmFsc2UpIHtcbiAgLy8gMS4gTGV0IHBvc2l0aW9uU3RhcnQgYmUgcG9zaXRpb24uXG4gIGNvbnN0IHBvc2l0aW9uU3RhcnQgPSBwb3NpdGlvbi5wb3NpdGlvblxuXG4gIC8vIDIuIExldCB2YWx1ZSBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICBsZXQgdmFsdWUgPSAnJ1xuXG4gIC8vIDMuIEFzc2VydDogdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0XG4gIC8vIGlzIFUrMDAyMiAoXCIpLlxuICBhc3NlcnQoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAnXCInKVxuXG4gIC8vIDQuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gIC8vIDUuIFdoaWxlIHRydWU6XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gMS4gQXBwZW5kIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzXG4gICAgLy8gdGhhdCBhcmUgbm90IFUrMDAyMiAoXCIpIG9yIFUrMDA1QyAoXFwpIGZyb20gaW5wdXQsIGdpdmVuXG4gICAgLy8gcG9zaXRpb24sIHRvIHZhbHVlLlxuICAgIHZhbHVlICs9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciAhPT0gJ1wiJyAmJiBjaGFyICE9PSAnXFxcXCcsXG4gICAgICBpbnB1dCxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuXG4gICAgLy8gMi4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuIGJyZWFrLlxuICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IHF1b3RlT3JCYWNrc2xhc2ggYmUgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluXG4gICAgLy8gaW5wdXQuXG4gICAgY29uc3QgcXVvdGVPckJhY2tzbGFzaCA9IGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXVxuXG4gICAgLy8gNC4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAgIC8vIDUuIElmIHF1b3RlT3JCYWNrc2xhc2ggaXMgVSswMDVDIChcXCksIHRoZW46XG4gICAgaWYgKHF1b3RlT3JCYWNrc2xhc2ggPT09ICdcXFxcJykge1xuICAgICAgLy8gMS4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuIGFwcGVuZFxuICAgICAgLy8gVSswMDVDIChcXCkgdG8gdmFsdWUgYW5kIGJyZWFrLlxuICAgICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID49IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSArPSAnXFxcXCdcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgLy8gMi4gQXBwZW5kIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCB0byB2YWx1ZS5cbiAgICAgIHZhbHVlICs9IGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXVxuXG4gICAgICAvLyAzLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgICAvLyA2LiBPdGhlcndpc2U6XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDEuIEFzc2VydDogcXVvdGVPckJhY2tzbGFzaCBpcyBVKzAwMjIgKFwiKS5cbiAgICAgIGFzc2VydChxdW90ZU9yQmFja3NsYXNoID09PSAnXCInKVxuXG4gICAgICAvLyAyLiBCcmVhay5cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gNi4gSWYgdGhlIGV4dHJhY3QtdmFsdWUgZmxhZyBpcyBzZXQsIHRoZW4gcmV0dXJuIHZhbHVlLlxuICBpZiAoZXh0cmFjdFZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvLyA3LiBSZXR1cm4gdGhlIGNvZGUgcG9pbnRzIGZyb20gcG9zaXRpb25TdGFydCB0byBwb3NpdGlvbixcbiAgLy8gaW5jbHVzaXZlLCB3aXRoaW4gaW5wdXQuXG4gIHJldHVybiBpbnB1dC5zbGljZShwb3NpdGlvblN0YXJ0LCBwb3NpdGlvbi5wb3NpdGlvbilcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jc2VyaWFsaXplLWEtbWltZS10eXBlXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUFNaW1lVHlwZSAobWltZVR5cGUpIHtcbiAgYXNzZXJ0KG1pbWVUeXBlICE9PSAnZmFpbHVyZScpXG4gIGNvbnN0IHsgcGFyYW1ldGVycywgZXNzZW5jZSB9ID0gbWltZVR5cGVcblxuICAvLyAxLiBMZXQgc2VyaWFsaXphdGlvbiBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBtaW1lVHlwZeKAmXNcbiAgLy8gICAgdHlwZSwgVSswMDJGICgvKSwgYW5kIG1pbWVUeXBl4oCZcyBzdWJ0eXBlLlxuICBsZXQgc2VyaWFsaXphdGlvbiA9IGVzc2VuY2VcblxuICAvLyAyLiBGb3IgZWFjaCBuYW1lIOKGkiB2YWx1ZSBvZiBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyczpcbiAgZm9yIChsZXQgW25hbWUsIHZhbHVlXSBvZiBwYXJhbWV0ZXJzLmVudHJpZXMoKSkge1xuICAgIC8vIDEuIEFwcGVuZCBVKzAwM0IgKDspIHRvIHNlcmlhbGl6YXRpb24uXG4gICAgc2VyaWFsaXphdGlvbiArPSAnOydcblxuICAgIC8vIDIuIEFwcGVuZCBuYW1lIHRvIHNlcmlhbGl6YXRpb24uXG4gICAgc2VyaWFsaXphdGlvbiArPSBuYW1lXG5cbiAgICAvLyAzLiBBcHBlbmQgVSswMDNEICg9KSB0byBzZXJpYWxpemF0aW9uLlxuICAgIHNlcmlhbGl6YXRpb24gKz0gJz0nXG5cbiAgICAvLyA0LiBJZiB2YWx1ZSBkb2VzIG5vdCBzb2xlbHkgY29udGFpbiBIVFRQIHRva2VuIGNvZGVcbiAgICAvLyAgICBwb2ludHMgb3IgdmFsdWUgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbjpcbiAgICBpZiAoIUhUVFBfVE9LRU5fQ09ERVBPSU5UUy50ZXN0KHZhbHVlKSkge1xuICAgICAgLy8gMS4gUHJlY2VkZSBlYWNoIG9jY3VycmVuY2Ugb2YgVSswMDIyIChcIikgb3JcbiAgICAgIC8vICAgIFUrMDA1QyAoXFwpIGluIHZhbHVlIHdpdGggVSswMDVDIChcXCkuXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyhcXFxcfFwiKS9nLCAnXFxcXCQxJylcblxuICAgICAgLy8gMi4gUHJlcGVuZCBVKzAwMjIgKFwiKSB0byB2YWx1ZS5cbiAgICAgIHZhbHVlID0gJ1wiJyArIHZhbHVlXG5cbiAgICAgIC8vIDMuIEFwcGVuZCBVKzAwMjIgKFwiKSB0byB2YWx1ZS5cbiAgICAgIHZhbHVlICs9ICdcIidcbiAgICB9XG5cbiAgICAvLyA1LiBBcHBlbmQgdmFsdWUgdG8gc2VyaWFsaXphdGlvbi5cbiAgICBzZXJpYWxpemF0aW9uICs9IHZhbHVlXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gc2VyaWFsaXphdGlvbi5cbiAgcmV0dXJuIHNlcmlhbGl6YXRpb25cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzSFRUUFdoaXRlU3BhY2UgKGNoYXIpIHtcbiAgLy8gXCJcXHJcXG5cXHQgXCJcbiAgcmV0dXJuIGNoYXIgPT09IDB4MDBkIHx8IGNoYXIgPT09IDB4MDBhIHx8IGNoYXIgPT09IDB4MDA5IHx8IGNoYXIgPT09IDB4MDIwXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC13aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtsZWFkaW5nPXRydWVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt0cmFpbGluZz10cnVlXVxuICovXG5mdW5jdGlvbiByZW1vdmVIVFRQV2hpdGVzcGFjZSAoc3RyLCBsZWFkaW5nID0gdHJ1ZSwgdHJhaWxpbmcgPSB0cnVlKSB7XG4gIHJldHVybiByZW1vdmVDaGFycyhzdHIsIGxlYWRpbmcsIHRyYWlsaW5nLCBpc0hUVFBXaGl0ZVNwYWNlKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzQVNDSUlXaGl0ZXNwYWNlIChjaGFyKSB7XG4gIC8vIFwiXFxyXFxuXFx0XFxmIFwiXG4gIHJldHVybiBjaGFyID09PSAweDAwZCB8fCBjaGFyID09PSAweDAwYSB8fCBjaGFyID09PSAweDAwOSB8fCBjaGFyID09PSAweDAwYyB8fCBjaGFyID09PSAweDAyMFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWxlYWRpbmctYW5kLXRyYWlsaW5nLWFzY2lpLXdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xlYWRpbmc9dHJ1ZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RyYWlsaW5nPXRydWVdXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUFTQ0lJV2hpdGVzcGFjZSAoc3RyLCBsZWFkaW5nID0gdHJ1ZSwgdHJhaWxpbmcgPSB0cnVlKSB7XG4gIHJldHVybiByZW1vdmVDaGFycyhzdHIsIGxlYWRpbmcsIHRyYWlsaW5nLCBpc0FTQ0lJV2hpdGVzcGFjZSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxlYWRpbmdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJhaWxpbmdcbiAqIEBwYXJhbSB7KGNoYXJDb2RlOiBudW1iZXIpID0+IGJvb2xlYW59IHByZWRpY2F0ZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2hhcnMgKHN0ciwgbGVhZGluZywgdHJhaWxpbmcsIHByZWRpY2F0ZSkge1xuICBsZXQgbGVhZCA9IDBcbiAgbGV0IHRyYWlsID0gc3RyLmxlbmd0aCAtIDFcblxuICBpZiAobGVhZGluZykge1xuICAgIHdoaWxlIChsZWFkIDwgc3RyLmxlbmd0aCAmJiBwcmVkaWNhdGUoc3RyLmNoYXJDb2RlQXQobGVhZCkpKSBsZWFkKytcbiAgfVxuXG4gIGlmICh0cmFpbGluZykge1xuICAgIHdoaWxlICh0cmFpbCA+IDAgJiYgcHJlZGljYXRlKHN0ci5jaGFyQ29kZUF0KHRyYWlsKSkpIHRyYWlsLS1cbiAgfVxuXG4gIHJldHVybiBsZWFkID09PSAwICYmIHRyYWlsID09PSBzdHIubGVuZ3RoIC0gMSA/IHN0ciA6IHN0ci5zbGljZShsZWFkLCB0cmFpbCArIDEpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jaXNvbW9ycGhpYy1kZWNvZGVcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gaW5wdXRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGlzb21vcnBoaWNEZWNvZGUgKGlucHV0KSB7XG4gIC8vIDEuIFRvIGlzb21vcnBoaWMgZGVjb2RlIGEgYnl0ZSBzZXF1ZW5jZSBpbnB1dCwgcmV0dXJuIGEgc3RyaW5nIHdob3NlIGNvZGUgcG9pbnRcbiAgLy8gICAgbGVuZ3RoIGlzIGVxdWFsIHRvIGlucHV04oCZcyBsZW5ndGggYW5kIHdob3NlIGNvZGUgcG9pbnRzIGhhdmUgdGhlIHNhbWUgdmFsdWVzXG4gIC8vICAgIGFzIHRoZSB2YWx1ZXMgb2YgaW5wdXTigJlzIGJ5dGVzLCBpbiB0aGUgc2FtZSBvcmRlci5cbiAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoXG4gIGlmICgoMiA8PCAxNSkgLSAxID4gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgaW5wdXQpXG4gIH1cbiAgbGV0IHJlc3VsdCA9ICcnOyBsZXQgaSA9IDBcbiAgbGV0IGFkZGl0aW9uID0gKDIgPDwgMTUpIC0gMVxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGlmIChpICsgYWRkaXRpb24gPiBsZW5ndGgpIHtcbiAgICAgIGFkZGl0aW9uID0gbGVuZ3RoIC0gaVxuICAgIH1cbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBpbnB1dC5zdWJhcnJheShpLCBpICs9IGFkZGl0aW9uKSlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI21pbmltaXplLWEtc3VwcG9ydGVkLW1pbWUtdHlwZVxuICogQHBhcmFtIHtFeGNsdWRlPFJldHVyblR5cGU8dHlwZW9mIHBhcnNlTUlNRVR5cGU+LCAnZmFpbHVyZSc+fSBtaW1lVHlwZVxuICovXG5mdW5jdGlvbiBtaW5pbWl6ZVN1cHBvcnRlZE1pbWVUeXBlIChtaW1lVHlwZSkge1xuICBzd2l0Y2ggKG1pbWVUeXBlLmVzc2VuY2UpIHtcbiAgICBjYXNlICdhcHBsaWNhdGlvbi9lY21hc2NyaXB0JzpcbiAgICBjYXNlICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JzpcbiAgICBjYXNlICdhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHQnOlxuICAgIGNhc2UgJ2FwcGxpY2F0aW9uL3gtamF2YXNjcmlwdCc6XG4gICAgY2FzZSAndGV4dC9lY21hc2NyaXB0JzpcbiAgICBjYXNlICd0ZXh0L2phdmFzY3JpcHQnOlxuICAgIGNhc2UgJ3RleHQvamF2YXNjcmlwdDEuMCc6XG4gICAgY2FzZSAndGV4dC9qYXZhc2NyaXB0MS4xJzpcbiAgICBjYXNlICd0ZXh0L2phdmFzY3JpcHQxLjInOlxuICAgIGNhc2UgJ3RleHQvamF2YXNjcmlwdDEuMyc6XG4gICAgY2FzZSAndGV4dC9qYXZhc2NyaXB0MS40JzpcbiAgICBjYXNlICd0ZXh0L2phdmFzY3JpcHQxLjUnOlxuICAgIGNhc2UgJ3RleHQvanNjcmlwdCc6XG4gICAgY2FzZSAndGV4dC9saXZlc2NyaXB0JzpcbiAgICBjYXNlICd0ZXh0L3gtZWNtYXNjcmlwdCc6XG4gICAgY2FzZSAndGV4dC94LWphdmFzY3JpcHQnOlxuICAgICAgLy8gMS4gSWYgbWltZVR5cGUgaXMgYSBKYXZhU2NyaXB0IE1JTUUgdHlwZSwgdGhlbiByZXR1cm4gXCJ0ZXh0L2phdmFzY3JpcHRcIi5cbiAgICAgIHJldHVybiAndGV4dC9qYXZhc2NyaXB0J1xuICAgIGNhc2UgJ2FwcGxpY2F0aW9uL2pzb24nOlxuICAgIGNhc2UgJ3RleHQvanNvbic6XG4gICAgICAvLyAyLiBJZiBtaW1lVHlwZSBpcyBhIEpTT04gTUlNRSB0eXBlLCB0aGVuIHJldHVybiBcImFwcGxpY2F0aW9uL2pzb25cIi5cbiAgICAgIHJldHVybiAnYXBwbGljYXRpb24vanNvbidcbiAgICBjYXNlICdpbWFnZS9zdmcreG1sJzpcbiAgICAgIC8vIDMuIElmIG1pbWVUeXBl4oCZcyBlc3NlbmNlIGlzIFwiaW1hZ2Uvc3ZnK3htbFwiLCB0aGVuIHJldHVybiBcImltYWdlL3N2Zyt4bWxcIi5cbiAgICAgIHJldHVybiAnaW1hZ2Uvc3ZnK3htbCdcbiAgICBjYXNlICd0ZXh0L3htbCc6XG4gICAgY2FzZSAnYXBwbGljYXRpb24veG1sJzpcbiAgICAgIC8vIDQuIElmIG1pbWVUeXBlIGlzIGFuIFhNTCBNSU1FIHR5cGUsIHRoZW4gcmV0dXJuIFwiYXBwbGljYXRpb24veG1sXCIuXG4gICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL3htbCdcbiAgfVxuXG4gIC8vIDIuIElmIG1pbWVUeXBlIGlzIGEgSlNPTiBNSU1FIHR5cGUsIHRoZW4gcmV0dXJuIFwiYXBwbGljYXRpb24vanNvblwiLlxuICBpZiAobWltZVR5cGUuc3VidHlwZS5lbmRzV2l0aCgnK2pzb24nKSkge1xuICAgIHJldHVybiAnYXBwbGljYXRpb24vanNvbidcbiAgfVxuXG4gIC8vIDQuIElmIG1pbWVUeXBlIGlzIGFuIFhNTCBNSU1FIHR5cGUsIHRoZW4gcmV0dXJuIFwiYXBwbGljYXRpb24veG1sXCIuXG4gIGlmIChtaW1lVHlwZS5zdWJ0eXBlLmVuZHNXaXRoKCcreG1sJykpIHtcbiAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL3htbCdcbiAgfVxuXG4gIC8vIDUuIElmIG1pbWVUeXBlIGlzIHN1cHBvcnRlZCBieSB0aGUgdXNlciBhZ2VudCwgdGhlbiByZXR1cm4gbWltZVR5cGXigJlzIGVzc2VuY2UuXG4gIC8vIFRlY2huaWNhbGx5LCBub2RlIGRvZXNuJ3Qgc3VwcG9ydCBhbnkgbWltZXR5cGVzLlxuXG4gIC8vIDYuIFJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuICByZXR1cm4gJydcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRhdGFVUkxQcm9jZXNzb3IsXG4gIFVSTFNlcmlhbGl6ZXIsXG4gIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMsXG4gIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0LFxuICBzdHJpbmdQZXJjZW50RGVjb2RlLFxuICBwYXJzZU1JTUVUeXBlLFxuICBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nLFxuICBzZXJpYWxpemVBTWltZVR5cGUsXG4gIHJlbW92ZUNoYXJzLFxuICByZW1vdmVIVFRQV2hpdGVzcGFjZSxcbiAgbWluaW1pemVTdXBwb3J0ZWRNaW1lVHlwZSxcbiAgSFRUUF9UT0tFTl9DT0RFUE9JTlRTLFxuICBpc29tb3JwaGljRGVjb2RlXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/dispatcher-weakref.js":
/*!*****************************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/dispatcher-weakref.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function () {\n  return { WeakRef, FinalizationRegistry }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZGlzcGF0Y2hlci13ZWFrcmVmLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsV0FBVztBQUNYIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9mZXRjaC9kaXNwYXRjaGVyLXdlYWtyZWYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4geyBXZWFrUmVmLCBGaW5hbGl6YXRpb25SZWdpc3RyeSB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/dispatcher-weakref.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/formdata-parser.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/formdata-parser.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { bufferToLowerCasedHeaderName } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { utf8DecodeBytes } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { makeEntry } = __webpack_require__(/*! ./formdata */ \"(rsc)/./node_modules/undici/lib/web/fetch/formdata.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { File: NodeFile } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\n\nconst File = globalThis.File ?? NodeFile\n\nconst formDataNameBuffer = Buffer.from('form-data; name=\"')\nconst filenameBuffer = Buffer.from('filename')\nconst dd = Buffer.from('--')\nconst ddcrlf = Buffer.from('--\\r\\n')\n\n/**\n * @param {string} chars\n */\nfunction isAsciiString (chars) {\n  for (let i = 0; i < chars.length; ++i) {\n    if ((chars.charCodeAt(i) & ~0x7F) !== 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-boundary\n * @param {string} boundary\n */\nfunction validateBoundary (boundary) {\n  const length = boundary.length\n\n  // - its length is greater or equal to 27 and lesser or equal to 70, and\n  if (length < 27 || length > 70) {\n    return false\n  }\n\n  // - it is composed by bytes in the ranges 0x30 to 0x39, 0x41 to 0x5A, or\n  //   0x61 to 0x7A, inclusive (ASCII alphanumeric), or which are 0x27 ('),\n  //   0x2D (-) or 0x5F (_).\n  for (let i = 0; i < length; ++i) {\n    const cp = boundary.charCodeAt(i)\n\n    if (!(\n      (cp >= 0x30 && cp <= 0x39) ||\n      (cp >= 0x41 && cp <= 0x5a) ||\n      (cp >= 0x61 && cp <= 0x7a) ||\n      cp === 0x27 ||\n      cp === 0x2d ||\n      cp === 0x5f\n    )) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-parser\n * @param {Buffer} input\n * @param {ReturnType<import('./data-url')['parseMIMEType']>} mimeType\n */\nfunction multipartFormDataParser (input, mimeType) {\n  // 1. Assert: mimeTypes essence is \"multipart/form-data\".\n  assert(mimeType !== 'failure' && mimeType.essence === 'multipart/form-data')\n\n  const boundaryString = mimeType.parameters.get('boundary')\n\n  // 2. If mimeTypes parameters[\"boundary\"] does not exist, return failure.\n  //    Otherwise, let boundary be the result of UTF-8 decoding mimeTypes\n  //    parameters[\"boundary\"].\n  if (boundaryString === undefined) {\n    throw parsingError('missing boundary in content-type header')\n  }\n\n  const boundary = Buffer.from(`--${boundaryString}`, 'utf8')\n\n  // 3. Let entry list be an empty entry list.\n  const entryList = []\n\n  // 4. Let position be a pointer to a byte in input, initially pointing at\n  //    the first byte.\n  const position = { position: 0 }\n\n  // Note: undici addition, allows leading and trailing CRLFs.\n  while (input[position.position] === 0x0d && input[position.position + 1] === 0x0a) {\n    position.position += 2\n  }\n\n  let trailing = input.length\n\n  while (input[trailing - 1] === 0x0a && input[trailing - 2] === 0x0d) {\n    trailing -= 2\n  }\n\n  if (trailing !== input.length) {\n    input = input.subarray(0, trailing)\n  }\n\n  // 5. While true:\n  while (true) {\n    // 5.1. If position points to a sequence of bytes starting with 0x2D 0x2D\n    //      (`--`) followed by boundary, advance position by 2 + the length of\n    //      boundary. Otherwise, return failure.\n    // Note: boundary is padded with 2 dashes already, no need to add 2.\n    if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {\n      position.position += boundary.length\n    } else {\n      throw parsingError('expected a value starting with -- and the boundary')\n    }\n\n    // 5.2. If position points to the sequence of bytes 0x2D 0x2D 0x0D 0x0A\n    //      (`--` followed by CR LF) followed by the end of input, return entry list.\n    // Note: a body does NOT need to end with CRLF. It can end with --.\n    if (\n      (position.position === input.length - 2 && bufferStartsWith(input, dd, position)) ||\n      (position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position))\n    ) {\n      return entryList\n    }\n\n    // 5.3. If position does not point to a sequence of bytes starting with 0x0D\n    //      0x0A (CR LF), return failure.\n    if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n      throw parsingError('expected CRLF')\n    }\n\n    // 5.4. Advance position by 2. (This skips past the newline.)\n    position.position += 2\n\n    // 5.5. Let name, filename and contentType be the result of parsing\n    //      multipart/form-data headers on input and position, if the result\n    //      is not failure. Otherwise, return failure.\n    const result = parseMultipartFormDataHeaders(input, position)\n\n    let { name, filename, contentType, encoding } = result\n\n    // 5.6. Advance position by 2. (This skips past the empty line that marks\n    //      the end of the headers.)\n    position.position += 2\n\n    // 5.7. Let body be the empty byte sequence.\n    let body\n\n    // 5.8. Body loop: While position is not past the end of input:\n    // TODO: the steps here are completely wrong\n    {\n      const boundaryIndex = input.indexOf(boundary.subarray(2), position.position)\n\n      if (boundaryIndex === -1) {\n        throw parsingError('expected boundary after body')\n      }\n\n      body = input.subarray(position.position, boundaryIndex - 4)\n\n      position.position += body.length\n\n      // Note: position must be advanced by the body's length before being\n      // decoded, otherwise the parsing will fail.\n      if (encoding === 'base64') {\n        body = Buffer.from(body.toString(), 'base64')\n      }\n    }\n\n    // 5.9. If position does not point to a sequence of bytes starting with\n    //      0x0D 0x0A (CR LF), return failure. Otherwise, advance position by 2.\n    if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n      throw parsingError('expected CRLF')\n    } else {\n      position.position += 2\n    }\n\n    // 5.10. If filename is not null:\n    let value\n\n    if (filename !== null) {\n      // 5.10.1. If contentType is null, set contentType to \"text/plain\".\n      contentType ??= 'text/plain'\n\n      // 5.10.2. If contentType is not an ASCII string, set contentType to the empty string.\n\n      // Note: `buffer.isAscii` can be used at zero-cost, but converting a string to a buffer is a high overhead.\n      // Content-Type is a relatively small string, so it is faster to use `String#charCodeAt`.\n      if (!isAsciiString(contentType)) {\n        contentType = ''\n      }\n\n      // 5.10.3. Let value be a new File object with name filename, type contentType, and body body.\n      value = new File([body], filename, { type: contentType })\n    } else {\n      // 5.11. Otherwise:\n\n      // 5.11.1. Let value be the UTF-8 decoding without BOM of body.\n      value = utf8DecodeBytes(Buffer.from(body))\n    }\n\n    // 5.12. Assert: name is a scalar value string and value is either a scalar value string or a File object.\n    assert(webidl.is.USVString(name))\n    assert((typeof value === 'string' && webidl.is.USVString(value)) || webidl.is.File(value))\n\n    // 5.13. Create an entry with name and value, and append it to entry list.\n    entryList.push(makeEntry(name, value, filename))\n  }\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-multipart-form-data-headers\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction parseMultipartFormDataHeaders (input, position) {\n  // 1. Let name, filename and contentType be null.\n  let name = null\n  let filename = null\n  let contentType = null\n  let encoding = null\n\n  // 2. While true:\n  while (true) {\n    // 2.1. If position points to a sequence of bytes starting with 0x0D 0x0A (CR LF):\n    if (input[position.position] === 0x0d && input[position.position + 1] === 0x0a) {\n      // 2.1.1. If name is null, return failure.\n      if (name === null) {\n        throw parsingError('header name is null')\n      }\n\n      // 2.1.2. Return name, filename and contentType.\n      return { name, filename, contentType, encoding }\n    }\n\n    // 2.2. Let header name be the result of collecting a sequence of bytes that are\n    //      not 0x0A (LF), 0x0D (CR) or 0x3A (:), given position.\n    let headerName = collectASequenceOfBytes(\n      (char) => char !== 0x0a && char !== 0x0d && char !== 0x3a,\n      input,\n      position\n    )\n\n    // 2.3. Remove any HTTP tab or space bytes from the start or end of header name.\n    headerName = removeChars(headerName, true, true, (char) => char === 0x9 || char === 0x20)\n\n    // 2.4. If header name does not match the field-name token production, return failure.\n    if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {\n      throw parsingError('header name does not match the field-name token production')\n    }\n\n    // 2.5. If the byte at position is not 0x3A (:), return failure.\n    if (input[position.position] !== 0x3a) {\n      throw parsingError('expected :')\n    }\n\n    // 2.6. Advance position by 1.\n    position.position++\n\n    // 2.7. Collect a sequence of bytes that are HTTP tab or space bytes given position.\n    //      (Do nothing with those bytes.)\n    collectASequenceOfBytes(\n      (char) => char === 0x20 || char === 0x09,\n      input,\n      position\n    )\n\n    // 2.8. Byte-lowercase header name and switch on the result:\n    switch (bufferToLowerCasedHeaderName(headerName)) {\n      case 'content-disposition': {\n        // 1. Set name and filename to null.\n        name = filename = null\n\n        // 2. If position does not point to a sequence of bytes starting with\n        //    `form-data; name=\"`, return failure.\n        if (!bufferStartsWith(input, formDataNameBuffer, position)) {\n          throw parsingError('expected form-data; name=\" for content-disposition header')\n        }\n\n        // 3. Advance position so it points at the byte after the next 0x22 (\")\n        //    byte (the one in the sequence of bytes matched above).\n        position.position += 17\n\n        // 4. Set name to the result of parsing a multipart/form-data name given\n        //    input and position, if the result is not failure. Otherwise, return\n        //    failure.\n        name = parseMultipartFormDataName(input, position)\n\n        // 5. If position points to a sequence of bytes starting with `; filename=\"`:\n        if (input[position.position] === 0x3b /* ; */ && input[position.position + 1] === 0x20 /* ' ' */) {\n          const at = { position: position.position + 2 }\n\n          if (bufferStartsWith(input, filenameBuffer, at)) {\n            if (input[at.position + 8] === 0x2a /* '*' */) {\n              at.position += 10 // skip past filename*=\n\n              // Remove leading http tab and spaces. See RFC for examples.\n              // https://datatracker.ietf.org/doc/html/rfc6266#section-5\n              collectASequenceOfBytes(\n                (char) => char === 0x20 || char === 0x09,\n                input,\n                at\n              )\n\n              const headerValue = collectASequenceOfBytes(\n                (char) => char !== 0x20 && char !== 0x0d && char !== 0x0a, // ' ' or CRLF\n                input,\n                at\n              )\n\n              if (\n                (headerValue[0] !== 0x75 && headerValue[0] !== 0x55) || // u or U\n                (headerValue[1] !== 0x74 && headerValue[1] !== 0x54) || // t or T\n                (headerValue[2] !== 0x66 && headerValue[2] !== 0x46) || // f or F\n                headerValue[3] !== 0x2d || // -\n                headerValue[4] !== 0x38 // 8\n              ) {\n                throw parsingError('unknown encoding, expected utf-8\\'\\'')\n              }\n\n              // skip utf-8''\n              filename = decodeURIComponent(new TextDecoder().decode(headerValue.subarray(7)))\n\n              position.position = at.position\n            } else {\n              // 1. Advance position so it points at the byte after the next 0x22 (\") byte\n              //    (the one in the sequence of bytes matched above).\n              position.position += 11\n\n              // Remove leading http tab and spaces. See RFC for examples.\n              // https://datatracker.ietf.org/doc/html/rfc6266#section-5\n              collectASequenceOfBytes(\n                (char) => char === 0x20 || char === 0x09,\n                input,\n                position\n              )\n\n              position.position++ // skip past \" after removing whitespace\n\n              // 2. Set filename to the result of parsing a multipart/form-data name given\n              //    input and position, if the result is not failure. Otherwise, return failure.\n              filename = parseMultipartFormDataName(input, position)\n            }\n          }\n        }\n\n        break\n      }\n      case 'content-type': {\n        // 1. Let header value be the result of collecting a sequence of bytes that are\n        //    not 0x0A (LF) or 0x0D (CR), given position.\n        let headerValue = collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n\n        // 2. Remove any HTTP tab or space bytes from the end of header value.\n        headerValue = removeChars(headerValue, false, true, (char) => char === 0x9 || char === 0x20)\n\n        // 3. Set contentType to the isomorphic decoding of header value.\n        contentType = isomorphicDecode(headerValue)\n\n        break\n      }\n      case 'content-transfer-encoding': {\n        let headerValue = collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n\n        headerValue = removeChars(headerValue, false, true, (char) => char === 0x9 || char === 0x20)\n\n        encoding = isomorphicDecode(headerValue)\n\n        break\n      }\n      default: {\n        // Collect a sequence of bytes that are not 0x0A (LF) or 0x0D (CR), given position.\n        // (Do nothing with those bytes.)\n        collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n      }\n    }\n\n    // 2.9. If position does not point to a sequence of bytes starting with 0x0D 0x0A\n    //      (CR LF), return failure. Otherwise, advance position by 2 (past the newline).\n    if (input[position.position] !== 0x0d && input[position.position + 1] !== 0x0a) {\n      throw parsingError('expected CRLF')\n    } else {\n      position.position += 2\n    }\n  }\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-a-multipart-form-data-name\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction parseMultipartFormDataName (input, position) {\n  // 1. Assert: The byte at (position - 1) is 0x22 (\").\n  assert(input[position.position - 1] === 0x22)\n\n  // 2. Let name be the result of collecting a sequence of bytes that are not 0x0A (LF), 0x0D (CR) or 0x22 (\"), given position.\n  /** @type {string | Buffer} */\n  let name = collectASequenceOfBytes(\n    (char) => char !== 0x0a && char !== 0x0d && char !== 0x22,\n    input,\n    position\n  )\n\n  // 3. If the byte at position is not 0x22 (\"), return failure. Otherwise, advance position by 1.\n  if (input[position.position] !== 0x22) {\n    throw parsingError('expected \"')\n  } else {\n    position.position++\n  }\n\n  // 4. Replace any occurrence of the following subsequences in name with the given byte:\n  // - `%0A`: 0x0A (LF)\n  // - `%0D`: 0x0D (CR)\n  // - `%22`: 0x22 (\")\n  name = new TextDecoder().decode(name)\n    .replace(/%0A/ig, '\\n')\n    .replace(/%0D/ig, '\\r')\n    .replace(/%22/g, '\"')\n\n  // 5. Return the UTF-8 decoding without BOM of name.\n  return name\n}\n\n/**\n * @param {(char: number) => boolean} condition\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfBytes (condition, input, position) {\n  let start = position.position\n\n  while (start < input.length && condition(input[start])) {\n    ++start\n  }\n\n  return input.subarray(position.position, (position.position = start))\n}\n\n/**\n * @param {Buffer} buf\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns {Buffer}\n */\nfunction removeChars (buf, leading, trailing, predicate) {\n  let lead = 0\n  let trail = buf.length - 1\n\n  if (leading) {\n    while (lead < buf.length && predicate(buf[lead])) lead++\n  }\n\n  if (trailing) {\n    while (trail > 0 && predicate(buf[trail])) trail--\n  }\n\n  return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1)\n}\n\n/**\n * Checks if {@param buffer} starts with {@param start}\n * @param {Buffer} buffer\n * @param {Buffer} start\n * @param {{ position: number }} position\n */\nfunction bufferStartsWith (buffer, start, position) {\n  if (buffer.length < start.length) {\n    return false\n  }\n\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== buffer[position.position + i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction parsingError (cause) {\n  return new TypeError('Failed to parse body as FormData.', { cause: new TypeError(cause) })\n}\n\nmodule.exports = {\n  multipartFormDataParser,\n  validateBoundary\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZm9ybWRhdGEtcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsK0JBQStCLEVBQUUsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDbEUsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQzVDLFFBQVEsMENBQTBDLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUN4RSxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLHlFQUFZO0FBQzFDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0VBQVc7QUFDdEMsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFaEQ7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtREFBbUQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxlQUFlOztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBOztBQUVBO0FBQ0EsY0FBYyxlQUFlLGFBQWE7QUFDMUMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RCw2QkFBNkI7QUFDM0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL2Zvcm1kYXRhLXBhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBidWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lIH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3QgeyB1dGY4RGVjb2RlQnl0ZXMgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IEhUVFBfVE9LRU5fQ09ERVBPSU5UUywgaXNvbW9ycGhpY0RlY29kZSB9ID0gcmVxdWlyZSgnLi9kYXRhLXVybCcpXG5jb25zdCB7IG1ha2VFbnRyeSB9ID0gcmVxdWlyZSgnLi9mb3JtZGF0YScpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vd2ViaWRsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgRmlsZTogTm9kZUZpbGUgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcblxuY29uc3QgRmlsZSA9IGdsb2JhbFRoaXMuRmlsZSA/PyBOb2RlRmlsZVxuXG5jb25zdCBmb3JtRGF0YU5hbWVCdWZmZXIgPSBCdWZmZXIuZnJvbSgnZm9ybS1kYXRhOyBuYW1lPVwiJylcbmNvbnN0IGZpbGVuYW1lQnVmZmVyID0gQnVmZmVyLmZyb20oJ2ZpbGVuYW1lJylcbmNvbnN0IGRkID0gQnVmZmVyLmZyb20oJy0tJylcbmNvbnN0IGRkY3JsZiA9IEJ1ZmZlci5mcm9tKCctLVxcclxcbicpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJzXG4gKi9cbmZ1bmN0aW9uIGlzQXNjaWlTdHJpbmcgKGNoYXJzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGNoYXJzLmNoYXJDb2RlQXQoaSkgJiB+MHg3RikgIT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9hbmRyZXVib3RlbGxhLmdpdGh1Yi5pby9tdWx0aXBhcnQtZm9ybS1kYXRhLyNtdWx0aXBhcnQtZm9ybS1kYXRhLWJvdW5kYXJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gYm91bmRhcnlcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVCb3VuZGFyeSAoYm91bmRhcnkpIHtcbiAgY29uc3QgbGVuZ3RoID0gYm91bmRhcnkubGVuZ3RoXG5cbiAgLy8gLSBpdHMgbGVuZ3RoIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMjcgYW5kIGxlc3NlciBvciBlcXVhbCB0byA3MCwgYW5kXG4gIGlmIChsZW5ndGggPCAyNyB8fCBsZW5ndGggPiA3MCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gLSBpdCBpcyBjb21wb3NlZCBieSBieXRlcyBpbiB0aGUgcmFuZ2VzIDB4MzAgdG8gMHgzOSwgMHg0MSB0byAweDVBLCBvclxuICAvLyAgIDB4NjEgdG8gMHg3QSwgaW5jbHVzaXZlIChBU0NJSSBhbHBoYW51bWVyaWMpLCBvciB3aGljaCBhcmUgMHgyNyAoJyksXG4gIC8vICAgMHgyRCAoLSkgb3IgMHg1RiAoXykuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjcCA9IGJvdW5kYXJ5LmNoYXJDb2RlQXQoaSlcblxuICAgIGlmICghKFxuICAgICAgKGNwID49IDB4MzAgJiYgY3AgPD0gMHgzOSkgfHxcbiAgICAgIChjcCA+PSAweDQxICYmIGNwIDw9IDB4NWEpIHx8XG4gICAgICAoY3AgPj0gMHg2MSAmJiBjcCA8PSAweDdhKSB8fFxuICAgICAgY3AgPT09IDB4MjcgfHxcbiAgICAgIGNwID09PSAweDJkIHx8XG4gICAgICBjcCA9PT0gMHg1ZlxuICAgICkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2FuZHJldWJvdGVsbGEuZ2l0aHViLmlvL211bHRpcGFydC1mb3JtLWRhdGEvI211bHRpcGFydC1mb3JtLWRhdGEtcGFyc2VyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW5wdXRcbiAqIEBwYXJhbSB7UmV0dXJuVHlwZTxpbXBvcnQoJy4vZGF0YS11cmwnKVsncGFyc2VNSU1FVHlwZSddPn0gbWltZVR5cGVcbiAqL1xuZnVuY3Rpb24gbXVsdGlwYXJ0Rm9ybURhdGFQYXJzZXIgKGlucHV0LCBtaW1lVHlwZSkge1xuICAvLyAxLiBBc3NlcnQ6IG1pbWVUeXBl4oCZcyBlc3NlbmNlIGlzIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLlxuICBhc3NlcnQobWltZVR5cGUgIT09ICdmYWlsdXJlJyAmJiBtaW1lVHlwZS5lc3NlbmNlID09PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpXG5cbiAgY29uc3QgYm91bmRhcnlTdHJpbmcgPSBtaW1lVHlwZS5wYXJhbWV0ZXJzLmdldCgnYm91bmRhcnknKVxuXG4gIC8vIDIuIElmIG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzW1wiYm91bmRhcnlcIl0gZG9lcyBub3QgZXhpc3QsIHJldHVybiBmYWlsdXJlLlxuICAvLyAgICBPdGhlcndpc2UsIGxldCBib3VuZGFyeSBiZSB0aGUgcmVzdWx0IG9mIFVURi04IGRlY29kaW5nIG1pbWVUeXBl4oCZc1xuICAvLyAgICBwYXJhbWV0ZXJzW1wiYm91bmRhcnlcIl0uXG4gIGlmIChib3VuZGFyeVN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgcGFyc2luZ0Vycm9yKCdtaXNzaW5nIGJvdW5kYXJ5IGluIGNvbnRlbnQtdHlwZSBoZWFkZXInKVxuICB9XG5cbiAgY29uc3QgYm91bmRhcnkgPSBCdWZmZXIuZnJvbShgLS0ke2JvdW5kYXJ5U3RyaW5nfWAsICd1dGY4JylcblxuICAvLyAzLiBMZXQgZW50cnkgbGlzdCBiZSBhbiBlbXB0eSBlbnRyeSBsaXN0LlxuICBjb25zdCBlbnRyeUxpc3QgPSBbXVxuXG4gIC8vIDQuIExldCBwb3NpdGlvbiBiZSBhIHBvaW50ZXIgdG8gYSBieXRlIGluIGlucHV0LCBpbml0aWFsbHkgcG9pbnRpbmcgYXRcbiAgLy8gICAgdGhlIGZpcnN0IGJ5dGUuXG4gIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG5cbiAgLy8gTm90ZTogdW5kaWNpIGFkZGl0aW9uLCBhbGxvd3MgbGVhZGluZyBhbmQgdHJhaWxpbmcgQ1JMRnMuXG4gIHdoaWxlIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gPT09IDB4MGQgJiYgaW5wdXRbcG9zaXRpb24ucG9zaXRpb24gKyAxXSA9PT0gMHgwYSkge1xuICAgIHBvc2l0aW9uLnBvc2l0aW9uICs9IDJcbiAgfVxuXG4gIGxldCB0cmFpbGluZyA9IGlucHV0Lmxlbmd0aFxuXG4gIHdoaWxlIChpbnB1dFt0cmFpbGluZyAtIDFdID09PSAweDBhICYmIGlucHV0W3RyYWlsaW5nIC0gMl0gPT09IDB4MGQpIHtcbiAgICB0cmFpbGluZyAtPSAyXG4gIH1cblxuICBpZiAodHJhaWxpbmcgIT09IGlucHV0Lmxlbmd0aCkge1xuICAgIGlucHV0ID0gaW5wdXQuc3ViYXJyYXkoMCwgdHJhaWxpbmcpXG4gIH1cblxuICAvLyA1LiBXaGlsZSB0cnVlOlxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIDUuMS4gSWYgcG9zaXRpb24gcG9pbnRzIHRvIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgc3RhcnRpbmcgd2l0aCAweDJEIDB4MkRcbiAgICAvLyAgICAgIChgLS1gKSBmb2xsb3dlZCBieSBib3VuZGFyeSwgYWR2YW5jZSBwb3NpdGlvbiBieSAyICsgdGhlIGxlbmd0aCBvZlxuICAgIC8vICAgICAgYm91bmRhcnkuIE90aGVyd2lzZSwgcmV0dXJuIGZhaWx1cmUuXG4gICAgLy8gTm90ZTogYm91bmRhcnkgaXMgcGFkZGVkIHdpdGggMiBkYXNoZXMgYWxyZWFkeSwgbm8gbmVlZCB0byBhZGQgMi5cbiAgICBpZiAoaW5wdXQuc3ViYXJyYXkocG9zaXRpb24ucG9zaXRpb24sIHBvc2l0aW9uLnBvc2l0aW9uICsgYm91bmRhcnkubGVuZ3RoKS5lcXVhbHMoYm91bmRhcnkpKSB7XG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSBib3VuZGFyeS5sZW5ndGhcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgcGFyc2luZ0Vycm9yKCdleHBlY3RlZCBhIHZhbHVlIHN0YXJ0aW5nIHdpdGggLS0gYW5kIHRoZSBib3VuZGFyeScpXG4gICAgfVxuXG4gICAgLy8gNS4yLiBJZiBwb3NpdGlvbiBwb2ludHMgdG8gdGhlIHNlcXVlbmNlIG9mIGJ5dGVzIDB4MkQgMHgyRCAweDBEIDB4MEFcbiAgICAvLyAgICAgIChgLS1gIGZvbGxvd2VkIGJ5IENSIExGKSBmb2xsb3dlZCBieSB0aGUgZW5kIG9mIGlucHV0LCByZXR1cm4gZW50cnkgbGlzdC5cbiAgICAvLyBOb3RlOiBhIGJvZHkgZG9lcyBOT1QgbmVlZCB0byBlbmQgd2l0aCBDUkxGLiBJdCBjYW4gZW5kIHdpdGggLS0uXG4gICAgaWYgKFxuICAgICAgKHBvc2l0aW9uLnBvc2l0aW9uID09PSBpbnB1dC5sZW5ndGggLSAyICYmIGJ1ZmZlclN0YXJ0c1dpdGgoaW5wdXQsIGRkLCBwb3NpdGlvbikpIHx8XG4gICAgICAocG9zaXRpb24ucG9zaXRpb24gPT09IGlucHV0Lmxlbmd0aCAtIDQgJiYgYnVmZmVyU3RhcnRzV2l0aChpbnB1dCwgZGRjcmxmLCBwb3NpdGlvbikpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZW50cnlMaXN0XG4gICAgfVxuXG4gICAgLy8gNS4zLiBJZiBwb3NpdGlvbiBkb2VzIG5vdCBwb2ludCB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGggMHgwRFxuICAgIC8vICAgICAgMHgwQSAoQ1IgTEYpLCByZXR1cm4gZmFpbHVyZS5cbiAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dICE9PSAweDBkIHx8IGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uICsgMV0gIT09IDB4MGEpIHtcbiAgICAgIHRocm93IHBhcnNpbmdFcnJvcignZXhwZWN0ZWQgQ1JMRicpXG4gICAgfVxuXG4gICAgLy8gNS40LiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDIuIChUaGlzIHNraXBzIHBhc3QgdGhlIG5ld2xpbmUuKVxuICAgIHBvc2l0aW9uLnBvc2l0aW9uICs9IDJcblxuICAgIC8vIDUuNS4gTGV0IG5hbWUsIGZpbGVuYW1lIGFuZCBjb250ZW50VHlwZSBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmdcbiAgICAvLyAgICAgIG11bHRpcGFydC9mb3JtLWRhdGEgaGVhZGVycyBvbiBpbnB1dCBhbmQgcG9zaXRpb24sIGlmIHRoZSByZXN1bHRcbiAgICAvLyAgICAgIGlzIG5vdCBmYWlsdXJlLiBPdGhlcndpc2UsIHJldHVybiBmYWlsdXJlLlxuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlTXVsdGlwYXJ0Rm9ybURhdGFIZWFkZXJzKGlucHV0LCBwb3NpdGlvbilcblxuICAgIGxldCB7IG5hbWUsIGZpbGVuYW1lLCBjb250ZW50VHlwZSwgZW5jb2RpbmcgfSA9IHJlc3VsdFxuXG4gICAgLy8gNS42LiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDIuIChUaGlzIHNraXBzIHBhc3QgdGhlIGVtcHR5IGxpbmUgdGhhdCBtYXJrc1xuICAgIC8vICAgICAgdGhlIGVuZCBvZiB0aGUgaGVhZGVycy4pXG4gICAgcG9zaXRpb24ucG9zaXRpb24gKz0gMlxuXG4gICAgLy8gNS43LiBMZXQgYm9keSBiZSB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZS5cbiAgICBsZXQgYm9keVxuXG4gICAgLy8gNS44LiBCb2R5IGxvb3A6IFdoaWxlIHBvc2l0aW9uIGlzIG5vdCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQ6XG4gICAgLy8gVE9ETzogdGhlIHN0ZXBzIGhlcmUgYXJlIGNvbXBsZXRlbHkgd3JvbmdcbiAgICB7XG4gICAgICBjb25zdCBib3VuZGFyeUluZGV4ID0gaW5wdXQuaW5kZXhPZihib3VuZGFyeS5zdWJhcnJheSgyKSwgcG9zaXRpb24ucG9zaXRpb24pXG5cbiAgICAgIGlmIChib3VuZGFyeUluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBwYXJzaW5nRXJyb3IoJ2V4cGVjdGVkIGJvdW5kYXJ5IGFmdGVyIGJvZHknKVxuICAgICAgfVxuXG4gICAgICBib2R5ID0gaW5wdXQuc3ViYXJyYXkocG9zaXRpb24ucG9zaXRpb24sIGJvdW5kYXJ5SW5kZXggLSA0KVxuXG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSBib2R5Lmxlbmd0aFxuXG4gICAgICAvLyBOb3RlOiBwb3NpdGlvbiBtdXN0IGJlIGFkdmFuY2VkIGJ5IHRoZSBib2R5J3MgbGVuZ3RoIGJlZm9yZSBiZWluZ1xuICAgICAgLy8gZGVjb2RlZCwgb3RoZXJ3aXNlIHRoZSBwYXJzaW5nIHdpbGwgZmFpbC5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgYm9keSA9IEJ1ZmZlci5mcm9tKGJvZHkudG9TdHJpbmcoKSwgJ2Jhc2U2NCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS45LiBJZiBwb3NpdGlvbiBkb2VzIG5vdCBwb2ludCB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGhcbiAgICAvLyAgICAgIDB4MEQgMHgwQSAoQ1IgTEYpLCByZXR1cm4gZmFpbHVyZS4gT3RoZXJ3aXNlLCBhZHZhbmNlIHBvc2l0aW9uIGJ5IDIuXG4gICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSAhPT0gMHgwZCB8fCBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbiArIDFdICE9PSAweDBhKSB7XG4gICAgICB0aHJvdyBwYXJzaW5nRXJyb3IoJ2V4cGVjdGVkIENSTEYnKVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSAyXG4gICAgfVxuXG4gICAgLy8gNS4xMC4gSWYgZmlsZW5hbWUgaXMgbm90IG51bGw6XG4gICAgbGV0IHZhbHVlXG5cbiAgICBpZiAoZmlsZW5hbWUgIT09IG51bGwpIHtcbiAgICAgIC8vIDUuMTAuMS4gSWYgY29udGVudFR5cGUgaXMgbnVsbCwgc2V0IGNvbnRlbnRUeXBlIHRvIFwidGV4dC9wbGFpblwiLlxuICAgICAgY29udGVudFR5cGUgPz89ICd0ZXh0L3BsYWluJ1xuXG4gICAgICAvLyA1LjEwLjIuIElmIGNvbnRlbnRUeXBlIGlzIG5vdCBhbiBBU0NJSSBzdHJpbmcsIHNldCBjb250ZW50VHlwZSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuXG4gICAgICAvLyBOb3RlOiBgYnVmZmVyLmlzQXNjaWlgIGNhbiBiZSB1c2VkIGF0IHplcm8tY29zdCwgYnV0IGNvbnZlcnRpbmcgYSBzdHJpbmcgdG8gYSBidWZmZXIgaXMgYSBoaWdoIG92ZXJoZWFkLlxuICAgICAgLy8gQ29udGVudC1UeXBlIGlzIGEgcmVsYXRpdmVseSBzbWFsbCBzdHJpbmcsIHNvIGl0IGlzIGZhc3RlciB0byB1c2UgYFN0cmluZyNjaGFyQ29kZUF0YC5cbiAgICAgIGlmICghaXNBc2NpaVN0cmluZyhjb250ZW50VHlwZSkpIHtcbiAgICAgICAgY29udGVudFR5cGUgPSAnJ1xuICAgICAgfVxuXG4gICAgICAvLyA1LjEwLjMuIExldCB2YWx1ZSBiZSBhIG5ldyBGaWxlIG9iamVjdCB3aXRoIG5hbWUgZmlsZW5hbWUsIHR5cGUgY29udGVudFR5cGUsIGFuZCBib2R5IGJvZHkuXG4gICAgICB2YWx1ZSA9IG5ldyBGaWxlKFtib2R5XSwgZmlsZW5hbWUsIHsgdHlwZTogY29udGVudFR5cGUgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gNS4xMS4gT3RoZXJ3aXNlOlxuXG4gICAgICAvLyA1LjExLjEuIExldCB2YWx1ZSBiZSB0aGUgVVRGLTggZGVjb2Rpbmcgd2l0aG91dCBCT00gb2YgYm9keS5cbiAgICAgIHZhbHVlID0gdXRmOERlY29kZUJ5dGVzKEJ1ZmZlci5mcm9tKGJvZHkpKVxuICAgIH1cblxuICAgIC8vIDUuMTIuIEFzc2VydDogbmFtZSBpcyBhIHNjYWxhciB2YWx1ZSBzdHJpbmcgYW5kIHZhbHVlIGlzIGVpdGhlciBhIHNjYWxhciB2YWx1ZSBzdHJpbmcgb3IgYSBGaWxlIG9iamVjdC5cbiAgICBhc3NlcnQod2ViaWRsLmlzLlVTVlN0cmluZyhuYW1lKSlcbiAgICBhc3NlcnQoKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgd2ViaWRsLmlzLlVTVlN0cmluZyh2YWx1ZSkpIHx8IHdlYmlkbC5pcy5GaWxlKHZhbHVlKSlcblxuICAgIC8vIDUuMTMuIENyZWF0ZSBhbiBlbnRyeSB3aXRoIG5hbWUgYW5kIHZhbHVlLCBhbmQgYXBwZW5kIGl0IHRvIGVudHJ5IGxpc3QuXG4gICAgZW50cnlMaXN0LnB1c2gobWFrZUVudHJ5KG5hbWUsIHZhbHVlLCBmaWxlbmFtZSkpXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vYW5kcmV1Ym90ZWxsYS5naXRodWIuaW8vbXVsdGlwYXJ0LWZvcm0tZGF0YS8jcGFyc2UtbXVsdGlwYXJ0LWZvcm0tZGF0YS1oZWFkZXJzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTXVsdGlwYXJ0Rm9ybURhdGFIZWFkZXJzIChpbnB1dCwgcG9zaXRpb24pIHtcbiAgLy8gMS4gTGV0IG5hbWUsIGZpbGVuYW1lIGFuZCBjb250ZW50VHlwZSBiZSBudWxsLlxuICBsZXQgbmFtZSA9IG51bGxcbiAgbGV0IGZpbGVuYW1lID0gbnVsbFxuICBsZXQgY29udGVudFR5cGUgPSBudWxsXG4gIGxldCBlbmNvZGluZyA9IG51bGxcblxuICAvLyAyLiBXaGlsZSB0cnVlOlxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIDIuMS4gSWYgcG9zaXRpb24gcG9pbnRzIHRvIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgc3RhcnRpbmcgd2l0aCAweDBEIDB4MEEgKENSIExGKTpcbiAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAweDBkICYmIGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uICsgMV0gPT09IDB4MGEpIHtcbiAgICAgIC8vIDIuMS4xLiBJZiBuYW1lIGlzIG51bGwsIHJldHVybiBmYWlsdXJlLlxuICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgcGFyc2luZ0Vycm9yKCdoZWFkZXIgbmFtZSBpcyBudWxsJylcbiAgICAgIH1cblxuICAgICAgLy8gMi4xLjIuIFJldHVybiBuYW1lLCBmaWxlbmFtZSBhbmQgY29udGVudFR5cGUuXG4gICAgICByZXR1cm4geyBuYW1lLCBmaWxlbmFtZSwgY29udGVudFR5cGUsIGVuY29kaW5nIH1cbiAgICB9XG5cbiAgICAvLyAyLjIuIExldCBoZWFkZXIgbmFtZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZiBieXRlcyB0aGF0IGFyZVxuICAgIC8vICAgICAgbm90IDB4MEEgKExGKSwgMHgwRCAoQ1IpIG9yIDB4M0EgKDopLCBnaXZlbiBwb3NpdGlvbi5cbiAgICBsZXQgaGVhZGVyTmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgIT09IDB4MGEgJiYgY2hhciAhPT0gMHgwZCAmJiBjaGFyICE9PSAweDNhLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDIuMy4gUmVtb3ZlIGFueSBIVFRQIHRhYiBvciBzcGFjZSBieXRlcyBmcm9tIHRoZSBzdGFydCBvciBlbmQgb2YgaGVhZGVyIG5hbWUuXG4gICAgaGVhZGVyTmFtZSA9IHJlbW92ZUNoYXJzKGhlYWRlck5hbWUsIHRydWUsIHRydWUsIChjaGFyKSA9PiBjaGFyID09PSAweDkgfHwgY2hhciA9PT0gMHgyMClcblxuICAgIC8vIDIuNC4gSWYgaGVhZGVyIG5hbWUgZG9lcyBub3QgbWF0Y2ggdGhlIGZpZWxkLW5hbWUgdG9rZW4gcHJvZHVjdGlvbiwgcmV0dXJuIGZhaWx1cmUuXG4gICAgaWYgKCFIVFRQX1RPS0VOX0NPREVQT0lOVFMudGVzdChoZWFkZXJOYW1lLnRvU3RyaW5nKCkpKSB7XG4gICAgICB0aHJvdyBwYXJzaW5nRXJyb3IoJ2hlYWRlciBuYW1lIGRvZXMgbm90IG1hdGNoIHRoZSBmaWVsZC1uYW1lIHRva2VuIHByb2R1Y3Rpb24nKVxuICAgIH1cblxuICAgIC8vIDIuNS4gSWYgdGhlIGJ5dGUgYXQgcG9zaXRpb24gaXMgbm90IDB4M0EgKDopLCByZXR1cm4gZmFpbHVyZS5cbiAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dICE9PSAweDNhKSB7XG4gICAgICB0aHJvdyBwYXJzaW5nRXJyb3IoJ2V4cGVjdGVkIDonKVxuICAgIH1cblxuICAgIC8vIDIuNi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAgIC8vIDIuNy4gQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGJ5dGVzIHRoYXQgYXJlIEhUVFAgdGFiIG9yIHNwYWNlIGJ5dGVzIGdpdmVuIHBvc2l0aW9uLlxuICAgIC8vICAgICAgKERvIG5vdGhpbmcgd2l0aCB0aG9zZSBieXRlcy4pXG4gICAgY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMoXG4gICAgICAoY2hhcikgPT4gY2hhciA9PT0gMHgyMCB8fCBjaGFyID09PSAweDA5LFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDIuOC4gQnl0ZS1sb3dlcmNhc2UgaGVhZGVyIG5hbWUgYW5kIHN3aXRjaCBvbiB0aGUgcmVzdWx0OlxuICAgIHN3aXRjaCAoYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZShoZWFkZXJOYW1lKSkge1xuICAgICAgY2FzZSAnY29udGVudC1kaXNwb3NpdGlvbic6IHtcbiAgICAgICAgLy8gMS4gU2V0IG5hbWUgYW5kIGZpbGVuYW1lIHRvIG51bGwuXG4gICAgICAgIG5hbWUgPSBmaWxlbmFtZSA9IG51bGxcblxuICAgICAgICAvLyAyLiBJZiBwb3NpdGlvbiBkb2VzIG5vdCBwb2ludCB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGhcbiAgICAgICAgLy8gICAgYGZvcm0tZGF0YTsgbmFtZT1cImAsIHJldHVybiBmYWlsdXJlLlxuICAgICAgICBpZiAoIWJ1ZmZlclN0YXJ0c1dpdGgoaW5wdXQsIGZvcm1EYXRhTmFtZUJ1ZmZlciwgcG9zaXRpb24pKSB7XG4gICAgICAgICAgdGhyb3cgcGFyc2luZ0Vycm9yKCdleHBlY3RlZCBmb3JtLWRhdGE7IG5hbWU9XCIgZm9yIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIEFkdmFuY2UgcG9zaXRpb24gc28gaXQgcG9pbnRzIGF0IHRoZSBieXRlIGFmdGVyIHRoZSBuZXh0IDB4MjIgKFwiKVxuICAgICAgICAvLyAgICBieXRlICh0aGUgb25lIGluIHRoZSBzZXF1ZW5jZSBvZiBieXRlcyBtYXRjaGVkIGFib3ZlKS5cbiAgICAgICAgcG9zaXRpb24ucG9zaXRpb24gKz0gMTdcblxuICAgICAgICAvLyA0LiBTZXQgbmFtZSB0byB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgYSBtdWx0aXBhcnQvZm9ybS1kYXRhIG5hbWUgZ2l2ZW5cbiAgICAgICAgLy8gICAgaW5wdXQgYW5kIHBvc2l0aW9uLCBpZiB0aGUgcmVzdWx0IGlzIG5vdCBmYWlsdXJlLiBPdGhlcndpc2UsIHJldHVyblxuICAgICAgICAvLyAgICBmYWlsdXJlLlxuICAgICAgICBuYW1lID0gcGFyc2VNdWx0aXBhcnRGb3JtRGF0YU5hbWUoaW5wdXQsIHBvc2l0aW9uKVxuXG4gICAgICAgIC8vIDUuIElmIHBvc2l0aW9uIHBvaW50cyB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGggYDsgZmlsZW5hbWU9XCJgOlxuICAgICAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAweDNiIC8qIDsgKi8gJiYgaW5wdXRbcG9zaXRpb24ucG9zaXRpb24gKyAxXSA9PT0gMHgyMCAvKiAnICcgKi8pIHtcbiAgICAgICAgICBjb25zdCBhdCA9IHsgcG9zaXRpb246IHBvc2l0aW9uLnBvc2l0aW9uICsgMiB9XG5cbiAgICAgICAgICBpZiAoYnVmZmVyU3RhcnRzV2l0aChpbnB1dCwgZmlsZW5hbWVCdWZmZXIsIGF0KSkge1xuICAgICAgICAgICAgaWYgKGlucHV0W2F0LnBvc2l0aW9uICsgOF0gPT09IDB4MmEgLyogJyonICovKSB7XG4gICAgICAgICAgICAgIGF0LnBvc2l0aW9uICs9IDEwIC8vIHNraXAgcGFzdCBmaWxlbmFtZSo9XG5cbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgaHR0cCB0YWIgYW5kIHNwYWNlcy4gU2VlIFJGQyBmb3IgZXhhbXBsZXMuXG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjI2NiNzZWN0aW9uLTVcbiAgICAgICAgICAgICAgY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMoXG4gICAgICAgICAgICAgICAgKGNoYXIpID0+IGNoYXIgPT09IDB4MjAgfHwgY2hhciA9PT0gMHgwOSxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBhdFxuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgY29uc3QgaGVhZGVyVmFsdWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZCeXRlcyhcbiAgICAgICAgICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gMHgyMCAmJiBjaGFyICE9PSAweDBkICYmIGNoYXIgIT09IDB4MGEsIC8vICcgJyBvciBDUkxGXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgYXRcbiAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoaGVhZGVyVmFsdWVbMF0gIT09IDB4NzUgJiYgaGVhZGVyVmFsdWVbMF0gIT09IDB4NTUpIHx8IC8vIHUgb3IgVVxuICAgICAgICAgICAgICAgIChoZWFkZXJWYWx1ZVsxXSAhPT0gMHg3NCAmJiBoZWFkZXJWYWx1ZVsxXSAhPT0gMHg1NCkgfHwgLy8gdCBvciBUXG4gICAgICAgICAgICAgICAgKGhlYWRlclZhbHVlWzJdICE9PSAweDY2ICYmIGhlYWRlclZhbHVlWzJdICE9PSAweDQ2KSB8fCAvLyBmIG9yIEZcbiAgICAgICAgICAgICAgICBoZWFkZXJWYWx1ZVszXSAhPT0gMHgyZCB8fCAvLyAtXG4gICAgICAgICAgICAgICAgaGVhZGVyVmFsdWVbNF0gIT09IDB4MzggLy8gOFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBwYXJzaW5nRXJyb3IoJ3Vua25vd24gZW5jb2RpbmcsIGV4cGVjdGVkIHV0Zi04XFwnXFwnJylcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIHNraXAgdXRmLTgnJ1xuICAgICAgICAgICAgICBmaWxlbmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudChuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoaGVhZGVyVmFsdWUuc3ViYXJyYXkoNykpKVxuXG4gICAgICAgICAgICAgIHBvc2l0aW9uLnBvc2l0aW9uID0gYXQucG9zaXRpb25cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIDEuIEFkdmFuY2UgcG9zaXRpb24gc28gaXQgcG9pbnRzIGF0IHRoZSBieXRlIGFmdGVyIHRoZSBuZXh0IDB4MjIgKFwiKSBieXRlXG4gICAgICAgICAgICAgIC8vICAgICh0aGUgb25lIGluIHRoZSBzZXF1ZW5jZSBvZiBieXRlcyBtYXRjaGVkIGFib3ZlKS5cbiAgICAgICAgICAgICAgcG9zaXRpb24ucG9zaXRpb24gKz0gMTFcblxuICAgICAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBodHRwIHRhYiBhbmQgc3BhY2VzLiBTZWUgUkZDIGZvciBleGFtcGxlcy5cbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2MjY2I3NlY3Rpb24tNVxuICAgICAgICAgICAgICBjb2xsZWN0QVNlcXVlbmNlT2ZCeXRlcyhcbiAgICAgICAgICAgICAgICAoY2hhcikgPT4gY2hhciA9PT0gMHgyMCB8fCBjaGFyID09PSAweDA5LFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICBwb3NpdGlvbi5wb3NpdGlvbisrIC8vIHNraXAgcGFzdCBcIiBhZnRlciByZW1vdmluZyB3aGl0ZXNwYWNlXG5cbiAgICAgICAgICAgICAgLy8gMi4gU2V0IGZpbGVuYW1lIHRvIHRoZSByZXN1bHQgb2YgcGFyc2luZyBhIG11bHRpcGFydC9mb3JtLWRhdGEgbmFtZSBnaXZlblxuICAgICAgICAgICAgICAvLyAgICBpbnB1dCBhbmQgcG9zaXRpb24sIGlmIHRoZSByZXN1bHQgaXMgbm90IGZhaWx1cmUuIE90aGVyd2lzZSwgcmV0dXJuIGZhaWx1cmUuXG4gICAgICAgICAgICAgIGZpbGVuYW1lID0gcGFyc2VNdWx0aXBhcnRGb3JtRGF0YU5hbWUoaW5wdXQsIHBvc2l0aW9uKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdjb250ZW50LXR5cGUnOiB7XG4gICAgICAgIC8vIDEuIExldCBoZWFkZXIgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgdGhhdCBhcmVcbiAgICAgICAgLy8gICAgbm90IDB4MEEgKExGKSBvciAweDBEIChDUiksIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgICBsZXQgaGVhZGVyVmFsdWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZCeXRlcyhcbiAgICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gMHgwYSAmJiBjaGFyICE9PSAweDBkLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIClcblxuICAgICAgICAvLyAyLiBSZW1vdmUgYW55IEhUVFAgdGFiIG9yIHNwYWNlIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBoZWFkZXIgdmFsdWUuXG4gICAgICAgIGhlYWRlclZhbHVlID0gcmVtb3ZlQ2hhcnMoaGVhZGVyVmFsdWUsIGZhbHNlLCB0cnVlLCAoY2hhcikgPT4gY2hhciA9PT0gMHg5IHx8IGNoYXIgPT09IDB4MjApXG5cbiAgICAgICAgLy8gMy4gU2V0IGNvbnRlbnRUeXBlIHRvIHRoZSBpc29tb3JwaGljIGRlY29kaW5nIG9mIGhlYWRlciB2YWx1ZS5cbiAgICAgICAgY29udGVudFR5cGUgPSBpc29tb3JwaGljRGVjb2RlKGhlYWRlclZhbHVlKVxuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdjb250ZW50LXRyYW5zZmVyLWVuY29kaW5nJzoge1xuICAgICAgICBsZXQgaGVhZGVyVmFsdWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZCeXRlcyhcbiAgICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gMHgwYSAmJiBjaGFyICE9PSAweDBkLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIClcblxuICAgICAgICBoZWFkZXJWYWx1ZSA9IHJlbW92ZUNoYXJzKGhlYWRlclZhbHVlLCBmYWxzZSwgdHJ1ZSwgKGNoYXIpID0+IGNoYXIgPT09IDB4OSB8fCBjaGFyID09PSAweDIwKVxuXG4gICAgICAgIGVuY29kaW5nID0gaXNvbW9ycGhpY0RlY29kZShoZWFkZXJWYWx1ZSlcblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICAvLyBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgYnl0ZXMgdGhhdCBhcmUgbm90IDB4MEEgKExGKSBvciAweDBEIChDUiksIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgICAvLyAoRG8gbm90aGluZyB3aXRoIHRob3NlIGJ5dGVzLilcbiAgICAgICAgY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMoXG4gICAgICAgICAgKGNoYXIpID0+IGNoYXIgIT09IDB4MGEgJiYgY2hhciAhPT0gMHgwZCxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMi45LiBJZiBwb3NpdGlvbiBkb2VzIG5vdCBwb2ludCB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGggMHgwRCAweDBBXG4gICAgLy8gICAgICAoQ1IgTEYpLCByZXR1cm4gZmFpbHVyZS4gT3RoZXJ3aXNlLCBhZHZhbmNlIHBvc2l0aW9uIGJ5IDIgKHBhc3QgdGhlIG5ld2xpbmUpLlxuICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gIT09IDB4MGQgJiYgaW5wdXRbcG9zaXRpb24ucG9zaXRpb24gKyAxXSAhPT0gMHgwYSkge1xuICAgICAgdGhyb3cgcGFyc2luZ0Vycm9yKCdleHBlY3RlZCBDUkxGJylcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zaXRpb24ucG9zaXRpb24gKz0gMlxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9hbmRyZXVib3RlbGxhLmdpdGh1Yi5pby9tdWx0aXBhcnQtZm9ybS1kYXRhLyNwYXJzZS1hLW11bHRpcGFydC1mb3JtLWRhdGEtbmFtZVxuICogQHBhcmFtIHtCdWZmZXJ9IGlucHV0XG4gKiBAcGFyYW0ge3sgcG9zaXRpb246IG51bWJlciB9fSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBwYXJzZU11bHRpcGFydEZvcm1EYXRhTmFtZSAoaW5wdXQsIHBvc2l0aW9uKSB7XG4gIC8vIDEuIEFzc2VydDogVGhlIGJ5dGUgYXQgKHBvc2l0aW9uIC0gMSkgaXMgMHgyMiAoXCIpLlxuICBhc3NlcnQoaW5wdXRbcG9zaXRpb24ucG9zaXRpb24gLSAxXSA9PT0gMHgyMilcblxuICAvLyAyLiBMZXQgbmFtZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZiBieXRlcyB0aGF0IGFyZSBub3QgMHgwQSAoTEYpLCAweDBEIChDUikgb3IgMHgyMiAoXCIpLCBnaXZlbiBwb3NpdGlvbi5cbiAgLyoqIEB0eXBlIHtzdHJpbmcgfCBCdWZmZXJ9ICovXG4gIGxldCBuYW1lID0gY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMoXG4gICAgKGNoYXIpID0+IGNoYXIgIT09IDB4MGEgJiYgY2hhciAhPT0gMHgwZCAmJiBjaGFyICE9PSAweDIyLFxuICAgIGlucHV0LFxuICAgIHBvc2l0aW9uXG4gIClcblxuICAvLyAzLiBJZiB0aGUgYnl0ZSBhdCBwb3NpdGlvbiBpcyBub3QgMHgyMiAoXCIpLCByZXR1cm4gZmFpbHVyZS4gT3RoZXJ3aXNlLCBhZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gIT09IDB4MjIpIHtcbiAgICB0aHJvdyBwYXJzaW5nRXJyb3IoJ2V4cGVjdGVkIFwiJylcbiAgfSBlbHNlIHtcbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG4gIH1cblxuICAvLyA0LiBSZXBsYWNlIGFueSBvY2N1cnJlbmNlIG9mIHRoZSBmb2xsb3dpbmcgc3Vic2VxdWVuY2VzIGluIG5hbWUgd2l0aCB0aGUgZ2l2ZW4gYnl0ZTpcbiAgLy8gLSBgJTBBYDogMHgwQSAoTEYpXG4gIC8vIC0gYCUwRGA6IDB4MEQgKENSKVxuICAvLyAtIGAlMjJgOiAweDIyIChcIilcbiAgbmFtZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShuYW1lKVxuICAgIC5yZXBsYWNlKC8lMEEvaWcsICdcXG4nKVxuICAgIC5yZXBsYWNlKC8lMEQvaWcsICdcXHInKVxuICAgIC5yZXBsYWNlKC8lMjIvZywgJ1wiJylcblxuICAvLyA1LiBSZXR1cm4gdGhlIFVURi04IGRlY29kaW5nIHdpdGhvdXQgQk9NIG9mIG5hbWUuXG4gIHJldHVybiBuYW1lXG59XG5cbi8qKlxuICogQHBhcmFtIHsoY2hhcjogbnVtYmVyKSA9PiBib29sZWFufSBjb25kaXRpb25cbiAqIEBwYXJhbSB7QnVmZmVyfSBpbnB1dFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMgKGNvbmRpdGlvbiwgaW5wdXQsIHBvc2l0aW9uKSB7XG4gIGxldCBzdGFydCA9IHBvc2l0aW9uLnBvc2l0aW9uXG5cbiAgd2hpbGUgKHN0YXJ0IDwgaW5wdXQubGVuZ3RoICYmIGNvbmRpdGlvbihpbnB1dFtzdGFydF0pKSB7XG4gICAgKytzdGFydFxuICB9XG5cbiAgcmV0dXJuIGlucHV0LnN1YmFycmF5KHBvc2l0aW9uLnBvc2l0aW9uLCAocG9zaXRpb24ucG9zaXRpb24gPSBzdGFydCkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHBhcmFtIHtib29sZWFufSBsZWFkaW5nXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHRyYWlsaW5nXG4gKiBAcGFyYW0geyhjaGFyQ29kZTogbnVtYmVyKSA9PiBib29sZWFufSBwcmVkaWNhdGVcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNoYXJzIChidWYsIGxlYWRpbmcsIHRyYWlsaW5nLCBwcmVkaWNhdGUpIHtcbiAgbGV0IGxlYWQgPSAwXG4gIGxldCB0cmFpbCA9IGJ1Zi5sZW5ndGggLSAxXG5cbiAgaWYgKGxlYWRpbmcpIHtcbiAgICB3aGlsZSAobGVhZCA8IGJ1Zi5sZW5ndGggJiYgcHJlZGljYXRlKGJ1ZltsZWFkXSkpIGxlYWQrK1xuICB9XG5cbiAgaWYgKHRyYWlsaW5nKSB7XG4gICAgd2hpbGUgKHRyYWlsID4gMCAmJiBwcmVkaWNhdGUoYnVmW3RyYWlsXSkpIHRyYWlsLS1cbiAgfVxuXG4gIHJldHVybiBsZWFkID09PSAwICYmIHRyYWlsID09PSBidWYubGVuZ3RoIC0gMSA/IGJ1ZiA6IGJ1Zi5zdWJhcnJheShsZWFkLCB0cmFpbCArIDEpXG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHtAcGFyYW0gYnVmZmVyfSBzdGFydHMgd2l0aCB7QHBhcmFtIHN0YXJ0fVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge3sgcG9zaXRpb246IG51bWJlciB9fSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBidWZmZXJTdGFydHNXaXRoIChidWZmZXIsIHN0YXJ0LCBwb3NpdGlvbikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCA8IHN0YXJ0Lmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFydC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdGFydFtpXSAhPT0gYnVmZmVyW3Bvc2l0aW9uLnBvc2l0aW9uICsgaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHBhcnNpbmdFcnJvciAoY2F1c2UpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBib2R5IGFzIEZvcm1EYXRhLicsIHsgY2F1c2U6IG5ldyBUeXBlRXJyb3IoY2F1c2UpIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtdWx0aXBhcnRGb3JtRGF0YVBhcnNlcixcbiAgdmFsaWRhdGVCb3VuZGFyeVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/formdata-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/formdata.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/formdata.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { iteratorMixin } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { File: NativeFile } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\")\n\n/** @type {globalThis['File']} */\nconst File = globalThis.File ?? NativeFile\n\n// https://xhr.spec.whatwg.org/#formdata\nclass FormData {\n  #state = []\n\n  constructor (form) {\n    webidl.util.markAsUncloneable(this)\n\n    if (form !== undefined) {\n      throw webidl.errors.conversionFailed({\n        prefix: 'FormData constructor',\n        argument: 'Argument 1',\n        types: ['undefined']\n      })\n    }\n  }\n\n  append (name, value, filename = undefined) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.append'\n    webidl.argumentLengthCheck(arguments, 2, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    if (arguments.length === 3 || webidl.is.Blob(value)) {\n      value = webidl.converters.Blob(value, prefix, 'value')\n\n      if (filename !== undefined) {\n        filename = webidl.converters.USVString(filename)\n      }\n    } else {\n      value = webidl.converters.USVString(value)\n    }\n\n    // 1. Let value be value if given; otherwise blobValue.\n\n    // 2. Let entry be the result of creating an entry with\n    // name, value, and filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. Append entry to thiss entry list.\n    this.#state.push(entry)\n  }\n\n  delete (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.delete'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    // The delete(name) method steps are to remove all entries whose name\n    // is name from thiss entry list.\n    this.#state = this.#state.filter(entry => entry.name !== name)\n  }\n\n  get (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.get'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    // 1. If there is no entry whose name is name in thiss entry list,\n    // then return null.\n    const idx = this.#state.findIndex((entry) => entry.name === name)\n    if (idx === -1) {\n      return null\n    }\n\n    // 2. Return the value of the first entry whose name is name from\n    // thiss entry list.\n    return this.#state[idx].value\n  }\n\n  getAll (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.getAll'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    // 1. If there is no entry whose name is name in thiss entry list,\n    // then return the empty list.\n    // 2. Return the values of all entries whose name is name, in order,\n    // from thiss entry list.\n    return this.#state\n      .filter((entry) => entry.name === name)\n      .map((entry) => entry.value)\n  }\n\n  has (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.has'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    // The has(name) method steps are to return true if there is an entry\n    // whose name is name in thiss entry list; otherwise false.\n    return this.#state.findIndex((entry) => entry.name === name) !== -1\n  }\n\n  set (name, value, filename = undefined) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.set'\n    webidl.argumentLengthCheck(arguments, 2, prefix)\n\n    name = webidl.converters.USVString(name)\n\n    if (arguments.length === 3 || webidl.is.Blob(value)) {\n      value = webidl.converters.Blob(value, prefix, 'value')\n\n      if (filename !== undefined) {\n        filename = webidl.converters.USVString(filename)\n      }\n    } else {\n      value = webidl.converters.USVString(value)\n    }\n\n    // The set(name, value) and set(name, blobValue, filename) method steps\n    // are:\n\n    // 1. Let value be value if given; otherwise blobValue.\n\n    // 2. Let entry be the result of creating an entry with name, value, and\n    // filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. If there are entries in thiss entry list whose name is name, then\n    // replace the first such entry with entry and remove the others.\n    const idx = this.#state.findIndex((entry) => entry.name === name)\n    if (idx !== -1) {\n      this.#state = [\n        ...this.#state.slice(0, idx),\n        entry,\n        ...this.#state.slice(idx + 1).filter((entry) => entry.name !== name)\n      ]\n    } else {\n      // 4. Otherwise, append entry to thiss entry list.\n      this.#state.push(entry)\n    }\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    const state = this.#state.reduce((a, b) => {\n      if (a[b.name]) {\n        if (Array.isArray(a[b.name])) {\n          a[b.name].push(b.value)\n        } else {\n          a[b.name] = [a[b.name], b.value]\n        }\n      } else {\n        a[b.name] = b.value\n      }\n\n      return a\n    }, { __proto__: null })\n\n    options.depth ??= depth\n    options.colors ??= true\n\n    const output = nodeUtil.formatWithOptions(options, state)\n\n    // remove [Object null prototype]\n    return `FormData ${output.slice(output.indexOf(']') + 2)}`\n  }\n\n  /**\n   * @param {FormData} formData\n   */\n  static getFormDataState (formData) {\n    return formData.#state\n  }\n\n  /**\n   * @param {FormData} formData\n   * @param {any[]} newState\n   */\n  static setFormDataState (formData, newState) {\n    formData.#state = newState\n  }\n}\n\nconst { getFormDataState, setFormDataState } = FormData\nReflect.deleteProperty(FormData, 'getFormDataState')\nReflect.deleteProperty(FormData, 'setFormDataState')\n\niteratorMixin('FormData', FormData, getFormDataState, 'name', 'value')\n\nObject.defineProperties(FormData.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  getAll: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'FormData',\n    configurable: true\n  }\n})\n\n/**\n * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry\n * @param {string} name\n * @param {string|Blob} value\n * @param {?string} filename\n * @returns\n */\nfunction makeEntry (name, value, filename) {\n  // 1. Set name to the result of converting name into a scalar value string.\n  // Note: This operation was done by the webidl converter USVString.\n\n  // 2. If value is a string, then set value to the result of converting\n  //    value into a scalar value string.\n  if (typeof value === 'string') {\n    // Note: This operation was done by the webidl converter USVString.\n  } else {\n    // 3. Otherwise:\n\n    // 1. If value is not a File object, then set value to a new File object,\n    //    representing the same bytes, whose name attribute value is \"blob\"\n    if (!webidl.is.File(value)) {\n      value = new File([value], 'blob', { type: value.type })\n    }\n\n    // 2. If filename is given, then set value to a new File object,\n    //    representing the same bytes, whose name attribute is filename.\n    if (filename !== undefined) {\n      /** @type {FilePropertyBag} */\n      const options = {\n        type: value.type,\n        lastModified: value.lastModified\n      }\n\n      value = new File([value], filename, options)\n    }\n  }\n\n  // 4. Return an entry whose name is name and whose value is value.\n  return { name, value }\n}\n\nwebidl.is.FormData = webidl.util.MakeTypeAssertion(FormData)\n\nmodule.exports = { FormData, makeEntry, setFormDataState }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZm9ybWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQzFDLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDekQsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzRUFBVztBQUN0QyxRQUFRLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDbEQsaUJBQWlCLG1CQUFPLENBQUMsNEJBQVc7O0FBRXBDLFdBQVcsb0JBQW9CO0FBQy9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLElBQUksaUJBQWlCOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCLHNDQUFzQztBQUM3RDs7QUFFQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHFDQUFxQztBQUM3QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQkFBa0I7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7O0FBRUEsbUJBQW1CIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9mZXRjaC9mb3JtZGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBpdGVyYXRvck1peGluIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL3dlYmlkbCcpXG5jb25zdCB7IEZpbGU6IE5hdGl2ZUZpbGUgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcbmNvbnN0IG5vZGVVdGlsID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcblxuLyoqIEB0eXBlIHtnbG9iYWxUaGlzWydGaWxlJ119ICovXG5jb25zdCBGaWxlID0gZ2xvYmFsVGhpcy5GaWxlID8/IE5hdGl2ZUZpbGVcblxuLy8gaHR0cHM6Ly94aHIuc3BlYy53aGF0d2cub3JnLyNmb3JtZGF0YVxuY2xhc3MgRm9ybURhdGEge1xuICAjc3RhdGUgPSBbXVxuXG4gIGNvbnN0cnVjdG9yIChmb3JtKSB7XG4gICAgd2ViaWRsLnV0aWwubWFya0FzVW5jbG9uZWFibGUodGhpcylcblxuICAgIGlmIChmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICAgIHByZWZpeDogJ0Zvcm1EYXRhIGNvbnN0cnVjdG9yJyxcbiAgICAgICAgYXJndW1lbnQ6ICdBcmd1bWVudCAxJyxcbiAgICAgICAgdHlwZXM6IFsndW5kZWZpbmVkJ11cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgYXBwZW5kIChuYW1lLCB2YWx1ZSwgZmlsZW5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5hcHBlbmQnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCBwcmVmaXgpXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUpXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyB8fCB3ZWJpZGwuaXMuQmxvYih2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYih2YWx1ZSwgcHJlZml4LCAndmFsdWUnKVxuXG4gICAgICBpZiAoZmlsZW5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmaWxlbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhmaWxlbmFtZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodmFsdWUpXG4gICAgfVxuXG4gICAgLy8gMS4gTGV0IHZhbHVlIGJlIHZhbHVlIGlmIGdpdmVuOyBvdGhlcndpc2UgYmxvYlZhbHVlLlxuXG4gICAgLy8gMi4gTGV0IGVudHJ5IGJlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW4gZW50cnkgd2l0aFxuICAgIC8vIG5hbWUsIHZhbHVlLCBhbmQgZmlsZW5hbWUgaWYgZ2l2ZW4uXG4gICAgY29uc3QgZW50cnkgPSBtYWtlRW50cnkobmFtZSwgdmFsdWUsIGZpbGVuYW1lKVxuXG4gICAgLy8gMy4gQXBwZW5kIGVudHJ5IHRvIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgdGhpcy4jc3RhdGUucHVzaChlbnRyeSlcbiAgfVxuXG4gIGRlbGV0ZSAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0Zvcm1EYXRhLmRlbGV0ZSdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSlcblxuICAgIC8vIFRoZSBkZWxldGUobmFtZSkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZW1vdmUgYWxsIGVudHJpZXMgd2hvc2UgbmFtZVxuICAgIC8vIGlzIG5hbWUgZnJvbSB0aGlz4oCZcyBlbnRyeSBsaXN0LlxuICAgIHRoaXMuI3N0YXRlID0gdGhpcy4jc3RhdGUuZmlsdGVyKGVudHJ5ID0+IGVudHJ5Lm5hbWUgIT09IG5hbWUpXG4gIH1cblxuICBnZXQgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5nZXQnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUpXG5cbiAgICAvLyAxLiBJZiB0aGVyZSBpcyBubyBlbnRyeSB3aG9zZSBuYW1lIGlzIG5hbWUgaW4gdGhpc+KAmXMgZW50cnkgbGlzdCxcbiAgICAvLyB0aGVuIHJldHVybiBudWxsLlxuICAgIGNvbnN0IGlkeCA9IHRoaXMuI3N0YXRlLmZpbmRJbmRleCgoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpXG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZW50cnkgd2hvc2UgbmFtZSBpcyBuYW1lIGZyb21cbiAgICAvLyB0aGlz4oCZcyBlbnRyeSBsaXN0LlxuICAgIHJldHVybiB0aGlzLiNzdGF0ZVtpZHhdLnZhbHVlXG4gIH1cblxuICBnZXRBbGwgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5nZXRBbGwnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUpXG5cbiAgICAvLyAxLiBJZiB0aGVyZSBpcyBubyBlbnRyeSB3aG9zZSBuYW1lIGlzIG5hbWUgaW4gdGhpc+KAmXMgZW50cnkgbGlzdCxcbiAgICAvLyB0aGVuIHJldHVybiB0aGUgZW1wdHkgbGlzdC5cbiAgICAvLyAyLiBSZXR1cm4gdGhlIHZhbHVlcyBvZiBhbGwgZW50cmllcyB3aG9zZSBuYW1lIGlzIG5hbWUsIGluIG9yZGVyLFxuICAgIC8vIGZyb20gdGhpc+KAmXMgZW50cnkgbGlzdC5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGVcbiAgICAgIC5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeS5uYW1lID09PSBuYW1lKVxuICAgICAgLm1hcCgoZW50cnkpID0+IGVudHJ5LnZhbHVlKVxuICB9XG5cbiAgaGFzIChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnRm9ybURhdGEuaGFzJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lKVxuXG4gICAgLy8gVGhlIGhhcyhuYW1lKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGFuIGVudHJ5XG4gICAgLy8gd2hvc2UgbmFtZSBpcyBuYW1lIGluIHRoaXPigJlzIGVudHJ5IGxpc3Q7IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUuZmluZEluZGV4KChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gbmFtZSkgIT09IC0xXG4gIH1cblxuICBzZXQgKG5hbWUsIHZhbHVlLCBmaWxlbmFtZSA9IHVuZGVmaW5lZCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0Zvcm1EYXRhLnNldCdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHByZWZpeClcblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSlcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzIHx8IHdlYmlkbC5pcy5CbG9iKHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB3ZWJpZGwuY29udmVydGVycy5CbG9iKHZhbHVlLCBwcmVmaXgsICd2YWx1ZScpXG5cbiAgICAgIGlmIChmaWxlbmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZpbGVuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKGZpbGVuYW1lKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh2YWx1ZSlcbiAgICB9XG5cbiAgICAvLyBUaGUgc2V0KG5hbWUsIHZhbHVlKSBhbmQgc2V0KG5hbWUsIGJsb2JWYWx1ZSwgZmlsZW5hbWUpIG1ldGhvZCBzdGVwc1xuICAgIC8vIGFyZTpcblxuICAgIC8vIDEuIExldCB2YWx1ZSBiZSB2YWx1ZSBpZiBnaXZlbjsgb3RoZXJ3aXNlIGJsb2JWYWx1ZS5cblxuICAgIC8vIDIuIExldCBlbnRyeSBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuIGVudHJ5IHdpdGggbmFtZSwgdmFsdWUsIGFuZFxuICAgIC8vIGZpbGVuYW1lIGlmIGdpdmVuLlxuICAgIGNvbnN0IGVudHJ5ID0gbWFrZUVudHJ5KG5hbWUsIHZhbHVlLCBmaWxlbmFtZSlcblxuICAgIC8vIDMuIElmIHRoZXJlIGFyZSBlbnRyaWVzIGluIHRoaXPigJlzIGVudHJ5IGxpc3Qgd2hvc2UgbmFtZSBpcyBuYW1lLCB0aGVuXG4gICAgLy8gcmVwbGFjZSB0aGUgZmlyc3Qgc3VjaCBlbnRyeSB3aXRoIGVudHJ5IGFuZCByZW1vdmUgdGhlIG90aGVycy5cbiAgICBjb25zdCBpZHggPSB0aGlzLiNzdGF0ZS5maW5kSW5kZXgoKGVudHJ5KSA9PiBlbnRyeS5uYW1lID09PSBuYW1lKVxuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICB0aGlzLiNzdGF0ZSA9IFtcbiAgICAgICAgLi4udGhpcy4jc3RhdGUuc2xpY2UoMCwgaWR4KSxcbiAgICAgICAgZW50cnksXG4gICAgICAgIC4uLnRoaXMuI3N0YXRlLnNsaWNlKGlkeCArIDEpLmZpbHRlcigoZW50cnkpID0+IGVudHJ5Lm5hbWUgIT09IG5hbWUpXG4gICAgICBdXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDQuIE90aGVyd2lzZSwgYXBwZW5kIGVudHJ5IHRvIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgICB0aGlzLiNzdGF0ZS5wdXNoKGVudHJ5KVxuICAgIH1cbiAgfVxuXG4gIFtub2RlVXRpbC5pbnNwZWN0LmN1c3RvbV0gKGRlcHRoLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLiNzdGF0ZS5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICAgIGlmIChhW2IubmFtZV0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYVtiLm5hbWVdKSkge1xuICAgICAgICAgIGFbYi5uYW1lXS5wdXNoKGIudmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYVtiLm5hbWVdID0gW2FbYi5uYW1lXSwgYi52YWx1ZV1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYVtiLm5hbWVdID0gYi52YWx1ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYVxuICAgIH0sIHsgX19wcm90b19fOiBudWxsIH0pXG5cbiAgICBvcHRpb25zLmRlcHRoID8/PSBkZXB0aFxuICAgIG9wdGlvbnMuY29sb3JzID8/PSB0cnVlXG5cbiAgICBjb25zdCBvdXRwdXQgPSBub2RlVXRpbC5mb3JtYXRXaXRoT3B0aW9ucyhvcHRpb25zLCBzdGF0ZSlcblxuICAgIC8vIHJlbW92ZSBbT2JqZWN0IG51bGwgcHJvdG90eXBlXVxuICAgIHJldHVybiBgRm9ybURhdGEgJHtvdXRwdXQuc2xpY2Uob3V0cHV0LmluZGV4T2YoJ10nKSArIDIpfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Zvcm1EYXRhfSBmb3JtRGF0YVxuICAgKi9cbiAgc3RhdGljIGdldEZvcm1EYXRhU3RhdGUgKGZvcm1EYXRhKSB7XG4gICAgcmV0dXJuIGZvcm1EYXRhLiNzdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Rm9ybURhdGF9IGZvcm1EYXRhXG4gICAqIEBwYXJhbSB7YW55W119IG5ld1N0YXRlXG4gICAqL1xuICBzdGF0aWMgc2V0Rm9ybURhdGFTdGF0ZSAoZm9ybURhdGEsIG5ld1N0YXRlKSB7XG4gICAgZm9ybURhdGEuI3N0YXRlID0gbmV3U3RhdGVcbiAgfVxufVxuXG5jb25zdCB7IGdldEZvcm1EYXRhU3RhdGUsIHNldEZvcm1EYXRhU3RhdGUgfSA9IEZvcm1EYXRhXG5SZWZsZWN0LmRlbGV0ZVByb3BlcnR5KEZvcm1EYXRhLCAnZ2V0Rm9ybURhdGFTdGF0ZScpXG5SZWZsZWN0LmRlbGV0ZVByb3BlcnR5KEZvcm1EYXRhLCAnc2V0Rm9ybURhdGFTdGF0ZScpXG5cbml0ZXJhdG9yTWl4aW4oJ0Zvcm1EYXRhJywgRm9ybURhdGEsIGdldEZvcm1EYXRhU3RhdGUsICduYW1lJywgJ3ZhbHVlJylcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRm9ybURhdGEucHJvdG90eXBlLCB7XG4gIGFwcGVuZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZGVsZXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBnZXQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGdldEFsbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaGFzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzZXQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdGb3JtRGF0YScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbi8qKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNjcmVhdGUtYW4tZW50cnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ3xCbG9ifSB2YWx1ZVxuICogQHBhcmFtIHs/c3RyaW5nfSBmaWxlbmFtZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gbWFrZUVudHJ5IChuYW1lLCB2YWx1ZSwgZmlsZW5hbWUpIHtcbiAgLy8gMS4gU2V0IG5hbWUgdG8gdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIG5hbWUgaW50byBhIHNjYWxhciB2YWx1ZSBzdHJpbmcuXG4gIC8vIE5vdGU6IFRoaXMgb3BlcmF0aW9uIHdhcyBkb25lIGJ5IHRoZSB3ZWJpZGwgY29udmVydGVyIFVTVlN0cmluZy5cblxuICAvLyAyLiBJZiB2YWx1ZSBpcyBhIHN0cmluZywgdGhlbiBzZXQgdmFsdWUgdG8gdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nXG4gIC8vICAgIHZhbHVlIGludG8gYSBzY2FsYXIgdmFsdWUgc3RyaW5nLlxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIC8vIE5vdGU6IFRoaXMgb3BlcmF0aW9uIHdhcyBkb25lIGJ5IHRoZSB3ZWJpZGwgY29udmVydGVyIFVTVlN0cmluZy5cbiAgfSBlbHNlIHtcbiAgICAvLyAzLiBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBJZiB2YWx1ZSBpcyBub3QgYSBGaWxlIG9iamVjdCwgdGhlbiBzZXQgdmFsdWUgdG8gYSBuZXcgRmlsZSBvYmplY3QsXG4gICAgLy8gICAgcmVwcmVzZW50aW5nIHRoZSBzYW1lIGJ5dGVzLCB3aG9zZSBuYW1lIGF0dHJpYnV0ZSB2YWx1ZSBpcyBcImJsb2JcIlxuICAgIGlmICghd2ViaWRsLmlzLkZpbGUodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBGaWxlKFt2YWx1ZV0sICdibG9iJywgeyB0eXBlOiB2YWx1ZS50eXBlIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgZmlsZW5hbWUgaXMgZ2l2ZW4sIHRoZW4gc2V0IHZhbHVlIHRvIGEgbmV3IEZpbGUgb2JqZWN0LFxuICAgIC8vICAgIHJlcHJlc2VudGluZyB0aGUgc2FtZSBieXRlcywgd2hvc2UgbmFtZSBhdHRyaWJ1dGUgaXMgZmlsZW5hbWUuXG4gICAgaWYgKGZpbGVuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qKiBAdHlwZSB7RmlsZVByb3BlcnR5QmFnfSAqL1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcbiAgICAgICAgbGFzdE1vZGlmaWVkOiB2YWx1ZS5sYXN0TW9kaWZpZWRcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBuZXcgRmlsZShbdmFsdWVdLCBmaWxlbmFtZSwgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICAvLyA0LiBSZXR1cm4gYW4gZW50cnkgd2hvc2UgbmFtZSBpcyBuYW1lIGFuZCB3aG9zZSB2YWx1ZSBpcyB2YWx1ZS5cbiAgcmV0dXJuIHsgbmFtZSwgdmFsdWUgfVxufVxuXG53ZWJpZGwuaXMuRm9ybURhdGEgPSB3ZWJpZGwudXRpbC5NYWtlVHlwZUFzc2VydGlvbihGb3JtRGF0YSlcblxubW9kdWxlLmV4cG9ydHMgPSB7IEZvcm1EYXRhLCBtYWtlRW50cnksIHNldEZvcm1EYXRhU3RhdGUgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/formdata.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/global.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/global.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n// In case of breaking changes, increase the version\n// number to avoid conflicts.\nconst globalOrigin = Symbol.for('undici.globalOrigin.1')\n\nfunction getGlobalOrigin () {\n  return globalThis[globalOrigin]\n}\n\nfunction setGlobalOrigin (newOrigin) {\n  if (newOrigin === undefined) {\n    Object.defineProperty(globalThis, globalOrigin, {\n      value: undefined,\n      writable: true,\n      enumerable: false,\n      configurable: false\n    })\n\n    return\n  }\n\n  const parsedURL = new URL(newOrigin)\n\n  if (parsedURL.protocol !== 'http:' && parsedURL.protocol !== 'https:') {\n    throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`)\n  }\n\n  Object.defineProperty(globalThis, globalOrigin, {\n    value: parsedURL,\n    writable: true,\n    enumerable: false,\n    configurable: false\n  })\n}\n\nmodule.exports = {\n  getGlobalOrigin,\n  setGlobalOrigin\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZ2xvYmFsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3RUFBd0UsbUJBQW1CO0FBQzNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL2dsb2JhbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gSW4gY2FzZSBvZiBicmVha2luZyBjaGFuZ2VzLCBpbmNyZWFzZSB0aGUgdmVyc2lvblxuLy8gbnVtYmVyIHRvIGF2b2lkIGNvbmZsaWN0cy5cbmNvbnN0IGdsb2JhbE9yaWdpbiA9IFN5bWJvbC5mb3IoJ3VuZGljaS5nbG9iYWxPcmlnaW4uMScpXG5cbmZ1bmN0aW9uIGdldEdsb2JhbE9yaWdpbiAoKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzW2dsb2JhbE9yaWdpbl1cbn1cblxuZnVuY3Rpb24gc2V0R2xvYmFsT3JpZ2luIChuZXdPcmlnaW4pIHtcbiAgaWYgKG5ld09yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIGdsb2JhbE9yaWdpbiwge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfSlcblxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgcGFyc2VkVVJMID0gbmV3IFVSTChuZXdPcmlnaW4pXG5cbiAgaWYgKHBhcnNlZFVSTC5wcm90b2NvbCAhPT0gJ2h0dHA6JyAmJiBwYXJzZWRVUkwucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgT25seSBodHRwICYgaHR0cHMgdXJscyBhcmUgYWxsb3dlZCwgcmVjZWl2ZWQgJHtwYXJzZWRVUkwucHJvdG9jb2x9YClcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLCBnbG9iYWxPcmlnaW4sIHtcbiAgICB2YWx1ZTogcGFyc2VkVVJMLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEdsb2JhbE9yaWdpbixcbiAgc2V0R2xvYmFsT3JpZ2luXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/global.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/headers.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/headers.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\n\n\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst {\n  iteratorMixin,\n  isValidHeaderName,\n  isValidHeaderValue\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst util = __webpack_require__(/*! node:util */ \"node:util\")\n\n/**\n * @param {number} code\n * @returns {code is (0x0a | 0x0d | 0x09 | 0x20)}\n */\nfunction isHTTPWhiteSpaceCharCode (code) {\n  return code === 0x0a || code === 0x0d || code === 0x09 || code === 0x20\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n * @returns {string}\n */\nfunction headerValueNormalize (potentialValue) {\n  //  To normalize a byte sequence potentialValue, remove\n  //  any leading and trailing HTTP whitespace bytes from\n  //  potentialValue.\n  let i = 0; let j = potentialValue.length\n\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i\n\n  return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j)\n}\n\n/**\n * @param {Headers} headers\n * @param {Array|Object} object\n */\nfunction fill (headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n\n  // 1. If object is a sequence, then for each header in object:\n  // Note: webidl conversion to array has already been done.\n  if (Array.isArray(object)) {\n    for (let i = 0; i < object.length; ++i) {\n      const header = object[i]\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (header.length !== 2) {\n        throw webidl.errors.exception({\n          header: 'Headers constructor',\n          message: `expected name/value pair to be length 2, found ${header.length}.`\n        })\n      }\n\n      // 2. Append (headers first item, headers second item) to headers.\n      appendHeader(headers, header[0], header[1])\n    }\n  } else if (typeof object === 'object' && object !== null) {\n    // Note: null should throw\n\n    // 2. Otherwise, object is a record, then for each key  value in object,\n    //    append (key, value) to headers\n    const keys = Object.keys(object)\n    for (let i = 0; i < keys.length; ++i) {\n      appendHeader(headers, keys[i], object[keys[i]])\n    }\n  } else {\n    throw webidl.errors.conversionFailed({\n      prefix: 'Headers constructor',\n      argument: 'Argument 1',\n      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n    })\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-headers-append\n * @param {Headers} headers\n * @param {string} name\n * @param {string} value\n */\nfunction appendHeader (headers, name, value) {\n  // 1. Normalize value.\n  value = headerValueNormalize(value)\n\n  // 2. If name is not a header name or value is not a\n  //    header value, then throw a TypeError.\n  if (!isValidHeaderName(name)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value: name,\n      type: 'header name'\n    })\n  } else if (!isValidHeaderValue(value)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value,\n      type: 'header value'\n    })\n  }\n\n  // 3. If headerss guard is \"immutable\", then throw a TypeError.\n  // 4. Otherwise, if headerss guard is \"request\" and name is a\n  //    forbidden header name, return.\n  // 5. Otherwise, if headerss guard is \"request-no-cors\":\n  //    TODO\n  // Note: undici does not implement forbidden header names\n  if (getHeadersGuard(headers) === 'immutable') {\n    throw new TypeError('immutable')\n  }\n\n  // 6. Otherwise, if headerss guard is \"response\" and name is a\n  //    forbidden response-header name, return.\n\n  // 7. Append (name, value) to headerss header list.\n  return getHeadersList(headers).append(name, value, false)\n\n  // 8. If headerss guard is \"request-no-cors\", then remove\n  //    privileged no-CORS request headers from headers\n}\n\n// https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n/**\n * @param {Headers} target\n */\nfunction headersListSortAndCombine (target) {\n  const headersList = getHeadersList(target)\n\n  if (!headersList) {\n    return []\n  }\n\n  if (headersList.sortedMap) {\n    return headersList.sortedMap\n  }\n\n  // 1. Let headers be an empty list of headers with the key being the name\n  //    and value the value.\n  const headers = []\n\n  // 2. Let names be the result of convert header names to a sorted-lowercase\n  //    set with all the names of the headers in list.\n  const names = headersList.toSortedArray()\n\n  const cookies = headersList.cookies\n\n  // fast-path\n  if (cookies === null || cookies.length === 1) {\n    // Note: The non-null assertion of value has already been done by `HeadersList#toSortedArray`\n    return (headersList.sortedMap = names)\n  }\n\n  // 3. For each name of names:\n  for (let i = 0; i < names.length; ++i) {\n    const { 0: name, 1: value } = names[i]\n    // 1. If name is `set-cookie`, then:\n    if (name === 'set-cookie') {\n      // 1. Let values be a list of all values of headers in list whose name\n      //    is a byte-case-insensitive match for name, in order.\n\n      // 2. For each value of values:\n      // 1. Append (name, value) to headers.\n      for (let j = 0; j < cookies.length; ++j) {\n        headers.push([name, cookies[j]])\n      }\n    } else {\n      // 2. Otherwise:\n\n      // 1. Let value be the result of getting name from list.\n\n      // 2. Assert: value is non-null.\n      // Note: This operation was done by `HeadersList#toSortedArray`.\n\n      // 3. Append (name, value) to headers.\n      headers.push([name, value])\n    }\n  }\n\n  // 4. Return headers.\n  return (headersList.sortedMap = headers)\n}\n\nfunction compareHeaderName (a, b) {\n  return a[0] < b[0] ? -1 : 1\n}\n\nclass HeadersList {\n  /** @type {[string, string][]|null} */\n  cookies = null\n\n  sortedMap\n  headersMap\n\n  constructor (init) {\n    if (init instanceof HeadersList) {\n      this.headersMap = new Map(init.headersMap)\n      this.sortedMap = init.sortedMap\n      this.cookies = init.cookies === null ? null : [...init.cookies]\n    } else {\n      this.headersMap = new Map(init)\n      this.sortedMap = null\n    }\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#header-list-contains\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   */\n  contains (name, isLowerCase) {\n    // A header list list contains a header name name if list\n    // contains a header whose name is a byte-case-insensitive\n    // match for name.\n\n    return this.headersMap.has(isLowerCase ? name : name.toLowerCase())\n  }\n\n  clear () {\n    this.headersMap.clear()\n    this.sortedMap = null\n    this.cookies = null\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-append\n   * @param {string} name\n   * @param {string} value\n   * @param {boolean} isLowerCase\n   */\n  append (name, value, isLowerCase) {\n    this.sortedMap = null\n\n    // 1. If list contains name, then set name to the first such\n    //    headers name.\n    const lowercaseName = isLowerCase ? name : name.toLowerCase()\n    const exists = this.headersMap.get(lowercaseName)\n\n    // 2. Append (name, value) to list.\n    if (exists) {\n      const delimiter = lowercaseName === 'cookie' ? '; ' : ', '\n      this.headersMap.set(lowercaseName, {\n        name: exists.name,\n        value: `${exists.value}${delimiter}${value}`\n      })\n    } else {\n      this.headersMap.set(lowercaseName, { name, value })\n    }\n\n    if (lowercaseName === 'set-cookie') {\n      (this.cookies ??= []).push(value)\n    }\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-set\n   * @param {string} name\n   * @param {string} value\n   * @param {boolean} isLowerCase\n   */\n  set (name, value, isLowerCase) {\n    this.sortedMap = null\n    const lowercaseName = isLowerCase ? name : name.toLowerCase()\n\n    if (lowercaseName === 'set-cookie') {\n      this.cookies = [value]\n    }\n\n    // 1. If list contains name, then set the value of\n    //    the first such header to value and remove the\n    //    others.\n    // 2. Otherwise, append header (name, value) to list.\n    this.headersMap.set(lowercaseName, { name, value })\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-delete\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   */\n  delete (name, isLowerCase) {\n    this.sortedMap = null\n    if (!isLowerCase) name = name.toLowerCase()\n\n    if (name === 'set-cookie') {\n      this.cookies = null\n    }\n\n    this.headersMap.delete(name)\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-get\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   * @returns {string | null}\n   */\n  get (name, isLowerCase) {\n    // 1. If list does not contain name, then return null.\n    // 2. Return the values of all headers in list whose name\n    //    is a byte-case-insensitive match for name,\n    //    separated from each other by 0x2C 0x20, in order.\n    return this.headersMap.get(isLowerCase ? name : name.toLowerCase())?.value ?? null\n  }\n\n  * [Symbol.iterator] () {\n    // use the lowercased name\n    for (const { 0: name, 1: { value } } of this.headersMap) {\n      yield [name, value]\n    }\n  }\n\n  get entries () {\n    const headers = {}\n\n    if (this.headersMap.size !== 0) {\n      for (const { name, value } of this.headersMap.values()) {\n        headers[name] = value\n      }\n    }\n\n    return headers\n  }\n\n  rawValues () {\n    return this.headersMap.values()\n  }\n\n  get entriesList () {\n    const headers = []\n\n    if (this.headersMap.size !== 0) {\n      for (const { 0: lowerName, 1: { name, value } } of this.headersMap) {\n        if (lowerName === 'set-cookie') {\n          for (const cookie of this.cookies) {\n            headers.push([name, cookie])\n          }\n        } else {\n          headers.push([name, value])\n        }\n      }\n    }\n\n    return headers\n  }\n\n  // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set\n  toSortedArray () {\n    const size = this.headersMap.size\n    const array = new Array(size)\n    // In most cases, you will use the fast-path.\n    // fast-path: Use binary insertion sort for small arrays.\n    if (size <= 32) {\n      if (size === 0) {\n        // If empty, it is an empty array. To avoid the first index assignment.\n        return array\n      }\n      // Improve performance by unrolling loop and avoiding double-loop.\n      // Double-loop-less version of the binary insertion sort.\n      const iterator = this.headersMap[Symbol.iterator]()\n      const firstValue = iterator.next().value\n      // set [name, value] to first index.\n      array[0] = [firstValue[0], firstValue[1].value]\n      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n      // 3.2.2. Assert: value is non-null.\n      assert(firstValue[1].value !== null)\n      for (\n        let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value;\n        i < size;\n        ++i\n      ) {\n        // get next value\n        value = iterator.next().value\n        // set [name, value] to current index.\n        x = array[i] = [value[0], value[1].value]\n        // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n        // 3.2.2. Assert: value is non-null.\n        assert(x[1] !== null)\n        left = 0\n        right = i\n        // binary search\n        while (left < right) {\n          // middle index\n          pivot = left + ((right - left) >> 1)\n          // compare header name\n          if (array[pivot][0] <= x[0]) {\n            left = pivot + 1\n          } else {\n            right = pivot\n          }\n        }\n        if (i !== pivot) {\n          j = i\n          while (j > left) {\n            array[j] = array[--j]\n          }\n          array[left] = x\n        }\n      }\n      /* c8 ignore next 4 */\n      if (!iterator.next().done) {\n        // This is for debugging and will never be called.\n        throw new TypeError('Unreachable')\n      }\n      return array\n    } else {\n      // This case would be a rare occurrence.\n      // slow-path: fallback\n      let i = 0\n      for (const { 0: name, 1: { value } } of this.headersMap) {\n        array[i++] = [name, value]\n        // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n        // 3.2.2. Assert: value is non-null.\n        assert(value !== null)\n      }\n      return array.sort(compareHeaderName)\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n  #guard\n  /**\n   * @type {HeadersList}\n   */\n  #headersList\n\n  /**\n   * @param {HeadersInit|Symbol} [init]\n   * @returns\n   */\n  constructor (init = undefined) {\n    webidl.util.markAsUncloneable(this)\n\n    if (init === kConstruct) {\n      return\n    }\n\n    this.#headersList = new HeadersList()\n\n    // The new Headers(init) constructor steps are:\n\n    // 1. Set thiss guard to \"none\".\n    this.#guard = 'none'\n\n    // 2. If init is given, then fill this with init.\n    if (init !== undefined) {\n      init = webidl.converters.HeadersInit(init, 'Headers constructor', 'init')\n      fill(this, init)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-append\n  append (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, 'Headers.append')\n\n    const prefix = 'Headers.append'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n    value = webidl.converters.ByteString(value, prefix, 'value')\n\n    return appendHeader(this, name, value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-delete\n  delete (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.delete')\n\n    const prefix = 'Headers.delete'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.delete',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. If thiss guard is \"immutable\", then throw a TypeError.\n    // 3. Otherwise, if thiss guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 4. Otherwise, if thiss guard is \"request-no-cors\", name\n    //    is not a no-CORS-safelisted request-header name, and\n    //    name is not a privileged no-CORS request-header name,\n    //    return.\n    // 5. Otherwise, if thiss guard is \"response\" and name is\n    //    a forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this.#guard === 'immutable') {\n      throw new TypeError('immutable')\n    }\n\n    // 6. If thiss header list does not contain name, then\n    //    return.\n    if (!this.#headersList.contains(name, false)) {\n      return\n    }\n\n    // 7. Delete name from thiss header list.\n    // 8. If thiss guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this.\n    this.#headersList.delete(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-get\n  get (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.get')\n\n    const prefix = 'Headers.get'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return the result of getting name from thiss header\n    //    list.\n    return this.#headersList.get(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-has\n  has (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.has')\n\n    const prefix = 'Headers.has'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return true if thiss header list contains name;\n    //    otherwise false.\n    return this.#headersList.contains(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-set\n  set (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, 'Headers.set')\n\n    const prefix = 'Headers.set'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n    value = webidl.converters.ByteString(value, prefix, 'value')\n\n    // 1. Normalize value.\n    value = headerValueNormalize(value)\n\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    } else if (!isValidHeaderValue(value)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value,\n        type: 'header value'\n      })\n    }\n\n    // 3. If thiss guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if thiss guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 5. Otherwise, if thiss guard is \"request-no-cors\" and\n    //    name/value is not a no-CORS-safelisted request-header,\n    //    return.\n    // 6. Otherwise, if thiss guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this.#guard === 'immutable') {\n      throw new TypeError('immutable')\n    }\n\n    // 7. Set (name, value) in thiss header list.\n    // 8. If thiss guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this\n    this.#headersList.set(name, value, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n  getSetCookie () {\n    webidl.brandCheck(this, Headers)\n\n    // 1. If thiss header list does not contain `Set-Cookie`, then return  .\n    // 2. Return the values of all headers in thiss header list whose name is\n    //    a byte-case-insensitive match for `Set-Cookie`, in order.\n\n    const list = this.#headersList.cookies\n\n    if (list) {\n      return [...list]\n    }\n\n    return []\n  }\n\n  [util.inspect.custom] (depth, options) {\n    options.depth ??= depth\n\n    return `Headers ${util.formatWithOptions(options, this.#headersList.entries)}`\n  }\n\n  static getHeadersGuard (o) {\n    return o.#guard\n  }\n\n  static setHeadersGuard (o, guard) {\n    o.#guard = guard\n  }\n\n  /**\n   * @param {Headers} o\n   */\n  static getHeadersList (o) {\n    return o.#headersList\n  }\n\n  /**\n   * @param {Headers} target\n   * @param {HeadersList} list\n   */\n  static setHeadersList (target, list) {\n    target.#headersList = list\n  }\n}\n\nconst { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers\nReflect.deleteProperty(Headers, 'getHeadersGuard')\nReflect.deleteProperty(Headers, 'setHeadersGuard')\nReflect.deleteProperty(Headers, 'getHeadersList')\nReflect.deleteProperty(Headers, 'setHeadersList')\n\niteratorMixin('Headers', Headers, headersListSortAndCombine, 0, 1)\n\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  getSetCookie: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Headers',\n    configurable: true\n  },\n  [util.inspect.custom]: {\n    enumerable: false\n  }\n})\n\nwebidl.converters.HeadersInit = function (V, prefix, argument) {\n  if (webidl.util.Type(V) === webidl.util.Types.OBJECT) {\n    const iterator = Reflect.get(V, Symbol.iterator)\n\n    // A work-around to ensure we send the properly-cased Headers when V is a Headers object.\n    // Read https://github.com/nodejs/undici/pull/3159#issuecomment-2075537226 before touching, please.\n    if (!util.types.isProxy(V) && iterator === Headers.prototype.entries) { // Headers object\n      try {\n        return getHeadersList(V).entriesList\n      } catch {\n        // fall-through\n      }\n    }\n\n    if (typeof iterator === 'function') {\n      return webidl.converters['sequence<sequence<ByteString>>'](V, prefix, argument, iterator.bind(V))\n    }\n\n    return webidl.converters['record<ByteString, ByteString>'](V, prefix, argument)\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix: 'Headers constructor',\n    argument: 'Argument 1',\n    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n  })\n}\n\nmodule.exports = {\n  fill,\n  // for test.\n  compareHeaderName,\n  Headers,\n  HeadersList,\n  getHeadersGuard,\n  setHeadersGuard,\n  setHeadersList,\n  getHeadersList\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvaGVhZGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFWTs7QUFFWixRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLDJFQUFvQjtBQUNuRCxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDcEIsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzRUFBVztBQUN0QyxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLDRCQUFXOztBQUVoQztBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGNBQWM7QUFDbkYsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsMkRBQTJEO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxtRUFBbUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9mZXRjaC9oZWFkZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9FdGhhbi1BcnJvd29vZC91bmRpY2ktZmV0Y2hcblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHtcbiAgaXRlcmF0b3JNaXhpbixcbiAgaXNWYWxpZEhlYWRlck5hbWUsXG4gIGlzVmFsaWRIZWFkZXJWYWx1ZVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vd2ViaWRsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7Y29kZSBpcyAoMHgwYSB8IDB4MGQgfCAweDA5IHwgMHgyMCl9XG4gKi9cbmZ1bmN0aW9uIGlzSFRUUFdoaXRlU3BhY2VDaGFyQ29kZSAoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMHgwYSB8fCBjb2RlID09PSAweDBkIHx8IGNvZGUgPT09IDB4MDkgfHwgY29kZSA9PT0gMHgyMFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLXZhbHVlLW5vcm1hbGl6ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBvdGVudGlhbFZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoZWFkZXJWYWx1ZU5vcm1hbGl6ZSAocG90ZW50aWFsVmFsdWUpIHtcbiAgLy8gIFRvIG5vcm1hbGl6ZSBhIGJ5dGUgc2VxdWVuY2UgcG90ZW50aWFsVmFsdWUsIHJlbW92ZVxuICAvLyAgYW55IGxlYWRpbmcgYW5kIHRyYWlsaW5nIEhUVFAgd2hpdGVzcGFjZSBieXRlcyBmcm9tXG4gIC8vICBwb3RlbnRpYWxWYWx1ZS5cbiAgbGV0IGkgPSAwOyBsZXQgaiA9IHBvdGVudGlhbFZhbHVlLmxlbmd0aFxuXG4gIHdoaWxlIChqID4gaSAmJiBpc0hUVFBXaGl0ZVNwYWNlQ2hhckNvZGUocG90ZW50aWFsVmFsdWUuY2hhckNvZGVBdChqIC0gMSkpKSAtLWpcbiAgd2hpbGUgKGogPiBpICYmIGlzSFRUUFdoaXRlU3BhY2VDaGFyQ29kZShwb3RlbnRpYWxWYWx1ZS5jaGFyQ29kZUF0KGkpKSkgKytpXG5cbiAgcmV0dXJuIGkgPT09IDAgJiYgaiA9PT0gcG90ZW50aWFsVmFsdWUubGVuZ3RoID8gcG90ZW50aWFsVmFsdWUgOiBwb3RlbnRpYWxWYWx1ZS5zdWJzdHJpbmcoaSwgailcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnNcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZmlsbCAoaGVhZGVycywgb2JqZWN0KSB7XG4gIC8vIFRvIGZpbGwgYSBIZWFkZXJzIG9iamVjdCBoZWFkZXJzIHdpdGggYSBnaXZlbiBvYmplY3Qgb2JqZWN0LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gMS4gSWYgb2JqZWN0IGlzIGEgc2VxdWVuY2UsIHRoZW4gZm9yIGVhY2ggaGVhZGVyIGluIG9iamVjdDpcbiAgLy8gTm90ZTogd2ViaWRsIGNvbnZlcnNpb24gdG8gYXJyYXkgaGFzIGFscmVhZHkgYmVlbiBkb25lLlxuICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGhlYWRlciA9IG9iamVjdFtpXVxuICAgICAgLy8gMS4gSWYgaGVhZGVyIGRvZXMgbm90IGNvbnRhaW4gZXhhY3RseSB0d28gaXRlbXMsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAoaGVhZGVyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgaGVhZGVyOiAnSGVhZGVycyBjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgbWVzc2FnZTogYGV4cGVjdGVkIG5hbWUvdmFsdWUgcGFpciB0byBiZSBsZW5ndGggMiwgZm91bmQgJHtoZWFkZXIubGVuZ3RofS5gXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIEFwcGVuZCAoaGVhZGVy4oCZcyBmaXJzdCBpdGVtLCBoZWFkZXLigJlzIHNlY29uZCBpdGVtKSB0byBoZWFkZXJzLlxuICAgICAgYXBwZW5kSGVhZGVyKGhlYWRlcnMsIGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICAvLyBOb3RlOiBudWxsIHNob3VsZCB0aHJvd1xuXG4gICAgLy8gMi4gT3RoZXJ3aXNlLCBvYmplY3QgaXMgYSByZWNvcmQsIHRoZW4gZm9yIGVhY2gga2V5IOKGkiB2YWx1ZSBpbiBvYmplY3QsXG4gICAgLy8gICAgYXBwZW5kIChrZXksIHZhbHVlKSB0byBoZWFkZXJzXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFwcGVuZEhlYWRlcihoZWFkZXJzLCBrZXlzW2ldLCBvYmplY3Rba2V5c1tpXV0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICBwcmVmaXg6ICdIZWFkZXJzIGNvbnN0cnVjdG9yJyxcbiAgICAgIGFyZ3VtZW50OiAnQXJndW1lbnQgMScsXG4gICAgICB0eXBlczogWydzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4nLCAncmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+J11cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXJzLWFwcGVuZFxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGFwcGVuZEhlYWRlciAoaGVhZGVycywgbmFtZSwgdmFsdWUpIHtcbiAgLy8gMS4gTm9ybWFsaXplIHZhbHVlLlxuICB2YWx1ZSA9IGhlYWRlclZhbHVlTm9ybWFsaXplKHZhbHVlKVxuXG4gIC8vIDIuIElmIG5hbWUgaXMgbm90IGEgaGVhZGVyIG5hbWUgb3IgdmFsdWUgaXMgbm90IGFcbiAgLy8gICAgaGVhZGVyIHZhbHVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgcHJlZml4OiAnSGVhZGVycy5hcHBlbmQnLFxuICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICB0eXBlOiAnaGVhZGVyIG5hbWUnXG4gICAgfSlcbiAgfSBlbHNlIGlmICghaXNWYWxpZEhlYWRlclZhbHVlKHZhbHVlKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgIHByZWZpeDogJ0hlYWRlcnMuYXBwZW5kJyxcbiAgICAgIHZhbHVlLFxuICAgICAgdHlwZTogJ2hlYWRlciB2YWx1ZSdcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgaGVhZGVyc+KAmXMgZ3VhcmQgaXMgXCJpbW11dGFibGVcIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgLy8gNC4gT3RoZXJ3aXNlLCBpZiBoZWFkZXJz4oCZcyBndWFyZCBpcyBcInJlcXVlc3RcIiBhbmQgbmFtZSBpcyBhXG4gIC8vICAgIGZvcmJpZGRlbiBoZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAvLyA1LiBPdGhlcndpc2UsIGlmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCI6XG4gIC8vICAgIFRPRE9cbiAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBmb3JiaWRkZW4gaGVhZGVyIG5hbWVzXG4gIGlmIChnZXRIZWFkZXJzR3VhcmQoaGVhZGVycykgPT09ICdpbW11dGFibGUnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW1tdXRhYmxlJylcbiAgfVxuXG4gIC8vIDYuIE90aGVyd2lzZSwgaWYgaGVhZGVyc+KAmXMgZ3VhcmQgaXMgXCJyZXNwb25zZVwiIGFuZCBuYW1lIGlzIGFcbiAgLy8gICAgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLCByZXR1cm4uXG5cbiAgLy8gNy4gQXBwZW5kIChuYW1lLCB2YWx1ZSkgdG8gaGVhZGVyc+KAmXMgaGVhZGVyIGxpc3QuXG4gIHJldHVybiBnZXRIZWFkZXJzTGlzdChoZWFkZXJzKS5hcHBlbmQobmFtZSwgdmFsdWUsIGZhbHNlKVxuXG4gIC8vIDguIElmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCIsIHRoZW4gcmVtb3ZlXG4gIC8vICAgIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0IGhlYWRlcnMgZnJvbSBoZWFkZXJzXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LXNvcnQtYW5kLWNvbWJpbmVcbi8qKlxuICogQHBhcmFtIHtIZWFkZXJzfSB0YXJnZXRcbiAqL1xuZnVuY3Rpb24gaGVhZGVyc0xpc3RTb3J0QW5kQ29tYmluZSAodGFyZ2V0KSB7XG4gIGNvbnN0IGhlYWRlcnNMaXN0ID0gZ2V0SGVhZGVyc0xpc3QodGFyZ2V0KVxuXG4gIGlmICghaGVhZGVyc0xpc3QpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIGlmIChoZWFkZXJzTGlzdC5zb3J0ZWRNYXApIHtcbiAgICByZXR1cm4gaGVhZGVyc0xpc3Quc29ydGVkTWFwXG4gIH1cblxuICAvLyAxLiBMZXQgaGVhZGVycyBiZSBhbiBlbXB0eSBsaXN0IG9mIGhlYWRlcnMgd2l0aCB0aGUga2V5IGJlaW5nIHRoZSBuYW1lXG4gIC8vICAgIGFuZCB2YWx1ZSB0aGUgdmFsdWUuXG4gIGNvbnN0IGhlYWRlcnMgPSBbXVxuXG4gIC8vIDIuIExldCBuYW1lcyBiZSB0aGUgcmVzdWx0IG9mIGNvbnZlcnQgaGVhZGVyIG5hbWVzIHRvIGEgc29ydGVkLWxvd2VyY2FzZVxuICAvLyAgICBzZXQgd2l0aCBhbGwgdGhlIG5hbWVzIG9mIHRoZSBoZWFkZXJzIGluIGxpc3QuXG4gIGNvbnN0IG5hbWVzID0gaGVhZGVyc0xpc3QudG9Tb3J0ZWRBcnJheSgpXG5cbiAgY29uc3QgY29va2llcyA9IGhlYWRlcnNMaXN0LmNvb2tpZXNcblxuICAvLyBmYXN0LXBhdGhcbiAgaWYgKGNvb2tpZXMgPT09IG51bGwgfHwgY29va2llcy5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBOb3RlOiBUaGUgbm9uLW51bGwgYXNzZXJ0aW9uIG9mIHZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gZG9uZSBieSBgSGVhZGVyc0xpc3QjdG9Tb3J0ZWRBcnJheWBcbiAgICByZXR1cm4gKGhlYWRlcnNMaXN0LnNvcnRlZE1hcCA9IG5hbWVzKVxuICB9XG5cbiAgLy8gMy4gRm9yIGVhY2ggbmFtZSBvZiBuYW1lczpcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHsgMDogbmFtZSwgMTogdmFsdWUgfSA9IG5hbWVzW2ldXG4gICAgLy8gMS4gSWYgbmFtZSBpcyBgc2V0LWNvb2tpZWAsIHRoZW46XG4gICAgaWYgKG5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgLy8gMS4gTGV0IHZhbHVlcyBiZSBhIGxpc3Qgb2YgYWxsIHZhbHVlcyBvZiBoZWFkZXJzIGluIGxpc3Qgd2hvc2UgbmFtZVxuICAgICAgLy8gICAgaXMgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIG5hbWUsIGluIG9yZGVyLlxuXG4gICAgICAvLyAyLiBGb3IgZWFjaCB2YWx1ZSBvZiB2YWx1ZXM6XG4gICAgICAvLyAxLiBBcHBlbmQgKG5hbWUsIHZhbHVlKSB0byBoZWFkZXJzLlxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb29raWVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGhlYWRlcnMucHVzaChbbmFtZSwgY29va2llc1tqXV0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDIuIE90aGVyd2lzZTpcblxuICAgICAgLy8gMS4gTGV0IHZhbHVlIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyBuYW1lIGZyb20gbGlzdC5cblxuICAgICAgLy8gMi4gQXNzZXJ0OiB2YWx1ZSBpcyBub24tbnVsbC5cbiAgICAgIC8vIE5vdGU6IFRoaXMgb3BlcmF0aW9uIHdhcyBkb25lIGJ5IGBIZWFkZXJzTGlzdCN0b1NvcnRlZEFycmF5YC5cblxuICAgICAgLy8gMy4gQXBwZW5kIChuYW1lLCB2YWx1ZSkgdG8gaGVhZGVycy5cbiAgICAgIGhlYWRlcnMucHVzaChbbmFtZSwgdmFsdWVdKVxuICAgIH1cbiAgfVxuXG4gIC8vIDQuIFJldHVybiBoZWFkZXJzLlxuICByZXR1cm4gKGhlYWRlcnNMaXN0LnNvcnRlZE1hcCA9IGhlYWRlcnMpXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVIZWFkZXJOYW1lIChhLCBiKSB7XG4gIHJldHVybiBhWzBdIDwgYlswXSA/IC0xIDogMVxufVxuXG5jbGFzcyBIZWFkZXJzTGlzdCB7XG4gIC8qKiBAdHlwZSB7W3N0cmluZywgc3RyaW5nXVtdfG51bGx9ICovXG4gIGNvb2tpZXMgPSBudWxsXG5cbiAgc29ydGVkTWFwXG4gIGhlYWRlcnNNYXBcblxuICBjb25zdHJ1Y3RvciAoaW5pdCkge1xuICAgIGlmIChpbml0IGluc3RhbmNlb2YgSGVhZGVyc0xpc3QpIHtcbiAgICAgIHRoaXMuaGVhZGVyc01hcCA9IG5ldyBNYXAoaW5pdC5oZWFkZXJzTWFwKVxuICAgICAgdGhpcy5zb3J0ZWRNYXAgPSBpbml0LnNvcnRlZE1hcFxuICAgICAgdGhpcy5jb29raWVzID0gaW5pdC5jb29raWVzID09PSBudWxsID8gbnVsbCA6IFsuLi5pbml0LmNvb2tpZXNdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVyc01hcCA9IG5ldyBNYXAoaW5pdClcbiAgICAgIHRoaXMuc29ydGVkTWFwID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXItbGlzdC1jb250YWluc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG93ZXJDYXNlXG4gICAqL1xuICBjb250YWlucyAobmFtZSwgaXNMb3dlckNhc2UpIHtcbiAgICAvLyBBIGhlYWRlciBsaXN0IGxpc3QgY29udGFpbnMgYSBoZWFkZXIgbmFtZSBuYW1lIGlmIGxpc3RcbiAgICAvLyBjb250YWlucyBhIGhlYWRlciB3aG9zZSBuYW1lIGlzIGEgYnl0ZS1jYXNlLWluc2Vuc2l0aXZlXG4gICAgLy8gbWF0Y2ggZm9yIG5hbWUuXG5cbiAgICByZXR1cm4gdGhpcy5oZWFkZXJzTWFwLmhhcyhpc0xvd2VyQ2FzZSA/IG5hbWUgOiBuYW1lLnRvTG93ZXJDYXNlKCkpXG4gIH1cblxuICBjbGVhciAoKSB7XG4gICAgdGhpcy5oZWFkZXJzTWFwLmNsZWFyKClcbiAgICB0aGlzLnNvcnRlZE1hcCA9IG51bGxcbiAgICB0aGlzLmNvb2tpZXMgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1hcHBlbmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb3dlckNhc2VcbiAgICovXG4gIGFwcGVuZCAobmFtZSwgdmFsdWUsIGlzTG93ZXJDYXNlKSB7XG4gICAgdGhpcy5zb3J0ZWRNYXAgPSBudWxsXG5cbiAgICAvLyAxLiBJZiBsaXN0IGNvbnRhaW5zIG5hbWUsIHRoZW4gc2V0IG5hbWUgdG8gdGhlIGZpcnN0IHN1Y2hcbiAgICAvLyAgICBoZWFkZXLigJlzIG5hbWUuXG4gICAgY29uc3QgbG93ZXJjYXNlTmFtZSA9IGlzTG93ZXJDYXNlID8gbmFtZSA6IG5hbWUudG9Mb3dlckNhc2UoKVxuICAgIGNvbnN0IGV4aXN0cyA9IHRoaXMuaGVhZGVyc01hcC5nZXQobG93ZXJjYXNlTmFtZSlcblxuICAgIC8vIDIuIEFwcGVuZCAobmFtZSwgdmFsdWUpIHRvIGxpc3QuXG4gICAgaWYgKGV4aXN0cykge1xuICAgICAgY29uc3QgZGVsaW1pdGVyID0gbG93ZXJjYXNlTmFtZSA9PT0gJ2Nvb2tpZScgPyAnOyAnIDogJywgJ1xuICAgICAgdGhpcy5oZWFkZXJzTWFwLnNldChsb3dlcmNhc2VOYW1lLCB7XG4gICAgICAgIG5hbWU6IGV4aXN0cy5uYW1lLFxuICAgICAgICB2YWx1ZTogYCR7ZXhpc3RzLnZhbHVlfSR7ZGVsaW1pdGVyfSR7dmFsdWV9YFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzTWFwLnNldChsb3dlcmNhc2VOYW1lLCB7IG5hbWUsIHZhbHVlIH0pXG4gICAgfVxuXG4gICAgaWYgKGxvd2VyY2FzZU5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgKHRoaXMuY29va2llcyA/Pz0gW10pLnB1c2godmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3Qtc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG93ZXJDYXNlXG4gICAqL1xuICBzZXQgKG5hbWUsIHZhbHVlLCBpc0xvd2VyQ2FzZSkge1xuICAgIHRoaXMuc29ydGVkTWFwID0gbnVsbFxuICAgIGNvbnN0IGxvd2VyY2FzZU5hbWUgPSBpc0xvd2VyQ2FzZSA/IG5hbWUgOiBuYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIGlmIChsb3dlcmNhc2VOYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIHRoaXMuY29va2llcyA9IFt2YWx1ZV1cbiAgICB9XG5cbiAgICAvLyAxLiBJZiBsaXN0IGNvbnRhaW5zIG5hbWUsIHRoZW4gc2V0IHRoZSB2YWx1ZSBvZlxuICAgIC8vICAgIHRoZSBmaXJzdCBzdWNoIGhlYWRlciB0byB2YWx1ZSBhbmQgcmVtb3ZlIHRoZVxuICAgIC8vICAgIG90aGVycy5cbiAgICAvLyAyLiBPdGhlcndpc2UsIGFwcGVuZCBoZWFkZXIgKG5hbWUsIHZhbHVlKSB0byBsaXN0LlxuICAgIHRoaXMuaGVhZGVyc01hcC5zZXQobG93ZXJjYXNlTmFtZSwgeyBuYW1lLCB2YWx1ZSB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3QtZGVsZXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb3dlckNhc2VcbiAgICovXG4gIGRlbGV0ZSAobmFtZSwgaXNMb3dlckNhc2UpIHtcbiAgICB0aGlzLnNvcnRlZE1hcCA9IG51bGxcbiAgICBpZiAoIWlzTG93ZXJDYXNlKSBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICBpZiAobmFtZSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICB0aGlzLmNvb2tpZXMgPSBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5oZWFkZXJzTWFwLmRlbGV0ZShuYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3QtZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb3dlckNhc2VcbiAgICogQHJldHVybnMge3N0cmluZyB8IG51bGx9XG4gICAqL1xuICBnZXQgKG5hbWUsIGlzTG93ZXJDYXNlKSB7XG4gICAgLy8gMS4gSWYgbGlzdCBkb2VzIG5vdCBjb250YWluIG5hbWUsIHRoZW4gcmV0dXJuIG51bGwuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSB2YWx1ZXMgb2YgYWxsIGhlYWRlcnMgaW4gbGlzdCB3aG9zZSBuYW1lXG4gICAgLy8gICAgaXMgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIG5hbWUsXG4gICAgLy8gICAgc2VwYXJhdGVkIGZyb20gZWFjaCBvdGhlciBieSAweDJDIDB4MjAsIGluIG9yZGVyLlxuICAgIHJldHVybiB0aGlzLmhlYWRlcnNNYXAuZ2V0KGlzTG93ZXJDYXNlID8gbmFtZSA6IG5hbWUudG9Mb3dlckNhc2UoKSk/LnZhbHVlID8/IG51bGxcbiAgfVxuXG4gICogW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIC8vIHVzZSB0aGUgbG93ZXJjYXNlZCBuYW1lXG4gICAgZm9yIChjb25zdCB7IDA6IG5hbWUsIDE6IHsgdmFsdWUgfSB9IG9mIHRoaXMuaGVhZGVyc01hcCkge1xuICAgICAgeWllbGQgW25hbWUsIHZhbHVlXVxuICAgIH1cbiAgfVxuXG4gIGdldCBlbnRyaWVzICgpIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge31cblxuICAgIGlmICh0aGlzLmhlYWRlcnNNYXAuc2l6ZSAhPT0gMCkge1xuICAgICAgZm9yIChjb25zdCB7IG5hbWUsIHZhbHVlIH0gb2YgdGhpcy5oZWFkZXJzTWFwLnZhbHVlcygpKSB7XG4gICAgICAgIGhlYWRlcnNbbmFtZV0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICByYXdWYWx1ZXMgKCkge1xuICAgIHJldHVybiB0aGlzLmhlYWRlcnNNYXAudmFsdWVzKClcbiAgfVxuXG4gIGdldCBlbnRyaWVzTGlzdCAoKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IFtdXG5cbiAgICBpZiAodGhpcy5oZWFkZXJzTWFwLnNpemUgIT09IDApIHtcbiAgICAgIGZvciAoY29uc3QgeyAwOiBsb3dlck5hbWUsIDE6IHsgbmFtZSwgdmFsdWUgfSB9IG9mIHRoaXMuaGVhZGVyc01hcCkge1xuICAgICAgICBpZiAobG93ZXJOYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGNvb2tpZSBvZiB0aGlzLmNvb2tpZXMpIHtcbiAgICAgICAgICAgIGhlYWRlcnMucHVzaChbbmFtZSwgY29va2llXSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZGVycy5wdXNoKFtuYW1lLCB2YWx1ZV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbnZlcnQtaGVhZGVyLW5hbWVzLXRvLWEtc29ydGVkLWxvd2VyY2FzZS1zZXRcbiAgdG9Tb3J0ZWRBcnJheSAoKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuaGVhZGVyc01hcC5zaXplXG4gICAgY29uc3QgYXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSlcbiAgICAvLyBJbiBtb3N0IGNhc2VzLCB5b3Ugd2lsbCB1c2UgdGhlIGZhc3QtcGF0aC5cbiAgICAvLyBmYXN0LXBhdGg6IFVzZSBiaW5hcnkgaW5zZXJ0aW9uIHNvcnQgZm9yIHNtYWxsIGFycmF5cy5cbiAgICBpZiAoc2l6ZSA8PSAzMikge1xuICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgLy8gSWYgZW1wdHksIGl0IGlzIGFuIGVtcHR5IGFycmF5LiBUbyBhdm9pZCB0aGUgZmlyc3QgaW5kZXggYXNzaWdubWVudC5cbiAgICAgICAgcmV0dXJuIGFycmF5XG4gICAgICB9XG4gICAgICAvLyBJbXByb3ZlIHBlcmZvcm1hbmNlIGJ5IHVucm9sbGluZyBsb29wIGFuZCBhdm9pZGluZyBkb3VibGUtbG9vcC5cbiAgICAgIC8vIERvdWJsZS1sb29wLWxlc3MgdmVyc2lvbiBvZiB0aGUgYmluYXJ5IGluc2VydGlvbiBzb3J0LlxuICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLmhlYWRlcnNNYXBbU3ltYm9sLml0ZXJhdG9yXSgpXG4gICAgICBjb25zdCBmaXJzdFZhbHVlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlXG4gICAgICAvLyBzZXQgW25hbWUsIHZhbHVlXSB0byBmaXJzdCBpbmRleC5cbiAgICAgIGFycmF5WzBdID0gW2ZpcnN0VmFsdWVbMF0sIGZpcnN0VmFsdWVbMV0udmFsdWVdXG4gICAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1zb3J0LWFuZC1jb21iaW5lXG4gICAgICAvLyAzLjIuMi4gQXNzZXJ0OiB2YWx1ZSBpcyBub24tbnVsbC5cbiAgICAgIGFzc2VydChmaXJzdFZhbHVlWzFdLnZhbHVlICE9PSBudWxsKVxuICAgICAgZm9yIChcbiAgICAgICAgbGV0IGkgPSAxLCBqID0gMCwgcmlnaHQgPSAwLCBsZWZ0ID0gMCwgcGl2b3QgPSAwLCB4LCB2YWx1ZTtcbiAgICAgICAgaSA8IHNpemU7XG4gICAgICAgICsraVxuICAgICAgKSB7XG4gICAgICAgIC8vIGdldCBuZXh0IHZhbHVlXG4gICAgICAgIHZhbHVlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlXG4gICAgICAgIC8vIHNldCBbbmFtZSwgdmFsdWVdIHRvIGN1cnJlbnQgaW5kZXguXG4gICAgICAgIHggPSBhcnJheVtpXSA9IFt2YWx1ZVswXSwgdmFsdWVbMV0udmFsdWVdXG4gICAgICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LXNvcnQtYW5kLWNvbWJpbmVcbiAgICAgICAgLy8gMy4yLjIuIEFzc2VydDogdmFsdWUgaXMgbm9uLW51bGwuXG4gICAgICAgIGFzc2VydCh4WzFdICE9PSBudWxsKVxuICAgICAgICBsZWZ0ID0gMFxuICAgICAgICByaWdodCA9IGlcbiAgICAgICAgLy8gYmluYXJ5IHNlYXJjaFxuICAgICAgICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICAgICAgLy8gbWlkZGxlIGluZGV4XG4gICAgICAgICAgcGl2b3QgPSBsZWZ0ICsgKChyaWdodCAtIGxlZnQpID4+IDEpXG4gICAgICAgICAgLy8gY29tcGFyZSBoZWFkZXIgbmFtZVxuICAgICAgICAgIGlmIChhcnJheVtwaXZvdF1bMF0gPD0geFswXSkge1xuICAgICAgICAgICAgbGVmdCA9IHBpdm90ICsgMVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByaWdodCA9IHBpdm90XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpICE9PSBwaXZvdCkge1xuICAgICAgICAgIGogPSBpXG4gICAgICAgICAgd2hpbGUgKGogPiBsZWZ0KSB7XG4gICAgICAgICAgICBhcnJheVtqXSA9IGFycmF5Wy0tal1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXJyYXlbbGVmdF0gPSB4XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDQgKi9cbiAgICAgIGlmICghaXRlcmF0b3IubmV4dCgpLmRvbmUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBmb3IgZGVidWdnaW5nIGFuZCB3aWxsIG5ldmVyIGJlIGNhbGxlZC5cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWFjaGFibGUnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgY2FzZSB3b3VsZCBiZSBhIHJhcmUgb2NjdXJyZW5jZS5cbiAgICAgIC8vIHNsb3ctcGF0aDogZmFsbGJhY2tcbiAgICAgIGxldCBpID0gMFxuICAgICAgZm9yIChjb25zdCB7IDA6IG5hbWUsIDE6IHsgdmFsdWUgfSB9IG9mIHRoaXMuaGVhZGVyc01hcCkge1xuICAgICAgICBhcnJheVtpKytdID0gW25hbWUsIHZhbHVlXVxuICAgICAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1zb3J0LWFuZC1jb21iaW5lXG4gICAgICAgIC8vIDMuMi4yLiBBc3NlcnQ6IHZhbHVlIGlzIG5vbi1udWxsLlxuICAgICAgICBhc3NlcnQodmFsdWUgIT09IG51bGwpXG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXkuc29ydChjb21wYXJlSGVhZGVyTmFtZSlcbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlcnMtY2xhc3NcbmNsYXNzIEhlYWRlcnMge1xuICAjZ3VhcmRcbiAgLyoqXG4gICAqIEB0eXBlIHtIZWFkZXJzTGlzdH1cbiAgICovXG4gICNoZWFkZXJzTGlzdFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hlYWRlcnNJbml0fFN5bWJvbH0gW2luaXRdXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaW5pdCA9IHVuZGVmaW5lZCkge1xuICAgIHdlYmlkbC51dGlsLm1hcmtBc1VuY2xvbmVhYmxlKHRoaXMpXG5cbiAgICBpZiAoaW5pdCA9PT0ga0NvbnN0cnVjdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy4jaGVhZGVyc0xpc3QgPSBuZXcgSGVhZGVyc0xpc3QoKVxuXG4gICAgLy8gVGhlIG5ldyBIZWFkZXJzKGluaXQpIGNvbnN0cnVjdG9yIHN0ZXBzIGFyZTpcblxuICAgIC8vIDEuIFNldCB0aGlz4oCZcyBndWFyZCB0byBcIm5vbmVcIi5cbiAgICB0aGlzLiNndWFyZCA9ICdub25lJ1xuXG4gICAgLy8gMi4gSWYgaW5pdCBpcyBnaXZlbiwgdGhlbiBmaWxsIHRoaXMgd2l0aCBpbml0LlxuICAgIGlmIChpbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdChpbml0LCAnSGVhZGVycyBjb25zdHJ1Y3RvcicsICdpbml0JylcbiAgICAgIGZpbGwodGhpcywgaW5pdClcbiAgICB9XG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtYXBwZW5kXG4gIGFwcGVuZCAobmFtZSwgdmFsdWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCAnSGVhZGVycy5hcHBlbmQnKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0hlYWRlcnMuYXBwZW5kJ1xuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyh2YWx1ZSwgcHJlZml4LCAndmFsdWUnKVxuXG4gICAgcmV0dXJuIGFwcGVuZEhlYWRlcih0aGlzLCBuYW1lLCB2YWx1ZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1kZWxldGVcbiAgZGVsZXRlIChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ0hlYWRlcnMuZGVsZXRlJylcblxuICAgIGNvbnN0IHByZWZpeCA9ICdIZWFkZXJzLmRlbGV0ZSdcbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcblxuICAgIC8vIDEuIElmIG5hbWUgaXMgbm90IGEgaGVhZGVyIG5hbWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICBwcmVmaXg6ICdIZWFkZXJzLmRlbGV0ZScsXG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICB0eXBlOiAnaGVhZGVyIG5hbWUnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIElmIHRoaXPigJlzIGd1YXJkIGlzIFwiaW1tdXRhYmxlXCIsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgLy8gMy4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3RcIiBhbmQgbmFtZSBpcyBhXG4gICAgLy8gICAgZm9yYmlkZGVuIGhlYWRlciBuYW1lLCByZXR1cm4uXG4gICAgLy8gNC4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiLCBuYW1lXG4gICAgLy8gICAgaXMgbm90IGEgbm8tQ09SUy1zYWZlbGlzdGVkIHJlcXVlc3QtaGVhZGVyIG5hbWUsIGFuZFxuICAgIC8vICAgIG5hbWUgaXMgbm90IGEgcHJpdmlsZWdlZCBuby1DT1JTIHJlcXVlc3QtaGVhZGVyIG5hbWUsXG4gICAgLy8gICAgcmV0dXJuLlxuICAgIC8vIDUuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXNwb25zZVwiIGFuZCBuYW1lIGlzXG4gICAgLy8gICAgYSBmb3JiaWRkZW4gcmVzcG9uc2UtaGVhZGVyIG5hbWUsIHJldHVybi5cbiAgICAvLyBOb3RlOiB1bmRpY2kgZG9lcyBub3QgaW1wbGVtZW50IGZvcmJpZGRlbiBoZWFkZXIgbmFtZXNcbiAgICBpZiAodGhpcy4jZ3VhcmQgPT09ICdpbW11dGFibGUnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbW11dGFibGUnKVxuICAgIH1cblxuICAgIC8vIDYuIElmIHRoaXPigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gbmFtZSwgdGhlblxuICAgIC8vICAgIHJldHVybi5cbiAgICBpZiAoIXRoaXMuI2hlYWRlcnNMaXN0LmNvbnRhaW5zKG5hbWUsIGZhbHNlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gNy4gRGVsZXRlIG5hbWUgZnJvbSB0aGlz4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAvLyA4LiBJZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiLCB0aGVuIHJlbW92ZVxuICAgIC8vICAgIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0IGhlYWRlcnMgZnJvbSB0aGlzLlxuICAgIHRoaXMuI2hlYWRlcnNMaXN0LmRlbGV0ZShuYW1lLCBmYWxzZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1nZXRcbiAgZ2V0IChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ0hlYWRlcnMuZ2V0JylcblxuICAgIGNvbnN0IHByZWZpeCA9ICdIZWFkZXJzLmdldCdcbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcblxuICAgIC8vIDEuIElmIG5hbWUgaXMgbm90IGEgaGVhZGVyIG5hbWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICBwcmVmaXgsXG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICB0eXBlOiAnaGVhZGVyIG5hbWUnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIFJldHVybiB0aGUgcmVzdWx0IG9mIGdldHRpbmcgbmFtZSBmcm9tIHRoaXPigJlzIGhlYWRlclxuICAgIC8vICAgIGxpc3QuXG4gICAgcmV0dXJuIHRoaXMuI2hlYWRlcnNMaXN0LmdldChuYW1lLCBmYWxzZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1oYXNcbiAgaGFzIChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ0hlYWRlcnMuaGFzJylcblxuICAgIGNvbnN0IHByZWZpeCA9ICdIZWFkZXJzLmhhcydcbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcblxuICAgIC8vIDEuIElmIG5hbWUgaXMgbm90IGEgaGVhZGVyIG5hbWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICBwcmVmaXgsXG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICB0eXBlOiAnaGVhZGVyIG5hbWUnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIFJldHVybiB0cnVlIGlmIHRoaXPigJlzIGhlYWRlciBsaXN0IGNvbnRhaW5zIG5hbWU7XG4gICAgLy8gICAgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzLiNoZWFkZXJzTGlzdC5jb250YWlucyhuYW1lLCBmYWxzZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1zZXRcbiAgc2V0IChuYW1lLCB2YWx1ZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsICdIZWFkZXJzLnNldCcpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnSGVhZGVycy5zZXQnXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG4gICAgdmFsdWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKHZhbHVlLCBwcmVmaXgsICd2YWx1ZScpXG5cbiAgICAvLyAxLiBOb3JtYWxpemUgdmFsdWUuXG4gICAgdmFsdWUgPSBoZWFkZXJWYWx1ZU5vcm1hbGl6ZSh2YWx1ZSlcblxuICAgIC8vIDIuIElmIG5hbWUgaXMgbm90IGEgaGVhZGVyIG5hbWUgb3IgdmFsdWUgaXMgbm90IGFcbiAgICAvLyAgICBoZWFkZXIgdmFsdWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICBwcmVmaXgsXG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICB0eXBlOiAnaGVhZGVyIG5hbWUnXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciB2YWx1ZSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJpbW11dGFibGVcIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAvLyA0LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdFwiIGFuZCBuYW1lIGlzIGFcbiAgICAvLyAgICBmb3JiaWRkZW4gaGVhZGVyIG5hbWUsIHJldHVybi5cbiAgICAvLyA1LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCIgYW5kXG4gICAgLy8gICAgbmFtZS92YWx1ZSBpcyBub3QgYSBuby1DT1JTLXNhZmVsaXN0ZWQgcmVxdWVzdC1oZWFkZXIsXG4gICAgLy8gICAgcmV0dXJuLlxuICAgIC8vIDYuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXNwb25zZVwiIGFuZCBuYW1lIGlzIGFcbiAgICAvLyAgICBmb3JiaWRkZW4gcmVzcG9uc2UtaGVhZGVyIG5hbWUsIHJldHVybi5cbiAgICAvLyBOb3RlOiB1bmRpY2kgZG9lcyBub3QgaW1wbGVtZW50IGZvcmJpZGRlbiBoZWFkZXIgbmFtZXNcbiAgICBpZiAodGhpcy4jZ3VhcmQgPT09ICdpbW11dGFibGUnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbW11dGFibGUnKVxuICAgIH1cblxuICAgIC8vIDcuIFNldCAobmFtZSwgdmFsdWUpIGluIHRoaXPigJlzIGhlYWRlciBsaXN0LlxuICAgIC8vIDguIElmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCIsIHRoZW4gcmVtb3ZlXG4gICAgLy8gICAgcHJpdmlsZWdlZCBuby1DT1JTIHJlcXVlc3QgaGVhZGVycyBmcm9tIHRoaXNcbiAgICB0aGlzLiNoZWFkZXJzTGlzdC5zZXQobmFtZSwgdmFsdWUsIGZhbHNlKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1oZWFkZXJzLWdldHNldGNvb2tpZVxuICBnZXRTZXRDb29raWUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICAvLyAxLiBJZiB0aGlz4oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBTZXQtQ29va2llYCwgdGhlbiByZXR1cm4gwqsgwrsuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSB2YWx1ZXMgb2YgYWxsIGhlYWRlcnMgaW4gdGhpc+KAmXMgaGVhZGVyIGxpc3Qgd2hvc2UgbmFtZSBpc1xuICAgIC8vICAgIGEgYnl0ZS1jYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBgU2V0LUNvb2tpZWAsIGluIG9yZGVyLlxuXG4gICAgY29uc3QgbGlzdCA9IHRoaXMuI2hlYWRlcnNMaXN0LmNvb2tpZXNcblxuICAgIGlmIChsaXN0KSB7XG4gICAgICByZXR1cm4gWy4uLmxpc3RdXG4gICAgfVxuXG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICBbdXRpbC5pbnNwZWN0LmN1c3RvbV0gKGRlcHRoLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5kZXB0aCA/Pz0gZGVwdGhcblxuICAgIHJldHVybiBgSGVhZGVycyAke3V0aWwuZm9ybWF0V2l0aE9wdGlvbnMob3B0aW9ucywgdGhpcy4jaGVhZGVyc0xpc3QuZW50cmllcyl9YFxuICB9XG5cbiAgc3RhdGljIGdldEhlYWRlcnNHdWFyZCAobykge1xuICAgIHJldHVybiBvLiNndWFyZFxuICB9XG5cbiAgc3RhdGljIHNldEhlYWRlcnNHdWFyZCAobywgZ3VhcmQpIHtcbiAgICBvLiNndWFyZCA9IGd1YXJkXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIZWFkZXJzfSBvXG4gICAqL1xuICBzdGF0aWMgZ2V0SGVhZGVyc0xpc3QgKG8pIHtcbiAgICByZXR1cm4gby4jaGVhZGVyc0xpc3RcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hlYWRlcnN9IHRhcmdldFxuICAgKiBAcGFyYW0ge0hlYWRlcnNMaXN0fSBsaXN0XG4gICAqL1xuICBzdGF0aWMgc2V0SGVhZGVyc0xpc3QgKHRhcmdldCwgbGlzdCkge1xuICAgIHRhcmdldC4jaGVhZGVyc0xpc3QgPSBsaXN0XG4gIH1cbn1cblxuY29uc3QgeyBnZXRIZWFkZXJzR3VhcmQsIHNldEhlYWRlcnNHdWFyZCwgZ2V0SGVhZGVyc0xpc3QsIHNldEhlYWRlcnNMaXN0IH0gPSBIZWFkZXJzXG5SZWZsZWN0LmRlbGV0ZVByb3BlcnR5KEhlYWRlcnMsICdnZXRIZWFkZXJzR3VhcmQnKVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShIZWFkZXJzLCAnc2V0SGVhZGVyc0d1YXJkJylcblJlZmxlY3QuZGVsZXRlUHJvcGVydHkoSGVhZGVycywgJ2dldEhlYWRlcnNMaXN0JylcblJlZmxlY3QuZGVsZXRlUHJvcGVydHkoSGVhZGVycywgJ3NldEhlYWRlcnNMaXN0JylcblxuaXRlcmF0b3JNaXhpbignSGVhZGVycycsIEhlYWRlcnMsIGhlYWRlcnNMaXN0U29ydEFuZENvbWJpbmUsIDAsIDEpXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEhlYWRlcnMucHJvdG90eXBlLCB7XG4gIGFwcGVuZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZGVsZXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBnZXQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGhhczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc2V0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBnZXRTZXRDb29raWU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdIZWFkZXJzJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgW3V0aWwuaW5zcGVjdC5jdXN0b21dOiB7XG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXQgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gd2ViaWRsLnV0aWwuVHlwZXMuT0JKRUNUKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBSZWZsZWN0LmdldChWLCBTeW1ib2wuaXRlcmF0b3IpXG5cbiAgICAvLyBBIHdvcmstYXJvdW5kIHRvIGVuc3VyZSB3ZSBzZW5kIHRoZSBwcm9wZXJseS1jYXNlZCBIZWFkZXJzIHdoZW4gViBpcyBhIEhlYWRlcnMgb2JqZWN0LlxuICAgIC8vIFJlYWQgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvcHVsbC8zMTU5I2lzc3VlY29tbWVudC0yMDc1NTM3MjI2IGJlZm9yZSB0b3VjaGluZywgcGxlYXNlLlxuICAgIGlmICghdXRpbC50eXBlcy5pc1Byb3h5KFYpICYmIGl0ZXJhdG9yID09PSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzKSB7IC8vIEhlYWRlcnMgb2JqZWN0XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZ2V0SGVhZGVyc0xpc3QoVikuZW50cmllc0xpc3RcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBmYWxsLXRocm91Z2hcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PiddKFYsIHByZWZpeCwgYXJndW1lbnQsIGl0ZXJhdG9yLmJpbmQoVikpXG4gICAgfVxuXG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzWydyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4nXShWLCBwcmVmaXgsIGFyZ3VtZW50KVxuICB9XG5cbiAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICBwcmVmaXg6ICdIZWFkZXJzIGNvbnN0cnVjdG9yJyxcbiAgICBhcmd1bWVudDogJ0FyZ3VtZW50IDEnLFxuICAgIHR5cGVzOiBbJ3NlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PicsICdyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4nXVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmlsbCxcbiAgLy8gZm9yIHRlc3QuXG4gIGNvbXBhcmVIZWFkZXJOYW1lLFxuICBIZWFkZXJzLFxuICBIZWFkZXJzTGlzdCxcbiAgZ2V0SGVhZGVyc0d1YXJkLFxuICBzZXRIZWFkZXJzR3VhcmQsXG4gIHNldEhlYWRlcnNMaXN0LFxuICBnZXRIZWFkZXJzTGlzdFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/headers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/index.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\n\n\nconst {\n  makeNetworkError,\n  makeAppropriateNetworkError,\n  filterResponse,\n  makeResponse,\n  fromInnerResponse,\n  getResponseState\n} = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/undici/lib/web/fetch/response.js\")\nconst { HeadersList } = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\")\nconst { Request, cloneRequest, getRequestDispatcher, getRequestState } = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/undici/lib/web/fetch/request.js\")\nconst zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\")\nconst {\n  bytesMatch,\n  makePolicyContainer,\n  clonePolicyContainer,\n  requestBadPort,\n  TAOCheck,\n  appendRequestOriginHeader,\n  responseLocationURL,\n  requestCurrentURL,\n  setRequestReferrerPolicyOnRedirect,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  createOpaqueTimingInfo,\n  appendFetchMetadata,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  determineRequestsReferrer,\n  coarsenedSharedCurrentTime,\n  createDeferredPromise,\n  sameOrigin,\n  isCancelled,\n  isAborted,\n  isErrorLike,\n  fullyReadBody,\n  readableStreamClose,\n  isomorphicEncode,\n  urlIsLocal,\n  urlIsHttpHttpsScheme,\n  urlHasHttpsScheme,\n  clampAndCoarsenConnectionTimingInfo,\n  simpleRangeHeaderValue,\n  buildContentRange,\n  createInflate,\n  extractMimeType\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { safelyExtractBody, extractBody } = __webpack_require__(/*! ./body */ \"(rsc)/./node_modules/undici/lib/web/fetch/body.js\")\nconst {\n  redirectStatusSet,\n  nullBodyStatus,\n  safeMethodsSet,\n  requestBodyHeader,\n  subresourceSet\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/fetch/constants.js\")\nconst EE = __webpack_require__(/*! node:events */ \"node:events\")\nconst { Readable, pipeline, finished, isErrored, isReadable } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { addAbortListener, bufferToLowerCasedHeaderName } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../../global */ \"(rsc)/./node_modules/undici/lib/global.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { STATUS_CODES } = __webpack_require__(/*! node:http */ \"node:http\")\nconst GET_OR_HEAD = ['GET', 'HEAD']\n\nconst defaultUserAgent = typeof __UNDICI_IS_NODE__ !== 'undefined' || typeof esbuildDetection !== 'undefined'\n  ? 'node'\n  : 'undici'\n\n/** @type {import('buffer').resolveObjectURL} */\nlet resolveObjectURL\n\nclass Fetch extends EE {\n  constructor (dispatcher) {\n    super()\n\n    this.dispatcher = dispatcher\n    this.connection = null\n    this.dump = false\n    this.state = 'ongoing'\n  }\n\n  terminate (reason) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    this.state = 'terminated'\n    this.connection?.destroy(reason)\n    this.emit('terminated', reason)\n  }\n\n  // https://fetch.spec.whatwg.org/#fetch-controller-abort\n  abort (error) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    // 1. Set controllers state to \"aborted\".\n    this.state = 'aborted'\n\n    // 2. Let fallbackError be an \"AbortError\" DOMException.\n    // 3. Set error to fallbackError if it is not given.\n    if (!error) {\n      error = new DOMException('The operation was aborted.', 'AbortError')\n    }\n\n    // 4. Let serializedError be StructuredSerialize(error).\n    //    If that threw an exception, catch it, and let\n    //    serializedError be StructuredSerialize(fallbackError).\n\n    // 5. Set controllers serialized abort reason to serializedError.\n    this.serializedAbortReason = error\n\n    this.connection?.destroy(error)\n    this.emit('terminated', error)\n  }\n}\n\nfunction handleFetchDone (response) {\n  finalizeAndReportTiming(response, 'fetch')\n}\n\n// https://fetch.spec.whatwg.org/#fetch-method\nfunction fetch (input, init = undefined) {\n  webidl.argumentLengthCheck(arguments, 1, 'globalThis.fetch')\n\n  // 1. Let p be a new promise.\n  let p = createDeferredPromise()\n\n  // 2. Let requestObject be the result of invoking the initial value of\n  // Request as constructor with input and init as arguments. If this throws\n  // an exception, reject p with it and return p.\n  let requestObject\n\n  try {\n    requestObject = new Request(input, init)\n  } catch (e) {\n    p.reject(e)\n    return p.promise\n  }\n\n  // 3. Let request be requestObjects request.\n  const request = getRequestState(requestObject)\n\n  // 4. If requestObjects signals aborted flag is set, then:\n  if (requestObject.signal.aborted) {\n    // 1. Abort the fetch() call with p, request, null, and\n    //    requestObjects signals abort reason.\n    abortFetch(p, request, null, requestObject.signal.reason)\n\n    // 2. Return p.\n    return p.promise\n  }\n\n  // 5. Let globalObject be requests clients global object.\n  const globalObject = request.client.globalObject\n\n  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n  // requests service-workers mode to \"none\".\n  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {\n    request.serviceWorkers = 'none'\n  }\n\n  // 7. Let responseObject be null.\n  let responseObject = null\n\n  // 8. Let relevantRealm be thiss relevant Realm.\n\n  // 9. Let locallyAborted be false.\n  let locallyAborted = false\n\n  // 10. Let controller be null.\n  let controller = null\n\n  // 11. Add the following abort steps to requestObjects signal:\n  addAbortListener(\n    requestObject.signal,\n    () => {\n      // 1. Set locallyAborted to true.\n      locallyAborted = true\n\n      // 2. Assert: controller is non-null.\n      assert(controller != null)\n\n      // 3. Abort controller with requestObjects signals abort reason.\n      controller.abort(requestObject.signal.reason)\n\n      const realResponse = responseObject?.deref()\n\n      // 4. Abort the fetch() call with p, request, responseObject,\n      //    and requestObjects signals abort reason.\n      abortFetch(p, request, realResponse, requestObject.signal.reason)\n    }\n  )\n\n  // 12. Let handleFetchDone given response response be to finalize and\n  // report timing with response, globalObject, and \"fetch\".\n  // see function handleFetchDone\n\n  // 13. Set controller to the result of calling fetch given request,\n  // with processResponseEndOfBody set to handleFetchDone, and processResponse\n  // given response being these substeps:\n\n  const processResponse = (response) => {\n    // 1. If locallyAborted is true, terminate these substeps.\n    if (locallyAborted) {\n      return\n    }\n\n    // 2. If responses aborted flag is set, then:\n    if (response.aborted) {\n      // 1. Let deserializedError be the result of deserialize a serialized\n      //    abort reason given controllers serialized abort reason and\n      //    relevantRealm.\n\n      // 2. Abort the fetch() call with p, request, responseObject, and\n      //    deserializedError.\n\n      abortFetch(p, request, responseObject, controller.serializedAbortReason)\n      return\n    }\n\n    // 3. If response is a network error, then reject p with a TypeError\n    // and terminate these substeps.\n    if (response.type === 'error') {\n      p.reject(new TypeError('fetch failed', { cause: response.error }))\n      return\n    }\n\n    // 4. Set responseObject to the result of creating a Response object,\n    // given response, \"immutable\", and relevantRealm.\n    responseObject = new WeakRef(fromInnerResponse(response, 'immutable'))\n\n    // 5. Resolve p with responseObject.\n    p.resolve(responseObject.deref())\n    p = null\n  }\n\n  controller = fetching({\n    request,\n    processResponseEndOfBody: handleFetchDone,\n    processResponse,\n    dispatcher: getRequestDispatcher(requestObject) // undici\n  })\n\n  // 14. Return p.\n  return p.promise\n}\n\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming (response, initiatorType = 'other') {\n  // 1. If response is an aborted network error, then return.\n  if (response.type === 'error' && response.aborted) {\n    return\n  }\n\n  // 2. If responses URL list is null or empty, then return.\n  if (!response.urlList?.length) {\n    return\n  }\n\n  // 3. Let originalURL be responses URL list[0].\n  const originalURL = response.urlList[0]\n\n  // 4. Let timingInfo be responses timing info.\n  let timingInfo = response.timingInfo\n\n  // 5. Let cacheState be responses cache state.\n  let cacheState = response.cacheState\n\n  // 6. If originalURLs scheme is not an HTTP(S) scheme, then return.\n  if (!urlIsHttpHttpsScheme(originalURL)) {\n    return\n  }\n\n  // 7. If timingInfo is null, then return.\n  if (timingInfo === null) {\n    return\n  }\n\n  // 8. If responses timing allow passed flag is not set, then:\n  if (!response.timingAllowPassed) {\n    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n    timingInfo = createOpaqueTimingInfo({\n      startTime: timingInfo.startTime\n    })\n\n    //  2. Set cacheState to the empty string.\n    cacheState = ''\n  }\n\n  // 9. Set timingInfos end time to the coarsened shared current time\n  // given globals relevant settings objects cross-origin isolated\n  // capability.\n  // TODO: given globals relevant settings objects cross-origin isolated\n  // capability?\n  timingInfo.endTime = coarsenedSharedCurrentTime()\n\n  // 10. Set responses timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n  // global, and cacheState.\n  markResourceTiming(\n    timingInfo,\n    originalURL.href,\n    initiatorType,\n    globalThis,\n    cacheState,\n    '', // bodyType\n    response.status\n  )\n}\n\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nconst markResourceTiming = performance.markResourceTiming\n\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch (p, request, responseObject, error) {\n  // 1. Reject promise with error.\n  if (p) {\n    // We might have already resolved the promise at this stage\n    p.reject(error)\n  }\n\n  // 2. If requests body is not null and is readable, then cancel requests\n  // body with error.\n  if (request.body?.stream != null && isReadable(request.body.stream)) {\n    request.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n\n  // 3. If responseObject is null, then return.\n  if (responseObject == null) {\n    return\n  }\n\n  // 4. Let response be responseObjects response.\n  const response = getResponseState(responseObject)\n\n  // 5. If responses body is not null and is readable, then error responses\n  // body with error.\n  if (response.body?.stream != null && isReadable(response.body.stream)) {\n    response.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching ({\n  request,\n  processRequestBodyChunkLength,\n  processRequestEndOfBody,\n  processResponse,\n  processResponseEndOfBody,\n  processResponseConsumeBody,\n  useParallelQueue = false,\n  dispatcher = getGlobalDispatcher() // undici\n}) {\n  // Ensure that the dispatcher is set accordingly\n  assert(dispatcher)\n\n  // 1. Let taskDestination be null.\n  let taskDestination = null\n\n  // 2. Let crossOriginIsolatedCapability be false.\n  let crossOriginIsolatedCapability = false\n\n  // 3. If requests client is non-null, then:\n  if (request.client != null) {\n    // 1. Set taskDestination to requests clients global object.\n    taskDestination = request.client.globalObject\n\n    // 2. Set crossOriginIsolatedCapability to requests clients cross-origin\n    // isolated capability.\n    crossOriginIsolatedCapability =\n      request.client.crossOriginIsolatedCapability\n  }\n\n  // 4. If useParallelQueue is true, then set taskDestination to the result of\n  // starting a new parallel queue.\n  // TODO\n\n  // 5. Let timingInfo be a new fetch timing info whose start time and\n  // post-redirect start time are the coarsened shared current time given\n  // crossOriginIsolatedCapability.\n  const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability)\n  const timingInfo = createOpaqueTimingInfo({\n    startTime: currentTime\n  })\n\n  // 6. Let fetchParams be a new fetch params whose\n  // request is request,\n  // timing info is timingInfo,\n  // process request body chunk length is processRequestBodyChunkLength,\n  // process request end-of-body is processRequestEndOfBody,\n  // process response is processResponse,\n  // process response consume body is processResponseConsumeBody,\n  // process response end-of-body is processResponseEndOfBody,\n  // task destination is taskDestination,\n  // and cross-origin isolated capability is crossOriginIsolatedCapability.\n  const fetchParams = {\n    controller: new Fetch(dispatcher),\n    request,\n    timingInfo,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseConsumeBody,\n    processResponseEndOfBody,\n    taskDestination,\n    crossOriginIsolatedCapability\n  }\n\n  // 7. If requests body is a byte sequence, then set requests body to\n  //    requests body as a body.\n  // NOTE: Since fetching is only called from fetch, body should already be\n  // extracted.\n  assert(!request.body || request.body.stream)\n\n  // 8. If requests window is \"client\", then set requests window to requests\n  // client, if requests clients global object is a Window object; otherwise\n  // \"no-window\".\n  if (request.window === 'client') {\n    // TODO: What if request.client is null?\n    request.window =\n      request.client?.globalObject?.constructor?.name === 'Window'\n        ? request.client\n        : 'no-window'\n  }\n\n  // 9. If requests origin is \"client\", then set requests origin to requests\n  // clients origin.\n  if (request.origin === 'client') {\n    request.origin = request.client.origin\n  }\n\n  // 10. If all of the following conditions are true:\n  // TODO\n\n  // 11. If requests policy container is \"client\", then:\n  if (request.policyContainer === 'client') {\n    // 1. If requests client is non-null, then set requests policy\n    // container to a clone of requests clients policy container. [HTML]\n    if (request.client != null) {\n      request.policyContainer = clonePolicyContainer(\n        request.client.policyContainer\n      )\n    } else {\n      // 2. Otherwise, set requests policy container to a new policy\n      // container.\n      request.policyContainer = makePolicyContainer()\n    }\n  }\n\n  // 12. If requests header list does not contain `Accept`, then:\n  if (!request.headersList.contains('accept', true)) {\n    // 1. Let value be `*/*`.\n    const value = '*/*'\n\n    // 2. A user agent should set value to the first matching statement, if\n    // any, switching on requests destination:\n    // \"document\"\n    // \"frame\"\n    // \"iframe\"\n    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n    // \"image\"\n    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n    // \"style\"\n    // `text/css,*/*;q=0.1`\n    // TODO\n\n    // 3. Append `Accept`/value to requests header list.\n    request.headersList.append('accept', value, true)\n  }\n\n  // 13. If requests header list does not contain `Accept-Language`, then\n  // user agents should append `Accept-Language`/an appropriate value to\n  // requests header list.\n  if (!request.headersList.contains('accept-language', true)) {\n    request.headersList.append('accept-language', '*', true)\n  }\n\n  // 14. If requests priority is null, then use requests initiator and\n  // destination appropriately in setting requests priority to a\n  // user-agent-defined object.\n  if (request.priority === null) {\n    // TODO\n  }\n\n  // 15. If request is a subresource request, then:\n  if (subresourceSet.has(request.destination)) {\n    // TODO\n  }\n\n  // 16. Run main fetch given fetchParams.\n  mainFetch(fetchParams)\n    .catch(err => {\n      fetchParams.controller.terminate(err)\n    })\n\n  // 17. Return fetchParam's controller\n  return fetchParams.controller\n}\n\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch (fetchParams, recursive = false) {\n  // 1. Let request be fetchParamss request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. If requests local-URLs-only flag is set and requests current URL is\n  // not local, then set response to a network error.\n  if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {\n    response = makeNetworkError('local URLs only')\n  }\n\n  // 4. Run report Content Security Policy violations for request.\n  // TODO\n\n  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n  tryUpgradeRequestToAPotentiallyTrustworthyURL(request)\n\n  // 6. If should request be blocked due to a bad port, should fetching request\n  // be blocked as mixed content, or should request be blocked by Content\n  // Security Policy returns blocked, then set response to a network error.\n  if (requestBadPort(request) === 'blocked') {\n    response = makeNetworkError('bad port')\n  }\n  // TODO: should fetching request be blocked as mixed content?\n  // TODO: should request be blocked by Content Security Policy?\n\n  // 7. If requests referrer policy is the empty string, then set requests\n  // referrer policy to requests policy containers referrer policy.\n  if (request.referrerPolicy === '') {\n    request.referrerPolicy = request.policyContainer.referrerPolicy\n  }\n\n  // 8. If requests referrer is not \"no-referrer\", then set requests\n  // referrer to the result of invoking determine requests referrer.\n  if (request.referrer !== 'no-referrer') {\n    request.referrer = determineRequestsReferrer(request)\n  }\n\n  // 9. Set requests current URLs scheme to \"https\" if all of the following\n  // conditions are true:\n  // - requests current URLs scheme is \"http\"\n  // - requests current URLs host is a domain\n  // - Matching requests current URLs host per Known HSTS Host Domain Name\n  //   Matching results in either a superdomain match with an asserted\n  //   includeSubDomains directive or a congruent match (with or without an\n  //   asserted includeSubDomains directive). [HSTS]\n  // TODO\n\n  // 10. If recursive is false, then run the remaining steps in parallel.\n  // TODO\n\n  // 11. If response is null, then set response to the result of running\n  // the steps corresponding to the first matching statement:\n  if (response === null) {\n    const currentURL = requestCurrentURL(request)\n    if (\n      // - requests current URLs origin is same origin with requests origin,\n      //   and requests response tainting is \"basic\"\n      (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||\n      // requests current URLs scheme is \"data\"\n      (currentURL.protocol === 'data:') ||\n      // - requests mode is \"navigate\" or \"websocket\"\n      (request.mode === 'navigate' || request.mode === 'websocket')\n    ) {\n      // 1. Set requests response tainting to \"basic\".\n      request.responseTainting = 'basic'\n\n      // 2. Return the result of running scheme fetch given fetchParams.\n      response = await schemeFetch(fetchParams)\n\n    // requests mode is \"same-origin\"\n    } else if (request.mode === 'same-origin') {\n      // 1. Return a network error.\n      response = makeNetworkError('request mode cannot be \"same-origin\"')\n\n    // requests mode is \"no-cors\"\n    } else if (request.mode === 'no-cors') {\n      // 1. If requests redirect mode is not \"follow\", then return a network\n      // error.\n      if (request.redirect !== 'follow') {\n        response = makeNetworkError(\n          'redirect mode cannot be \"follow\" for \"no-cors\" request'\n        )\n      } else {\n        // 2. Set requests response tainting to \"opaque\".\n        request.responseTainting = 'opaque'\n\n        // 3. Return the result of running scheme fetch given fetchParams.\n        response = await schemeFetch(fetchParams)\n      }\n    // requests current URLs scheme is not an HTTP(S) scheme\n    } else if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {\n      // Return a network error.\n      response = makeNetworkError('URL scheme must be a HTTP(S) scheme')\n\n      // - requests use-CORS-preflight flag is set\n      // - requests unsafe-request flag is set and either requests method is\n      //   not a CORS-safelisted method or CORS-unsafe request-header names with\n      //   requests header list is not empty\n      //    1. Set requests response tainting to \"cors\".\n      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n      //    given fetchParams and true.\n      //    3. If corsWithPreflightResponse is a network error, then clear cache\n      //    entries using request.\n      //    4. Return corsWithPreflightResponse.\n      // TODO\n\n    // Otherwise\n    } else {\n      //    1. Set requests response tainting to \"cors\".\n      request.responseTainting = 'cors'\n\n      //    2. Return the result of running HTTP fetch given fetchParams.\n      response = await httpFetch(fetchParams)\n    }\n  }\n\n  // 12. If recursive is true, then return response.\n  if (recursive) {\n    return response\n  }\n\n  // 13. If response is not a network error and response is not a filtered\n  // response, then:\n  if (response.status !== 0 && !response.internalResponse) {\n    // If requests response tainting is \"cors\", then:\n    if (request.responseTainting === 'cors') {\n      // 1. Let headerNames be the result of extracting header list values\n      // given `Access-Control-Expose-Headers` and responses header list.\n      // TODO\n      // 2. If requests credentials mode is not \"include\" and headerNames\n      // contains `*`, then set responses CORS-exposed header-name list to\n      // all unique header names in responses header list.\n      // TODO\n      // 3. Otherwise, if headerNames is not null or failure, then set\n      // responses CORS-exposed header-name list to headerNames.\n      // TODO\n    }\n\n    // Set response to the following filtered response with response as its\n    // internal response, depending on requests response tainting:\n    if (request.responseTainting === 'basic') {\n      response = filterResponse(response, 'basic')\n    } else if (request.responseTainting === 'cors') {\n      response = filterResponse(response, 'cors')\n    } else if (request.responseTainting === 'opaque') {\n      response = filterResponse(response, 'opaque')\n    } else {\n      assert(false)\n    }\n  }\n\n  // 14. Let internalResponse be response, if response is a network error,\n  // and responses internal response otherwise.\n  let internalResponse =\n    response.status === 0 ? response : response.internalResponse\n\n  // 15. If internalResponses URL list is empty, then set it to a clone of\n  // requests URL list.\n  if (internalResponse.urlList.length === 0) {\n    internalResponse.urlList.push(...request.urlList)\n  }\n\n  // 16. If requests timing allow failed flag is unset, then set\n  // internalResponses timing allow passed flag.\n  if (!request.timingAllowFailed) {\n    response.timingAllowPassed = true\n  }\n\n  // 17. If response is not a network error and any of the following returns\n  // blocked\n  // - should internalResponse to request be blocked as mixed content\n  // - should internalResponse to request be blocked by Content Security Policy\n  // - should internalResponse to request be blocked due to its MIME type\n  // - should internalResponse to request be blocked due to nosniff\n  // TODO\n\n  // 18. If responses type is \"opaque\", internalResponses status is 206,\n  // internalResponses range-requested flag is set, and requests header\n  // list does not contain `Range`, then set response and internalResponse\n  // to a network error.\n  if (\n    response.type === 'opaque' &&\n    internalResponse.status === 206 &&\n    internalResponse.rangeRequested &&\n    !request.headers.contains('range', true)\n  ) {\n    response = internalResponse = makeNetworkError()\n  }\n\n  // 19. If response is not a network error and either requests method is\n  // `HEAD` or `CONNECT`, or internalResponses status is a null body status,\n  // set internalResponses body to null and disregard any enqueuing toward\n  // it (if any).\n  if (\n    response.status !== 0 &&\n    (request.method === 'HEAD' ||\n      request.method === 'CONNECT' ||\n      nullBodyStatus.includes(internalResponse.status))\n  ) {\n    internalResponse.body = null\n    fetchParams.controller.dump = true\n  }\n\n  // 20. If requests integrity metadata is not the empty string, then:\n  if (request.integrity) {\n    // 1. Let processBodyError be this step: run fetch finale given fetchParams\n    // and a network error.\n    const processBodyError = (reason) =>\n      fetchFinale(fetchParams, makeNetworkError(reason))\n\n    // 2. If requests response tainting is \"opaque\", or responses body is null,\n    // then run processBodyError and abort these steps.\n    if (request.responseTainting === 'opaque' || response.body == null) {\n      processBodyError(response.error)\n      return\n    }\n\n    // 3. Let processBody given bytes be these steps:\n    const processBody = (bytes) => {\n      // 1. If bytes do not match requests integrity metadata,\n      // then run processBodyError and abort these steps. [SRI]\n      if (!bytesMatch(bytes, request.integrity)) {\n        processBodyError('integrity mismatch')\n        return\n      }\n\n      // 2. Set responses body to bytes as a body.\n      response.body = safelyExtractBody(bytes)[0]\n\n      // 3. Run fetch finale given fetchParams and response.\n      fetchFinale(fetchParams, response)\n    }\n\n    // 4. Fully read responses body given processBody and processBodyError.\n    await fullyReadBody(response.body, processBody, processBodyError)\n  } else {\n    // 21. Otherwise, run fetch finale given fetchParams and response.\n    fetchFinale(fetchParams, response)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nfunction schemeFetch (fetchParams) {\n  // Note: since the connection is destroyed on redirect, which sets fetchParams to a\n  // cancelled state, we do not want this condition to trigger *unless* there have been\n  // no redirects. See https://github.com/nodejs/undici/issues/1776\n  // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n  if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {\n    return Promise.resolve(makeAppropriateNetworkError(fetchParams))\n  }\n\n  // 2. Let request be fetchParamss request.\n  const { request } = fetchParams\n\n  const { protocol: scheme } = requestCurrentURL(request)\n\n  // 3. Switch on requests current URLs scheme and run the associated steps:\n  switch (scheme) {\n    case 'about:': {\n      // If requests current URLs path is the string \"blank\", then return a new response\n      // whose status message is `OK`, header list is  (`Content-Type`, `text/html;charset=utf-8`) ,\n      // and body is the empty byte sequence as a body.\n\n      // Otherwise, return a network error.\n      return Promise.resolve(makeNetworkError('about scheme is not supported'))\n    }\n    case 'blob:': {\n      if (!resolveObjectURL) {\n        resolveObjectURL = (__webpack_require__(/*! node:buffer */ \"node:buffer\").resolveObjectURL)\n      }\n\n      // 1. Let blobURLEntry be requests current URLs blob URL entry.\n      const blobURLEntry = requestCurrentURL(request)\n\n      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n      // Buffer.resolveObjectURL does not ignore URL queries.\n      if (blobURLEntry.search.length !== 0) {\n        return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'))\n      }\n\n      const blob = resolveObjectURL(blobURLEntry.toString())\n\n      // 2. If requests method is not `GET`, blobURLEntry is null, or blobURLEntrys\n      //    object is not a Blob object, then return a network error.\n      if (request.method !== 'GET' || !webidl.is.Blob(blob)) {\n        return Promise.resolve(makeNetworkError('invalid method'))\n      }\n\n      // 3. Let blob be blobURLEntrys object.\n      // Note: done above\n\n      // 4. Let response be a new response.\n      const response = makeResponse()\n\n      // 5. Let fullLength be blobs size.\n      const fullLength = blob.size\n\n      // 6. Let serializedFullLength be fullLength, serialized and isomorphic encoded.\n      const serializedFullLength = isomorphicEncode(`${fullLength}`)\n\n      // 7. Let type be blobs type.\n      const type = blob.type\n\n      // 8. If requests header list does not contain `Range`:\n      // 9. Otherwise:\n      if (!request.headersList.contains('range', true)) {\n        // 1. Let bodyWithType be the result of safely extracting blob.\n        // Note: in the FileAPI a blob \"object\" is a Blob *or* a MediaSource.\n        // In node, this can only ever be a Blob. Therefore we can safely\n        // use extractBody directly.\n        const bodyWithType = extractBody(blob)\n\n        // 2. Set responses status message to `OK`.\n        response.statusText = 'OK'\n\n        // 3. Set responses body to bodyWithTypes body.\n        response.body = bodyWithType[0]\n\n        // 4. Set responses header list to  (`Content-Length`, serializedFullLength), (`Content-Type`, type) .\n        response.headersList.set('content-length', serializedFullLength, true)\n        response.headersList.set('content-type', type, true)\n      } else {\n        // 1. Set responses range-requested flag.\n        response.rangeRequested = true\n\n        // 2. Let rangeHeader be the result of getting `Range` from requests header list.\n        const rangeHeader = request.headersList.get('range', true)\n\n        // 3. Let rangeValue be the result of parsing a single range header value given rangeHeader and true.\n        const rangeValue = simpleRangeHeaderValue(rangeHeader, true)\n\n        // 4. If rangeValue is failure, then return a network error.\n        if (rangeValue === 'failure') {\n          return Promise.resolve(makeNetworkError('failed to fetch the data URL'))\n        }\n\n        // 5. Let (rangeStart, rangeEnd) be rangeValue.\n        let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue\n\n        // 6. If rangeStart is null:\n        // 7. Otherwise:\n        if (rangeStart === null) {\n          // 1. Set rangeStart to fullLength  rangeEnd.\n          rangeStart = fullLength - rangeEnd\n\n          // 2. Set rangeEnd to rangeStart + rangeEnd  1.\n          rangeEnd = rangeStart + rangeEnd - 1\n        } else {\n          // 1. If rangeStart is greater than or equal to fullLength, then return a network error.\n          if (rangeStart >= fullLength) {\n            return Promise.resolve(makeNetworkError('Range start is greater than the blob\\'s size.'))\n          }\n\n          // 2. If rangeEnd is null or rangeEnd is greater than or equal to fullLength, then set\n          //    rangeEnd to fullLength  1.\n          if (rangeEnd === null || rangeEnd >= fullLength) {\n            rangeEnd = fullLength - 1\n          }\n        }\n\n        // 8. Let slicedBlob be the result of invoking slice blob given blob, rangeStart,\n        //    rangeEnd + 1, and type.\n        const slicedBlob = blob.slice(rangeStart, rangeEnd, type)\n\n        // 9. Let slicedBodyWithType be the result of safely extracting slicedBlob.\n        // Note: same reason as mentioned above as to why we use extractBody\n        const slicedBodyWithType = extractBody(slicedBlob)\n\n        // 10. Set responses body to slicedBodyWithTypes body.\n        response.body = slicedBodyWithType[0]\n\n        // 11. Let serializedSlicedLength be slicedBlobs size, serialized and isomorphic encoded.\n        const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`)\n\n        // 12. Let contentRange be the result of invoking build a content range given rangeStart,\n        //     rangeEnd, and fullLength.\n        const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength)\n\n        // 13. Set responses status to 206.\n        response.status = 206\n\n        // 14. Set responses status message to `Partial Content`.\n        response.statusText = 'Partial Content'\n\n        // 15. Set responses header list to  (`Content-Length`, serializedSlicedLength),\n        //     (`Content-Type`, type), (`Content-Range`, contentRange) .\n        response.headersList.set('content-length', serializedSlicedLength, true)\n        response.headersList.set('content-type', type, true)\n        response.headersList.set('content-range', contentRange, true)\n      }\n\n      // 10. Return response.\n      return Promise.resolve(response)\n    }\n    case 'data:': {\n      // 1. Let dataURLStruct be the result of running the\n      //    data: URL processor on requests current URL.\n      const currentURL = requestCurrentURL(request)\n      const dataURLStruct = dataURLProcessor(currentURL)\n\n      // 2. If dataURLStruct is failure, then return a\n      //    network error.\n      if (dataURLStruct === 'failure') {\n        return Promise.resolve(makeNetworkError('failed to fetch the data URL'))\n      }\n\n      // 3. Let mimeType be dataURLStructs MIME type, serialized.\n      const mimeType = serializeAMimeType(dataURLStruct.mimeType)\n\n      // 4. Return a response whose status message is `OK`,\n      //    header list is  (`Content-Type`, mimeType) ,\n      //    and body is dataURLStructs body as a body.\n      return Promise.resolve(makeResponse({\n        statusText: 'OK',\n        headersList: [\n          ['content-type', { name: 'Content-Type', value: mimeType }]\n        ],\n        body: safelyExtractBody(dataURLStruct.body)[0]\n      }))\n    }\n    case 'file:': {\n      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n      // When in doubt, return a network error.\n      return Promise.resolve(makeNetworkError('not implemented... yet...'))\n    }\n    case 'http:':\n    case 'https:': {\n      // Return the result of running HTTP fetch given fetchParams.\n\n      return httpFetch(fetchParams)\n        .catch((err) => makeNetworkError(err))\n    }\n    default: {\n      return Promise.resolve(makeNetworkError('unknown scheme'))\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse (fetchParams, response) {\n  // 1. Set fetchParamss requests done flag.\n  fetchParams.request.done = true\n\n  // 2, If fetchParamss process response done is not null, then queue a fetch\n  // task to run fetchParamss process response done given response, with\n  // fetchParamss task destination.\n  if (fetchParams.processResponseDone != null) {\n    queueMicrotask(() => fetchParams.processResponseDone(response))\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale (fetchParams, response) {\n  // 1. Let timingInfo be fetchParamss timing info.\n  let timingInfo = fetchParams.timingInfo\n\n  // 2. If response is not a network error and fetchParamss requests client is a secure context,\n  //    then set timingInfos server-timing headers to the result of getting, decoding, and splitting\n  //    `Server-Timing` from responses internal responses header list.\n  // TODO\n\n  // 3. Let processResponseEndOfBody be the following steps:\n  const processResponseEndOfBody = () => {\n    // 1. Let unsafeEndTime be the unsafe shared current time.\n    const unsafeEndTime = Date.now() // ?\n\n    // 2. If fetchParamss requests destination is \"document\", then set fetchParamss controllers\n    //    full timing info to fetchParamss timing info.\n    if (fetchParams.request.destination === 'document') {\n      fetchParams.controller.fullTimingInfo = timingInfo\n    }\n\n    // 3. Set fetchParamss controllers report timing steps to the following steps given a global object global:\n    fetchParams.controller.reportTimingSteps = () => {\n      // 1. If fetchParamss requests URLs scheme is not an HTTP(S) scheme, then return.\n      if (!urlIsHttpHttpsScheme(fetchParams.request.url)) {\n        return\n      }\n\n      // 2. Set timingInfos end time to the relative high resolution time given unsafeEndTime and global.\n      timingInfo.endTime = unsafeEndTime\n\n      // 3. Let cacheState be responses cache state.\n      let cacheState = response.cacheState\n\n      // 4. Let bodyInfo be responses body info.\n      const bodyInfo = response.bodyInfo\n\n      // 5. If responses timing allow passed flag is not set, then set timingInfo to the result of creating an\n      //    opaque timing info for timingInfo and set cacheState to the empty string.\n      if (!response.timingAllowPassed) {\n        timingInfo = createOpaqueTimingInfo(timingInfo)\n\n        cacheState = ''\n      }\n\n      // 6. Let responseStatus be 0.\n      let responseStatus = 0\n\n      // 7. If fetchParamss requests mode is not \"navigate\" or responses has-cross-origin-redirects is false:\n      if (fetchParams.request.mode !== 'navigator' || !response.hasCrossOriginRedirects) {\n        // 1. Set responseStatus to responses status.\n        responseStatus = response.status\n\n        // 2. Let mimeType be the result of extracting a MIME type from responses header list.\n        const mimeType = extractMimeType(response.headersList)\n\n        // 3. If mimeType is not failure, then set bodyInfos content type to the result of minimizing a supported MIME type given mimeType.\n        if (mimeType !== 'failure') {\n          bodyInfo.contentType = minimizeSupportedMimeType(mimeType)\n        }\n      }\n\n      // 8. If fetchParamss requests initiator type is non-null, then mark resource timing given timingInfo,\n      //    fetchParamss requests URL, fetchParamss requests initiator type, global, cacheState, bodyInfo,\n      //    and responseStatus.\n      if (fetchParams.request.initiatorType != null) {\n        markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus)\n      }\n    }\n\n    // 4. Let processResponseEndOfBodyTask be the following steps:\n    const processResponseEndOfBodyTask = () => {\n      // 1. Set fetchParamss requests done flag.\n      fetchParams.request.done = true\n\n      // 2. If fetchParamss process response end-of-body is non-null, then run fetchParamss process\n      //    response end-of-body given response.\n      if (fetchParams.processResponseEndOfBody != null) {\n        queueMicrotask(() => fetchParams.processResponseEndOfBody(response))\n      }\n\n      // 3. If fetchParamss requests initiator type is non-null and fetchParamss requests clients\n      //    global object is fetchParamss task destination, then run fetchParamss controllers report\n      //    timing steps given fetchParamss requests clients global object.\n      if (fetchParams.request.initiatorType != null) {\n        fetchParams.controller.reportTimingSteps()\n      }\n    }\n\n    // 5. Queue a fetch task to run processResponseEndOfBodyTask with fetchParamss task destination\n    queueMicrotask(() => processResponseEndOfBodyTask())\n  }\n\n  // 4. If fetchParamss process response is non-null, then queue a fetch task to run fetchParamss\n  //    process response given response, with fetchParamss task destination.\n  if (fetchParams.processResponse != null) {\n    queueMicrotask(() => {\n      fetchParams.processResponse(response)\n      fetchParams.processResponse = null\n    })\n  }\n\n  // 5. Let internalResponse be response, if response is a network error; otherwise responses internal response.\n  const internalResponse = response.type === 'error' ? response : (response.internalResponse ?? response)\n\n  // 6. If internalResponses body is null, then run processResponseEndOfBody.\n  // 7. Otherwise:\n  if (internalResponse.body == null) {\n    processResponseEndOfBody()\n  } else {\n    // mcollina: all the following steps of the specs are skipped.\n    // The internal transform stream is not needed.\n    // See https://github.com/nodejs/undici/pull/3093#issuecomment-2050198541\n\n    // 1. Let transformStream be a new TransformStream.\n    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk, enqueues chunk in transformStream.\n    // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm and flushAlgorithm\n    //    set to processResponseEndOfBody.\n    // 4. Set internalResponses bodys stream to the result of internalResponses bodys stream piped through transformStream.\n\n    finished(internalResponse.body.stream, () => {\n      processResponseEndOfBody()\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch (fetchParams) {\n  // 1. Let request be fetchParamss request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let actualResponse be null.\n  let actualResponse = null\n\n  // 4. Let timingInfo be fetchParamss timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 5. If requests service-workers mode is \"all\", then:\n  if (request.serviceWorkers === 'all') {\n    // TODO\n  }\n\n  // 6. If response is null, then:\n  if (response === null) {\n    // 1. If makeCORSPreflight is true and one of these conditions is true:\n    // TODO\n\n    // 2. If requests redirect mode is \"follow\", then set requests\n    // service-workers mode to \"none\".\n    if (request.redirect === 'follow') {\n      request.serviceWorkers = 'none'\n    }\n\n    // 3. Set response and actualResponse to the result of running\n    // HTTP-network-or-cache fetch given fetchParams.\n    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams)\n\n    // 4. If requests response tainting is \"cors\" and a CORS check\n    // for request and response returns failure, then return a network error.\n    if (\n      request.responseTainting === 'cors' &&\n      corsCheck(request, response) === 'failure'\n    ) {\n      return makeNetworkError('cors failure')\n    }\n\n    // 5. If the TAO check for request and response returns failure, then set\n    // requests timing allow failed flag.\n    if (TAOCheck(request, response) === 'failure') {\n      request.timingAllowFailed = true\n    }\n  }\n\n  // 7. If either requests response tainting or responses type\n  // is \"opaque\", and the cross-origin resource policy check with\n  // requests origin, requests client, requests destination,\n  // and actualResponse returns blocked, then return a network error.\n  if (\n    (request.responseTainting === 'opaque' || response.type === 'opaque') &&\n    crossOriginResourcePolicyCheck(\n      request.origin,\n      request.client,\n      request.destination,\n      actualResponse\n    ) === 'blocked'\n  ) {\n    return makeNetworkError('blocked')\n  }\n\n  // 8. If actualResponses status is a redirect status, then:\n  if (redirectStatusSet.has(actualResponse.status)) {\n    // 1. If actualResponses status is not 303, requests body is not null,\n    // and the connection uses HTTP/2, then user agents may, and are even\n    // encouraged to, transmit an RST_STREAM frame.\n    // See, https://github.com/whatwg/fetch/issues/1288\n    if (request.redirect !== 'manual') {\n      fetchParams.controller.connection.destroy(undefined, false)\n    }\n\n    // 2. Switch on requests redirect mode:\n    if (request.redirect === 'error') {\n      // Set response to a network error.\n      response = makeNetworkError('unexpected redirect')\n    } else if (request.redirect === 'manual') {\n      // Set response to an opaque-redirect filtered response whose internal\n      // response is actualResponse.\n      // NOTE(spec): On the web this would return an `opaqueredirect` response,\n      // but that doesn't make sense server side.\n      // See https://github.com/nodejs/undici/issues/1193.\n      response = actualResponse\n    } else if (request.redirect === 'follow') {\n      // Set response to the result of running HTTP-redirect fetch given\n      // fetchParams and response.\n      response = await httpRedirectFetch(fetchParams, response)\n    } else {\n      assert(false)\n    }\n  }\n\n  // 9. Set responses timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 10. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nfunction httpRedirectFetch (fetchParams, response) {\n  // 1. Let request be fetchParamss request.\n  const request = fetchParams.request\n\n  // 2. Let actualResponse be response, if response is not a filtered response,\n  // and responses internal response otherwise.\n  const actualResponse = response.internalResponse\n    ? response.internalResponse\n    : response\n\n  // 3. Let locationURL be actualResponses location URL given requests current\n  // URLs fragment.\n  let locationURL\n\n  try {\n    locationURL = responseLocationURL(\n      actualResponse,\n      requestCurrentURL(request).hash\n    )\n\n    // 4. If locationURL is null, then return response.\n    if (locationURL == null) {\n      return response\n    }\n  } catch (err) {\n    // 5. If locationURL is failure, then return a network error.\n    return Promise.resolve(makeNetworkError(err))\n  }\n\n  // 6. If locationURLs scheme is not an HTTP(S) scheme, then return a network\n  // error.\n  if (!urlIsHttpHttpsScheme(locationURL)) {\n    return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'))\n  }\n\n  // 7. If requests redirect count is 20, then return a network error.\n  if (request.redirectCount === 20) {\n    return Promise.resolve(makeNetworkError('redirect count exceeded'))\n  }\n\n  // 8. Increase requests redirect count by 1.\n  request.redirectCount += 1\n\n  // 9. If requests mode is \"cors\", locationURL includes credentials, and\n  // requests origin is not same origin with locationURLs origin, then return\n  //  a network error.\n  if (\n    request.mode === 'cors' &&\n    (locationURL.username || locationURL.password) &&\n    !sameOrigin(request, locationURL)\n  ) {\n    return Promise.resolve(makeNetworkError('cross origin not allowed for request mode \"cors\"'))\n  }\n\n  // 10. If requests response tainting is \"cors\" and locationURL includes\n  // credentials, then return a network error.\n  if (\n    request.responseTainting === 'cors' &&\n    (locationURL.username || locationURL.password)\n  ) {\n    return Promise.resolve(makeNetworkError(\n      'URL cannot contain credentials for request mode \"cors\"'\n    ))\n  }\n\n  // 11. If actualResponses status is not 303, requests body is non-null,\n  // and requests bodys source is null, then return a network error.\n  if (\n    actualResponse.status !== 303 &&\n    request.body != null &&\n    request.body.source == null\n  ) {\n    return Promise.resolve(makeNetworkError())\n  }\n\n  // 12. If one of the following is true\n  // - actualResponses status is 301 or 302 and requests method is `POST`\n  // - actualResponses status is 303 and requests method is not `GET` or `HEAD`\n  if (\n    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||\n    (actualResponse.status === 303 &&\n      !GET_OR_HEAD.includes(request.method))\n  ) {\n    // then:\n    // 1. Set requests method to `GET` and requests body to null.\n    request.method = 'GET'\n    request.body = null\n\n    // 2. For each headerName of request-body-header name, delete headerName from\n    // requests header list.\n    for (const headerName of requestBodyHeader) {\n      request.headersList.delete(headerName)\n    }\n  }\n\n  // 13. If requests current URLs origin is not same origin with locationURLs\n  //     origin, then for each headerName of CORS non-wildcard request-header name,\n  //     delete headerName from requests header list.\n  if (!sameOrigin(requestCurrentURL(request), locationURL)) {\n    // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name\n    request.headersList.delete('authorization', true)\n\n    // https://fetch.spec.whatwg.org/#authentication-entries\n    request.headersList.delete('proxy-authorization', true)\n\n    // \"Cookie\" and \"Host\" are forbidden request-headers, which undici doesn't implement.\n    request.headersList.delete('cookie', true)\n    request.headersList.delete('host', true)\n  }\n\n  // 14. If requests body is non-null, then set requests body to the first return\n  // value of safely extracting requests bodys source.\n  if (request.body != null) {\n    assert(request.body.source != null)\n    request.body = safelyExtractBody(request.body.source)[0]\n  }\n\n  // 15. Let timingInfo be fetchParamss timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 16. Set timingInfos redirect end time and post-redirect start time to the\n  // coarsened shared current time given fetchParamss cross-origin isolated\n  // capability.\n  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =\n    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n\n  // 17. If timingInfos redirect start time is 0, then set timingInfos\n  //  redirect start time to timingInfos start time.\n  if (timingInfo.redirectStartTime === 0) {\n    timingInfo.redirectStartTime = timingInfo.startTime\n  }\n\n  // 18. Append locationURL to requests URL list.\n  request.urlList.push(locationURL)\n\n  // 19. Invoke set requests referrer policy on redirect on request and\n  // actualResponse.\n  setRequestReferrerPolicyOnRedirect(request, actualResponse)\n\n  // 20. Return the result of running main fetch given fetchParams and true.\n  return mainFetch(fetchParams, true)\n}\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch (\n  fetchParams,\n  isAuthenticationFetch = false,\n  isNewConnectionFetch = false\n) {\n  // 1. Let request be fetchParamss request.\n  const request = fetchParams.request\n\n  // 2. Let httpFetchParams be null.\n  let httpFetchParams = null\n\n  // 3. Let httpRequest be null.\n  let httpRequest = null\n\n  // 4. Let response be null.\n  let response = null\n\n  // 5. Let storedResponse be null.\n  // TODO: cache\n\n  // 6. Let httpCache be null.\n  const httpCache = null\n\n  // 7. Let the revalidatingFlag be unset.\n  const revalidatingFlag = false\n\n  // 8. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If requests window is \"no-window\" and requests redirect mode is\n  //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n  //    request.\n  if (request.window === 'no-window' && request.redirect === 'error') {\n    httpFetchParams = fetchParams\n    httpRequest = request\n  } else {\n    // Otherwise:\n\n    // 1. Set httpRequest to a clone of request.\n    httpRequest = cloneRequest(request)\n\n    // 2. Set httpFetchParams to a copy of fetchParams.\n    httpFetchParams = { ...fetchParams }\n\n    // 3. Set httpFetchParamss request to httpRequest.\n    httpFetchParams.request = httpRequest\n  }\n\n  //    3. Let includeCredentials be true if one of\n  const includeCredentials =\n    request.credentials === 'include' ||\n    (request.credentials === 'same-origin' &&\n      request.responseTainting === 'basic')\n\n  //    4. Let contentLength be httpRequests bodys length, if httpRequests\n  //    body is non-null; otherwise null.\n  const contentLength = httpRequest.body ? httpRequest.body.length : null\n\n  //    5. Let contentLengthHeaderValue be null.\n  let contentLengthHeaderValue = null\n\n  //    6. If httpRequests body is null and httpRequests method is `POST` or\n  //    `PUT`, then set contentLengthHeaderValue to `0`.\n  if (\n    httpRequest.body == null &&\n    ['POST', 'PUT'].includes(httpRequest.method)\n  ) {\n    contentLengthHeaderValue = '0'\n  }\n\n  //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n  //    contentLength, serialized and isomorphic encoded.\n  if (contentLength != null) {\n    contentLengthHeaderValue = isomorphicEncode(`${contentLength}`)\n  }\n\n  //    8. If contentLengthHeaderValue is non-null, then append\n  //    `Content-Length`/contentLengthHeaderValue to httpRequests header\n  //    list.\n  if (contentLengthHeaderValue != null) {\n    httpRequest.headersList.append('content-length', contentLengthHeaderValue, true)\n  }\n\n  //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n  //    contentLengthHeaderValue) to httpRequests header list.\n\n  //    10. If contentLength is non-null and httpRequests keepalive is true,\n  //    then:\n  if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n  }\n\n  //    11. If httpRequests referrer is a URL, then append\n  //    `Referer`/httpRequests referrer, serialized and isomorphic encoded,\n  //     to httpRequests header list.\n  if (webidl.is.URL(httpRequest.referrer)) {\n    httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href), true)\n  }\n\n  //    12. Append a request `Origin` header for httpRequest.\n  appendRequestOriginHeader(httpRequest)\n\n  //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n  appendFetchMetadata(httpRequest)\n\n  //    14. If httpRequests header list does not contain `User-Agent`, then\n  //    user agents should append `User-Agent`/default `User-Agent` value to\n  //    httpRequests header list.\n  if (!httpRequest.headersList.contains('user-agent', true)) {\n    httpRequest.headersList.append('user-agent', defaultUserAgent, true)\n  }\n\n  //    15. If httpRequests cache mode is \"default\" and httpRequests header\n  //    list contains `If-Modified-Since`, `If-None-Match`,\n  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n  //    httpRequests cache mode to \"no-store\".\n  if (\n    httpRequest.cache === 'default' &&\n    (httpRequest.headersList.contains('if-modified-since', true) ||\n      httpRequest.headersList.contains('if-none-match', true) ||\n      httpRequest.headersList.contains('if-unmodified-since', true) ||\n      httpRequest.headersList.contains('if-match', true) ||\n      httpRequest.headersList.contains('if-range', true))\n  ) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    16. If httpRequests cache mode is \"no-cache\", httpRequests prevent\n  //    no-cache cache-control header modification flag is unset, and\n  //    httpRequests header list does not contain `Cache-Control`, then append\n  //    `Cache-Control`/`max-age=0` to httpRequests header list.\n  if (\n    httpRequest.cache === 'no-cache' &&\n    !httpRequest.preventNoCacheCacheControlHeaderModification &&\n    !httpRequest.headersList.contains('cache-control', true)\n  ) {\n    httpRequest.headersList.append('cache-control', 'max-age=0', true)\n  }\n\n  //    17. If httpRequests cache mode is \"no-store\" or \"reload\", then:\n  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n    // 1. If httpRequests header list does not contain `Pragma`, then append\n    // `Pragma`/`no-cache` to httpRequests header list.\n    if (!httpRequest.headersList.contains('pragma', true)) {\n      httpRequest.headersList.append('pragma', 'no-cache', true)\n    }\n\n    // 2. If httpRequests header list does not contain `Cache-Control`,\n    // then append `Cache-Control`/`no-cache` to httpRequests header list.\n    if (!httpRequest.headersList.contains('cache-control', true)) {\n      httpRequest.headersList.append('cache-control', 'no-cache', true)\n    }\n  }\n\n  //    18. If httpRequests header list contains `Range`, then append\n  //    `Accept-Encoding`/`identity` to httpRequests header list.\n  if (httpRequest.headersList.contains('range', true)) {\n    httpRequest.headersList.append('accept-encoding', 'identity', true)\n  }\n\n  //    19. Modify httpRequests header list per HTTP. Do not append a given\n  //    header if httpRequests header list contains that headers name.\n  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n  if (!httpRequest.headersList.contains('accept-encoding', true)) {\n    if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {\n      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate', true)\n    } else {\n      httpRequest.headersList.append('accept-encoding', 'gzip, deflate', true)\n    }\n  }\n\n  httpRequest.headersList.delete('host', true)\n\n  //    20. If includeCredentials is true, then:\n  if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequests header list does not contain `Authorization`, then:\n    // TODO: credentials\n  }\n\n  //    21. If theres a proxy-authentication entry, use it as appropriate.\n  //    TODO: proxy-authentication\n\n  //    22. Set httpCache to the result of determining the HTTP cache\n  //    partition, given httpRequest.\n  //    TODO: cache\n\n  //    23. If httpCache is null, then set httpRequests cache mode to\n  //    \"no-store\".\n  if (httpCache == null) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    24. If httpRequests cache mode is neither \"no-store\" nor \"reload\",\n  //    then:\n  if (httpRequest.cache !== 'no-store' && httpRequest.cache !== 'reload') {\n    // TODO: cache\n  }\n\n  // 9. If aborted, then return the appropriate network error for fetchParams.\n  // TODO\n\n  // 10. If response is null, then:\n  if (response == null) {\n    // 1. If httpRequests cache mode is \"only-if-cached\", then return a\n    // network error.\n    if (httpRequest.cache === 'only-if-cached') {\n      return makeNetworkError('only if cached')\n    }\n\n    // 2. Let forwardResponse be the result of running HTTP-network fetch\n    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n    const forwardResponse = await httpNetworkFetch(\n      httpFetchParams,\n      includeCredentials,\n      isNewConnectionFetch\n    )\n\n    // 3. If httpRequests method is unsafe and forwardResponses status is\n    // in the range 200 to 399, inclusive, invalidate appropriate stored\n    // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n    // Caching, and set storedResponse to null. [HTTP-CACHING]\n    if (\n      !safeMethodsSet.has(httpRequest.method) &&\n      forwardResponse.status >= 200 &&\n      forwardResponse.status <= 399\n    ) {\n      // TODO: cache\n    }\n\n    // 4. If the revalidatingFlag is set and forwardResponses status is 304,\n    // then:\n    if (revalidatingFlag && forwardResponse.status === 304) {\n      // TODO: cache\n    }\n\n    // 5. If response is null, then:\n    if (response == null) {\n      // 1. Set response to forwardResponse.\n      response = forwardResponse\n\n      // 2. Store httpRequest and forwardResponse in httpCache, as per the\n      // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n      // TODO: cache\n    }\n  }\n\n  // 11. Set responses URL list to a clone of httpRequests URL list.\n  response.urlList = [...httpRequest.urlList]\n\n  // 12. If httpRequests header list contains `Range`, then set responses\n  // range-requested flag.\n  if (httpRequest.headersList.contains('range', true)) {\n    response.rangeRequested = true\n  }\n\n  // 13. Set responses request-includes-credentials to includeCredentials.\n  response.requestIncludesCredentials = includeCredentials\n\n  // 14. If responses status is 401, httpRequests response tainting is not\n  // \"cors\", includeCredentials is true, and requests window is an environment\n  // settings object, then:\n  // TODO\n\n  // 15. If responses status is 407, then:\n  if (response.status === 407) {\n    // 1. If requests window is \"no-window\", then return a network error.\n    if (request.window === 'no-window') {\n      return makeNetworkError()\n    }\n\n    // 2. ???\n\n    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 4. Prompt the end user as appropriate in requests window and store\n    // the result as a proxy-authentication entry. [HTTP-AUTH]\n    // TODO: Invoke some kind of callback?\n\n    // 5. Set response to the result of running HTTP-network-or-cache fetch given\n    // fetchParams.\n    // TODO\n    return makeNetworkError('proxy authentication required')\n  }\n\n  // 16. If all of the following are true\n  if (\n    // responses status is 421\n    response.status === 421 &&\n    // isNewConnectionFetch is false\n    !isNewConnectionFetch &&\n    // requests body is null, or requests body is non-null and requests bodys source is non-null\n    (request.body == null || request.body.source != null)\n  ) {\n    // then:\n\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 2. Set response to the result of running HTTP-network-or-cache\n    // fetch given fetchParams, isAuthenticationFetch, and true.\n\n    // TODO (spec): The spec doesn't specify this but we need to cancel\n    // the active response before we can start a new one.\n    // https://github.com/whatwg/fetch/issues/1293\n    fetchParams.controller.connection.destroy()\n\n    response = await httpNetworkOrCacheFetch(\n      fetchParams,\n      isAuthenticationFetch,\n      true\n    )\n  }\n\n  // 17. If isAuthenticationFetch is true, then create an authentication entry\n  if (isAuthenticationFetch) {\n    // TODO\n  }\n\n  // 18. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function httpNetworkFetch (\n  fetchParams,\n  includeCredentials = false,\n  forceNewConnection = false\n) {\n  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed)\n\n  fetchParams.controller.connection = {\n    abort: null,\n    destroyed: false,\n    destroy (err, abort = true) {\n      if (!this.destroyed) {\n        this.destroyed = true\n        if (abort) {\n          this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'))\n        }\n      }\n    }\n  }\n\n  // 1. Let request be fetchParamss request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let timingInfo be fetchParamss timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 4. Let httpCache be the result of determining the HTTP cache partition,\n  // given request.\n  // TODO: cache\n  const httpCache = null\n\n  // 5. If httpCache is null, then set requests cache mode to \"no-store\".\n  if (httpCache == null) {\n    request.cache = 'no-store'\n  }\n\n  // 6. Let networkPartitionKey be the result of determining the network\n  // partition key given request.\n  // TODO\n\n  // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n  // \"no\".\n  const newConnection = forceNewConnection ? 'yes' : 'no' // eslint-disable-line no-unused-vars\n\n  // 8. Switch on requests mode:\n  if (request.mode === 'websocket') {\n    // Let connection be the result of obtaining a WebSocket connection,\n    // given requests current URL.\n    // TODO\n  } else {\n    // Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, requests current URLs origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n  }\n\n  // 9. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If connection is failure, then return a network error.\n\n  //    2. Set timingInfos final connection timing info to the result of\n  //    calling clamp and coarsen connection timing info with connections\n  //    timing info, timingInfos post-redirect start time, and fetchParamss\n  //    cross-origin isolated capability.\n\n  //    3. If connection is not an HTTP/2 connection, requests body is non-null,\n  //    and requests bodys source is null, then append (`Transfer-Encoding`,\n  //    `chunked`) to requests header list.\n\n  //    4. Set timingInfos final network-request start time to the coarsened\n  //    shared current time given fetchParamss cross-origin isolated\n  //    capability.\n\n  //    5. Set response to the result of making an HTTP request over connection\n  //    using request with the following caveats:\n\n  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n\n  //        - If requests body is non-null, and requests bodys source is null,\n  //        then the user agent may have a buffer of up to 64 kibibytes and store\n  //        a part of requests body in that buffer. If the user agent reads from\n  //        requests body beyond that buffers size and the user agent needs to\n  //        resend request, then instead return a network error.\n\n  //        - Set timingInfos final network-response start time to the coarsened\n  //        shared current time given fetchParamss cross-origin isolated capability,\n  //        immediately after the user agents HTTP parser receives the first byte\n  //        of the response (e.g., frame header bytes for HTTP/2 or response status\n  //        line for HTTP/1.x).\n\n  //        - Wait until all the headers are transmitted.\n\n  //        - Any responses whose status is in the range 100 to 199, inclusive,\n  //        and is not 101, are to be ignored, except for the purposes of setting\n  //        timingInfos final network-response start time above.\n\n  //    - If requests header list contains `Transfer-Encoding`/`chunked` and\n  //    response is transferred via HTTP/1.0 or older, then return a network\n  //    error.\n\n  //    - If the HTTP request results in a TLS client certificate dialog, then:\n\n  //        1. If requests window is an environment settings object, make the\n  //        dialog available in requests window.\n\n  //        2. Otherwise, return a network error.\n\n  // To transmit requests body body, run these steps:\n  let requestBody = null\n  // 1. If body is null and fetchParamss process request end-of-body is\n  // non-null, then queue a fetch task given fetchParamss process request\n  // end-of-body and fetchParamss task destination.\n  if (request.body == null && fetchParams.processRequestEndOfBody) {\n    queueMicrotask(() => fetchParams.processRequestEndOfBody())\n  } else if (request.body != null) {\n    // 2. Otherwise, if body is non-null:\n\n    //    1. Let processBodyChunk given bytes be these steps:\n    const processBodyChunk = async function * (bytes) {\n      // 1. If the ongoing fetch is terminated, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. Run this step in parallel: transmit bytes.\n      yield bytes\n\n      // 3. If fetchParamss process request body is non-null, then run\n      // fetchParamss process request body given bytess length.\n      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength)\n    }\n\n    // 2. Let processEndOfBody be these steps:\n    const processEndOfBody = () => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If fetchParamss process request end-of-body is non-null,\n      // then run fetchParamss process request end-of-body.\n      if (fetchParams.processRequestEndOfBody) {\n        fetchParams.processRequestEndOfBody()\n      }\n    }\n\n    // 3. Let processBodyError given e be these steps:\n    const processBodyError = (e) => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If e is an \"AbortError\" DOMException, then abort fetchParamss controller.\n      if (e.name === 'AbortError') {\n        fetchParams.controller.abort()\n      } else {\n        fetchParams.controller.terminate(e)\n      }\n    }\n\n    // 4. Incrementally read requests body given processBodyChunk, processEndOfBody,\n    // processBodyError, and fetchParamss task destination.\n    requestBody = (async function * () {\n      try {\n        for await (const bytes of request.body.stream) {\n          yield * processBodyChunk(bytes)\n        }\n        processEndOfBody()\n      } catch (err) {\n        processBodyError(err)\n      }\n    })()\n  }\n\n  try {\n    // socket is only provided for websockets\n    const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody })\n\n    if (socket) {\n      response = makeResponse({ status, statusText, headersList, socket })\n    } else {\n      const iterator = body[Symbol.asyncIterator]()\n      fetchParams.controller.next = () => iterator.next()\n\n      response = makeResponse({ status, statusText, headersList })\n    }\n  } catch (err) {\n    // 10. If aborted, then:\n    if (err.name === 'AbortError') {\n      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      fetchParams.controller.connection.destroy()\n\n      // 2. Return the appropriate network error for fetchParams.\n      return makeAppropriateNetworkError(fetchParams, err)\n    }\n\n    return makeNetworkError(err)\n  }\n\n  // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n  // if it is suspended.\n  const pullAlgorithm = () => {\n    return fetchParams.controller.resume()\n  }\n\n  // 12. Let cancelAlgorithm be an algorithm that aborts fetchParamss\n  // controller with reason, given reason.\n  const cancelAlgorithm = (reason) => {\n    // If the aborted fetch was already terminated, then we do not\n    // need to do anything.\n    if (!isCancelled(fetchParams)) {\n      fetchParams.controller.abort(reason)\n    }\n  }\n\n  // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n  // the user agent.\n  // TODO\n\n  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n  // TODO\n\n  // 15. Let stream be a new ReadableStream.\n  // 16. Set up stream with byte reading support with pullAlgorithm set to pullAlgorithm,\n  //     cancelAlgorithm set to cancelAlgorithm.\n  const stream = new ReadableStream(\n    {\n      async start (controller) {\n        fetchParams.controller.controller = controller\n      },\n      async pull (controller) {\n        await pullAlgorithm(controller)\n      },\n      async cancel (reason) {\n        await cancelAlgorithm(reason)\n      },\n      type: 'bytes'\n    }\n  )\n\n  // 17. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. Set responses body to a new body whose stream is stream.\n  response.body = { stream, source: null, length: null }\n\n  //    2. If response is not a network error and requests cache mode is\n  //    not \"no-store\", then update response in httpCache for request.\n  //    TODO\n\n  //    3. If includeCredentials is true and the user agent is not configured\n  //    to block cookies for request (see section 7 of [COOKIES]), then run the\n  //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n  //    the value of each header whose name is a byte-case-insensitive match for\n  //    `Set-Cookie` in responses header list, if any, and requests current URL.\n  //    TODO\n\n  // 18. If aborted, then:\n  // TODO\n\n  // 19. Run these steps in parallel:\n\n  //    1. Run these steps, but abort when fetchParams is canceled:\n  if (!fetchParams.controller.resume) {\n    fetchParams.controller.on('terminated', onAborted)\n  }\n\n  fetchParams.controller.resume = async () => {\n    // 1. While true\n    while (true) {\n      // 1-3. See onData...\n\n      // 4. Set bytes to the result of handling content codings given\n      // codings and bytes.\n      let bytes\n      let isFailure\n      try {\n        const { done, value } = await fetchParams.controller.next()\n\n        if (isAborted(fetchParams)) {\n          break\n        }\n\n        bytes = done ? undefined : value\n      } catch (err) {\n        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n          // zlib doesn't like empty streams.\n          bytes = undefined\n        } else {\n          bytes = err\n\n          // err may be propagated from the result of calling readablestream.cancel,\n          // which might not be an error. https://github.com/nodejs/undici/issues/2009\n          isFailure = true\n        }\n      }\n\n      if (bytes === undefined) {\n        // 2. Otherwise, if the bytes transmission for responses message\n        // body is done normally and stream is readable, then close\n        // stream, finalize response for fetchParams and response, and\n        // abort these in-parallel steps.\n        readableStreamClose(fetchParams.controller.controller)\n\n        finalizeResponse(fetchParams, response)\n\n        return\n      }\n\n      // 5. Increase timingInfos decoded body size by bytess length.\n      timingInfo.decodedBodySize += bytes?.byteLength ?? 0\n\n      // 6. If bytes is failure, then terminate fetchParamss controller.\n      if (isFailure) {\n        fetchParams.controller.terminate(bytes)\n        return\n      }\n\n      // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n      // into stream.\n      const buffer = new Uint8Array(bytes)\n      if (buffer.byteLength) {\n        fetchParams.controller.controller.enqueue(buffer)\n      }\n\n      // 8. If stream is errored, then terminate the ongoing fetch.\n      if (isErrored(stream)) {\n        fetchParams.controller.terminate()\n        return\n      }\n\n      // 9. If stream doesnt need more data ask the user agent to suspend\n      // the ongoing fetch.\n      if (fetchParams.controller.controller.desiredSize <= 0) {\n        return\n      }\n    }\n  }\n\n  //    2. If aborted, then:\n  function onAborted (reason) {\n    // 2. If fetchParams is aborted, then:\n    if (isAborted(fetchParams)) {\n      // 1. Set responses aborted flag.\n      response.aborted = true\n\n      // 2. If stream is readable, then error stream with the result of\n      //    deserialize a serialized abort reason given fetchParamss\n      //    controllers serialized abort reason and an\n      //    implementation-defined realm.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(\n          fetchParams.controller.serializedAbortReason\n        )\n      }\n    } else {\n      // 3. Otherwise, if stream is readable, error stream with a TypeError.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(new TypeError('terminated', {\n          cause: isErrorLike(reason) ? reason : undefined\n        }))\n      }\n    }\n\n    // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n    fetchParams.controller.connection.destroy()\n  }\n\n  // 20. Return response.\n  return response\n\n  function dispatch ({ body }) {\n    const url = requestCurrentURL(request)\n    /** @type {import('../..').Agent} */\n    const agent = fetchParams.controller.dispatcher\n\n    return new Promise((resolve, reject) => agent.dispatch(\n      {\n        path: url.pathname + url.search,\n        origin: url.origin,\n        method: request.method,\n        body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,\n        headers: request.headersList.entries,\n        maxRedirections: 0,\n        upgrade: request.mode === 'websocket' ? 'websocket' : undefined\n      },\n      {\n        body: null,\n        abort: null,\n\n        onConnect (abort) {\n          // TODO (fix): Do we need connection here?\n          const { connection } = fetchParams.controller\n\n          // Set timingInfos final connection timing info to the result of calling clamp and coarsen\n          // connection timing info with connections timing info, timingInfos post-redirect start\n          // time, and fetchParamss cross-origin isolated capability.\n          // TODO: implement connection timing\n          timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(undefined, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability)\n\n          if (connection.destroyed) {\n            abort(new DOMException('The operation was aborted.', 'AbortError'))\n          } else {\n            fetchParams.controller.on('terminated', abort)\n            this.abort = connection.abort = abort\n          }\n\n          // Set timingInfos final network-request start time to the coarsened shared current time given\n          // fetchParamss cross-origin isolated capability.\n          timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n        },\n\n        onResponseStarted () {\n          // Set timingInfos final network-response start time to the coarsened shared current\n          // time given fetchParamss cross-origin isolated capability, immediately after the\n          // user agents HTTP parser receives the first byte of the response (e.g., frame header\n          // bytes for HTTP/2 or response status line for HTTP/1.x).\n          timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n        },\n\n        onHeaders (status, rawHeaders, resume, statusText) {\n          if (status < 200) {\n            return\n          }\n\n          /** @type {string[]} */\n          let codings = []\n          let location = ''\n\n          const headersList = new HeadersList()\n\n          for (let i = 0; i < rawHeaders.length; i += 2) {\n            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true)\n          }\n          const contentEncoding = headersList.get('content-encoding', true)\n          if (contentEncoding) {\n            // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n            // \"All content-coding values are case-insensitive...\"\n            codings = contentEncoding.toLowerCase().split(',').map((x) => x.trim())\n          }\n          location = headersList.get('location', true)\n\n          this.body = new Readable({ read: resume })\n\n          const decoders = []\n\n          const willFollow = location && request.redirect === 'follow' &&\n            redirectStatusSet.has(status)\n\n          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n          if (codings.length !== 0 && request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {\n            for (let i = codings.length - 1; i >= 0; --i) {\n              const coding = codings[i]\n              // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2\n              if (coding === 'x-gzip' || coding === 'gzip') {\n                decoders.push(zlib.createGunzip({\n                  // Be less strict when decoding compressed responses, since sometimes\n                  // servers send slightly invalid responses that are still accepted\n                  // by common browsers.\n                  // Always using Z_SYNC_FLUSH is what cURL does.\n                  flush: zlib.constants.Z_SYNC_FLUSH,\n                  finishFlush: zlib.constants.Z_SYNC_FLUSH\n                }))\n              } else if (coding === 'deflate') {\n                decoders.push(createInflate({\n                  flush: zlib.constants.Z_SYNC_FLUSH,\n                  finishFlush: zlib.constants.Z_SYNC_FLUSH\n                }))\n              } else if (coding === 'br') {\n                decoders.push(zlib.createBrotliDecompress({\n                  flush: zlib.constants.BROTLI_OPERATION_FLUSH,\n                  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH\n                }))\n              } else if (coding === 'zstd' && typeof zlib.createZstdDecompress === 'function') {\n                // Node.js v23.8.0+ and v22.15.0+ supports Zstandard\n                decoders.push(zlib.createZstdDecompress({\n                  flush: zlib.constants.ZSTD_e_continue,\n                  finishFlush: zlib.constants.ZSTD_e_end\n                }))\n              } else {\n                decoders.length = 0\n                break\n              }\n            }\n          }\n\n          const onError = this.onError.bind(this)\n\n          resolve({\n            status,\n            statusText,\n            headersList,\n            body: decoders.length\n              ? pipeline(this.body, ...decoders, (err) => {\n                if (err) {\n                  this.onError(err)\n                }\n              }).on('error', onError)\n              : this.body.on('error', onError)\n          })\n\n          return true\n        },\n\n        onData (chunk) {\n          if (fetchParams.controller.dump) {\n            return\n          }\n\n          // 1. If one or more bytes have been transmitted from responses\n          // message body, then:\n\n          //  1. Let bytes be the transmitted bytes.\n          const bytes = chunk\n\n          //  2. Let codings be the result of extracting header list values\n          //  given `Content-Encoding` and responses header list.\n          //  See pullAlgorithm.\n\n          //  3. Increase timingInfos encoded body size by bytess length.\n          timingInfo.encodedBodySize += bytes.byteLength\n\n          //  4. See pullAlgorithm...\n\n          return this.body.push(bytes)\n        },\n\n        onComplete () {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          fetchParams.controller.ended = true\n\n          this.body.push(null)\n        },\n\n        onError (error) {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          this.body?.destroy(error)\n\n          fetchParams.controller.terminate(error)\n\n          reject(error)\n        },\n\n        onUpgrade (status, rawHeaders, socket) {\n          if (status !== 101) {\n            return\n          }\n\n          const headersList = new HeadersList()\n\n          for (let i = 0; i < rawHeaders.length; i += 2) {\n            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true)\n          }\n\n          resolve({\n            status,\n            statusText: STATUS_CODES[status],\n            headersList,\n            socket\n          })\n\n          return true\n        }\n      }\n    ))\n  }\n}\n\nmodule.exports = {\n  fetch,\n  Fetch,\n  fetching,\n  finalizeAndReportTiming\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUN4QixRQUFRLGNBQWMsRUFBRSxtQkFBTyxDQUFDLHVFQUFXO0FBQzNDLFFBQVEsK0RBQStELEVBQUUsbUJBQU8sQ0FBQyx1RUFBVztBQUM1RixhQUFhLG1CQUFPLENBQUMsNEJBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDcEIsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsaUNBQWlDLEVBQUUsbUJBQU8sQ0FBQyxpRUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywyRUFBYTtBQUN6QixXQUFXLG1CQUFPLENBQUMsZ0NBQWE7QUFDaEMsUUFBUSxzREFBc0QsRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3JGLFFBQVEsaURBQWlELEVBQUUsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDcEYsUUFBUSxrRUFBa0UsRUFBRSxtQkFBTyxDQUFDLHlFQUFZO0FBQ2hHLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQywrREFBYztBQUN0RCxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNFQUFXO0FBQ3RDLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUNBQW1DO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHVCQUF1QjtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsVUFBVTtBQUNsRTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxVQUFVOztBQUVwQixVQUFVLG1CQUFtQjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3RUFBdUM7QUFDbEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQsV0FBVzs7QUFFbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHVEQUF1RDs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsZ0JBQWdCOztBQUUzRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUNBQXVDO0FBQ3BFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsMEVBQTBFO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtFQUFrRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGdE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QUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9FdGhhbi1BcnJvd29vZC91bmRpY2ktZmV0Y2hcblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgbWFrZU5ldHdvcmtFcnJvcixcbiAgbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yLFxuICBmaWx0ZXJSZXNwb25zZSxcbiAgbWFrZVJlc3BvbnNlLFxuICBmcm9tSW5uZXJSZXNwb25zZSxcbiAgZ2V0UmVzcG9uc2VTdGF0ZVxufSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKVxuY29uc3QgeyBIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi9oZWFkZXJzJylcbmNvbnN0IHsgUmVxdWVzdCwgY2xvbmVSZXF1ZXN0LCBnZXRSZXF1ZXN0RGlzcGF0Y2hlciwgZ2V0UmVxdWVzdFN0YXRlIH0gPSByZXF1aXJlKCcuL3JlcXVlc3QnKVxuY29uc3QgemxpYiA9IHJlcXVpcmUoJ25vZGU6emxpYicpXG5jb25zdCB7XG4gIGJ5dGVzTWF0Y2gsXG4gIG1ha2VQb2xpY3lDb250YWluZXIsXG4gIGNsb25lUG9saWN5Q29udGFpbmVyLFxuICByZXF1ZXN0QmFkUG9ydCxcbiAgVEFPQ2hlY2ssXG4gIGFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIsXG4gIHJlc3BvbnNlTG9jYXRpb25VUkwsXG4gIHJlcXVlc3RDdXJyZW50VVJMLFxuICBzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0LFxuICB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwsXG4gIGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8sXG4gIGFwcGVuZEZldGNoTWV0YWRhdGEsXG4gIGNvcnNDaGVjayxcbiAgY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrLFxuICBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyLFxuICBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSxcbiAgY3JlYXRlRGVmZXJyZWRQcm9taXNlLFxuICBzYW1lT3JpZ2luLFxuICBpc0NhbmNlbGxlZCxcbiAgaXNBYm9ydGVkLFxuICBpc0Vycm9yTGlrZSxcbiAgZnVsbHlSZWFkQm9keSxcbiAgcmVhZGFibGVTdHJlYW1DbG9zZSxcbiAgaXNvbW9ycGhpY0VuY29kZSxcbiAgdXJsSXNMb2NhbCxcbiAgdXJsSXNIdHRwSHR0cHNTY2hlbWUsXG4gIHVybEhhc0h0dHBzU2NoZW1lLFxuICBjbGFtcEFuZENvYXJzZW5Db25uZWN0aW9uVGltaW5nSW5mbyxcbiAgc2ltcGxlUmFuZ2VIZWFkZXJWYWx1ZSxcbiAgYnVpbGRDb250ZW50UmFuZ2UsXG4gIGNyZWF0ZUluZmxhdGUsXG4gIGV4dHJhY3RNaW1lVHlwZVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IHNhZmVseUV4dHJhY3RCb2R5LCBleHRyYWN0Qm9keSB9ID0gcmVxdWlyZSgnLi9ib2R5JylcbmNvbnN0IHtcbiAgcmVkaXJlY3RTdGF0dXNTZXQsXG4gIG51bGxCb2R5U3RhdHVzLFxuICBzYWZlTWV0aG9kc1NldCxcbiAgcmVxdWVzdEJvZHlIZWFkZXIsXG4gIHN1YnJlc291cmNlU2V0XG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgRUUgPSByZXF1aXJlKCdub2RlOmV2ZW50cycpXG5jb25zdCB7IFJlYWRhYmxlLCBwaXBlbGluZSwgZmluaXNoZWQsIGlzRXJyb3JlZCwgaXNSZWFkYWJsZSB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgeyBhZGRBYm9ydExpc3RlbmVyLCBidWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lIH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBkYXRhVVJMUHJvY2Vzc29yLCBzZXJpYWxpemVBTWltZVR5cGUsIG1pbmltaXplU3VwcG9ydGVkTWltZVR5cGUgfSA9IHJlcXVpcmUoJy4vZGF0YS11cmwnKVxuY29uc3QgeyBnZXRHbG9iYWxEaXNwYXRjaGVyIH0gPSByZXF1aXJlKCcuLi8uLi9nbG9iYWwnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL3dlYmlkbCcpXG5jb25zdCB7IFNUQVRVU19DT0RFUyB9ID0gcmVxdWlyZSgnbm9kZTpodHRwJylcbmNvbnN0IEdFVF9PUl9IRUFEID0gWydHRVQnLCAnSEVBRCddXG5cbmNvbnN0IGRlZmF1bHRVc2VyQWdlbnQgPSB0eXBlb2YgX19VTkRJQ0lfSVNfTk9ERV9fICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZXNidWlsZERldGVjdGlvbiAhPT0gJ3VuZGVmaW5lZCdcbiAgPyAnbm9kZSdcbiAgOiAndW5kaWNpJ1xuXG4vKiogQHR5cGUge2ltcG9ydCgnYnVmZmVyJykucmVzb2x2ZU9iamVjdFVSTH0gKi9cbmxldCByZXNvbHZlT2JqZWN0VVJMXG5cbmNsYXNzIEZldGNoIGV4dGVuZHMgRUUge1xuICBjb25zdHJ1Y3RvciAoZGlzcGF0Y2hlcikge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXJcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsXG4gICAgdGhpcy5kdW1wID0gZmFsc2VcbiAgICB0aGlzLnN0YXRlID0gJ29uZ29pbmcnXG4gIH1cblxuICB0ZXJtaW5hdGUgKHJlYXNvbikge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSAnb25nb2luZycpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSAndGVybWluYXRlZCdcbiAgICB0aGlzLmNvbm5lY3Rpb24/LmRlc3Ryb3kocmVhc29uKVxuICAgIHRoaXMuZW1pdCgndGVybWluYXRlZCcsIHJlYXNvbilcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmZXRjaC1jb250cm9sbGVyLWFib3J0XG4gIGFib3J0IChlcnJvcikge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSAnb25nb2luZycpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDEuIFNldCBjb250cm9sbGVy4oCZcyBzdGF0ZSB0byBcImFib3J0ZWRcIi5cbiAgICB0aGlzLnN0YXRlID0gJ2Fib3J0ZWQnXG5cbiAgICAvLyAyLiBMZXQgZmFsbGJhY2tFcnJvciBiZSBhbiBcIkFib3J0RXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgLy8gMy4gU2V0IGVycm9yIHRvIGZhbGxiYWNrRXJyb3IgaWYgaXQgaXMgbm90IGdpdmVuLlxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIGVycm9yID0gbmV3IERPTUV4Y2VwdGlvbignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nLCAnQWJvcnRFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gNC4gTGV0IHNlcmlhbGl6ZWRFcnJvciBiZSBTdHJ1Y3R1cmVkU2VyaWFsaXplKGVycm9yKS5cbiAgICAvLyAgICBJZiB0aGF0IHRocmV3IGFuIGV4Y2VwdGlvbiwgY2F0Y2ggaXQsIGFuZCBsZXRcbiAgICAvLyAgICBzZXJpYWxpemVkRXJyb3IgYmUgU3RydWN0dXJlZFNlcmlhbGl6ZShmYWxsYmFja0Vycm9yKS5cblxuICAgIC8vIDUuIFNldCBjb250cm9sbGVy4oCZcyBzZXJpYWxpemVkIGFib3J0IHJlYXNvbiB0byBzZXJpYWxpemVkRXJyb3IuXG4gICAgdGhpcy5zZXJpYWxpemVkQWJvcnRSZWFzb24gPSBlcnJvclxuXG4gICAgdGhpcy5jb25uZWN0aW9uPy5kZXN0cm95KGVycm9yKVxuICAgIHRoaXMuZW1pdCgndGVybWluYXRlZCcsIGVycm9yKVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZldGNoRG9uZSAocmVzcG9uc2UpIHtcbiAgZmluYWxpemVBbmRSZXBvcnRUaW1pbmcocmVzcG9uc2UsICdmZXRjaCcpXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmZXRjaC1tZXRob2RcbmZ1bmN0aW9uIGZldGNoIChpbnB1dCwgaW5pdCA9IHVuZGVmaW5lZCkge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdnbG9iYWxUaGlzLmZldGNoJylcblxuICAvLyAxLiBMZXQgcCBiZSBhIG5ldyBwcm9taXNlLlxuICBsZXQgcCA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgLy8gMi4gTGV0IHJlcXVlc3RPYmplY3QgYmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgaW5pdGlhbCB2YWx1ZSBvZlxuICAvLyBSZXF1ZXN0IGFzIGNvbnN0cnVjdG9yIHdpdGggaW5wdXQgYW5kIGluaXQgYXMgYXJndW1lbnRzLiBJZiB0aGlzIHRocm93c1xuICAvLyBhbiBleGNlcHRpb24sIHJlamVjdCBwIHdpdGggaXQgYW5kIHJldHVybiBwLlxuICBsZXQgcmVxdWVzdE9iamVjdFxuXG4gIHRyeSB7XG4gICAgcmVxdWVzdE9iamVjdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICB9IGNhdGNoIChlKSB7XG4gICAgcC5yZWplY3QoZSlcbiAgICByZXR1cm4gcC5wcm9taXNlXG4gIH1cblxuICAvLyAzLiBMZXQgcmVxdWVzdCBiZSByZXF1ZXN0T2JqZWN04oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gZ2V0UmVxdWVzdFN0YXRlKHJlcXVlc3RPYmplY3QpXG5cbiAgLy8gNC4gSWYgcmVxdWVzdE9iamVjdOKAmXMgc2lnbmFs4oCZcyBhYm9ydGVkIGZsYWcgaXMgc2V0LCB0aGVuOlxuICBpZiAocmVxdWVzdE9iamVjdC5zaWduYWwuYWJvcnRlZCkge1xuICAgIC8vIDEuIEFib3J0IHRoZSBmZXRjaCgpIGNhbGwgd2l0aCBwLCByZXF1ZXN0LCBudWxsLCBhbmRcbiAgICAvLyAgICByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWzigJlzIGFib3J0IHJlYXNvbi5cbiAgICBhYm9ydEZldGNoKHAsIHJlcXVlc3QsIG51bGwsIHJlcXVlc3RPYmplY3Quc2lnbmFsLnJlYXNvbilcblxuICAgIC8vIDIuIFJldHVybiBwLlxuICAgIHJldHVybiBwLnByb21pc2VcbiAgfVxuXG4gIC8vIDUuIExldCBnbG9iYWxPYmplY3QgYmUgcmVxdWVzdOKAmXMgY2xpZW504oCZcyBnbG9iYWwgb2JqZWN0LlxuICBjb25zdCBnbG9iYWxPYmplY3QgPSByZXF1ZXN0LmNsaWVudC5nbG9iYWxPYmplY3RcblxuICAvLyA2LiBJZiBnbG9iYWxPYmplY3QgaXMgYSBTZXJ2aWNlV29ya2VyR2xvYmFsU2NvcGUgb2JqZWN0LCB0aGVuIHNldFxuICAvLyByZXF1ZXN04oCZcyBzZXJ2aWNlLXdvcmtlcnMgbW9kZSB0byBcIm5vbmVcIi5cbiAgaWYgKGdsb2JhbE9iamVjdD8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdTZXJ2aWNlV29ya2VyR2xvYmFsU2NvcGUnKSB7XG4gICAgcmVxdWVzdC5zZXJ2aWNlV29ya2VycyA9ICdub25lJ1xuICB9XG5cbiAgLy8gNy4gTGV0IHJlc3BvbnNlT2JqZWN0IGJlIG51bGwuXG4gIGxldCByZXNwb25zZU9iamVjdCA9IG51bGxcblxuICAvLyA4LiBMZXQgcmVsZXZhbnRSZWFsbSBiZSB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cblxuICAvLyA5LiBMZXQgbG9jYWxseUFib3J0ZWQgYmUgZmFsc2UuXG4gIGxldCBsb2NhbGx5QWJvcnRlZCA9IGZhbHNlXG5cbiAgLy8gMTAuIExldCBjb250cm9sbGVyIGJlIG51bGwuXG4gIGxldCBjb250cm9sbGVyID0gbnVsbFxuXG4gIC8vIDExLiBBZGQgdGhlIGZvbGxvd2luZyBhYm9ydCBzdGVwcyB0byByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWw6XG4gIGFkZEFib3J0TGlzdGVuZXIoXG4gICAgcmVxdWVzdE9iamVjdC5zaWduYWwsXG4gICAgKCkgPT4ge1xuICAgICAgLy8gMS4gU2V0IGxvY2FsbHlBYm9ydGVkIHRvIHRydWUuXG4gICAgICBsb2NhbGx5QWJvcnRlZCA9IHRydWVcblxuICAgICAgLy8gMi4gQXNzZXJ0OiBjb250cm9sbGVyIGlzIG5vbi1udWxsLlxuICAgICAgYXNzZXJ0KGNvbnRyb2xsZXIgIT0gbnVsbClcblxuICAgICAgLy8gMy4gQWJvcnQgY29udHJvbGxlciB3aXRoIHJlcXVlc3RPYmplY3TigJlzIHNpZ25hbOKAmXMgYWJvcnQgcmVhc29uLlxuICAgICAgY29udHJvbGxlci5hYm9ydChyZXF1ZXN0T2JqZWN0LnNpZ25hbC5yZWFzb24pXG5cbiAgICAgIGNvbnN0IHJlYWxSZXNwb25zZSA9IHJlc3BvbnNlT2JqZWN0Py5kZXJlZigpXG5cbiAgICAgIC8vIDQuIEFib3J0IHRoZSBmZXRjaCgpIGNhbGwgd2l0aCBwLCByZXF1ZXN0LCByZXNwb25zZU9iamVjdCxcbiAgICAgIC8vICAgIGFuZCByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWzigJlzIGFib3J0IHJlYXNvbi5cbiAgICAgIGFib3J0RmV0Y2gocCwgcmVxdWVzdCwgcmVhbFJlc3BvbnNlLCByZXF1ZXN0T2JqZWN0LnNpZ25hbC5yZWFzb24pXG4gICAgfVxuICApXG5cbiAgLy8gMTIuIExldCBoYW5kbGVGZXRjaERvbmUgZ2l2ZW4gcmVzcG9uc2UgcmVzcG9uc2UgYmUgdG8gZmluYWxpemUgYW5kXG4gIC8vIHJlcG9ydCB0aW1pbmcgd2l0aCByZXNwb25zZSwgZ2xvYmFsT2JqZWN0LCBhbmQgXCJmZXRjaFwiLlxuICAvLyBzZWUgZnVuY3Rpb24gaGFuZGxlRmV0Y2hEb25lXG5cbiAgLy8gMTMuIFNldCBjb250cm9sbGVyIHRvIHRoZSByZXN1bHQgb2YgY2FsbGluZyBmZXRjaCBnaXZlbiByZXF1ZXN0LFxuICAvLyB3aXRoIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSBzZXQgdG8gaGFuZGxlRmV0Y2hEb25lLCBhbmQgcHJvY2Vzc1Jlc3BvbnNlXG4gIC8vIGdpdmVuIHJlc3BvbnNlIGJlaW5nIHRoZXNlIHN1YnN0ZXBzOlxuXG4gIGNvbnN0IHByb2Nlc3NSZXNwb25zZSA9IChyZXNwb25zZSkgPT4ge1xuICAgIC8vIDEuIElmIGxvY2FsbHlBYm9ydGVkIGlzIHRydWUsIHRlcm1pbmF0ZSB0aGVzZSBzdWJzdGVwcy5cbiAgICBpZiAobG9jYWxseUFib3J0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDIuIElmIHJlc3BvbnNl4oCZcyBhYm9ydGVkIGZsYWcgaXMgc2V0LCB0aGVuOlxuICAgIGlmIChyZXNwb25zZS5hYm9ydGVkKSB7XG4gICAgICAvLyAxLiBMZXQgZGVzZXJpYWxpemVkRXJyb3IgYmUgdGhlIHJlc3VsdCBvZiBkZXNlcmlhbGl6ZSBhIHNlcmlhbGl6ZWRcbiAgICAgIC8vICAgIGFib3J0IHJlYXNvbiBnaXZlbiBjb250cm9sbGVy4oCZcyBzZXJpYWxpemVkIGFib3J0IHJlYXNvbiBhbmRcbiAgICAgIC8vICAgIHJlbGV2YW50UmVhbG0uXG5cbiAgICAgIC8vIDIuIEFib3J0IHRoZSBmZXRjaCgpIGNhbGwgd2l0aCBwLCByZXF1ZXN0LCByZXNwb25zZU9iamVjdCwgYW5kXG4gICAgICAvLyAgICBkZXNlcmlhbGl6ZWRFcnJvci5cblxuICAgICAgYWJvcnRGZXRjaChwLCByZXF1ZXN0LCByZXNwb25zZU9iamVjdCwgY29udHJvbGxlci5zZXJpYWxpemVkQWJvcnRSZWFzb24pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAzLiBJZiByZXNwb25zZSBpcyBhIG5ldHdvcmsgZXJyb3IsIHRoZW4gcmVqZWN0IHAgd2l0aCBhIFR5cGVFcnJvclxuICAgIC8vIGFuZCB0ZXJtaW5hdGUgdGhlc2Ugc3Vic3RlcHMuXG4gICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIHAucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ2ZldGNoIGZhaWxlZCcsIHsgY2F1c2U6IHJlc3BvbnNlLmVycm9yIH0pKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gNC4gU2V0IHJlc3BvbnNlT2JqZWN0IHRvIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYSBSZXNwb25zZSBvYmplY3QsXG4gICAgLy8gZ2l2ZW4gcmVzcG9uc2UsIFwiaW1tdXRhYmxlXCIsIGFuZCByZWxldmFudFJlYWxtLlxuICAgIHJlc3BvbnNlT2JqZWN0ID0gbmV3IFdlYWtSZWYoZnJvbUlubmVyUmVzcG9uc2UocmVzcG9uc2UsICdpbW11dGFibGUnKSlcblxuICAgIC8vIDUuIFJlc29sdmUgcCB3aXRoIHJlc3BvbnNlT2JqZWN0LlxuICAgIHAucmVzb2x2ZShyZXNwb25zZU9iamVjdC5kZXJlZigpKVxuICAgIHAgPSBudWxsXG4gIH1cblxuICBjb250cm9sbGVyID0gZmV0Y2hpbmcoe1xuICAgIHJlcXVlc3QsXG4gICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5OiBoYW5kbGVGZXRjaERvbmUsXG4gICAgcHJvY2Vzc1Jlc3BvbnNlLFxuICAgIGRpc3BhdGNoZXI6IGdldFJlcXVlc3REaXNwYXRjaGVyKHJlcXVlc3RPYmplY3QpIC8vIHVuZGljaVxuICB9KVxuXG4gIC8vIDE0LiBSZXR1cm4gcC5cbiAgcmV0dXJuIHAucHJvbWlzZVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmluYWxpemUtYW5kLXJlcG9ydC10aW1pbmdcbmZ1bmN0aW9uIGZpbmFsaXplQW5kUmVwb3J0VGltaW5nIChyZXNwb25zZSwgaW5pdGlhdG9yVHlwZSA9ICdvdGhlcicpIHtcbiAgLy8gMS4gSWYgcmVzcG9uc2UgaXMgYW4gYWJvcnRlZCBuZXR3b3JrIGVycm9yLCB0aGVuIHJldHVybi5cbiAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicgJiYgcmVzcG9uc2UuYWJvcnRlZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gMi4gSWYgcmVzcG9uc2XigJlzIFVSTCBsaXN0IGlzIG51bGwgb3IgZW1wdHksIHRoZW4gcmV0dXJuLlxuICBpZiAoIXJlc3BvbnNlLnVybExpc3Q/Lmxlbmd0aCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gMy4gTGV0IG9yaWdpbmFsVVJMIGJlIHJlc3BvbnNl4oCZcyBVUkwgbGlzdFswXS5cbiAgY29uc3Qgb3JpZ2luYWxVUkwgPSByZXNwb25zZS51cmxMaXN0WzBdXG5cbiAgLy8gNC4gTGV0IHRpbWluZ0luZm8gYmUgcmVzcG9uc2XigJlzIHRpbWluZyBpbmZvLlxuICBsZXQgdGltaW5nSW5mbyA9IHJlc3BvbnNlLnRpbWluZ0luZm9cblxuICAvLyA1LiBMZXQgY2FjaGVTdGF0ZSBiZSByZXNwb25zZeKAmXMgY2FjaGUgc3RhdGUuXG4gIGxldCBjYWNoZVN0YXRlID0gcmVzcG9uc2UuY2FjaGVTdGF0ZVxuXG4gIC8vIDYuIElmIG9yaWdpbmFsVVJM4oCZcyBzY2hlbWUgaXMgbm90IGFuIEhUVFAoUykgc2NoZW1lLCB0aGVuIHJldHVybi5cbiAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShvcmlnaW5hbFVSTCkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDcuIElmIHRpbWluZ0luZm8gaXMgbnVsbCwgdGhlbiByZXR1cm4uXG4gIGlmICh0aW1pbmdJbmZvID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyA4LiBJZiByZXNwb25zZeKAmXMgdGltaW5nIGFsbG93IHBhc3NlZCBmbGFnIGlzIG5vdCBzZXQsIHRoZW46XG4gIGlmICghcmVzcG9uc2UudGltaW5nQWxsb3dQYXNzZWQpIHtcbiAgICAvLyAgMS4gU2V0IHRpbWluZ0luZm8gdG8gYSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuIG9wYXF1ZSB0aW1pbmcgaW5mbyBmb3IgdGltaW5nSW5mby5cbiAgICB0aW1pbmdJbmZvID0gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyh7XG4gICAgICBzdGFydFRpbWU6IHRpbWluZ0luZm8uc3RhcnRUaW1lXG4gICAgfSlcblxuICAgIC8vICAyLiBTZXQgY2FjaGVTdGF0ZSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIGNhY2hlU3RhdGUgPSAnJ1xuICB9XG5cbiAgLy8gOS4gU2V0IHRpbWluZ0luZm/igJlzIGVuZCB0aW1lIHRvIHRoZSBjb2Fyc2VuZWQgc2hhcmVkIGN1cnJlbnQgdGltZVxuICAvLyBnaXZlbiBnbG9iYWzigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdOKAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkXG4gIC8vIGNhcGFiaWxpdHkuXG4gIC8vIFRPRE86IGdpdmVuIGdsb2JhbOKAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN04oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWRcbiAgLy8gY2FwYWJpbGl0eT9cbiAgdGltaW5nSW5mby5lbmRUaW1lID0gY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoKVxuXG4gIC8vIDEwLiBTZXQgcmVzcG9uc2XigJlzIHRpbWluZyBpbmZvIHRvIHRpbWluZ0luZm8uXG4gIHJlc3BvbnNlLnRpbWluZ0luZm8gPSB0aW1pbmdJbmZvXG5cbiAgLy8gMTEuIE1hcmsgcmVzb3VyY2UgdGltaW5nIGZvciB0aW1pbmdJbmZvLCBvcmlnaW5hbFVSTCwgaW5pdGlhdG9yVHlwZSxcbiAgLy8gZ2xvYmFsLCBhbmQgY2FjaGVTdGF0ZS5cbiAgbWFya1Jlc291cmNlVGltaW5nKFxuICAgIHRpbWluZ0luZm8sXG4gICAgb3JpZ2luYWxVUkwuaHJlZixcbiAgICBpbml0aWF0b3JUeXBlLFxuICAgIGdsb2JhbFRoaXMsXG4gICAgY2FjaGVTdGF0ZSxcbiAgICAnJywgLy8gYm9keVR5cGVcbiAgICByZXNwb25zZS5zdGF0dXNcbiAgKVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vcmVzb3VyY2UtdGltaW5nLyNkZm4tbWFyay1yZXNvdXJjZS10aW1pbmdcbmNvbnN0IG1hcmtSZXNvdXJjZVRpbWluZyA9IHBlcmZvcm1hbmNlLm1hcmtSZXNvdXJjZVRpbWluZ1xuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYWJvcnQtZmV0Y2hcbmZ1bmN0aW9uIGFib3J0RmV0Y2ggKHAsIHJlcXVlc3QsIHJlc3BvbnNlT2JqZWN0LCBlcnJvcikge1xuICAvLyAxLiBSZWplY3QgcHJvbWlzZSB3aXRoIGVycm9yLlxuICBpZiAocCkge1xuICAgIC8vIFdlIG1pZ2h0IGhhdmUgYWxyZWFkeSByZXNvbHZlZCB0aGUgcHJvbWlzZSBhdCB0aGlzIHN0YWdlXG4gICAgcC5yZWplY3QoZXJyb3IpXG4gIH1cblxuICAvLyAyLiBJZiByZXF1ZXN04oCZcyBib2R5IGlzIG5vdCBudWxsIGFuZCBpcyByZWFkYWJsZSwgdGhlbiBjYW5jZWwgcmVxdWVzdOKAmXNcbiAgLy8gYm9keSB3aXRoIGVycm9yLlxuICBpZiAocmVxdWVzdC5ib2R5Py5zdHJlYW0gIT0gbnVsbCAmJiBpc1JlYWRhYmxlKHJlcXVlc3QuYm9keS5zdHJlYW0pKSB7XG4gICAgcmVxdWVzdC5ib2R5LnN0cmVhbS5jYW5jZWwoZXJyb3IpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9JTlZBTElEX1NUQVRFJykge1xuICAgICAgICAvLyBOb2RlIGJ1Zz9cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgcmVzcG9uc2VPYmplY3QgaXMgbnVsbCwgdGhlbiByZXR1cm4uXG4gIGlmIChyZXNwb25zZU9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyA0LiBMZXQgcmVzcG9uc2UgYmUgcmVzcG9uc2VPYmplY3TigJlzIHJlc3BvbnNlLlxuICBjb25zdCByZXNwb25zZSA9IGdldFJlc3BvbnNlU3RhdGUocmVzcG9uc2VPYmplY3QpXG5cbiAgLy8gNS4gSWYgcmVzcG9uc2XigJlzIGJvZHkgaXMgbm90IG51bGwgYW5kIGlzIHJlYWRhYmxlLCB0aGVuIGVycm9yIHJlc3BvbnNl4oCZc1xuICAvLyBib2R5IHdpdGggZXJyb3IuXG4gIGlmIChyZXNwb25zZS5ib2R5Py5zdHJlYW0gIT0gbnVsbCAmJiBpc1JlYWRhYmxlKHJlc3BvbnNlLmJvZHkuc3RyZWFtKSkge1xuICAgIHJlc3BvbnNlLmJvZHkuc3RyZWFtLmNhbmNlbChlcnJvcikuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRVJSX0lOVkFMSURfU1RBVEUnKSB7XG4gICAgICAgIC8vIE5vZGUgYnVnP1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH0pXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZldGNoaW5nXG5mdW5jdGlvbiBmZXRjaGluZyAoe1xuICByZXF1ZXN0LFxuICBwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCxcbiAgcHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHksXG4gIHByb2Nlc3NSZXNwb25zZSxcbiAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LFxuICBwcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keSxcbiAgdXNlUGFyYWxsZWxRdWV1ZSA9IGZhbHNlLFxuICBkaXNwYXRjaGVyID0gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpIC8vIHVuZGljaVxufSkge1xuICAvLyBFbnN1cmUgdGhhdCB0aGUgZGlzcGF0Y2hlciBpcyBzZXQgYWNjb3JkaW5nbHlcbiAgYXNzZXJ0KGRpc3BhdGNoZXIpXG5cbiAgLy8gMS4gTGV0IHRhc2tEZXN0aW5hdGlvbiBiZSBudWxsLlxuICBsZXQgdGFza0Rlc3RpbmF0aW9uID0gbnVsbFxuXG4gIC8vIDIuIExldCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSBiZSBmYWxzZS5cbiAgbGV0IGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5ID0gZmFsc2VcblxuICAvLyAzLiBJZiByZXF1ZXN04oCZcyBjbGllbnQgaXMgbm9uLW51bGwsIHRoZW46XG4gIGlmIChyZXF1ZXN0LmNsaWVudCAhPSBudWxsKSB7XG4gICAgLy8gMS4gU2V0IHRhc2tEZXN0aW5hdGlvbiB0byByZXF1ZXN04oCZcyBjbGllbnTigJlzIGdsb2JhbCBvYmplY3QuXG4gICAgdGFza0Rlc3RpbmF0aW9uID0gcmVxdWVzdC5jbGllbnQuZ2xvYmFsT2JqZWN0XG5cbiAgICAvLyAyLiBTZXQgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkgdG8gcmVxdWVzdOKAmXMgY2xpZW504oCZcyBjcm9zcy1vcmlnaW5cbiAgICAvLyBpc29sYXRlZCBjYXBhYmlsaXR5LlxuICAgIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5ID1cbiAgICAgIHJlcXVlc3QuY2xpZW50LmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5XG4gIH1cblxuICAvLyA0LiBJZiB1c2VQYXJhbGxlbFF1ZXVlIGlzIHRydWUsIHRoZW4gc2V0IHRhc2tEZXN0aW5hdGlvbiB0byB0aGUgcmVzdWx0IG9mXG4gIC8vIHN0YXJ0aW5nIGEgbmV3IHBhcmFsbGVsIHF1ZXVlLlxuICAvLyBUT0RPXG5cbiAgLy8gNS4gTGV0IHRpbWluZ0luZm8gYmUgYSBuZXcgZmV0Y2ggdGltaW5nIGluZm8gd2hvc2Ugc3RhcnQgdGltZSBhbmRcbiAgLy8gcG9zdC1yZWRpcmVjdCBzdGFydCB0aW1lIGFyZSB0aGUgY29hcnNlbmVkIHNoYXJlZCBjdXJyZW50IHRpbWUgZ2l2ZW5cbiAgLy8gY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkuXG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpXG4gIGNvbnN0IHRpbWluZ0luZm8gPSBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvKHtcbiAgICBzdGFydFRpbWU6IGN1cnJlbnRUaW1lXG4gIH0pXG5cbiAgLy8gNi4gTGV0IGZldGNoUGFyYW1zIGJlIGEgbmV3IGZldGNoIHBhcmFtcyB3aG9zZVxuICAvLyByZXF1ZXN0IGlzIHJlcXVlc3QsXG4gIC8vIHRpbWluZyBpbmZvIGlzIHRpbWluZ0luZm8sXG4gIC8vIHByb2Nlc3MgcmVxdWVzdCBib2R5IGNodW5rIGxlbmd0aCBpcyBwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCxcbiAgLy8gcHJvY2VzcyByZXF1ZXN0IGVuZC1vZi1ib2R5IGlzIHByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5LFxuICAvLyBwcm9jZXNzIHJlc3BvbnNlIGlzIHByb2Nlc3NSZXNwb25zZSxcbiAgLy8gcHJvY2VzcyByZXNwb25zZSBjb25zdW1lIGJvZHkgaXMgcHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHksXG4gIC8vIHByb2Nlc3MgcmVzcG9uc2UgZW5kLW9mLWJvZHkgaXMgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LFxuICAvLyB0YXNrIGRlc3RpbmF0aW9uIGlzIHRhc2tEZXN0aW5hdGlvbixcbiAgLy8gYW5kIGNyb3NzLW9yaWdpbiBpc29sYXRlZCBjYXBhYmlsaXR5IGlzIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5LlxuICBjb25zdCBmZXRjaFBhcmFtcyA9IHtcbiAgICBjb250cm9sbGVyOiBuZXcgRmV0Y2goZGlzcGF0Y2hlciksXG4gICAgcmVxdWVzdCxcbiAgICB0aW1pbmdJbmZvLFxuICAgIHByb2Nlc3NSZXF1ZXN0Qm9keUNodW5rTGVuZ3RoLFxuICAgIHByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5LFxuICAgIHByb2Nlc3NSZXNwb25zZSxcbiAgICBwcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keSxcbiAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHksXG4gICAgdGFza0Rlc3RpbmF0aW9uLFxuICAgIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5XG4gIH1cblxuICAvLyA3LiBJZiByZXF1ZXN04oCZcyBib2R5IGlzIGEgYnl0ZSBzZXF1ZW5jZSwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgYm9keSB0b1xuICAvLyAgICByZXF1ZXN04oCZcyBib2R5IGFzIGEgYm9keS5cbiAgLy8gTk9URTogU2luY2UgZmV0Y2hpbmcgaXMgb25seSBjYWxsZWQgZnJvbSBmZXRjaCwgYm9keSBzaG91bGQgYWxyZWFkeSBiZVxuICAvLyBleHRyYWN0ZWQuXG4gIGFzc2VydCghcmVxdWVzdC5ib2R5IHx8IHJlcXVlc3QuYm9keS5zdHJlYW0pXG5cbiAgLy8gOC4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIFwiY2xpZW50XCIsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHdpbmRvdyB0byByZXF1ZXN04oCZc1xuICAvLyBjbGllbnQsIGlmIHJlcXVlc3TigJlzIGNsaWVudOKAmXMgZ2xvYmFsIG9iamVjdCBpcyBhIFdpbmRvdyBvYmplY3Q7IG90aGVyd2lzZVxuICAvLyBcIm5vLXdpbmRvd1wiLlxuICBpZiAocmVxdWVzdC53aW5kb3cgPT09ICdjbGllbnQnKSB7XG4gICAgLy8gVE9ETzogV2hhdCBpZiByZXF1ZXN0LmNsaWVudCBpcyBudWxsP1xuICAgIHJlcXVlc3Qud2luZG93ID1cbiAgICAgIHJlcXVlc3QuY2xpZW50Py5nbG9iYWxPYmplY3Q/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnV2luZG93J1xuICAgICAgICA/IHJlcXVlc3QuY2xpZW50XG4gICAgICAgIDogJ25vLXdpbmRvdydcbiAgfVxuXG4gIC8vIDkuIElmIHJlcXVlc3TigJlzIG9yaWdpbiBpcyBcImNsaWVudFwiLCB0aGVuIHNldCByZXF1ZXN04oCZcyBvcmlnaW4gdG8gcmVxdWVzdOKAmXNcbiAgLy8gY2xpZW504oCZcyBvcmlnaW4uXG4gIGlmIChyZXF1ZXN0Lm9yaWdpbiA9PT0gJ2NsaWVudCcpIHtcbiAgICByZXF1ZXN0Lm9yaWdpbiA9IHJlcXVlc3QuY2xpZW50Lm9yaWdpblxuICB9XG5cbiAgLy8gMTAuIElmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4gIC8vIFRPRE9cblxuICAvLyAxMS4gSWYgcmVxdWVzdOKAmXMgcG9saWN5IGNvbnRhaW5lciBpcyBcImNsaWVudFwiLCB0aGVuOlxuICBpZiAocmVxdWVzdC5wb2xpY3lDb250YWluZXIgPT09ICdjbGllbnQnKSB7XG4gICAgLy8gMS4gSWYgcmVxdWVzdOKAmXMgY2xpZW50IGlzIG5vbi1udWxsLCB0aGVuIHNldCByZXF1ZXN04oCZcyBwb2xpY3lcbiAgICAvLyBjb250YWluZXIgdG8gYSBjbG9uZSBvZiByZXF1ZXN04oCZcyBjbGllbnTigJlzIHBvbGljeSBjb250YWluZXIuIFtIVE1MXVxuICAgIGlmIChyZXF1ZXN0LmNsaWVudCAhPSBudWxsKSB7XG4gICAgICByZXF1ZXN0LnBvbGljeUNvbnRhaW5lciA9IGNsb25lUG9saWN5Q29udGFpbmVyKFxuICAgICAgICByZXF1ZXN0LmNsaWVudC5wb2xpY3lDb250YWluZXJcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMi4gT3RoZXJ3aXNlLCBzZXQgcmVxdWVzdOKAmXMgcG9saWN5IGNvbnRhaW5lciB0byBhIG5ldyBwb2xpY3lcbiAgICAgIC8vIGNvbnRhaW5lci5cbiAgICAgIHJlcXVlc3QucG9saWN5Q29udGFpbmVyID0gbWFrZVBvbGljeUNvbnRhaW5lcigpXG4gICAgfVxuICB9XG5cbiAgLy8gMTIuIElmIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYEFjY2VwdGAsIHRoZW46XG4gIGlmICghcmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnYWNjZXB0JywgdHJ1ZSkpIHtcbiAgICAvLyAxLiBMZXQgdmFsdWUgYmUgYCovKmAuXG4gICAgY29uc3QgdmFsdWUgPSAnKi8qJ1xuXG4gICAgLy8gMi4gQSB1c2VyIGFnZW50IHNob3VsZCBzZXQgdmFsdWUgdG8gdGhlIGZpcnN0IG1hdGNoaW5nIHN0YXRlbWVudCwgaWZcbiAgICAvLyBhbnksIHN3aXRjaGluZyBvbiByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbjpcbiAgICAvLyBcImRvY3VtZW50XCJcbiAgICAvLyBcImZyYW1lXCJcbiAgICAvLyBcImlmcmFtZVwiXG4gICAgLy8gYHRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LCovKjtxPTAuOGBcbiAgICAvLyBcImltYWdlXCJcbiAgICAvLyBgaW1hZ2UvcG5nLGltYWdlL3N2Zyt4bWwsaW1hZ2UvKjtxPTAuOCwqLyo7cT0wLjVgXG4gICAgLy8gXCJzdHlsZVwiXG4gICAgLy8gYHRleHQvY3NzLCovKjtxPTAuMWBcbiAgICAvLyBUT0RPXG5cbiAgICAvLyAzLiBBcHBlbmQgYEFjY2VwdGAvdmFsdWUgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdCcsIHZhbHVlLCB0cnVlKVxuICB9XG5cbiAgLy8gMTMuIElmIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYEFjY2VwdC1MYW5ndWFnZWAsIHRoZW5cbiAgLy8gdXNlciBhZ2VudHMgc2hvdWxkIGFwcGVuZCBgQWNjZXB0LUxhbmd1YWdlYC9hbiBhcHByb3ByaWF0ZSB2YWx1ZSB0b1xuICAvLyByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKCFyZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdhY2NlcHQtbGFuZ3VhZ2UnLCB0cnVlKSkge1xuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdhY2NlcHQtbGFuZ3VhZ2UnLCAnKicsIHRydWUpXG4gIH1cblxuICAvLyAxNC4gSWYgcmVxdWVzdOKAmXMgcHJpb3JpdHkgaXMgbnVsbCwgdGhlbiB1c2UgcmVxdWVzdOKAmXMgaW5pdGlhdG9yIGFuZFxuICAvLyBkZXN0aW5hdGlvbiBhcHByb3ByaWF0ZWx5IGluIHNldHRpbmcgcmVxdWVzdOKAmXMgcHJpb3JpdHkgdG8gYVxuICAvLyB1c2VyLWFnZW50LWRlZmluZWQgb2JqZWN0LlxuICBpZiAocmVxdWVzdC5wcmlvcml0eSA9PT0gbnVsbCkge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDE1LiBJZiByZXF1ZXN0IGlzIGEgc3VicmVzb3VyY2UgcmVxdWVzdCwgdGhlbjpcbiAgaWYgKHN1YnJlc291cmNlU2V0LmhhcyhyZXF1ZXN0LmRlc3RpbmF0aW9uKSkge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDE2LiBSdW4gbWFpbiBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgbWFpbkZldGNoKGZldGNoUGFyYW1zKVxuICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoZXJyKVxuICAgIH0pXG5cbiAgLy8gMTcuIFJldHVybiBmZXRjaFBhcmFtJ3MgY29udHJvbGxlclxuICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlclxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tYWluLWZldGNoXG5hc3luYyBmdW5jdGlvbiBtYWluRmV0Y2ggKGZldGNoUGFyYW1zLCByZWN1cnNpdmUgPSBmYWxzZSkge1xuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDMuIElmIHJlcXVlc3TigJlzIGxvY2FsLVVSTHMtb25seSBmbGFnIGlzIHNldCBhbmQgcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgaXNcbiAgLy8gbm90IGxvY2FsLCB0aGVuIHNldCByZXNwb25zZSB0byBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChyZXF1ZXN0LmxvY2FsVVJMc09ubHkgJiYgIXVybElzTG9jYWwocmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkpKSB7XG4gICAgcmVzcG9uc2UgPSBtYWtlTmV0d29ya0Vycm9yKCdsb2NhbCBVUkxzIG9ubHknKVxuICB9XG5cbiAgLy8gNC4gUnVuIHJlcG9ydCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB2aW9sYXRpb25zIGZvciByZXF1ZXN0LlxuICAvLyBUT0RPXG5cbiAgLy8gNS4gVXBncmFkZSByZXF1ZXN0IHRvIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLCBpZiBhcHByb3ByaWF0ZS5cbiAgdHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMKHJlcXVlc3QpXG5cbiAgLy8gNi4gSWYgc2hvdWxkIHJlcXVlc3QgYmUgYmxvY2tlZCBkdWUgdG8gYSBiYWQgcG9ydCwgc2hvdWxkIGZldGNoaW5nIHJlcXVlc3RcbiAgLy8gYmUgYmxvY2tlZCBhcyBtaXhlZCBjb250ZW50LCBvciBzaG91bGQgcmVxdWVzdCBiZSBibG9ja2VkIGJ5IENvbnRlbnRcbiAgLy8gU2VjdXJpdHkgUG9saWN5IHJldHVybnMgYmxvY2tlZCwgdGhlbiBzZXQgcmVzcG9uc2UgdG8gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAocmVxdWVzdEJhZFBvcnQocmVxdWVzdCkgPT09ICdibG9ja2VkJykge1xuICAgIHJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcignYmFkIHBvcnQnKVxuICB9XG4gIC8vIFRPRE86IHNob3VsZCBmZXRjaGluZyByZXF1ZXN0IGJlIGJsb2NrZWQgYXMgbWl4ZWQgY29udGVudD9cbiAgLy8gVE9ETzogc2hvdWxkIHJlcXVlc3QgYmUgYmxvY2tlZCBieSBDb250ZW50IFNlY3VyaXR5IFBvbGljeT9cblxuICAvLyA3LiBJZiByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcmVxdWVzdOKAmXNcbiAgLy8gcmVmZXJyZXIgcG9saWN5IHRvIHJlcXVlc3TigJlzIHBvbGljeSBjb250YWluZXLigJlzIHJlZmVycmVyIHBvbGljeS5cbiAgaWYgKHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPT09ICcnKSB7XG4gICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9IHJlcXVlc3QucG9saWN5Q29udGFpbmVyLnJlZmVycmVyUG9saWN5XG4gIH1cblxuICAvLyA4LiBJZiByZXF1ZXN04oCZcyByZWZlcnJlciBpcyBub3QgXCJuby1yZWZlcnJlclwiLCB0aGVuIHNldCByZXF1ZXN04oCZc1xuICAvLyByZWZlcnJlciB0byB0aGUgcmVzdWx0IG9mIGludm9raW5nIGRldGVybWluZSByZXF1ZXN04oCZcyByZWZlcnJlci5cbiAgaWYgKHJlcXVlc3QucmVmZXJyZXIgIT09ICduby1yZWZlcnJlcicpIHtcbiAgICByZXF1ZXN0LnJlZmVycmVyID0gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcihyZXF1ZXN0KVxuICB9XG5cbiAgLy8gOS4gU2V0IHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgdG8gXCJodHRwc1wiIGlmIGFsbCBvZiB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4gIC8vIC0gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBpcyBcImh0dHBcIlxuICAvLyAtIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBob3N0IGlzIGEgZG9tYWluXG4gIC8vIC0gTWF0Y2hpbmcgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIGhvc3QgcGVyIEtub3duIEhTVFMgSG9zdCBEb21haW4gTmFtZVxuICAvLyAgIE1hdGNoaW5nIHJlc3VsdHMgaW4gZWl0aGVyIGEgc3VwZXJkb21haW4gbWF0Y2ggd2l0aCBhbiBhc3NlcnRlZFxuICAvLyAgIGluY2x1ZGVTdWJEb21haW5zIGRpcmVjdGl2ZSBvciBhIGNvbmdydWVudCBtYXRjaCAod2l0aCBvciB3aXRob3V0IGFuXG4gIC8vICAgYXNzZXJ0ZWQgaW5jbHVkZVN1YkRvbWFpbnMgZGlyZWN0aXZlKS4gW0hTVFNdXG4gIC8vIFRPRE9cblxuICAvLyAxMC4gSWYgcmVjdXJzaXZlIGlzIGZhbHNlLCB0aGVuIHJ1biB0aGUgcmVtYWluaW5nIHN0ZXBzIGluIHBhcmFsbGVsLlxuICAvLyBUT0RPXG5cbiAgLy8gMTEuIElmIHJlc3BvbnNlIGlzIG51bGwsIHRoZW4gc2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAvLyB0aGUgc3RlcHMgY29ycmVzcG9uZGluZyB0byB0aGUgZmlyc3QgbWF0Y2hpbmcgc3RhdGVtZW50OlxuICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICBjb25zdCBjdXJyZW50VVJMID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcbiAgICBpZiAoXG4gICAgICAvLyAtIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBvcmlnaW4gaXMgc2FtZSBvcmlnaW4gd2l0aCByZXF1ZXN04oCZcyBvcmlnaW4sXG4gICAgICAvLyAgIGFuZCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcImJhc2ljXCJcbiAgICAgIChzYW1lT3JpZ2luKGN1cnJlbnRVUkwsIHJlcXVlc3QudXJsKSAmJiByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdiYXNpYycpIHx8XG4gICAgICAvLyByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGlzIFwiZGF0YVwiXG4gICAgICAoY3VycmVudFVSTC5wcm90b2NvbCA9PT0gJ2RhdGE6JykgfHxcbiAgICAgIC8vIC0gcmVxdWVzdOKAmXMgbW9kZSBpcyBcIm5hdmlnYXRlXCIgb3IgXCJ3ZWJzb2NrZXRcIlxuICAgICAgKHJlcXVlc3QubW9kZSA9PT0gJ25hdmlnYXRlJyB8fCByZXF1ZXN0Lm1vZGUgPT09ICd3ZWJzb2NrZXQnKVxuICAgICkge1xuICAgICAgLy8gMS4gU2V0IHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIHRvIFwiYmFzaWNcIi5cbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9ICdiYXNpYydcblxuICAgICAgLy8gMi4gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBzY2hlbWUgZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG4gICAgICByZXNwb25zZSA9IGF3YWl0IHNjaGVtZUZldGNoKGZldGNoUGFyYW1zKVxuXG4gICAgLy8gcmVxdWVzdOKAmXMgbW9kZSBpcyBcInNhbWUtb3JpZ2luXCJcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ3NhbWUtb3JpZ2luJykge1xuICAgICAgLy8gMS4gUmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgIHJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcigncmVxdWVzdCBtb2RlIGNhbm5vdCBiZSBcInNhbWUtb3JpZ2luXCInKVxuXG4gICAgLy8gcmVxdWVzdOKAmXMgbW9kZSBpcyBcIm5vLWNvcnNcIlxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5tb2RlID09PSAnbm8tY29ycycpIHtcbiAgICAgIC8vIDEuIElmIHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGUgaXMgbm90IFwiZm9sbG93XCIsIHRoZW4gcmV0dXJuIGEgbmV0d29ya1xuICAgICAgLy8gZXJyb3IuXG4gICAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCAhPT0gJ2ZvbGxvdycpIHtcbiAgICAgICAgcmVzcG9uc2UgPSBtYWtlTmV0d29ya0Vycm9yKFxuICAgICAgICAgICdyZWRpcmVjdCBtb2RlIGNhbm5vdCBiZSBcImZvbGxvd1wiIGZvciBcIm5vLWNvcnNcIiByZXF1ZXN0J1xuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAyLiBTZXQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgdG8gXCJvcGFxdWVcIi5cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID0gJ29wYXF1ZSdcblxuICAgICAgICAvLyAzLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIHNjaGVtZSBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBzY2hlbWVGZXRjaChmZXRjaFBhcmFtcylcbiAgICAgIH1cbiAgICAvLyByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGlzIG5vdCBhbiBIVFRQKFMpIHNjaGVtZVxuICAgIH0gZWxzZSBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpKSkge1xuICAgICAgLy8gUmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgIHJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcignVVJMIHNjaGVtZSBtdXN0IGJlIGEgSFRUUChTKSBzY2hlbWUnKVxuXG4gICAgICAvLyAtIHJlcXVlc3TigJlzIHVzZS1DT1JTLXByZWZsaWdodCBmbGFnIGlzIHNldFxuICAgICAgLy8gLSByZXF1ZXN04oCZcyB1bnNhZmUtcmVxdWVzdCBmbGFnIGlzIHNldCBhbmQgZWl0aGVyIHJlcXVlc3TigJlzIG1ldGhvZCBpc1xuICAgICAgLy8gICBub3QgYSBDT1JTLXNhZmVsaXN0ZWQgbWV0aG9kIG9yIENPUlMtdW5zYWZlIHJlcXVlc3QtaGVhZGVyIG5hbWVzIHdpdGhcbiAgICAgIC8vICAgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgaXMgbm90IGVtcHR5XG4gICAgICAvLyAgICAxLiBTZXQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgdG8gXCJjb3JzXCIuXG4gICAgICAvLyAgICAyLiBMZXQgY29yc1dpdGhQcmVmbGlnaHRSZXNwb25zZSBiZSB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUCBmZXRjaFxuICAgICAgLy8gICAgZ2l2ZW4gZmV0Y2hQYXJhbXMgYW5kIHRydWUuXG4gICAgICAvLyAgICAzLiBJZiBjb3JzV2l0aFByZWZsaWdodFJlc3BvbnNlIGlzIGEgbmV0d29yayBlcnJvciwgdGhlbiBjbGVhciBjYWNoZVxuICAgICAgLy8gICAgZW50cmllcyB1c2luZyByZXF1ZXN0LlxuICAgICAgLy8gICAgNC4gUmV0dXJuIGNvcnNXaXRoUHJlZmxpZ2h0UmVzcG9uc2UuXG4gICAgICAvLyBUT0RPXG5cbiAgICAvLyBPdGhlcndpc2VcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gICAgMS4gU2V0IHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIHRvIFwiY29yc1wiLlxuICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID0gJ2NvcnMnXG5cbiAgICAgIC8vICAgIDIuIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUCBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaHR0cEZldGNoKGZldGNoUGFyYW1zKVxuICAgIH1cbiAgfVxuXG4gIC8vIDEyLiBJZiByZWN1cnNpdmUgaXMgdHJ1ZSwgdGhlbiByZXR1cm4gcmVzcG9uc2UuXG4gIGlmIChyZWN1cnNpdmUpIHtcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIC8vIDEzLiBJZiByZXNwb25zZSBpcyBub3QgYSBuZXR3b3JrIGVycm9yIGFuZCByZXNwb25zZSBpcyBub3QgYSBmaWx0ZXJlZFxuICAvLyByZXNwb25zZSwgdGhlbjpcbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMCAmJiAhcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZSkge1xuICAgIC8vIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiY29yc1wiLCB0aGVuOlxuICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJykge1xuICAgICAgLy8gMS4gTGV0IGhlYWRlck5hbWVzIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBoZWFkZXIgbGlzdCB2YWx1ZXNcbiAgICAgIC8vIGdpdmVuIGBBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVyc2AgYW5kIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgIC8vIFRPRE9cbiAgICAgIC8vIDIuIElmIHJlcXVlc3TigJlzIGNyZWRlbnRpYWxzIG1vZGUgaXMgbm90IFwiaW5jbHVkZVwiIGFuZCBoZWFkZXJOYW1lc1xuICAgICAgLy8gY29udGFpbnMgYCpgLCB0aGVuIHNldCByZXNwb25zZeKAmXMgQ09SUy1leHBvc2VkIGhlYWRlci1uYW1lIGxpc3QgdG9cbiAgICAgIC8vIGFsbCB1bmlxdWUgaGVhZGVyIG5hbWVzIGluIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgIC8vIFRPRE9cbiAgICAgIC8vIDMuIE90aGVyd2lzZSwgaWYgaGVhZGVyTmFtZXMgaXMgbm90IG51bGwgb3IgZmFpbHVyZSwgdGhlbiBzZXRcbiAgICAgIC8vIHJlc3BvbnNl4oCZcyBDT1JTLWV4cG9zZWQgaGVhZGVyLW5hbWUgbGlzdCB0byBoZWFkZXJOYW1lcy5cbiAgICAgIC8vIFRPRE9cbiAgICB9XG5cbiAgICAvLyBTZXQgcmVzcG9uc2UgdG8gdGhlIGZvbGxvd2luZyBmaWx0ZXJlZCByZXNwb25zZSB3aXRoIHJlc3BvbnNlIGFzIGl0c1xuICAgIC8vIGludGVybmFsIHJlc3BvbnNlLCBkZXBlbmRpbmcgb24gcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmc6XG4gICAgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2Jhc2ljJykge1xuICAgICAgcmVzcG9uc2UgPSBmaWx0ZXJSZXNwb25zZShyZXNwb25zZSwgJ2Jhc2ljJylcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2NvcnMnKSB7XG4gICAgICByZXNwb25zZSA9IGZpbHRlclJlc3BvbnNlKHJlc3BvbnNlLCAnY29ycycpXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdvcGFxdWUnKSB7XG4gICAgICByZXNwb25zZSA9IGZpbHRlclJlc3BvbnNlKHJlc3BvbnNlLCAnb3BhcXVlJylcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIC8vIDE0LiBMZXQgaW50ZXJuYWxSZXNwb25zZSBiZSByZXNwb25zZSwgaWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yLFxuICAvLyBhbmQgcmVzcG9uc2XigJlzIGludGVybmFsIHJlc3BvbnNlIG90aGVyd2lzZS5cbiAgbGV0IGludGVybmFsUmVzcG9uc2UgPVxuICAgIHJlc3BvbnNlLnN0YXR1cyA9PT0gMCA/IHJlc3BvbnNlIDogcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZVxuXG4gIC8vIDE1LiBJZiBpbnRlcm5hbFJlc3BvbnNl4oCZcyBVUkwgbGlzdCBpcyBlbXB0eSwgdGhlbiBzZXQgaXQgdG8gYSBjbG9uZSBvZlxuICAvLyByZXF1ZXN04oCZcyBVUkwgbGlzdC5cbiAgaWYgKGludGVybmFsUmVzcG9uc2UudXJsTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICBpbnRlcm5hbFJlc3BvbnNlLnVybExpc3QucHVzaCguLi5yZXF1ZXN0LnVybExpc3QpXG4gIH1cblxuICAvLyAxNi4gSWYgcmVxdWVzdOKAmXMgdGltaW5nIGFsbG93IGZhaWxlZCBmbGFnIGlzIHVuc2V0LCB0aGVuIHNldFxuICAvLyBpbnRlcm5hbFJlc3BvbnNl4oCZcyB0aW1pbmcgYWxsb3cgcGFzc2VkIGZsYWcuXG4gIGlmICghcmVxdWVzdC50aW1pbmdBbGxvd0ZhaWxlZCkge1xuICAgIHJlc3BvbnNlLnRpbWluZ0FsbG93UGFzc2VkID0gdHJ1ZVxuICB9XG5cbiAgLy8gMTcuIElmIHJlc3BvbnNlIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IgYW5kIGFueSBvZiB0aGUgZm9sbG93aW5nIHJldHVybnNcbiAgLy8gYmxvY2tlZFxuICAvLyAtIHNob3VsZCBpbnRlcm5hbFJlc3BvbnNlIHRvIHJlcXVlc3QgYmUgYmxvY2tlZCBhcyBtaXhlZCBjb250ZW50XG4gIC8vIC0gc2hvdWxkIGludGVybmFsUmVzcG9uc2UgdG8gcmVxdWVzdCBiZSBibG9ja2VkIGJ5IENvbnRlbnQgU2VjdXJpdHkgUG9saWN5XG4gIC8vIC0gc2hvdWxkIGludGVybmFsUmVzcG9uc2UgdG8gcmVxdWVzdCBiZSBibG9ja2VkIGR1ZSB0byBpdHMgTUlNRSB0eXBlXG4gIC8vIC0gc2hvdWxkIGludGVybmFsUmVzcG9uc2UgdG8gcmVxdWVzdCBiZSBibG9ja2VkIGR1ZSB0byBub3NuaWZmXG4gIC8vIFRPRE9cblxuICAvLyAxOC4gSWYgcmVzcG9uc2XigJlzIHR5cGUgaXMgXCJvcGFxdWVcIiwgaW50ZXJuYWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIDIwNixcbiAgLy8gaW50ZXJuYWxSZXNwb25zZeKAmXMgcmFuZ2UtcmVxdWVzdGVkIGZsYWcgaXMgc2V0LCBhbmQgcmVxdWVzdOKAmXMgaGVhZGVyXG4gIC8vIGxpc3QgZG9lcyBub3QgY29udGFpbiBgUmFuZ2VgLCB0aGVuIHNldCByZXNwb25zZSBhbmQgaW50ZXJuYWxSZXNwb25zZVxuICAvLyB0byBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICByZXNwb25zZS50eXBlID09PSAnb3BhcXVlJyAmJlxuICAgIGludGVybmFsUmVzcG9uc2Uuc3RhdHVzID09PSAyMDYgJiZcbiAgICBpbnRlcm5hbFJlc3BvbnNlLnJhbmdlUmVxdWVzdGVkICYmXG4gICAgIXJlcXVlc3QuaGVhZGVycy5jb250YWlucygncmFuZ2UnLCB0cnVlKVxuICApIHtcbiAgICByZXNwb25zZSA9IGludGVybmFsUmVzcG9uc2UgPSBtYWtlTmV0d29ya0Vycm9yKClcbiAgfVxuXG4gIC8vIDE5LiBJZiByZXNwb25zZSBpcyBub3QgYSBuZXR3b3JrIGVycm9yIGFuZCBlaXRoZXIgcmVxdWVzdOKAmXMgbWV0aG9kIGlzXG4gIC8vIGBIRUFEYCBvciBgQ09OTkVDVGAsIG9yIGludGVybmFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyBhIG51bGwgYm9keSBzdGF0dXMsXG4gIC8vIHNldCBpbnRlcm5hbFJlc3BvbnNl4oCZcyBib2R5IHRvIG51bGwgYW5kIGRpc3JlZ2FyZCBhbnkgZW5xdWV1aW5nIHRvd2FyZFxuICAvLyBpdCAoaWYgYW55KS5cbiAgaWYgKFxuICAgIHJlc3BvbnNlLnN0YXR1cyAhPT0gMCAmJlxuICAgIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnIHx8XG4gICAgICByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0NPTk5FQ1QnIHx8XG4gICAgICBudWxsQm9keVN0YXR1cy5pbmNsdWRlcyhpbnRlcm5hbFJlc3BvbnNlLnN0YXR1cykpXG4gICkge1xuICAgIGludGVybmFsUmVzcG9uc2UuYm9keSA9IG51bGxcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmR1bXAgPSB0cnVlXG4gIH1cblxuICAvLyAyMC4gSWYgcmVxdWVzdOKAmXMgaW50ZWdyaXR5IG1ldGFkYXRhIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuOlxuICBpZiAocmVxdWVzdC5pbnRlZ3JpdHkpIHtcbiAgICAvLyAxLiBMZXQgcHJvY2Vzc0JvZHlFcnJvciBiZSB0aGlzIHN0ZXA6IHJ1biBmZXRjaCBmaW5hbGUgZ2l2ZW4gZmV0Y2hQYXJhbXNcbiAgICAvLyBhbmQgYSBuZXR3b3JrIGVycm9yLlxuICAgIGNvbnN0IHByb2Nlc3NCb2R5RXJyb3IgPSAocmVhc29uKSA9PlxuICAgICAgZmV0Y2hGaW5hbGUoZmV0Y2hQYXJhbXMsIG1ha2VOZXR3b3JrRXJyb3IocmVhc29uKSlcblxuICAgIC8vIDIuIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwib3BhcXVlXCIsIG9yIHJlc3BvbnNl4oCZcyBib2R5IGlzIG51bGwsXG4gICAgLy8gdGhlbiBydW4gcHJvY2Vzc0JvZHlFcnJvciBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ29wYXF1ZScgfHwgcmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzQm9keUVycm9yKHJlc3BvbnNlLmVycm9yKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IHByb2Nlc3NCb2R5IGdpdmVuIGJ5dGVzIGJlIHRoZXNlIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NCb2R5ID0gKGJ5dGVzKSA9PiB7XG4gICAgICAvLyAxLiBJZiBieXRlcyBkbyBub3QgbWF0Y2ggcmVxdWVzdOKAmXMgaW50ZWdyaXR5IG1ldGFkYXRhLFxuICAgICAgLy8gdGhlbiBydW4gcHJvY2Vzc0JvZHlFcnJvciBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuIFtTUkldXG4gICAgICBpZiAoIWJ5dGVzTWF0Y2goYnl0ZXMsIHJlcXVlc3QuaW50ZWdyaXR5KSkge1xuICAgICAgICBwcm9jZXNzQm9keUVycm9yKCdpbnRlZ3JpdHkgbWlzbWF0Y2gnKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMi4gU2V0IHJlc3BvbnNl4oCZcyBib2R5IHRvIGJ5dGVzIGFzIGEgYm9keS5cbiAgICAgIHJlc3BvbnNlLmJvZHkgPSBzYWZlbHlFeHRyYWN0Qm9keShieXRlcylbMF1cblxuICAgICAgLy8gMy4gUnVuIGZldGNoIGZpbmFsZSBnaXZlbiBmZXRjaFBhcmFtcyBhbmQgcmVzcG9uc2UuXG4gICAgICBmZXRjaEZpbmFsZShmZXRjaFBhcmFtcywgcmVzcG9uc2UpXG4gICAgfVxuXG4gICAgLy8gNC4gRnVsbHkgcmVhZCByZXNwb25zZeKAmXMgYm9keSBnaXZlbiBwcm9jZXNzQm9keSBhbmQgcHJvY2Vzc0JvZHlFcnJvci5cbiAgICBhd2FpdCBmdWxseVJlYWRCb2R5KHJlc3BvbnNlLmJvZHksIHByb2Nlc3NCb2R5LCBwcm9jZXNzQm9keUVycm9yKVxuICB9IGVsc2Uge1xuICAgIC8vIDIxLiBPdGhlcndpc2UsIHJ1biBmZXRjaCBmaW5hbGUgZ2l2ZW4gZmV0Y2hQYXJhbXMgYW5kIHJlc3BvbnNlLlxuICAgIGZldGNoRmluYWxlKGZldGNoUGFyYW1zLCByZXNwb25zZSlcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1zY2hlbWUtZmV0Y2hcbi8vIGdpdmVuIGEgZmV0Y2ggcGFyYW1zIGZldGNoUGFyYW1zXG5mdW5jdGlvbiBzY2hlbWVGZXRjaCAoZmV0Y2hQYXJhbXMpIHtcbiAgLy8gTm90ZTogc2luY2UgdGhlIGNvbm5lY3Rpb24gaXMgZGVzdHJveWVkIG9uIHJlZGlyZWN0LCB3aGljaCBzZXRzIGZldGNoUGFyYW1zIHRvIGFcbiAgLy8gY2FuY2VsbGVkIHN0YXRlLCB3ZSBkbyBub3Qgd2FudCB0aGlzIGNvbmRpdGlvbiB0byB0cmlnZ2VyICp1bmxlc3MqIHRoZXJlIGhhdmUgYmVlblxuICAvLyBubyByZWRpcmVjdHMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTc3NlxuICAvLyAxLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpICYmIGZldGNoUGFyYW1zLnJlcXVlc3QucmVkaXJlY3RDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zKSlcbiAgfVxuXG4gIC8vIDIuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCB7IHJlcXVlc3QgfSA9IGZldGNoUGFyYW1zXG5cbiAgY29uc3QgeyBwcm90b2NvbDogc2NoZW1lIH0gPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gIC8vIDMuIFN3aXRjaCBvbiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGFuZCBydW4gdGhlIGFzc29jaWF0ZWQgc3RlcHM6XG4gIHN3aXRjaCAoc2NoZW1lKSB7XG4gICAgY2FzZSAnYWJvdXQ6Jzoge1xuICAgICAgLy8gSWYgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHBhdGggaXMgdGhlIHN0cmluZyBcImJsYW5rXCIsIHRoZW4gcmV0dXJuIGEgbmV3IHJlc3BvbnNlXG4gICAgICAvLyB3aG9zZSBzdGF0dXMgbWVzc2FnZSBpcyBgT0tgLCBoZWFkZXIgbGlzdCBpcyDCqyAoYENvbnRlbnQtVHlwZWAsIGB0ZXh0L2h0bWw7Y2hhcnNldD11dGYtOGApIMK7LFxuICAgICAgLy8gYW5kIGJvZHkgaXMgdGhlIGVtcHR5IGJ5dGUgc2VxdWVuY2UgYXMgYSBib2R5LlxuXG4gICAgICAvLyBPdGhlcndpc2UsIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2Fib3V0IHNjaGVtZSBpcyBub3Qgc3VwcG9ydGVkJykpXG4gICAgfVxuICAgIGNhc2UgJ2Jsb2I6Jzoge1xuICAgICAgaWYgKCFyZXNvbHZlT2JqZWN0VVJMKSB7XG4gICAgICAgIHJlc29sdmVPYmplY3RVUkwgPSByZXF1aXJlKCdub2RlOmJ1ZmZlcicpLnJlc29sdmVPYmplY3RVUkxcbiAgICAgIH1cblxuICAgICAgLy8gMS4gTGV0IGJsb2JVUkxFbnRyeSBiZSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgYmxvYiBVUkwgZW50cnkuXG4gICAgICBjb25zdCBibG9iVVJMRW50cnkgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2ViLXBsYXRmb3JtLXRlc3RzL3dwdC9ibG9iLzdiMGViYWNjYzYyYjU2NmExOTY1Mzk2ZTViZTdiYjJiYzA2Zjg0MWYvRmlsZUFQSS91cmwvcmVzb3VyY2VzL2ZldGNoLXRlc3RzLmpzI0w1Mi1MNTZcbiAgICAgIC8vIEJ1ZmZlci5yZXNvbHZlT2JqZWN0VVJMIGRvZXMgbm90IGlnbm9yZSBVUkwgcXVlcmllcy5cbiAgICAgIGlmIChibG9iVVJMRW50cnkuc2VhcmNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ05ldHdvcmtFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZmV0Y2ggcmVzb3VyY2UuJykpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJsb2IgPSByZXNvbHZlT2JqZWN0VVJMKGJsb2JVUkxFbnRyeS50b1N0cmluZygpKVxuXG4gICAgICAvLyAyLiBJZiByZXF1ZXN04oCZcyBtZXRob2QgaXMgbm90IGBHRVRgLCBibG9iVVJMRW50cnkgaXMgbnVsbCwgb3IgYmxvYlVSTEVudHJ54oCZc1xuICAgICAgLy8gICAgb2JqZWN0IGlzIG5vdCBhIEJsb2Igb2JqZWN0LCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09ICdHRVQnIHx8ICF3ZWJpZGwuaXMuQmxvYihibG9iKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2ludmFsaWQgbWV0aG9kJykpXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIExldCBibG9iIGJlIGJsb2JVUkxFbnRyeeKAmXMgb2JqZWN0LlxuICAgICAgLy8gTm90ZTogZG9uZSBhYm92ZVxuXG4gICAgICAvLyA0LiBMZXQgcmVzcG9uc2UgYmUgYSBuZXcgcmVzcG9uc2UuXG4gICAgICBjb25zdCByZXNwb25zZSA9IG1ha2VSZXNwb25zZSgpXG5cbiAgICAgIC8vIDUuIExldCBmdWxsTGVuZ3RoIGJlIGJsb2LigJlzIHNpemUuXG4gICAgICBjb25zdCBmdWxsTGVuZ3RoID0gYmxvYi5zaXplXG5cbiAgICAgIC8vIDYuIExldCBzZXJpYWxpemVkRnVsbExlbmd0aCBiZSBmdWxsTGVuZ3RoLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQuXG4gICAgICBjb25zdCBzZXJpYWxpemVkRnVsbExlbmd0aCA9IGlzb21vcnBoaWNFbmNvZGUoYCR7ZnVsbExlbmd0aH1gKVxuXG4gICAgICAvLyA3LiBMZXQgdHlwZSBiZSBibG9i4oCZcyB0eXBlLlxuICAgICAgY29uc3QgdHlwZSA9IGJsb2IudHlwZVxuXG4gICAgICAvLyA4LiBJZiByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBSYW5nZWA6XG4gICAgICAvLyA5LiBPdGhlcndpc2U6XG4gICAgICBpZiAoIXJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3JhbmdlJywgdHJ1ZSkpIHtcbiAgICAgICAgLy8gMS4gTGV0IGJvZHlXaXRoVHlwZSBiZSB0aGUgcmVzdWx0IG9mIHNhZmVseSBleHRyYWN0aW5nIGJsb2IuXG4gICAgICAgIC8vIE5vdGU6IGluIHRoZSBGaWxlQVBJIGEgYmxvYiBcIm9iamVjdFwiIGlzIGEgQmxvYiAqb3IqIGEgTWVkaWFTb3VyY2UuXG4gICAgICAgIC8vIEluIG5vZGUsIHRoaXMgY2FuIG9ubHkgZXZlciBiZSBhIEJsb2IuIFRoZXJlZm9yZSB3ZSBjYW4gc2FmZWx5XG4gICAgICAgIC8vIHVzZSBleHRyYWN0Qm9keSBkaXJlY3RseS5cbiAgICAgICAgY29uc3QgYm9keVdpdGhUeXBlID0gZXh0cmFjdEJvZHkoYmxvYilcblxuICAgICAgICAvLyAyLiBTZXQgcmVzcG9uc2XigJlzIHN0YXR1cyBtZXNzYWdlIHRvIGBPS2AuXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQgPSAnT0snXG5cbiAgICAgICAgLy8gMy4gU2V0IHJlc3BvbnNl4oCZcyBib2R5IHRvIGJvZHlXaXRoVHlwZeKAmXMgYm9keS5cbiAgICAgICAgcmVzcG9uc2UuYm9keSA9IGJvZHlXaXRoVHlwZVswXVxuXG4gICAgICAgIC8vIDQuIFNldCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QgdG8gwqsgKGBDb250ZW50LUxlbmd0aGAsIHNlcmlhbGl6ZWRGdWxsTGVuZ3RoKSwgKGBDb250ZW50LVR5cGVgLCB0eXBlKSDCuy5cbiAgICAgICAgcmVzcG9uc2UuaGVhZGVyc0xpc3Quc2V0KCdjb250ZW50LWxlbmd0aCcsIHNlcmlhbGl6ZWRGdWxsTGVuZ3RoLCB0cnVlKVxuICAgICAgICByZXNwb25zZS5oZWFkZXJzTGlzdC5zZXQoJ2NvbnRlbnQtdHlwZScsIHR5cGUsIHRydWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAxLiBTZXQgcmVzcG9uc2XigJlzIHJhbmdlLXJlcXVlc3RlZCBmbGFnLlxuICAgICAgICByZXNwb25zZS5yYW5nZVJlcXVlc3RlZCA9IHRydWVcblxuICAgICAgICAvLyAyLiBMZXQgcmFuZ2VIZWFkZXIgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIGBSYW5nZWAgZnJvbSByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgICAgY29uc3QgcmFuZ2VIZWFkZXIgPSByZXF1ZXN0LmhlYWRlcnNMaXN0LmdldCgncmFuZ2UnLCB0cnVlKVxuXG4gICAgICAgIC8vIDMuIExldCByYW5nZVZhbHVlIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyBhIHNpbmdsZSByYW5nZSBoZWFkZXIgdmFsdWUgZ2l2ZW4gcmFuZ2VIZWFkZXIgYW5kIHRydWUuXG4gICAgICAgIGNvbnN0IHJhbmdlVmFsdWUgPSBzaW1wbGVSYW5nZUhlYWRlclZhbHVlKHJhbmdlSGVhZGVyLCB0cnVlKVxuXG4gICAgICAgIC8vIDQuIElmIHJhbmdlVmFsdWUgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgICBpZiAocmFuZ2VWYWx1ZSA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdmYWlsZWQgdG8gZmV0Y2ggdGhlIGRhdGEgVVJMJykpXG4gICAgICAgIH1cblxuICAgICAgICAvLyA1LiBMZXQgKHJhbmdlU3RhcnQsIHJhbmdlRW5kKSBiZSByYW5nZVZhbHVlLlxuICAgICAgICBsZXQgeyByYW5nZVN0YXJ0VmFsdWU6IHJhbmdlU3RhcnQsIHJhbmdlRW5kVmFsdWU6IHJhbmdlRW5kIH0gPSByYW5nZVZhbHVlXG5cbiAgICAgICAgLy8gNi4gSWYgcmFuZ2VTdGFydCBpcyBudWxsOlxuICAgICAgICAvLyA3LiBPdGhlcndpc2U6XG4gICAgICAgIGlmIChyYW5nZVN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gMS4gU2V0IHJhbmdlU3RhcnQgdG8gZnVsbExlbmd0aCDiiJIgcmFuZ2VFbmQuXG4gICAgICAgICAgcmFuZ2VTdGFydCA9IGZ1bGxMZW5ndGggLSByYW5nZUVuZFxuXG4gICAgICAgICAgLy8gMi4gU2V0IHJhbmdlRW5kIHRvIHJhbmdlU3RhcnQgKyByYW5nZUVuZCDiiJIgMS5cbiAgICAgICAgICByYW5nZUVuZCA9IHJhbmdlU3RhcnQgKyByYW5nZUVuZCAtIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAxLiBJZiByYW5nZVN0YXJ0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBmdWxsTGVuZ3RoLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICAgICAgaWYgKHJhbmdlU3RhcnQgPj0gZnVsbExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdSYW5nZSBzdGFydCBpcyBncmVhdGVyIHRoYW4gdGhlIGJsb2JcXCdzIHNpemUuJykpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gMi4gSWYgcmFuZ2VFbmQgaXMgbnVsbCBvciByYW5nZUVuZCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gZnVsbExlbmd0aCwgdGhlbiBzZXRcbiAgICAgICAgICAvLyAgICByYW5nZUVuZCB0byBmdWxsTGVuZ3RoIOKIkiAxLlxuICAgICAgICAgIGlmIChyYW5nZUVuZCA9PT0gbnVsbCB8fCByYW5nZUVuZCA+PSBmdWxsTGVuZ3RoKSB7XG4gICAgICAgICAgICByYW5nZUVuZCA9IGZ1bGxMZW5ndGggLSAxXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gOC4gTGV0IHNsaWNlZEJsb2IgYmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyBzbGljZSBibG9iIGdpdmVuIGJsb2IsIHJhbmdlU3RhcnQsXG4gICAgICAgIC8vICAgIHJhbmdlRW5kICsgMSwgYW5kIHR5cGUuXG4gICAgICAgIGNvbnN0IHNsaWNlZEJsb2IgPSBibG9iLnNsaWNlKHJhbmdlU3RhcnQsIHJhbmdlRW5kLCB0eXBlKVxuXG4gICAgICAgIC8vIDkuIExldCBzbGljZWRCb2R5V2l0aFR5cGUgYmUgdGhlIHJlc3VsdCBvZiBzYWZlbHkgZXh0cmFjdGluZyBzbGljZWRCbG9iLlxuICAgICAgICAvLyBOb3RlOiBzYW1lIHJlYXNvbiBhcyBtZW50aW9uZWQgYWJvdmUgYXMgdG8gd2h5IHdlIHVzZSBleHRyYWN0Qm9keVxuICAgICAgICBjb25zdCBzbGljZWRCb2R5V2l0aFR5cGUgPSBleHRyYWN0Qm9keShzbGljZWRCbG9iKVxuXG4gICAgICAgIC8vIDEwLiBTZXQgcmVzcG9uc2XigJlzIGJvZHkgdG8gc2xpY2VkQm9keVdpdGhUeXBl4oCZcyBib2R5LlxuICAgICAgICByZXNwb25zZS5ib2R5ID0gc2xpY2VkQm9keVdpdGhUeXBlWzBdXG5cbiAgICAgICAgLy8gMTEuIExldCBzZXJpYWxpemVkU2xpY2VkTGVuZ3RoIGJlIHNsaWNlZEJsb2LigJlzIHNpemUsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZC5cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZFNsaWNlZExlbmd0aCA9IGlzb21vcnBoaWNFbmNvZGUoYCR7c2xpY2VkQmxvYi5zaXplfWApXG5cbiAgICAgICAgLy8gMTIuIExldCBjb250ZW50UmFuZ2UgYmUgdGhlIHJlc3VsdCBvZiBpbnZva2luZyBidWlsZCBhIGNvbnRlbnQgcmFuZ2UgZ2l2ZW4gcmFuZ2VTdGFydCxcbiAgICAgICAgLy8gICAgIHJhbmdlRW5kLCBhbmQgZnVsbExlbmd0aC5cbiAgICAgICAgY29uc3QgY29udGVudFJhbmdlID0gYnVpbGRDb250ZW50UmFuZ2UocmFuZ2VTdGFydCwgcmFuZ2VFbmQsIGZ1bGxMZW5ndGgpXG5cbiAgICAgICAgLy8gMTMuIFNldCByZXNwb25zZeKAmXMgc3RhdHVzIHRvIDIwNi5cbiAgICAgICAgcmVzcG9uc2Uuc3RhdHVzID0gMjA2XG5cbiAgICAgICAgLy8gMTQuIFNldCByZXNwb25zZeKAmXMgc3RhdHVzIG1lc3NhZ2UgdG8gYFBhcnRpYWwgQ29udGVudGAuXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQgPSAnUGFydGlhbCBDb250ZW50J1xuXG4gICAgICAgIC8vIDE1LiBTZXQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0IHRvIMKrIChgQ29udGVudC1MZW5ndGhgLCBzZXJpYWxpemVkU2xpY2VkTGVuZ3RoKSxcbiAgICAgICAgLy8gICAgIChgQ29udGVudC1UeXBlYCwgdHlwZSksIChgQ29udGVudC1SYW5nZWAsIGNvbnRlbnRSYW5nZSkgwrsuXG4gICAgICAgIHJlc3BvbnNlLmhlYWRlcnNMaXN0LnNldCgnY29udGVudC1sZW5ndGgnLCBzZXJpYWxpemVkU2xpY2VkTGVuZ3RoLCB0cnVlKVxuICAgICAgICByZXNwb25zZS5oZWFkZXJzTGlzdC5zZXQoJ2NvbnRlbnQtdHlwZScsIHR5cGUsIHRydWUpXG4gICAgICAgIHJlc3BvbnNlLmhlYWRlcnNMaXN0LnNldCgnY29udGVudC1yYW5nZScsIGNvbnRlbnRSYW5nZSwgdHJ1ZSlcbiAgICAgIH1cblxuICAgICAgLy8gMTAuIFJldHVybiByZXNwb25zZS5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpXG4gICAgfVxuICAgIGNhc2UgJ2RhdGE6Jzoge1xuICAgICAgLy8gMS4gTGV0IGRhdGFVUkxTdHJ1Y3QgYmUgdGhlIHJlc3VsdCBvZiBydW5uaW5nIHRoZVxuICAgICAgLy8gICAgZGF0YTogVVJMIHByb2Nlc3NvciBvbiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgICAgIGNvbnN0IGN1cnJlbnRVUkwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuICAgICAgY29uc3QgZGF0YVVSTFN0cnVjdCA9IGRhdGFVUkxQcm9jZXNzb3IoY3VycmVudFVSTClcblxuICAgICAgLy8gMi4gSWYgZGF0YVVSTFN0cnVjdCBpcyBmYWlsdXJlLCB0aGVuIHJldHVybiBhXG4gICAgICAvLyAgICBuZXR3b3JrIGVycm9yLlxuICAgICAgaWYgKGRhdGFVUkxTdHJ1Y3QgPT09ICdmYWlsdXJlJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2ZhaWxlZCB0byBmZXRjaCB0aGUgZGF0YSBVUkwnKSlcbiAgICAgIH1cblxuICAgICAgLy8gMy4gTGV0IG1pbWVUeXBlIGJlIGRhdGFVUkxTdHJ1Y3TigJlzIE1JTUUgdHlwZSwgc2VyaWFsaXplZC5cbiAgICAgIGNvbnN0IG1pbWVUeXBlID0gc2VyaWFsaXplQU1pbWVUeXBlKGRhdGFVUkxTdHJ1Y3QubWltZVR5cGUpXG5cbiAgICAgIC8vIDQuIFJldHVybiBhIHJlc3BvbnNlIHdob3NlIHN0YXR1cyBtZXNzYWdlIGlzIGBPS2AsXG4gICAgICAvLyAgICBoZWFkZXIgbGlzdCBpcyDCqyAoYENvbnRlbnQtVHlwZWAsIG1pbWVUeXBlKSDCuyxcbiAgICAgIC8vICAgIGFuZCBib2R5IGlzIGRhdGFVUkxTdHJ1Y3TigJlzIGJvZHkgYXMgYSBib2R5LlxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlUmVzcG9uc2Uoe1xuICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgICAgICBoZWFkZXJzTGlzdDogW1xuICAgICAgICAgIFsnY29udGVudC10eXBlJywgeyBuYW1lOiAnQ29udGVudC1UeXBlJywgdmFsdWU6IG1pbWVUeXBlIH1dXG4gICAgICAgIF0sXG4gICAgICAgIGJvZHk6IHNhZmVseUV4dHJhY3RCb2R5KGRhdGFVUkxTdHJ1Y3QuYm9keSlbMF1cbiAgICAgIH0pKVxuICAgIH1cbiAgICBjYXNlICdmaWxlOic6IHtcbiAgICAgIC8vIEZvciBub3csIHVuZm9ydHVuYXRlIGFzIGl0IGlzLCBmaWxlIFVSTHMgYXJlIGxlZnQgYXMgYW4gZXhlcmNpc2UgZm9yIHRoZSByZWFkZXIuXG4gICAgICAvLyBXaGVuIGluIGRvdWJ0LCByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdub3QgaW1wbGVtZW50ZWQuLi4geWV0Li4uJykpXG4gICAgfVxuICAgIGNhc2UgJ2h0dHA6JzpcbiAgICBjYXNlICdodHRwczonOiB7XG4gICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAgZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG5cbiAgICAgIHJldHVybiBodHRwRmV0Y2goZmV0Y2hQYXJhbXMpXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiBtYWtlTmV0d29ya0Vycm9yKGVycikpXG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcigndW5rbm93biBzY2hlbWUnKSlcbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZpbmFsaXplLXJlc3BvbnNlXG5mdW5jdGlvbiBmaW5hbGl6ZVJlc3BvbnNlIChmZXRjaFBhcmFtcywgcmVzcG9uc2UpIHtcbiAgLy8gMS4gU2V0IGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBkb25lIGZsYWcuXG4gIGZldGNoUGFyYW1zLnJlcXVlc3QuZG9uZSA9IHRydWVcblxuICAvLyAyLCBJZiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZSBkb25lIGlzIG5vdCBudWxsLCB0aGVuIHF1ZXVlIGEgZmV0Y2hcbiAgLy8gdGFzayB0byBydW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2UgZG9uZSBnaXZlbiByZXNwb25zZSwgd2l0aFxuICAvLyBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbi5cbiAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZURvbmUgIT0gbnVsbCkge1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZURvbmUocmVzcG9uc2UpKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmZXRjaC1maW5hbGVcbmZ1bmN0aW9uIGZldGNoRmluYWxlIChmZXRjaFBhcmFtcywgcmVzcG9uc2UpIHtcbiAgLy8gMS4gTGV0IHRpbWluZ0luZm8gYmUgZmV0Y2hQYXJhbXPigJlzIHRpbWluZyBpbmZvLlxuICBsZXQgdGltaW5nSW5mbyA9IGZldGNoUGFyYW1zLnRpbWluZ0luZm9cblxuICAvLyAyLiBJZiByZXNwb25zZSBpcyBub3QgYSBuZXR3b3JrIGVycm9yIGFuZCBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgY2xpZW50IGlzIGEgc2VjdXJlIGNvbnRleHQsXG4gIC8vICAgIHRoZW4gc2V0IHRpbWluZ0luZm/igJlzIHNlcnZlci10aW1pbmcgaGVhZGVycyB0byB0aGUgcmVzdWx0IG9mIGdldHRpbmcsIGRlY29kaW5nLCBhbmQgc3BsaXR0aW5nXG4gIC8vICAgIGBTZXJ2ZXItVGltaW5nYCBmcm9tIHJlc3BvbnNl4oCZcyBpbnRlcm5hbCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gIC8vIFRPRE9cblxuICAvLyAzLiBMZXQgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IGJlIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gIGNvbnN0IHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSA9ICgpID0+IHtcbiAgICAvLyAxLiBMZXQgdW5zYWZlRW5kVGltZSBiZSB0aGUgdW5zYWZlIHNoYXJlZCBjdXJyZW50IHRpbWUuXG4gICAgY29uc3QgdW5zYWZlRW5kVGltZSA9IERhdGUubm93KCkgLy8gP1xuXG4gICAgLy8gMi4gSWYgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGRlc3RpbmF0aW9uIGlzIFwiZG9jdW1lbnRcIiwgdGhlbiBzZXQgZmV0Y2hQYXJhbXPigJlzIGNvbnRyb2xsZXLigJlzXG4gICAgLy8gICAgZnVsbCB0aW1pbmcgaW5mbyB0byBmZXRjaFBhcmFtc+KAmXMgdGltaW5nIGluZm8uXG4gICAgaWYgKGZldGNoUGFyYW1zLnJlcXVlc3QuZGVzdGluYXRpb24gPT09ICdkb2N1bWVudCcpIHtcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZnVsbFRpbWluZ0luZm8gPSB0aW1pbmdJbmZvXG4gICAgfVxuXG4gICAgLy8gMy4gU2V0IGZldGNoUGFyYW1z4oCZcyBjb250cm9sbGVy4oCZcyByZXBvcnQgdGltaW5nIHN0ZXBzIHRvIHRoZSBmb2xsb3dpbmcgc3RlcHMgZ2l2ZW4gYSBnbG9iYWwgb2JqZWN0IGdsb2JhbDpcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnJlcG9ydFRpbWluZ1N0ZXBzID0gKCkgPT4ge1xuICAgICAgLy8gMS4gSWYgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIFVSTOKAmXMgc2NoZW1lIGlzIG5vdCBhbiBIVFRQKFMpIHNjaGVtZSwgdGhlbiByZXR1cm4uXG4gICAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKGZldGNoUGFyYW1zLnJlcXVlc3QudXJsKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMi4gU2V0IHRpbWluZ0luZm/igJlzIGVuZCB0aW1lIHRvIHRoZSByZWxhdGl2ZSBoaWdoIHJlc29sdXRpb24gdGltZSBnaXZlbiB1bnNhZmVFbmRUaW1lIGFuZCBnbG9iYWwuXG4gICAgICB0aW1pbmdJbmZvLmVuZFRpbWUgPSB1bnNhZmVFbmRUaW1lXG5cbiAgICAgIC8vIDMuIExldCBjYWNoZVN0YXRlIGJlIHJlc3BvbnNl4oCZcyBjYWNoZSBzdGF0ZS5cbiAgICAgIGxldCBjYWNoZVN0YXRlID0gcmVzcG9uc2UuY2FjaGVTdGF0ZVxuXG4gICAgICAvLyA0LiBMZXQgYm9keUluZm8gYmUgcmVzcG9uc2XigJlzIGJvZHkgaW5mby5cbiAgICAgIGNvbnN0IGJvZHlJbmZvID0gcmVzcG9uc2UuYm9keUluZm9cblxuICAgICAgLy8gNS4gSWYgcmVzcG9uc2XigJlzIHRpbWluZyBhbGxvdyBwYXNzZWQgZmxhZyBpcyBub3Qgc2V0LCB0aGVuIHNldCB0aW1pbmdJbmZvIHRvIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW5cbiAgICAgIC8vICAgIG9wYXF1ZSB0aW1pbmcgaW5mbyBmb3IgdGltaW5nSW5mbyBhbmQgc2V0IGNhY2hlU3RhdGUgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgIGlmICghcmVzcG9uc2UudGltaW5nQWxsb3dQYXNzZWQpIHtcbiAgICAgICAgdGltaW5nSW5mbyA9IGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8odGltaW5nSW5mbylcblxuICAgICAgICBjYWNoZVN0YXRlID0gJydcbiAgICAgIH1cblxuICAgICAgLy8gNi4gTGV0IHJlc3BvbnNlU3RhdHVzIGJlIDAuXG4gICAgICBsZXQgcmVzcG9uc2VTdGF0dXMgPSAwXG5cbiAgICAgIC8vIDcuIElmIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBtb2RlIGlzIG5vdCBcIm5hdmlnYXRlXCIgb3IgcmVzcG9uc2XigJlzIGhhcy1jcm9zcy1vcmlnaW4tcmVkaXJlY3RzIGlzIGZhbHNlOlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnJlcXVlc3QubW9kZSAhPT0gJ25hdmlnYXRvcicgfHwgIXJlc3BvbnNlLmhhc0Nyb3NzT3JpZ2luUmVkaXJlY3RzKSB7XG4gICAgICAgIC8vIDEuIFNldCByZXNwb25zZVN0YXR1cyB0byByZXNwb25zZeKAmXMgc3RhdHVzLlxuICAgICAgICByZXNwb25zZVN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c1xuXG4gICAgICAgIC8vIDIuIExldCBtaW1lVHlwZSBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgYSBNSU1FIHR5cGUgZnJvbSByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gZXh0cmFjdE1pbWVUeXBlKHJlc3BvbnNlLmhlYWRlcnNMaXN0KVxuXG4gICAgICAgIC8vIDMuIElmIG1pbWVUeXBlIGlzIG5vdCBmYWlsdXJlLCB0aGVuIHNldCBib2R5SW5mb+KAmXMgY29udGVudCB0eXBlIHRvIHRoZSByZXN1bHQgb2YgbWluaW1pemluZyBhIHN1cHBvcnRlZCBNSU1FIHR5cGUgZ2l2ZW4gbWltZVR5cGUuXG4gICAgICAgIGlmIChtaW1lVHlwZSAhPT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgICAgYm9keUluZm8uY29udGVudFR5cGUgPSBtaW5pbWl6ZVN1cHBvcnRlZE1pbWVUeXBlKG1pbWVUeXBlKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDguIElmIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBpbml0aWF0b3IgdHlwZSBpcyBub24tbnVsbCwgdGhlbiBtYXJrIHJlc291cmNlIHRpbWluZyBnaXZlbiB0aW1pbmdJbmZvLFxuICAgICAgLy8gICAgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIFVSTCwgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGluaXRpYXRvciB0eXBlLCBnbG9iYWwsIGNhY2hlU3RhdGUsIGJvZHlJbmZvLFxuICAgICAgLy8gICAgYW5kIHJlc3BvbnNlU3RhdHVzLlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnJlcXVlc3QuaW5pdGlhdG9yVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIG1hcmtSZXNvdXJjZVRpbWluZyh0aW1pbmdJbmZvLCBmZXRjaFBhcmFtcy5yZXF1ZXN0LnVybC5ocmVmLCBmZXRjaFBhcmFtcy5yZXF1ZXN0LmluaXRpYXRvclR5cGUsIGdsb2JhbFRoaXMsIGNhY2hlU3RhdGUsIGJvZHlJbmZvLCByZXNwb25zZVN0YXR1cylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LiBMZXQgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5VGFzayBiZSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keVRhc2sgPSAoKSA9PiB7XG4gICAgICAvLyAxLiBTZXQgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGRvbmUgZmxhZy5cbiAgICAgIGZldGNoUGFyYW1zLnJlcXVlc3QuZG9uZSA9IHRydWVcblxuICAgICAgLy8gMi4gSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2UgZW5kLW9mLWJvZHkgaXMgbm9uLW51bGwsIHRoZW4gcnVuIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzXG4gICAgICAvLyAgICByZXNwb25zZSBlbmQtb2YtYm9keSBnaXZlbiByZXNwb25zZS5cbiAgICAgIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgIT0gbnVsbCkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkocmVzcG9uc2UpKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBJZiBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgaW5pdGlhdG9yIHR5cGUgaXMgbm9uLW51bGwgYW5kIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBjbGllbnTigJlzXG4gICAgICAvLyAgICBnbG9iYWwgb2JqZWN0IGlzIGZldGNoUGFyYW1z4oCZcyB0YXNrIGRlc3RpbmF0aW9uLCB0aGVuIHJ1biBmZXRjaFBhcmFtc+KAmXMgY29udHJvbGxlcuKAmXMgcmVwb3J0XG4gICAgICAvLyAgICB0aW1pbmcgc3RlcHMgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGNsaWVudOKAmXMgZ2xvYmFsIG9iamVjdC5cbiAgICAgIGlmIChmZXRjaFBhcmFtcy5yZXF1ZXN0LmluaXRpYXRvclR5cGUgIT0gbnVsbCkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnJlcG9ydFRpbWluZ1N0ZXBzKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LiBRdWV1ZSBhIGZldGNoIHRhc2sgdG8gcnVuIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keVRhc2sgd2l0aCBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvblxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keVRhc2soKSlcbiAgfVxuXG4gIC8vIDQuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGlzIG5vbi1udWxsLCB0aGVuIHF1ZXVlIGEgZmV0Y2ggdGFzayB0byBydW4gZmV0Y2hQYXJhbXPigJlzXG4gIC8vICAgIHByb2Nlc3MgcmVzcG9uc2UgZ2l2ZW4gcmVzcG9uc2UsIHdpdGggZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZShyZXNwb25zZSlcbiAgICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZSA9IG51bGxcbiAgICB9KVxuICB9XG5cbiAgLy8gNS4gTGV0IGludGVybmFsUmVzcG9uc2UgYmUgcmVzcG9uc2UsIGlmIHJlc3BvbnNlIGlzIGEgbmV0d29yayBlcnJvcjsgb3RoZXJ3aXNlIHJlc3BvbnNl4oCZcyBpbnRlcm5hbCByZXNwb25zZS5cbiAgY29uc3QgaW50ZXJuYWxSZXNwb25zZSA9IHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicgPyByZXNwb25zZSA6IChyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlID8/IHJlc3BvbnNlKVxuXG4gIC8vIDYuIElmIGludGVybmFsUmVzcG9uc2XigJlzIGJvZHkgaXMgbnVsbCwgdGhlbiBydW4gcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LlxuICAvLyA3LiBPdGhlcndpc2U6XG4gIGlmIChpbnRlcm5hbFJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSgpXG4gIH0gZWxzZSB7XG4gICAgLy8gbWNvbGxpbmE6IGFsbCB0aGUgZm9sbG93aW5nIHN0ZXBzIG9mIHRoZSBzcGVjcyBhcmUgc2tpcHBlZC5cbiAgICAvLyBUaGUgaW50ZXJuYWwgdHJhbnNmb3JtIHN0cmVhbSBpcyBub3QgbmVlZGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9wdWxsLzMwOTMjaXNzdWVjb21tZW50LTIwNTAxOTg1NDFcblxuICAgIC8vIDEuIExldCB0cmFuc2Zvcm1TdHJlYW0gYmUgYSBuZXcgVHJhbnNmb3JtU3RyZWFtLlxuICAgIC8vIDIuIExldCBpZGVudGl0eVRyYW5zZm9ybUFsZ29yaXRobSBiZSBhbiBhbGdvcml0aG0gd2hpY2gsIGdpdmVuIGNodW5rLCBlbnF1ZXVlcyBjaHVuayBpbiB0cmFuc2Zvcm1TdHJlYW0uXG4gICAgLy8gMy4gU2V0IHVwIHRyYW5zZm9ybVN0cmVhbSB3aXRoIHRyYW5zZm9ybUFsZ29yaXRobSBzZXQgdG8gaWRlbnRpdHlUcmFuc2Zvcm1BbGdvcml0aG0gYW5kIGZsdXNoQWxnb3JpdGhtXG4gICAgLy8gICAgc2V0IHRvIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keS5cbiAgICAvLyA0LiBTZXQgaW50ZXJuYWxSZXNwb25zZeKAmXMgYm9keeKAmXMgc3RyZWFtIHRvIHRoZSByZXN1bHQgb2YgaW50ZXJuYWxSZXNwb25zZeKAmXMgYm9keeKAmXMgc3RyZWFtIHBpcGVkIHRocm91Z2ggdHJhbnNmb3JtU3RyZWFtLlxuXG4gICAgZmluaXNoZWQoaW50ZXJuYWxSZXNwb25zZS5ib2R5LnN0cmVhbSwgKCkgPT4ge1xuICAgICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5KClcbiAgICB9KVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLWZldGNoXG5hc3luYyBmdW5jdGlvbiBodHRwRmV0Y2ggKGZldGNoUGFyYW1zKSB7XG4gIC8vIDEuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gZmV0Y2hQYXJhbXMucmVxdWVzdFxuXG4gIC8vIDIuIExldCByZXNwb25zZSBiZSBudWxsLlxuICBsZXQgcmVzcG9uc2UgPSBudWxsXG5cbiAgLy8gMy4gTGV0IGFjdHVhbFJlc3BvbnNlIGJlIG51bGwuXG4gIGxldCBhY3R1YWxSZXNwb25zZSA9IG51bGxcblxuICAvLyA0LiBMZXQgdGltaW5nSW5mbyBiZSBmZXRjaFBhcmFtc+KAmXMgdGltaW5nIGluZm8uXG4gIGNvbnN0IHRpbWluZ0luZm8gPSBmZXRjaFBhcmFtcy50aW1pbmdJbmZvXG5cbiAgLy8gNS4gSWYgcmVxdWVzdOKAmXMgc2VydmljZS13b3JrZXJzIG1vZGUgaXMgXCJhbGxcIiwgdGhlbjpcbiAgaWYgKHJlcXVlc3Quc2VydmljZVdvcmtlcnMgPT09ICdhbGwnKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbiAgLy8gNi4gSWYgcmVzcG9uc2UgaXMgbnVsbCwgdGhlbjpcbiAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgLy8gMS4gSWYgbWFrZUNPUlNQcmVmbGlnaHQgaXMgdHJ1ZSBhbmQgb25lIG9mIHRoZXNlIGNvbmRpdGlvbnMgaXMgdHJ1ZTpcbiAgICAvLyBUT0RPXG5cbiAgICAvLyAyLiBJZiByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlIGlzIFwiZm9sbG93XCIsIHRoZW4gc2V0IHJlcXVlc3TigJlzXG4gICAgLy8gc2VydmljZS13b3JrZXJzIG1vZGUgdG8gXCJub25lXCIuXG4gICAgaWYgKHJlcXVlc3QucmVkaXJlY3QgPT09ICdmb2xsb3cnKSB7XG4gICAgICByZXF1ZXN0LnNlcnZpY2VXb3JrZXJzID0gJ25vbmUnXG4gICAgfVxuXG4gICAgLy8gMy4gU2V0IHJlc3BvbnNlIGFuZCBhY3R1YWxSZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG4gICAgYWN0dWFsUmVzcG9uc2UgPSByZXNwb25zZSA9IGF3YWl0IGh0dHBOZXR3b3JrT3JDYWNoZUZldGNoKGZldGNoUGFyYW1zKVxuXG4gICAgLy8gNC4gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJjb3JzXCIgYW5kIGEgQ09SUyBjaGVja1xuICAgIC8vIGZvciByZXF1ZXN0IGFuZCByZXNwb25zZSByZXR1cm5zIGZhaWx1cmUsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICBpZiAoXG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJyAmJlxuICAgICAgY29yc0NoZWNrKHJlcXVlc3QsIHJlc3BvbnNlKSA9PT0gJ2ZhaWx1cmUnXG4gICAgKSB7XG4gICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcignY29ycyBmYWlsdXJlJylcbiAgICB9XG5cbiAgICAvLyA1LiBJZiB0aGUgVEFPIGNoZWNrIGZvciByZXF1ZXN0IGFuZCByZXNwb25zZSByZXR1cm5zIGZhaWx1cmUsIHRoZW4gc2V0XG4gICAgLy8gcmVxdWVzdOKAmXMgdGltaW5nIGFsbG93IGZhaWxlZCBmbGFnLlxuICAgIGlmIChUQU9DaGVjayhyZXF1ZXN0LCByZXNwb25zZSkgPT09ICdmYWlsdXJlJykge1xuICAgICAgcmVxdWVzdC50aW1pbmdBbGxvd0ZhaWxlZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICAvLyA3LiBJZiBlaXRoZXIgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgb3IgcmVzcG9uc2XigJlzIHR5cGVcbiAgLy8gaXMgXCJvcGFxdWVcIiwgYW5kIHRoZSBjcm9zcy1vcmlnaW4gcmVzb3VyY2UgcG9saWN5IGNoZWNrIHdpdGhcbiAgLy8gcmVxdWVzdOKAmXMgb3JpZ2luLCByZXF1ZXN04oCZcyBjbGllbnQsIHJlcXVlc3TigJlzIGRlc3RpbmF0aW9uLFxuICAvLyBhbmQgYWN0dWFsUmVzcG9uc2UgcmV0dXJucyBibG9ja2VkLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnb3BhcXVlJyB8fCByZXNwb25zZS50eXBlID09PSAnb3BhcXVlJykgJiZcbiAgICBjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2soXG4gICAgICByZXF1ZXN0Lm9yaWdpbixcbiAgICAgIHJlcXVlc3QuY2xpZW50LFxuICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbixcbiAgICAgIGFjdHVhbFJlc3BvbnNlXG4gICAgKSA9PT0gJ2Jsb2NrZWQnXG4gICkge1xuICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdibG9ja2VkJylcbiAgfVxuXG4gIC8vIDguIElmIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgYSByZWRpcmVjdCBzdGF0dXMsIHRoZW46XG4gIGlmIChyZWRpcmVjdFN0YXR1c1NldC5oYXMoYWN0dWFsUmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIC8vIDEuIElmIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgbm90IDMwMywgcmVxdWVzdOKAmXMgYm9keSBpcyBub3QgbnVsbCxcbiAgICAvLyBhbmQgdGhlIGNvbm5lY3Rpb24gdXNlcyBIVFRQLzIsIHRoZW4gdXNlciBhZ2VudHMgbWF5LCBhbmQgYXJlIGV2ZW5cbiAgICAvLyBlbmNvdXJhZ2VkIHRvLCB0cmFuc21pdCBhbiBSU1RfU1RSRUFNIGZyYW1lLlxuICAgIC8vIFNlZSwgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9mZXRjaC9pc3N1ZXMvMTI4OFxuICAgIGlmIChyZXF1ZXN0LnJlZGlyZWN0ICE9PSAnbWFudWFsJykge1xuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3kodW5kZWZpbmVkLCBmYWxzZSlcbiAgICB9XG5cbiAgICAvLyAyLiBTd2l0Y2ggb24gcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZTpcbiAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2Vycm9yJykge1xuICAgICAgLy8gU2V0IHJlc3BvbnNlIHRvIGEgbmV0d29yayBlcnJvci5cbiAgICAgIHJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcigndW5leHBlY3RlZCByZWRpcmVjdCcpXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSAnbWFudWFsJykge1xuICAgICAgLy8gU2V0IHJlc3BvbnNlIHRvIGFuIG9wYXF1ZS1yZWRpcmVjdCBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSBpbnRlcm5hbFxuICAgICAgLy8gcmVzcG9uc2UgaXMgYWN0dWFsUmVzcG9uc2UuXG4gICAgICAvLyBOT1RFKHNwZWMpOiBPbiB0aGUgd2ViIHRoaXMgd291bGQgcmV0dXJuIGFuIGBvcGFxdWVyZWRpcmVjdGAgcmVzcG9uc2UsXG4gICAgICAvLyBidXQgdGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2Ugc2VydmVyIHNpZGUuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzExOTMuXG4gICAgICByZXNwb25zZSA9IGFjdHVhbFJlc3BvbnNlXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSAnZm9sbG93Jykge1xuICAgICAgLy8gU2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQLXJlZGlyZWN0IGZldGNoIGdpdmVuXG4gICAgICAvLyBmZXRjaFBhcmFtcyBhbmQgcmVzcG9uc2UuXG4gICAgICByZXNwb25zZSA9IGF3YWl0IGh0dHBSZWRpcmVjdEZldGNoKGZldGNoUGFyYW1zLCByZXNwb25zZSlcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIC8vIDkuIFNldCByZXNwb25zZeKAmXMgdGltaW5nIGluZm8gdG8gdGltaW5nSW5mby5cbiAgcmVzcG9uc2UudGltaW5nSW5mbyA9IHRpbWluZ0luZm9cblxuICAvLyAxMC4gUmV0dXJuIHJlc3BvbnNlLlxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtcmVkaXJlY3QtZmV0Y2hcbmZ1bmN0aW9uIGh0dHBSZWRpcmVjdEZldGNoIChmZXRjaFBhcmFtcywgcmVzcG9uc2UpIHtcbiAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0XG5cbiAgLy8gMi4gTGV0IGFjdHVhbFJlc3BvbnNlIGJlIHJlc3BvbnNlLCBpZiByZXNwb25zZSBpcyBub3QgYSBmaWx0ZXJlZCByZXNwb25zZSxcbiAgLy8gYW5kIHJlc3BvbnNl4oCZcyBpbnRlcm5hbCByZXNwb25zZSBvdGhlcndpc2UuXG4gIGNvbnN0IGFjdHVhbFJlc3BvbnNlID0gcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZVxuICAgID8gcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZVxuICAgIDogcmVzcG9uc2VcblxuICAvLyAzLiBMZXQgbG9jYXRpb25VUkwgYmUgYWN0dWFsUmVzcG9uc2XigJlzIGxvY2F0aW9uIFVSTCBnaXZlbiByZXF1ZXN04oCZcyBjdXJyZW50XG4gIC8vIFVSTOKAmXMgZnJhZ21lbnQuXG4gIGxldCBsb2NhdGlvblVSTFxuXG4gIHRyeSB7XG4gICAgbG9jYXRpb25VUkwgPSByZXNwb25zZUxvY2F0aW9uVVJMKFxuICAgICAgYWN0dWFsUmVzcG9uc2UsXG4gICAgICByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KS5oYXNoXG4gICAgKVxuXG4gICAgLy8gNC4gSWYgbG9jYXRpb25VUkwgaXMgbnVsbCwgdGhlbiByZXR1cm4gcmVzcG9uc2UuXG4gICAgaWYgKGxvY2F0aW9uVVJMID09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXNwb25zZVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gNS4gSWYgbG9jYXRpb25VUkwgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcihlcnIpKVxuICB9XG5cbiAgLy8gNi4gSWYgbG9jYXRpb25VUkzigJlzIHNjaGVtZSBpcyBub3QgYW4gSFRUUChTKSBzY2hlbWUsIHRoZW4gcmV0dXJuIGEgbmV0d29ya1xuICAvLyBlcnJvci5cbiAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShsb2NhdGlvblVSTCkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ1VSTCBzY2hlbWUgbXVzdCBiZSBhIEhUVFAoUykgc2NoZW1lJykpXG4gIH1cblxuICAvLyA3LiBJZiByZXF1ZXN04oCZcyByZWRpcmVjdCBjb3VudCBpcyAyMCwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAocmVxdWVzdC5yZWRpcmVjdENvdW50ID09PSAyMCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcigncmVkaXJlY3QgY291bnQgZXhjZWVkZWQnKSlcbiAgfVxuXG4gIC8vIDguIEluY3JlYXNlIHJlcXVlc3TigJlzIHJlZGlyZWN0IGNvdW50IGJ5IDEuXG4gIHJlcXVlc3QucmVkaXJlY3RDb3VudCArPSAxXG5cbiAgLy8gOS4gSWYgcmVxdWVzdOKAmXMgbW9kZSBpcyBcImNvcnNcIiwgbG9jYXRpb25VUkwgaW5jbHVkZXMgY3JlZGVudGlhbHMsIGFuZFxuICAvLyByZXF1ZXN04oCZcyBvcmlnaW4gaXMgbm90IHNhbWUgb3JpZ2luIHdpdGggbG9jYXRpb25VUkzigJlzIG9yaWdpbiwgdGhlbiByZXR1cm5cbiAgLy8gIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIHJlcXVlc3QubW9kZSA9PT0gJ2NvcnMnICYmXG4gICAgKGxvY2F0aW9uVVJMLnVzZXJuYW1lIHx8IGxvY2F0aW9uVVJMLnBhc3N3b3JkKSAmJlxuICAgICFzYW1lT3JpZ2luKHJlcXVlc3QsIGxvY2F0aW9uVVJMKVxuICApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2Nyb3NzIG9yaWdpbiBub3QgYWxsb3dlZCBmb3IgcmVxdWVzdCBtb2RlIFwiY29yc1wiJykpXG4gIH1cblxuICAvLyAxMC4gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJjb3JzXCIgYW5kIGxvY2F0aW9uVVJMIGluY2x1ZGVzXG4gIC8vIGNyZWRlbnRpYWxzLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJyAmJlxuICAgIChsb2NhdGlvblVSTC51c2VybmFtZSB8fCBsb2NhdGlvblVSTC5wYXNzd29yZClcbiAgKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKFxuICAgICAgJ1VSTCBjYW5ub3QgY29udGFpbiBjcmVkZW50aWFscyBmb3IgcmVxdWVzdCBtb2RlIFwiY29yc1wiJ1xuICAgICkpXG4gIH1cblxuICAvLyAxMS4gSWYgYWN0dWFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyBub3QgMzAzLCByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLFxuICAvLyBhbmQgcmVxdWVzdOKAmXMgYm9keeKAmXMgc291cmNlIGlzIG51bGwsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIGFjdHVhbFJlc3BvbnNlLnN0YXR1cyAhPT0gMzAzICYmXG4gICAgcmVxdWVzdC5ib2R5ICE9IG51bGwgJiZcbiAgICByZXF1ZXN0LmJvZHkuc291cmNlID09IG51bGxcbiAgKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCkpXG4gIH1cblxuICAvLyAxMi4gSWYgb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZVxuICAvLyAtIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMzAxIG9yIDMwMiBhbmQgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIGBQT1NUYFxuICAvLyAtIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMzAzIGFuZCByZXF1ZXN04oCZcyBtZXRob2QgaXMgbm90IGBHRVRgIG9yIGBIRUFEYFxuICBpZiAoXG4gICAgKFszMDEsIDMwMl0uaW5jbHVkZXMoYWN0dWFsUmVzcG9uc2Uuc3RhdHVzKSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnKSB8fFxuICAgIChhY3R1YWxSZXNwb25zZS5zdGF0dXMgPT09IDMwMyAmJlxuICAgICAgIUdFVF9PUl9IRUFELmluY2x1ZGVzKHJlcXVlc3QubWV0aG9kKSlcbiAgKSB7XG4gICAgLy8gdGhlbjpcbiAgICAvLyAxLiBTZXQgcmVxdWVzdOKAmXMgbWV0aG9kIHRvIGBHRVRgIGFuZCByZXF1ZXN04oCZcyBib2R5IHRvIG51bGwuXG4gICAgcmVxdWVzdC5tZXRob2QgPSAnR0VUJ1xuICAgIHJlcXVlc3QuYm9keSA9IG51bGxcblxuICAgIC8vIDIuIEZvciBlYWNoIGhlYWRlck5hbWUgb2YgcmVxdWVzdC1ib2R5LWhlYWRlciBuYW1lLCBkZWxldGUgaGVhZGVyTmFtZSBmcm9tXG4gICAgLy8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgZm9yIChjb25zdCBoZWFkZXJOYW1lIG9mIHJlcXVlc3RCb2R5SGVhZGVyKSB7XG4gICAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZShoZWFkZXJOYW1lKVxuICAgIH1cbiAgfVxuXG4gIC8vIDEzLiBJZiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgb3JpZ2luIGlzIG5vdCBzYW1lIG9yaWdpbiB3aXRoIGxvY2F0aW9uVVJM4oCZc1xuICAvLyAgICAgb3JpZ2luLCB0aGVuIGZvciBlYWNoIGhlYWRlck5hbWUgb2YgQ09SUyBub24td2lsZGNhcmQgcmVxdWVzdC1oZWFkZXIgbmFtZSxcbiAgLy8gICAgIGRlbGV0ZSBoZWFkZXJOYW1lIGZyb20gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmICghc2FtZU9yaWdpbihyZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KSwgbG9jYXRpb25VUkwpKSB7XG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvcnMtbm9uLXdpbGRjYXJkLXJlcXVlc3QtaGVhZGVyLW5hbWVcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZSgnYXV0aG9yaXphdGlvbicsIHRydWUpXG5cbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYXV0aGVudGljYXRpb24tZW50cmllc1xuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKCdwcm94eS1hdXRob3JpemF0aW9uJywgdHJ1ZSlcblxuICAgIC8vIFwiQ29va2llXCIgYW5kIFwiSG9zdFwiIGFyZSBmb3JiaWRkZW4gcmVxdWVzdC1oZWFkZXJzLCB3aGljaCB1bmRpY2kgZG9lc24ndCBpbXBsZW1lbnQuXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoJ2Nvb2tpZScsIHRydWUpXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoJ2hvc3QnLCB0cnVlKVxuICB9XG5cbiAgLy8gMTQuIElmIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGJvZHkgdG8gdGhlIGZpcnN0IHJldHVyblxuICAvLyB2YWx1ZSBvZiBzYWZlbHkgZXh0cmFjdGluZyByZXF1ZXN04oCZcyBib2R54oCZcyBzb3VyY2UuXG4gIGlmIChyZXF1ZXN0LmJvZHkgIT0gbnVsbCkge1xuICAgIGFzc2VydChyZXF1ZXN0LmJvZHkuc291cmNlICE9IG51bGwpXG4gICAgcmVxdWVzdC5ib2R5ID0gc2FmZWx5RXh0cmFjdEJvZHkocmVxdWVzdC5ib2R5LnNvdXJjZSlbMF1cbiAgfVxuXG4gIC8vIDE1LiBMZXQgdGltaW5nSW5mbyBiZSBmZXRjaFBhcmFtc+KAmXMgdGltaW5nIGluZm8uXG4gIGNvbnN0IHRpbWluZ0luZm8gPSBmZXRjaFBhcmFtcy50aW1pbmdJbmZvXG5cbiAgLy8gMTYuIFNldCB0aW1pbmdJbmZv4oCZcyByZWRpcmVjdCBlbmQgdGltZSBhbmQgcG9zdC1yZWRpcmVjdCBzdGFydCB0aW1lIHRvIHRoZVxuICAvLyBjb2Fyc2VuZWQgc2hhcmVkIGN1cnJlbnQgdGltZSBnaXZlbiBmZXRjaFBhcmFtc+KAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkXG4gIC8vIGNhcGFiaWxpdHkuXG4gIHRpbWluZ0luZm8ucmVkaXJlY3RFbmRUaW1lID0gdGltaW5nSW5mby5wb3N0UmVkaXJlY3RTdGFydFRpbWUgPVxuICAgIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKGZldGNoUGFyYW1zLmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KVxuXG4gIC8vIDE3LiBJZiB0aW1pbmdJbmZv4oCZcyByZWRpcmVjdCBzdGFydCB0aW1lIGlzIDAsIHRoZW4gc2V0IHRpbWluZ0luZm/igJlzXG4gIC8vICByZWRpcmVjdCBzdGFydCB0aW1lIHRvIHRpbWluZ0luZm/igJlzIHN0YXJ0IHRpbWUuXG4gIGlmICh0aW1pbmdJbmZvLnJlZGlyZWN0U3RhcnRUaW1lID09PSAwKSB7XG4gICAgdGltaW5nSW5mby5yZWRpcmVjdFN0YXJ0VGltZSA9IHRpbWluZ0luZm8uc3RhcnRUaW1lXG4gIH1cblxuICAvLyAxOC4gQXBwZW5kIGxvY2F0aW9uVVJMIHRvIHJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICByZXF1ZXN0LnVybExpc3QucHVzaChsb2NhdGlvblVSTClcblxuICAvLyAxOS4gSW52b2tlIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgb24gcmVkaXJlY3Qgb24gcmVxdWVzdCBhbmRcbiAgLy8gYWN0dWFsUmVzcG9uc2UuXG4gIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QocmVxdWVzdCwgYWN0dWFsUmVzcG9uc2UpXG5cbiAgLy8gMjAuIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgbWFpbiBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcyBhbmQgdHJ1ZS5cbiAgcmV0dXJuIG1haW5GZXRjaChmZXRjaFBhcmFtcywgdHJ1ZSlcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtbmV0d29yay1vci1jYWNoZS1mZXRjaFxuYXN5bmMgZnVuY3Rpb24gaHR0cE5ldHdvcmtPckNhY2hlRmV0Y2ggKFxuICBmZXRjaFBhcmFtcyxcbiAgaXNBdXRoZW50aWNhdGlvbkZldGNoID0gZmFsc2UsXG4gIGlzTmV3Q29ubmVjdGlvbkZldGNoID0gZmFsc2Vcbikge1xuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgaHR0cEZldGNoUGFyYW1zIGJlIG51bGwuXG4gIGxldCBodHRwRmV0Y2hQYXJhbXMgPSBudWxsXG5cbiAgLy8gMy4gTGV0IGh0dHBSZXF1ZXN0IGJlIG51bGwuXG4gIGxldCBodHRwUmVxdWVzdCA9IG51bGxcblxuICAvLyA0LiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDUuIExldCBzdG9yZWRSZXNwb25zZSBiZSBudWxsLlxuICAvLyBUT0RPOiBjYWNoZVxuXG4gIC8vIDYuIExldCBodHRwQ2FjaGUgYmUgbnVsbC5cbiAgY29uc3QgaHR0cENhY2hlID0gbnVsbFxuXG4gIC8vIDcuIExldCB0aGUgcmV2YWxpZGF0aW5nRmxhZyBiZSB1bnNldC5cbiAgY29uc3QgcmV2YWxpZGF0aW5nRmxhZyA9IGZhbHNlXG5cbiAgLy8gOC4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiB0aGUgb25nb2luZyBmZXRjaCBpcyB0ZXJtaW5hdGVkOlxuXG4gIC8vICAgIDEuIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBcIm5vLXdpbmRvd1wiIGFuZCByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlIGlzXG4gIC8vICAgIFwiZXJyb3JcIiwgdGhlbiBzZXQgaHR0cEZldGNoUGFyYW1zIHRvIGZldGNoUGFyYW1zIGFuZCBodHRwUmVxdWVzdCB0b1xuICAvLyAgICByZXF1ZXN0LlxuICBpZiAocmVxdWVzdC53aW5kb3cgPT09ICduby13aW5kb3cnICYmIHJlcXVlc3QucmVkaXJlY3QgPT09ICdlcnJvcicpIHtcbiAgICBodHRwRmV0Y2hQYXJhbXMgPSBmZXRjaFBhcmFtc1xuICAgIGh0dHBSZXF1ZXN0ID0gcmVxdWVzdFxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIFNldCBodHRwUmVxdWVzdCB0byBhIGNsb25lIG9mIHJlcXVlc3QuXG4gICAgaHR0cFJlcXVlc3QgPSBjbG9uZVJlcXVlc3QocmVxdWVzdClcblxuICAgIC8vIDIuIFNldCBodHRwRmV0Y2hQYXJhbXMgdG8gYSBjb3B5IG9mIGZldGNoUGFyYW1zLlxuICAgIGh0dHBGZXRjaFBhcmFtcyA9IHsgLi4uZmV0Y2hQYXJhbXMgfVxuXG4gICAgLy8gMy4gU2V0IGh0dHBGZXRjaFBhcmFtc+KAmXMgcmVxdWVzdCB0byBodHRwUmVxdWVzdC5cbiAgICBodHRwRmV0Y2hQYXJhbXMucmVxdWVzdCA9IGh0dHBSZXF1ZXN0XG4gIH1cblxuICAvLyAgICAzLiBMZXQgaW5jbHVkZUNyZWRlbnRpYWxzIGJlIHRydWUgaWYgb25lIG9mXG4gIGNvbnN0IGluY2x1ZGVDcmVkZW50aWFscyA9XG4gICAgcmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnIHx8XG4gICAgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdzYW1lLW9yaWdpbicgJiZcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2Jhc2ljJylcblxuICAvLyAgICA0LiBMZXQgY29udGVudExlbmd0aCBiZSBodHRwUmVxdWVzdOKAmXMgYm9keeKAmXMgbGVuZ3RoLCBpZiBodHRwUmVxdWVzdOKAmXNcbiAgLy8gICAgYm9keSBpcyBub24tbnVsbDsgb3RoZXJ3aXNlIG51bGwuXG4gIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBodHRwUmVxdWVzdC5ib2R5ID8gaHR0cFJlcXVlc3QuYm9keS5sZW5ndGggOiBudWxsXG5cbiAgLy8gICAgNS4gTGV0IGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSBiZSBudWxsLlxuICBsZXQgY29udGVudExlbmd0aEhlYWRlclZhbHVlID0gbnVsbFxuXG4gIC8vICAgIDYuIElmIGh0dHBSZXF1ZXN04oCZcyBib2R5IGlzIG51bGwgYW5kIGh0dHBSZXF1ZXN04oCZcyBtZXRob2QgaXMgYFBPU1RgIG9yXG4gIC8vICAgIGBQVVRgLCB0aGVuIHNldCBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgdG8gYDBgLlxuICBpZiAoXG4gICAgaHR0cFJlcXVlc3QuYm9keSA9PSBudWxsICYmXG4gICAgWydQT1NUJywgJ1BVVCddLmluY2x1ZGVzKGh0dHBSZXF1ZXN0Lm1ldGhvZClcbiAgKSB7XG4gICAgY29udGVudExlbmd0aEhlYWRlclZhbHVlID0gJzAnXG4gIH1cblxuICAvLyAgICA3LiBJZiBjb250ZW50TGVuZ3RoIGlzIG5vbi1udWxsLCB0aGVuIHNldCBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgdG9cbiAgLy8gICAgY29udGVudExlbmd0aCwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLlxuICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsKSB7XG4gICAgY29udGVudExlbmd0aEhlYWRlclZhbHVlID0gaXNvbW9ycGhpY0VuY29kZShgJHtjb250ZW50TGVuZ3RofWApXG4gIH1cblxuICAvLyAgICA4LiBJZiBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgaXMgbm9uLW51bGwsIHRoZW4gYXBwZW5kXG4gIC8vICAgIGBDb250ZW50LUxlbmd0aGAvY29udGVudExlbmd0aEhlYWRlclZhbHVlIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXJcbiAgLy8gICAgbGlzdC5cbiAgaWYgKGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSAhPSBudWxsKSB7XG4gICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdjb250ZW50LWxlbmd0aCcsIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSwgdHJ1ZSlcbiAgfVxuXG4gIC8vICAgIDkuIElmIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSBpcyBub24tbnVsbCwgdGhlbiBhcHBlbmQgKGBDb250ZW50LUxlbmd0aGAsXG4gIC8vICAgIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSkgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuXG4gIC8vICAgIDEwLiBJZiBjb250ZW50TGVuZ3RoIGlzIG5vbi1udWxsIGFuZCBodHRwUmVxdWVzdOKAmXMga2VlcGFsaXZlIGlzIHRydWUsXG4gIC8vICAgIHRoZW46XG4gIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwgJiYgaHR0cFJlcXVlc3Qua2VlcGFsaXZlKSB7XG4gICAgLy8gTk9URToga2VlcGFsaXZlIGlzIGEgbm9vcCBvdXRzaWRlIG9mIGJyb3dzZXIgY29udGV4dC5cbiAgfVxuXG4gIC8vICAgIDExLiBJZiBodHRwUmVxdWVzdOKAmXMgcmVmZXJyZXIgaXMgYSBVUkwsIHRoZW4gYXBwZW5kXG4gIC8vICAgIGBSZWZlcmVyYC9odHRwUmVxdWVzdOKAmXMgcmVmZXJyZXIsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZCxcbiAgLy8gICAgIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKHdlYmlkbC5pcy5VUkwoaHR0cFJlcXVlc3QucmVmZXJyZXIpKSB7XG4gICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdyZWZlcmVyJywgaXNvbW9ycGhpY0VuY29kZShodHRwUmVxdWVzdC5yZWZlcnJlci5ocmVmKSwgdHJ1ZSlcbiAgfVxuXG4gIC8vICAgIDEyLiBBcHBlbmQgYSByZXF1ZXN0IGBPcmlnaW5gIGhlYWRlciBmb3IgaHR0cFJlcXVlc3QuXG4gIGFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIoaHR0cFJlcXVlc3QpXG5cbiAgLy8gICAgMTMuIEFwcGVuZCB0aGUgRmV0Y2ggbWV0YWRhdGEgaGVhZGVycyBmb3IgaHR0cFJlcXVlc3QuIFtGRVRDSC1NRVRBREFUQV1cbiAgYXBwZW5kRmV0Y2hNZXRhZGF0YShodHRwUmVxdWVzdClcblxuICAvLyAgICAxNC4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYFVzZXItQWdlbnRgLCB0aGVuXG4gIC8vICAgIHVzZXIgYWdlbnRzIHNob3VsZCBhcHBlbmQgYFVzZXItQWdlbnRgL2RlZmF1bHQgYFVzZXItQWdlbnRgIHZhbHVlIHRvXG4gIC8vICAgIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygndXNlci1hZ2VudCcsIHRydWUpKSB7XG4gICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCd1c2VyLWFnZW50JywgZGVmYXVsdFVzZXJBZ2VudCwgdHJ1ZSlcbiAgfVxuXG4gIC8vICAgIDE1LiBJZiBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBcImRlZmF1bHRcIiBhbmQgaHR0cFJlcXVlc3TigJlzIGhlYWRlclxuICAvLyAgICBsaXN0IGNvbnRhaW5zIGBJZi1Nb2RpZmllZC1TaW5jZWAsIGBJZi1Ob25lLU1hdGNoYCxcbiAgLy8gICAgYElmLVVubW9kaWZpZWQtU2luY2VgLCBgSWYtTWF0Y2hgLCBvciBgSWYtUmFuZ2VgLCB0aGVuIHNldFxuICAvLyAgICBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSB0byBcIm5vLXN0b3JlXCIuXG4gIGlmIChcbiAgICBodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ2RlZmF1bHQnICYmXG4gICAgKGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi1tb2RpZmllZC1zaW5jZScsIHRydWUpIHx8XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtbm9uZS1tYXRjaCcsIHRydWUpIHx8XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtdW5tb2RpZmllZC1zaW5jZScsIHRydWUpIHx8XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtbWF0Y2gnLCB0cnVlKSB8fFxuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2lmLXJhbmdlJywgdHJ1ZSkpXG4gICkge1xuICAgIGh0dHBSZXF1ZXN0LmNhY2hlID0gJ25vLXN0b3JlJ1xuICB9XG5cbiAgLy8gICAgMTYuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwibm8tY2FjaGVcIiwgaHR0cFJlcXVlc3TigJlzIHByZXZlbnRcbiAgLy8gICAgbm8tY2FjaGUgY2FjaGUtY29udHJvbCBoZWFkZXIgbW9kaWZpY2F0aW9uIGZsYWcgaXMgdW5zZXQsIGFuZFxuICAvLyAgICBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgQ2FjaGUtQ29udHJvbGAsIHRoZW4gYXBwZW5kXG4gIC8vICAgIGBDYWNoZS1Db250cm9sYC9gbWF4LWFnZT0wYCB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmIChcbiAgICBodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ25vLWNhY2hlJyAmJlxuICAgICFodHRwUmVxdWVzdC5wcmV2ZW50Tm9DYWNoZUNhY2hlQ29udHJvbEhlYWRlck1vZGlmaWNhdGlvbiAmJlxuICAgICFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnY2FjaGUtY29udHJvbCcsIHRydWUpXG4gICkge1xuICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnY2FjaGUtY29udHJvbCcsICdtYXgtYWdlPTAnLCB0cnVlKVxuICB9XG5cbiAgLy8gICAgMTcuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwibm8tc3RvcmVcIiBvciBcInJlbG9hZFwiLCB0aGVuOlxuICBpZiAoaHR0cFJlcXVlc3QuY2FjaGUgPT09ICduby1zdG9yZScgfHwgaHR0cFJlcXVlc3QuY2FjaGUgPT09ICdyZWxvYWQnKSB7XG4gICAgLy8gMS4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYFByYWdtYWAsIHRoZW4gYXBwZW5kXG4gICAgLy8gYFByYWdtYWAvYG5vLWNhY2hlYCB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygncHJhZ21hJywgdHJ1ZSkpIHtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgncHJhZ21hJywgJ25vLWNhY2hlJywgdHJ1ZSlcbiAgICB9XG5cbiAgICAvLyAyLiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgQ2FjaGUtQ29udHJvbGAsXG4gICAgLy8gdGhlbiBhcHBlbmQgYENhY2hlLUNvbnRyb2xgL2Buby1jYWNoZWAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgIGlmICghaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2NhY2hlLWNvbnRyb2wnLCB0cnVlKSkge1xuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdjYWNoZS1jb250cm9sJywgJ25vLWNhY2hlJywgdHJ1ZSlcbiAgICB9XG4gIH1cblxuICAvLyAgICAxOC4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGNvbnRhaW5zIGBSYW5nZWAsIHRoZW4gYXBwZW5kXG4gIC8vICAgIGBBY2NlcHQtRW5jb2RpbmdgL2BpZGVudGl0eWAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3JhbmdlJywgdHJ1ZSkpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdC1lbmNvZGluZycsICdpZGVudGl0eScsIHRydWUpXG4gIH1cblxuICAvLyAgICAxOS4gTW9kaWZ5IGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBwZXIgSFRUUC4gRG8gbm90IGFwcGVuZCBhIGdpdmVuXG4gIC8vICAgIGhlYWRlciBpZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgdGhhdCBoZWFkZXLigJlzIG5hbWUuXG4gIC8vICAgIFRPRE86IGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzEyODUjaXNzdWVjb21tZW50LTg5NjU2MDEyOVxuICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdhY2NlcHQtZW5jb2RpbmcnLCB0cnVlKSkge1xuICAgIGlmICh1cmxIYXNIdHRwc1NjaGVtZShyZXF1ZXN0Q3VycmVudFVSTChodHRwUmVxdWVzdCkpKSB7XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdC1lbmNvZGluZycsICdiciwgZ3ppcCwgZGVmbGF0ZScsIHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnYWNjZXB0LWVuY29kaW5nJywgJ2d6aXAsIGRlZmxhdGUnLCB0cnVlKVxuICAgIH1cbiAgfVxuXG4gIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZSgnaG9zdCcsIHRydWUpXG5cbiAgLy8gICAgMjAuIElmIGluY2x1ZGVDcmVkZW50aWFscyBpcyB0cnVlLCB0aGVuOlxuICBpZiAoaW5jbHVkZUNyZWRlbnRpYWxzKSB7XG4gICAgLy8gMS4gSWYgdGhlIHVzZXIgYWdlbnQgaXMgbm90IGNvbmZpZ3VyZWQgdG8gYmxvY2sgY29va2llcyBmb3IgaHR0cFJlcXVlc3RcbiAgICAvLyAoc2VlIHNlY3Rpb24gNyBvZiBbQ09PS0lFU10pLCB0aGVuOlxuICAgIC8vIFRPRE86IGNyZWRlbnRpYWxzXG4gICAgLy8gMi4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYEF1dGhvcml6YXRpb25gLCB0aGVuOlxuICAgIC8vIFRPRE86IGNyZWRlbnRpYWxzXG4gIH1cblxuICAvLyAgICAyMS4gSWYgdGhlcmXigJlzIGEgcHJveHktYXV0aGVudGljYXRpb24gZW50cnksIHVzZSBpdCBhcyBhcHByb3ByaWF0ZS5cbiAgLy8gICAgVE9ETzogcHJveHktYXV0aGVudGljYXRpb25cblxuICAvLyAgICAyMi4gU2V0IGh0dHBDYWNoZSB0byB0aGUgcmVzdWx0IG9mIGRldGVybWluaW5nIHRoZSBIVFRQIGNhY2hlXG4gIC8vICAgIHBhcnRpdGlvbiwgZ2l2ZW4gaHR0cFJlcXVlc3QuXG4gIC8vICAgIFRPRE86IGNhY2hlXG5cbiAgLy8gICAgMjMuIElmIGh0dHBDYWNoZSBpcyBudWxsLCB0aGVuIHNldCBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSB0b1xuICAvLyAgICBcIm5vLXN0b3JlXCIuXG4gIGlmIChodHRwQ2FjaGUgPT0gbnVsbCkge1xuICAgIGh0dHBSZXF1ZXN0LmNhY2hlID0gJ25vLXN0b3JlJ1xuICB9XG5cbiAgLy8gICAgMjQuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIG5laXRoZXIgXCJuby1zdG9yZVwiIG5vciBcInJlbG9hZFwiLFxuICAvLyAgICB0aGVuOlxuICBpZiAoaHR0cFJlcXVlc3QuY2FjaGUgIT09ICduby1zdG9yZScgJiYgaHR0cFJlcXVlc3QuY2FjaGUgIT09ICdyZWxvYWQnKSB7XG4gICAgLy8gVE9ETzogY2FjaGVcbiAgfVxuXG4gIC8vIDkuIElmIGFib3J0ZWQsIHRoZW4gcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBuZXR3b3JrIGVycm9yIGZvciBmZXRjaFBhcmFtcy5cbiAgLy8gVE9ET1xuXG4gIC8vIDEwLiBJZiByZXNwb25zZSBpcyBudWxsLCB0aGVuOlxuICBpZiAocmVzcG9uc2UgPT0gbnVsbCkge1xuICAgIC8vIDEuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwib25seS1pZi1jYWNoZWRcIiwgdGhlbiByZXR1cm4gYVxuICAgIC8vIG5ldHdvcmsgZXJyb3IuXG4gICAgaWYgKGh0dHBSZXF1ZXN0LmNhY2hlID09PSAnb25seS1pZi1jYWNoZWQnKSB7XG4gICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcignb25seSBpZiBjYWNoZWQnKVxuICAgIH1cblxuICAgIC8vIDIuIExldCBmb3J3YXJkUmVzcG9uc2UgYmUgdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAtbmV0d29yayBmZXRjaFxuICAgIC8vIGdpdmVuIGh0dHBGZXRjaFBhcmFtcywgaW5jbHVkZUNyZWRlbnRpYWxzLCBhbmQgaXNOZXdDb25uZWN0aW9uRmV0Y2guXG4gICAgY29uc3QgZm9yd2FyZFJlc3BvbnNlID0gYXdhaXQgaHR0cE5ldHdvcmtGZXRjaChcbiAgICAgIGh0dHBGZXRjaFBhcmFtcyxcbiAgICAgIGluY2x1ZGVDcmVkZW50aWFscyxcbiAgICAgIGlzTmV3Q29ubmVjdGlvbkZldGNoXG4gICAgKVxuXG4gICAgLy8gMy4gSWYgaHR0cFJlcXVlc3TigJlzIG1ldGhvZCBpcyB1bnNhZmUgYW5kIGZvcndhcmRSZXNwb25zZeKAmXMgc3RhdHVzIGlzXG4gICAgLy8gaW4gdGhlIHJhbmdlIDIwMCB0byAzOTksIGluY2x1c2l2ZSwgaW52YWxpZGF0ZSBhcHByb3ByaWF0ZSBzdG9yZWRcbiAgICAvLyByZXNwb25zZXMgaW4gaHR0cENhY2hlLCBhcyBwZXIgdGhlIFwiSW52YWxpZGF0aW9uXCIgY2hhcHRlciBvZiBIVFRQXG4gICAgLy8gQ2FjaGluZywgYW5kIHNldCBzdG9yZWRSZXNwb25zZSB0byBudWxsLiBbSFRUUC1DQUNISU5HXVxuICAgIGlmIChcbiAgICAgICFzYWZlTWV0aG9kc1NldC5oYXMoaHR0cFJlcXVlc3QubWV0aG9kKSAmJlxuICAgICAgZm9yd2FyZFJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiZcbiAgICAgIGZvcndhcmRSZXNwb25zZS5zdGF0dXMgPD0gMzk5XG4gICAgKSB7XG4gICAgICAvLyBUT0RPOiBjYWNoZVxuICAgIH1cblxuICAgIC8vIDQuIElmIHRoZSByZXZhbGlkYXRpbmdGbGFnIGlzIHNldCBhbmQgZm9yd2FyZFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMzA0LFxuICAgIC8vIHRoZW46XG4gICAgaWYgKHJldmFsaWRhdGluZ0ZsYWcgJiYgZm9yd2FyZFJlc3BvbnNlLnN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICAvLyBUT0RPOiBjYWNoZVxuICAgIH1cblxuICAgIC8vIDUuIElmIHJlc3BvbnNlIGlzIG51bGwsIHRoZW46XG4gICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgIC8vIDEuIFNldCByZXNwb25zZSB0byBmb3J3YXJkUmVzcG9uc2UuXG4gICAgICByZXNwb25zZSA9IGZvcndhcmRSZXNwb25zZVxuXG4gICAgICAvLyAyLiBTdG9yZSBodHRwUmVxdWVzdCBhbmQgZm9yd2FyZFJlc3BvbnNlIGluIGh0dHBDYWNoZSwgYXMgcGVyIHRoZVxuICAgICAgLy8gXCJTdG9yaW5nIFJlc3BvbnNlcyBpbiBDYWNoZXNcIiBjaGFwdGVyIG9mIEhUVFAgQ2FjaGluZy4gW0hUVFAtQ0FDSElOR11cbiAgICAgIC8vIFRPRE86IGNhY2hlXG4gICAgfVxuICB9XG5cbiAgLy8gMTEuIFNldCByZXNwb25zZeKAmXMgVVJMIGxpc3QgdG8gYSBjbG9uZSBvZiBodHRwUmVxdWVzdOKAmXMgVVJMIGxpc3QuXG4gIHJlc3BvbnNlLnVybExpc3QgPSBbLi4uaHR0cFJlcXVlc3QudXJsTGlzdF1cblxuICAvLyAxMi4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGNvbnRhaW5zIGBSYW5nZWAsIHRoZW4gc2V0IHJlc3BvbnNl4oCZc1xuICAvLyByYW5nZS1yZXF1ZXN0ZWQgZmxhZy5cbiAgaWYgKGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdyYW5nZScsIHRydWUpKSB7XG4gICAgcmVzcG9uc2UucmFuZ2VSZXF1ZXN0ZWQgPSB0cnVlXG4gIH1cblxuICAvLyAxMy4gU2V0IHJlc3BvbnNl4oCZcyByZXF1ZXN0LWluY2x1ZGVzLWNyZWRlbnRpYWxzIHRvIGluY2x1ZGVDcmVkZW50aWFscy5cbiAgcmVzcG9uc2UucmVxdWVzdEluY2x1ZGVzQ3JlZGVudGlhbHMgPSBpbmNsdWRlQ3JlZGVudGlhbHNcblxuICAvLyAxNC4gSWYgcmVzcG9uc2XigJlzIHN0YXR1cyBpcyA0MDEsIGh0dHBSZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBub3RcbiAgLy8gXCJjb3JzXCIsIGluY2x1ZGVDcmVkZW50aWFscyBpcyB0cnVlLCBhbmQgcmVxdWVzdOKAmXMgd2luZG93IGlzIGFuIGVudmlyb25tZW50XG4gIC8vIHNldHRpbmdzIG9iamVjdCwgdGhlbjpcbiAgLy8gVE9ET1xuXG4gIC8vIDE1LiBJZiByZXNwb25zZeKAmXMgc3RhdHVzIGlzIDQwNywgdGhlbjpcbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA3KSB7XG4gICAgLy8gMS4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIFwibm8td2luZG93XCIsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICBpZiAocmVxdWVzdC53aW5kb3cgPT09ICduby13aW5kb3cnKSB7XG4gICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcigpXG4gICAgfVxuXG4gICAgLy8gMi4gPz8/XG5cbiAgICAvLyAzLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgIHJldHVybiBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMpXG4gICAgfVxuXG4gICAgLy8gNC4gUHJvbXB0IHRoZSBlbmQgdXNlciBhcyBhcHByb3ByaWF0ZSBpbiByZXF1ZXN04oCZcyB3aW5kb3cgYW5kIHN0b3JlXG4gICAgLy8gdGhlIHJlc3VsdCBhcyBhIHByb3h5LWF1dGhlbnRpY2F0aW9uIGVudHJ5LiBbSFRUUC1BVVRIXVxuICAgIC8vIFRPRE86IEludm9rZSBzb21lIGtpbmQgb2YgY2FsbGJhY2s/XG5cbiAgICAvLyA1LiBTZXQgcmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBnaXZlblxuICAgIC8vIGZldGNoUGFyYW1zLlxuICAgIC8vIFRPRE9cbiAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcigncHJveHkgYXV0aGVudGljYXRpb24gcmVxdWlyZWQnKVxuICB9XG5cbiAgLy8gMTYuIElmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGFyZSB0cnVlXG4gIGlmIChcbiAgICAvLyByZXNwb25zZeKAmXMgc3RhdHVzIGlzIDQyMVxuICAgIHJlc3BvbnNlLnN0YXR1cyA9PT0gNDIxICYmXG4gICAgLy8gaXNOZXdDb25uZWN0aW9uRmV0Y2ggaXMgZmFsc2VcbiAgICAhaXNOZXdDb25uZWN0aW9uRmV0Y2ggJiZcbiAgICAvLyByZXF1ZXN04oCZcyBib2R5IGlzIG51bGwsIG9yIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwgYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBub24tbnVsbFxuICAgIChyZXF1ZXN0LmJvZHkgPT0gbnVsbCB8fCByZXF1ZXN0LmJvZHkuc291cmNlICE9IG51bGwpXG4gICkge1xuICAgIC8vIHRoZW46XG5cbiAgICAvLyAxLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgIHJldHVybiBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMpXG4gICAgfVxuXG4gICAgLy8gMi4gU2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQLW5ldHdvcmstb3ItY2FjaGVcbiAgICAvLyBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcywgaXNBdXRoZW50aWNhdGlvbkZldGNoLCBhbmQgdHJ1ZS5cblxuICAgIC8vIFRPRE8gKHNwZWMpOiBUaGUgc3BlYyBkb2Vzbid0IHNwZWNpZnkgdGhpcyBidXQgd2UgbmVlZCB0byBjYW5jZWxcbiAgICAvLyB0aGUgYWN0aXZlIHJlc3BvbnNlIGJlZm9yZSB3ZSBjYW4gc3RhcnQgYSBuZXcgb25lLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzEyOTNcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSgpXG5cbiAgICByZXNwb25zZSA9IGF3YWl0IGh0dHBOZXR3b3JrT3JDYWNoZUZldGNoKFxuICAgICAgZmV0Y2hQYXJhbXMsXG4gICAgICBpc0F1dGhlbnRpY2F0aW9uRmV0Y2gsXG4gICAgICB0cnVlXG4gICAgKVxuICB9XG5cbiAgLy8gMTcuIElmIGlzQXV0aGVudGljYXRpb25GZXRjaCBpcyB0cnVlLCB0aGVuIGNyZWF0ZSBhbiBhdXRoZW50aWNhdGlvbiBlbnRyeVxuICBpZiAoaXNBdXRoZW50aWNhdGlvbkZldGNoKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbiAgLy8gMTguIFJldHVybiByZXNwb25zZS5cbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLW5ldHdvcmstZmV0Y2hcbmFzeW5jIGZ1bmN0aW9uIGh0dHBOZXR3b3JrRmV0Y2ggKFxuICBmZXRjaFBhcmFtcyxcbiAgaW5jbHVkZUNyZWRlbnRpYWxzID0gZmFsc2UsXG4gIGZvcmNlTmV3Q29ubmVjdGlvbiA9IGZhbHNlXG4pIHtcbiAgYXNzZXJ0KCFmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24gfHwgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3llZClcblxuICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24gPSB7XG4gICAgYWJvcnQ6IG51bGwsXG4gICAgZGVzdHJveWVkOiBmYWxzZSxcbiAgICBkZXN0cm95IChlcnIsIGFib3J0ID0gdHJ1ZSkge1xuICAgICAgaWYgKCF0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcbiAgICAgICAgaWYgKGFib3J0KSB7XG4gICAgICAgICAgdGhpcy5hYm9ydD8uKGVyciA/PyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicsICdBYm9ydEVycm9yJykpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDMuIExldCB0aW1pbmdJbmZvIGJlIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgY29uc3QgdGltaW5nSW5mbyA9IGZldGNoUGFyYW1zLnRpbWluZ0luZm9cblxuICAvLyA0LiBMZXQgaHR0cENhY2hlIGJlIHRoZSByZXN1bHQgb2YgZGV0ZXJtaW5pbmcgdGhlIEhUVFAgY2FjaGUgcGFydGl0aW9uLFxuICAvLyBnaXZlbiByZXF1ZXN0LlxuICAvLyBUT0RPOiBjYWNoZVxuICBjb25zdCBodHRwQ2FjaGUgPSBudWxsXG5cbiAgLy8gNS4gSWYgaHR0cENhY2hlIGlzIG51bGwsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGNhY2hlIG1vZGUgdG8gXCJuby1zdG9yZVwiLlxuICBpZiAoaHR0cENhY2hlID09IG51bGwpIHtcbiAgICByZXF1ZXN0LmNhY2hlID0gJ25vLXN0b3JlJ1xuICB9XG5cbiAgLy8gNi4gTGV0IG5ldHdvcmtQYXJ0aXRpb25LZXkgYmUgdGhlIHJlc3VsdCBvZiBkZXRlcm1pbmluZyB0aGUgbmV0d29ya1xuICAvLyBwYXJ0aXRpb24ga2V5IGdpdmVuIHJlcXVlc3QuXG4gIC8vIFRPRE9cblxuICAvLyA3LiBMZXQgbmV3Q29ubmVjdGlvbiBiZSBcInllc1wiIGlmIGZvcmNlTmV3Q29ubmVjdGlvbiBpcyB0cnVlOyBvdGhlcndpc2VcbiAgLy8gXCJub1wiLlxuICBjb25zdCBuZXdDb25uZWN0aW9uID0gZm9yY2VOZXdDb25uZWN0aW9uID8gJ3llcycgOiAnbm8nIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvLyA4LiBTd2l0Y2ggb24gcmVxdWVzdOKAmXMgbW9kZTpcbiAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ3dlYnNvY2tldCcpIHtcbiAgICAvLyBMZXQgY29ubmVjdGlvbiBiZSB0aGUgcmVzdWx0IG9mIG9idGFpbmluZyBhIFdlYlNvY2tldCBjb25uZWN0aW9uLFxuICAgIC8vIGdpdmVuIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMLlxuICAgIC8vIFRPRE9cbiAgfSBlbHNlIHtcbiAgICAvLyBMZXQgY29ubmVjdGlvbiBiZSB0aGUgcmVzdWx0IG9mIG9idGFpbmluZyBhIGNvbm5lY3Rpb24sIGdpdmVuXG4gICAgLy8gbmV0d29ya1BhcnRpdGlvbktleSwgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIG9yaWdpbixcbiAgICAvLyBpbmNsdWRlQ3JlZGVudGlhbHMsIGFuZCBmb3JjZU5ld0Nvbm5lY3Rpb24uXG4gICAgLy8gVE9ET1xuICB9XG5cbiAgLy8gOS4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiB0aGUgb25nb2luZyBmZXRjaCBpcyB0ZXJtaW5hdGVkOlxuXG4gIC8vICAgIDEuIElmIGNvbm5lY3Rpb24gaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuXG4gIC8vICAgIDIuIFNldCB0aW1pbmdJbmZv4oCZcyBmaW5hbCBjb25uZWN0aW9uIHRpbWluZyBpbmZvIHRvIHRoZSByZXN1bHQgb2ZcbiAgLy8gICAgY2FsbGluZyBjbGFtcCBhbmQgY29hcnNlbiBjb25uZWN0aW9uIHRpbWluZyBpbmZvIHdpdGggY29ubmVjdGlvbuKAmXNcbiAgLy8gICAgdGltaW5nIGluZm8sIHRpbWluZ0luZm/igJlzIHBvc3QtcmVkaXJlY3Qgc3RhcnQgdGltZSwgYW5kIGZldGNoUGFyYW1z4oCZc1xuICAvLyAgICBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eS5cblxuICAvLyAgICAzLiBJZiBjb25uZWN0aW9uIGlzIG5vdCBhbiBIVFRQLzIgY29ubmVjdGlvbiwgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCxcbiAgLy8gICAgYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBudWxsLCB0aGVuIGFwcGVuZCAoYFRyYW5zZmVyLUVuY29kaW5nYCxcbiAgLy8gICAgYGNodW5rZWRgKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cblxuICAvLyAgICA0LiBTZXQgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXF1ZXN0IHN0YXJ0IHRpbWUgdG8gdGhlIGNvYXJzZW5lZFxuICAvLyAgICBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWRcbiAgLy8gICAgY2FwYWJpbGl0eS5cblxuICAvLyAgICA1LiBTZXQgcmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBtYWtpbmcgYW4gSFRUUCByZXF1ZXN0IG92ZXIgY29ubmVjdGlvblxuICAvLyAgICB1c2luZyByZXF1ZXN0IHdpdGggdGhlIGZvbGxvd2luZyBjYXZlYXRzOlxuXG4gIC8vICAgICAgICAtIEZvbGxvdyB0aGUgcmVsZXZhbnQgcmVxdWlyZW1lbnRzIGZyb20gSFRUUC4gW0hUVFBdIFtIVFRQLVNFTUFOVElDU11cbiAgLy8gICAgICAgIFtIVFRQLUNPTkRdIFtIVFRQLUNBQ0hJTkddIFtIVFRQLUFVVEhdXG5cbiAgLy8gICAgICAgIC0gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCwgYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBudWxsLFxuICAvLyAgICAgICAgdGhlbiB0aGUgdXNlciBhZ2VudCBtYXkgaGF2ZSBhIGJ1ZmZlciBvZiB1cCB0byA2NCBraWJpYnl0ZXMgYW5kIHN0b3JlXG4gIC8vICAgICAgICBhIHBhcnQgb2YgcmVxdWVzdOKAmXMgYm9keSBpbiB0aGF0IGJ1ZmZlci4gSWYgdGhlIHVzZXIgYWdlbnQgcmVhZHMgZnJvbVxuICAvLyAgICAgICAgcmVxdWVzdOKAmXMgYm9keSBiZXlvbmQgdGhhdCBidWZmZXLigJlzIHNpemUgYW5kIHRoZSB1c2VyIGFnZW50IG5lZWRzIHRvXG4gIC8vICAgICAgICByZXNlbmQgcmVxdWVzdCwgdGhlbiBpbnN0ZWFkIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG5cbiAgLy8gICAgICAgIC0gU2V0IHRpbWluZ0luZm/igJlzIGZpbmFsIG5ldHdvcmstcmVzcG9uc2Ugc3RhcnQgdGltZSB0byB0aGUgY29hcnNlbmVkXG4gIC8vICAgICAgICBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eSxcbiAgLy8gICAgICAgIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSB1c2VyIGFnZW504oCZcyBIVFRQIHBhcnNlciByZWNlaXZlcyB0aGUgZmlyc3QgYnl0ZVxuICAvLyAgICAgICAgb2YgdGhlIHJlc3BvbnNlIChlLmcuLCBmcmFtZSBoZWFkZXIgYnl0ZXMgZm9yIEhUVFAvMiBvciByZXNwb25zZSBzdGF0dXNcbiAgLy8gICAgICAgIGxpbmUgZm9yIEhUVFAvMS54KS5cblxuICAvLyAgICAgICAgLSBXYWl0IHVudGlsIGFsbCB0aGUgaGVhZGVycyBhcmUgdHJhbnNtaXR0ZWQuXG5cbiAgLy8gICAgICAgIC0gQW55IHJlc3BvbnNlcyB3aG9zZSBzdGF0dXMgaXMgaW4gdGhlIHJhbmdlIDEwMCB0byAxOTksIGluY2x1c2l2ZSxcbiAgLy8gICAgICAgIGFuZCBpcyBub3QgMTAxLCBhcmUgdG8gYmUgaWdub3JlZCwgZXhjZXB0IGZvciB0aGUgcHVycG9zZXMgb2Ygc2V0dGluZ1xuICAvLyAgICAgICAgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXNwb25zZSBzdGFydCB0aW1lIGFib3ZlLlxuXG4gIC8vICAgIC0gSWYgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgYFRyYW5zZmVyLUVuY29kaW5nYC9gY2h1bmtlZGAgYW5kXG4gIC8vICAgIHJlc3BvbnNlIGlzIHRyYW5zZmVycmVkIHZpYSBIVFRQLzEuMCBvciBvbGRlciwgdGhlbiByZXR1cm4gYSBuZXR3b3JrXG4gIC8vICAgIGVycm9yLlxuXG4gIC8vICAgIC0gSWYgdGhlIEhUVFAgcmVxdWVzdCByZXN1bHRzIGluIGEgVExTIGNsaWVudCBjZXJ0aWZpY2F0ZSBkaWFsb2csIHRoZW46XG5cbiAgLy8gICAgICAgIDEuIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBhbiBlbnZpcm9ubWVudCBzZXR0aW5ncyBvYmplY3QsIG1ha2UgdGhlXG4gIC8vICAgICAgICBkaWFsb2cgYXZhaWxhYmxlIGluIHJlcXVlc3TigJlzIHdpbmRvdy5cblxuICAvLyAgICAgICAgMi4gT3RoZXJ3aXNlLCByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuXG4gIC8vIFRvIHRyYW5zbWl0IHJlcXVlc3TigJlzIGJvZHkgYm9keSwgcnVuIHRoZXNlIHN0ZXBzOlxuICBsZXQgcmVxdWVzdEJvZHkgPSBudWxsXG4gIC8vIDEuIElmIGJvZHkgaXMgbnVsbCBhbmQgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdCBlbmQtb2YtYm9keSBpc1xuICAvLyBub24tbnVsbCwgdGhlbiBxdWV1ZSBhIGZldGNoIHRhc2sgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdFxuICAvLyBlbmQtb2YtYm9keSBhbmQgZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gIGlmIChyZXF1ZXN0LmJvZHkgPT0gbnVsbCAmJiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVxdWVzdEVuZE9mQm9keSkge1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KCkpXG4gIH0gZWxzZSBpZiAocmVxdWVzdC5ib2R5ICE9IG51bGwpIHtcbiAgICAvLyAyLiBPdGhlcndpc2UsIGlmIGJvZHkgaXMgbm9uLW51bGw6XG5cbiAgICAvLyAgICAxLiBMZXQgcHJvY2Vzc0JvZHlDaHVuayBnaXZlbiBieXRlcyBiZSB0aGVzZSBzdGVwczpcbiAgICBjb25zdCBwcm9jZXNzQm9keUNodW5rID0gYXN5bmMgZnVuY3Rpb24gKiAoYnl0ZXMpIHtcbiAgICAgIC8vIDEuIElmIHRoZSBvbmdvaW5nIGZldGNoIGlzIHRlcm1pbmF0ZWQsIHRoZW4gYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBSdW4gdGhpcyBzdGVwIGluIHBhcmFsbGVsOiB0cmFuc21pdCBieXRlcy5cbiAgICAgIHlpZWxkIGJ5dGVzXG5cbiAgICAgIC8vIDMuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgYm9keSBpcyBub24tbnVsbCwgdGhlbiBydW5cbiAgICAgIC8vIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgYm9keSBnaXZlbiBieXRlc+KAmXMgbGVuZ3RoLlxuICAgICAgZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGg/LihieXRlcy5ieXRlTGVuZ3RoKVxuICAgIH1cblxuICAgIC8vIDIuIExldCBwcm9jZXNzRW5kT2ZCb2R5IGJlIHRoZXNlIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NFbmRPZkJvZHkgPSAoKSA9PiB7XG4gICAgICAvLyAxLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgZW5kLW9mLWJvZHkgaXMgbm9uLW51bGwsXG4gICAgICAvLyB0aGVuIHJ1biBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0IGVuZC1vZi1ib2R5LlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KSB7XG4gICAgICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzLiBMZXQgcHJvY2Vzc0JvZHlFcnJvciBnaXZlbiBlIGJlIHRoZXNlIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NCb2R5RXJyb3IgPSAoZSkgPT4ge1xuICAgICAgLy8gMS4gSWYgZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQsIHRoZW4gYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiBlIGlzIGFuIFwiQWJvcnRFcnJvclwiIERPTUV4Y2VwdGlvbiwgdGhlbiBhYm9ydCBmZXRjaFBhcmFtc+KAmXMgY29udHJvbGxlci5cbiAgICAgIGlmIChlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmFib3J0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC4gSW5jcmVtZW50YWxseSByZWFkIHJlcXVlc3TigJlzIGJvZHkgZ2l2ZW4gcHJvY2Vzc0JvZHlDaHVuaywgcHJvY2Vzc0VuZE9mQm9keSxcbiAgICAvLyBwcm9jZXNzQm9keUVycm9yLCBhbmQgZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gICAgcmVxdWVzdEJvZHkgPSAoYXN5bmMgZnVuY3Rpb24gKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJ5dGVzIG9mIHJlcXVlc3QuYm9keS5zdHJlYW0pIHtcbiAgICAgICAgICB5aWVsZCAqIHByb2Nlc3NCb2R5Q2h1bmsoYnl0ZXMpXG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0VuZE9mQm9keSgpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcHJvY2Vzc0JvZHlFcnJvcihlcnIpXG4gICAgICB9XG4gICAgfSkoKVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBzb2NrZXQgaXMgb25seSBwcm92aWRlZCBmb3Igd2Vic29ja2V0c1xuICAgIGNvbnN0IHsgYm9keSwgc3RhdHVzLCBzdGF0dXNUZXh0LCBoZWFkZXJzTGlzdCwgc29ja2V0IH0gPSBhd2FpdCBkaXNwYXRjaCh7IGJvZHk6IHJlcXVlc3RCb2R5IH0pXG5cbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICByZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7IHN0YXR1cywgc3RhdHVzVGV4dCwgaGVhZGVyc0xpc3QsIHNvY2tldCB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IGJvZHlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKClcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIubmV4dCA9ICgpID0+IGl0ZXJhdG9yLm5leHQoKVxuXG4gICAgICByZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7IHN0YXR1cywgc3RhdHVzVGV4dCwgaGVhZGVyc0xpc3QgfSlcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIDEwLiBJZiBhYm9ydGVkLCB0aGVuOlxuICAgIGlmIChlcnIubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAvLyAxLiBJZiBjb25uZWN0aW9uIHVzZXMgSFRUUC8yLCB0aGVuIHRyYW5zbWl0IGFuIFJTVF9TVFJFQU0gZnJhbWUuXG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSgpXG5cbiAgICAgIC8vIDIuIFJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gICAgICByZXR1cm4gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zLCBlcnIpXG4gICAgfVxuXG4gICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoZXJyKVxuICB9XG5cbiAgLy8gMTEuIExldCBwdWxsQWxnb3JpdGhtIGJlIGFuIGFjdGlvbiB0aGF0IHJlc3VtZXMgdGhlIG9uZ29pbmcgZmV0Y2hcbiAgLy8gaWYgaXQgaXMgc3VzcGVuZGVkLlxuICBjb25zdCBwdWxsQWxnb3JpdGhtID0gKCkgPT4ge1xuICAgIHJldHVybiBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnJlc3VtZSgpXG4gIH1cblxuICAvLyAxMi4gTGV0IGNhbmNlbEFsZ29yaXRobSBiZSBhbiBhbGdvcml0aG0gdGhhdCBhYm9ydHMgZmV0Y2hQYXJhbXPigJlzXG4gIC8vIGNvbnRyb2xsZXIgd2l0aCByZWFzb24sIGdpdmVuIHJlYXNvbi5cbiAgY29uc3QgY2FuY2VsQWxnb3JpdGhtID0gKHJlYXNvbikgPT4ge1xuICAgIC8vIElmIHRoZSBhYm9ydGVkIGZldGNoIHdhcyBhbHJlYWR5IHRlcm1pbmF0ZWQsIHRoZW4gd2UgZG8gbm90XG4gICAgLy8gbmVlZCB0byBkbyBhbnl0aGluZy5cbiAgICBpZiAoIWlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5hYm9ydChyZWFzb24pXG4gICAgfVxuICB9XG5cbiAgLy8gMTMuIExldCBoaWdoV2F0ZXJNYXJrIGJlIGEgbm9uLW5lZ2F0aXZlLCBub24tTmFOIG51bWJlciwgY2hvc2VuIGJ5XG4gIC8vIHRoZSB1c2VyIGFnZW50LlxuICAvLyBUT0RPXG5cbiAgLy8gMTQuIExldCBzaXplQWxnb3JpdGhtIGJlIGFuIGFsZ29yaXRobSB0aGF0IGFjY2VwdHMgYSBjaHVuayBvYmplY3RcbiAgLy8gYW5kIHJldHVybnMgYSBub24tbmVnYXRpdmUsIG5vbi1OYU4sIG5vbi1pbmZpbml0ZSBudW1iZXIsIGNob3NlbiBieSB0aGUgdXNlciBhZ2VudC5cbiAgLy8gVE9ET1xuXG4gIC8vIDE1LiBMZXQgc3RyZWFtIGJlIGEgbmV3IFJlYWRhYmxlU3RyZWFtLlxuICAvLyAxNi4gU2V0IHVwIHN0cmVhbSB3aXRoIGJ5dGUgcmVhZGluZyBzdXBwb3J0IHdpdGggcHVsbEFsZ29yaXRobSBzZXQgdG8gcHVsbEFsZ29yaXRobSxcbiAgLy8gICAgIGNhbmNlbEFsZ29yaXRobSBzZXQgdG8gY2FuY2VsQWxnb3JpdGhtLlxuICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAge1xuICAgICAgYXN5bmMgc3RhcnQgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyID0gY29udHJvbGxlclxuICAgICAgfSxcbiAgICAgIGFzeW5jIHB1bGwgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgYXdhaXQgcHVsbEFsZ29yaXRobShjb250cm9sbGVyKVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGNhbmNlbCAocmVhc29uKSB7XG4gICAgICAgIGF3YWl0IGNhbmNlbEFsZ29yaXRobShyZWFzb24pXG4gICAgICB9LFxuICAgICAgdHlwZTogJ2J5dGVzJ1xuICAgIH1cbiAgKVxuXG4gIC8vIDE3LiBSdW4gdGhlc2Ugc3RlcHMsIGJ1dCBhYm9ydCB3aGVuIHRoZSBvbmdvaW5nIGZldGNoIGlzIHRlcm1pbmF0ZWQ6XG5cbiAgLy8gICAgMS4gU2V0IHJlc3BvbnNl4oCZcyBib2R5IHRvIGEgbmV3IGJvZHkgd2hvc2Ugc3RyZWFtIGlzIHN0cmVhbS5cbiAgcmVzcG9uc2UuYm9keSA9IHsgc3RyZWFtLCBzb3VyY2U6IG51bGwsIGxlbmd0aDogbnVsbCB9XG5cbiAgLy8gICAgMi4gSWYgcmVzcG9uc2UgaXMgbm90IGEgbmV0d29yayBlcnJvciBhbmQgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpc1xuICAvLyAgICBub3QgXCJuby1zdG9yZVwiLCB0aGVuIHVwZGF0ZSByZXNwb25zZSBpbiBodHRwQ2FjaGUgZm9yIHJlcXVlc3QuXG4gIC8vICAgIFRPRE9cblxuICAvLyAgICAzLiBJZiBpbmNsdWRlQ3JlZGVudGlhbHMgaXMgdHJ1ZSBhbmQgdGhlIHVzZXIgYWdlbnQgaXMgbm90IGNvbmZpZ3VyZWRcbiAgLy8gICAgdG8gYmxvY2sgY29va2llcyBmb3IgcmVxdWVzdCAoc2VlIHNlY3Rpb24gNyBvZiBbQ09PS0lFU10pLCB0aGVuIHJ1biB0aGVcbiAgLy8gICAgXCJzZXQtY29va2llLXN0cmluZ1wiIHBhcnNpbmcgYWxnb3JpdGhtIChzZWUgc2VjdGlvbiA1LjIgb2YgW0NPT0tJRVNdKSBvblxuICAvLyAgICB0aGUgdmFsdWUgb2YgZWFjaCBoZWFkZXIgd2hvc2UgbmFtZSBpcyBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3JcbiAgLy8gICAgYFNldC1Db29raWVgIGluIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdCwgaWYgYW55LCBhbmQgcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gIC8vICAgIFRPRE9cblxuICAvLyAxOC4gSWYgYWJvcnRlZCwgdGhlbjpcbiAgLy8gVE9ET1xuXG4gIC8vIDE5LiBSdW4gdGhlc2Ugc3RlcHMgaW4gcGFyYWxsZWw6XG5cbiAgLy8gICAgMS4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZDpcbiAgaWYgKCFmZXRjaFBhcmFtcy5jb250cm9sbGVyLnJlc3VtZSkge1xuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub24oJ3Rlcm1pbmF0ZWQnLCBvbkFib3J0ZWQpXG4gIH1cblxuICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnJlc3VtZSA9IGFzeW5jICgpID0+IHtcbiAgICAvLyAxLiBXaGlsZSB0cnVlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIDEtMy4gU2VlIG9uRGF0YS4uLlxuXG4gICAgICAvLyA0LiBTZXQgYnl0ZXMgdG8gdGhlIHJlc3VsdCBvZiBoYW5kbGluZyBjb250ZW50IGNvZGluZ3MgZ2l2ZW5cbiAgICAgIC8vIGNvZGluZ3MgYW5kIGJ5dGVzLlxuICAgICAgbGV0IGJ5dGVzXG4gICAgICBsZXQgaXNGYWlsdXJlXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm5leHQoKVxuXG4gICAgICAgIGlmIChpc0Fib3J0ZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ5dGVzID0gZG9uZSA/IHVuZGVmaW5lZCA6IHZhbHVlXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZW5kZWQgJiYgIXRpbWluZ0luZm8uZW5jb2RlZEJvZHlTaXplKSB7XG4gICAgICAgICAgLy8gemxpYiBkb2Vzbid0IGxpa2UgZW1wdHkgc3RyZWFtcy5cbiAgICAgICAgICBieXRlcyA9IHVuZGVmaW5lZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ5dGVzID0gZXJyXG5cbiAgICAgICAgICAvLyBlcnIgbWF5IGJlIHByb3BhZ2F0ZWQgZnJvbSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgcmVhZGFibGVzdHJlYW0uY2FuY2VsLFxuICAgICAgICAgIC8vIHdoaWNoIG1pZ2h0IG5vdCBiZSBhbiBlcnJvci4gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzIwMDlcbiAgICAgICAgICBpc0ZhaWx1cmUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGJ5dGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gMi4gT3RoZXJ3aXNlLCBpZiB0aGUgYnl0ZXMgdHJhbnNtaXNzaW9uIGZvciByZXNwb25zZeKAmXMgbWVzc2FnZVxuICAgICAgICAvLyBib2R5IGlzIGRvbmUgbm9ybWFsbHkgYW5kIHN0cmVhbSBpcyByZWFkYWJsZSwgdGhlbiBjbG9zZVxuICAgICAgICAvLyBzdHJlYW0sIGZpbmFsaXplIHJlc3BvbnNlIGZvciBmZXRjaFBhcmFtcyBhbmQgcmVzcG9uc2UsIGFuZFxuICAgICAgICAvLyBhYm9ydCB0aGVzZSBpbi1wYXJhbGxlbCBzdGVwcy5cbiAgICAgICAgcmVhZGFibGVTdHJlYW1DbG9zZShmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIpXG5cbiAgICAgICAgZmluYWxpemVSZXNwb25zZShmZXRjaFBhcmFtcywgcmVzcG9uc2UpXG5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDUuIEluY3JlYXNlIHRpbWluZ0luZm/igJlzIGRlY29kZWQgYm9keSBzaXplIGJ5IGJ5dGVz4oCZcyBsZW5ndGguXG4gICAgICB0aW1pbmdJbmZvLmRlY29kZWRCb2R5U2l6ZSArPSBieXRlcz8uYnl0ZUxlbmd0aCA/PyAwXG5cbiAgICAgIC8vIDYuIElmIGJ5dGVzIGlzIGZhaWx1cmUsIHRoZW4gdGVybWluYXRlIGZldGNoUGFyYW1z4oCZcyBjb250cm9sbGVyLlxuICAgICAgaWYgKGlzRmFpbHVyZSkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZShieXRlcylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDcuIEVucXVldWUgYSBVaW50OEFycmF5IHdyYXBwaW5nIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgYnl0ZXNcbiAgICAgIC8vIGludG8gc3RyZWFtLlxuICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpXG4gICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyLmVucXVldWUoYnVmZmVyKVxuICAgICAgfVxuXG4gICAgICAvLyA4LiBJZiBzdHJlYW0gaXMgZXJyb3JlZCwgdGhlbiB0ZXJtaW5hdGUgdGhlIG9uZ29pbmcgZmV0Y2guXG4gICAgICBpZiAoaXNFcnJvcmVkKHN0cmVhbSkpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gOS4gSWYgc3RyZWFtIGRvZXNu4oCZdCBuZWVkIG1vcmUgZGF0YSBhc2sgdGhlIHVzZXIgYWdlbnQgdG8gc3VzcGVuZFxuICAgICAgLy8gdGhlIG9uZ29pbmcgZmV0Y2guXG4gICAgICBpZiAoZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyLmRlc2lyZWRTaXplIDw9IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gICAgMi4gSWYgYWJvcnRlZCwgdGhlbjpcbiAgZnVuY3Rpb24gb25BYm9ydGVkIChyZWFzb24pIHtcbiAgICAvLyAyLiBJZiBmZXRjaFBhcmFtcyBpcyBhYm9ydGVkLCB0aGVuOlxuICAgIGlmIChpc0Fib3J0ZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAvLyAxLiBTZXQgcmVzcG9uc2XigJlzIGFib3J0ZWQgZmxhZy5cbiAgICAgIHJlc3BvbnNlLmFib3J0ZWQgPSB0cnVlXG5cbiAgICAgIC8vIDIuIElmIHN0cmVhbSBpcyByZWFkYWJsZSwgdGhlbiBlcnJvciBzdHJlYW0gd2l0aCB0aGUgcmVzdWx0IG9mXG4gICAgICAvLyAgICBkZXNlcmlhbGl6ZSBhIHNlcmlhbGl6ZWQgYWJvcnQgcmVhc29uIGdpdmVuIGZldGNoUGFyYW1z4oCZc1xuICAgICAgLy8gICAgY29udHJvbGxlcuKAmXMgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gYW5kIGFuXG4gICAgICAvLyAgICBpbXBsZW1lbnRhdGlvbi1kZWZpbmVkIHJlYWxtLlxuICAgICAgaWYgKGlzUmVhZGFibGUoc3RyZWFtKSkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIuZXJyb3IoXG4gICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zZXJpYWxpemVkQWJvcnRSZWFzb25cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAzLiBPdGhlcndpc2UsIGlmIHN0cmVhbSBpcyByZWFkYWJsZSwgZXJyb3Igc3RyZWFtIHdpdGggYSBUeXBlRXJyb3IuXG4gICAgICBpZiAoaXNSZWFkYWJsZShzdHJlYW0pKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5lcnJvcihuZXcgVHlwZUVycm9yKCd0ZXJtaW5hdGVkJywge1xuICAgICAgICAgIGNhdXNlOiBpc0Vycm9yTGlrZShyZWFzb24pID8gcmVhc29uIDogdW5kZWZpbmVkXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQuIElmIGNvbm5lY3Rpb24gdXNlcyBIVFRQLzIsIHRoZW4gdHJhbnNtaXQgYW4gUlNUX1NUUkVBTSBmcmFtZS5cbiAgICAvLyA1LiBPdGhlcndpc2UsIHRoZSB1c2VyIGFnZW50IHNob3VsZCBjbG9zZSBjb25uZWN0aW9uIHVubGVzcyBpdCB3b3VsZCBiZSBiYWQgZm9yIHBlcmZvcm1hbmNlIHRvIGRvIHNvLlxuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KClcbiAgfVxuXG4gIC8vIDIwLiBSZXR1cm4gcmVzcG9uc2UuXG4gIHJldHVybiByZXNwb25zZVxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoICh7IGJvZHkgfSkge1xuICAgIGNvbnN0IHVybCA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uLy4uJykuQWdlbnR9ICovXG4gICAgY29uc3QgYWdlbnQgPSBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmRpc3BhdGNoZXJcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBhZ2VudC5kaXNwYXRjaChcbiAgICAgIHtcbiAgICAgICAgcGF0aDogdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCxcbiAgICAgICAgb3JpZ2luOiB1cmwub3JpZ2luLFxuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBib2R5OiBhZ2VudC5pc01vY2tBY3RpdmUgPyByZXF1ZXN0LmJvZHkgJiYgKHJlcXVlc3QuYm9keS5zb3VyY2UgfHwgcmVxdWVzdC5ib2R5LnN0cmVhbSkgOiBib2R5LFxuICAgICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnNMaXN0LmVudHJpZXMsXG4gICAgICAgIG1heFJlZGlyZWN0aW9uczogMCxcbiAgICAgICAgdXBncmFkZTogcmVxdWVzdC5tb2RlID09PSAnd2Vic29ja2V0JyA/ICd3ZWJzb2NrZXQnIDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBib2R5OiBudWxsLFxuICAgICAgICBhYm9ydDogbnVsbCxcblxuICAgICAgICBvbkNvbm5lY3QgKGFib3J0KSB7XG4gICAgICAgICAgLy8gVE9ETyAoZml4KTogRG8gd2UgbmVlZCBjb25uZWN0aW9uIGhlcmU/XG4gICAgICAgICAgY29uc3QgeyBjb25uZWN0aW9uIH0gPSBmZXRjaFBhcmFtcy5jb250cm9sbGVyXG5cbiAgICAgICAgICAvLyBTZXQgdGltaW5nSW5mb+KAmXMgZmluYWwgY29ubmVjdGlvbiB0aW1pbmcgaW5mbyB0byB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgY2xhbXAgYW5kIGNvYXJzZW5cbiAgICAgICAgICAvLyBjb25uZWN0aW9uIHRpbWluZyBpbmZvIHdpdGggY29ubmVjdGlvbuKAmXMgdGltaW5nIGluZm8sIHRpbWluZ0luZm/igJlzIHBvc3QtcmVkaXJlY3Qgc3RhcnRcbiAgICAgICAgICAvLyB0aW1lLCBhbmQgZmV0Y2hQYXJhbXPigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZCBjYXBhYmlsaXR5LlxuICAgICAgICAgIC8vIFRPRE86IGltcGxlbWVudCBjb25uZWN0aW9uIHRpbWluZ1xuICAgICAgICAgIHRpbWluZ0luZm8uZmluYWxDb25uZWN0aW9uVGltaW5nSW5mbyA9IGNsYW1wQW5kQ29hcnNlbkNvbm5lY3Rpb25UaW1pbmdJbmZvKHVuZGVmaW5lZCwgdGltaW5nSW5mby5wb3N0UmVkaXJlY3RTdGFydFRpbWUsIGZldGNoUGFyYW1zLmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KVxuXG4gICAgICAgICAgaWYgKGNvbm5lY3Rpb24uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICBhYm9ydChuZXcgRE9NRXhjZXB0aW9uKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicsICdBYm9ydEVycm9yJykpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub24oJ3Rlcm1pbmF0ZWQnLCBhYm9ydClcbiAgICAgICAgICAgIHRoaXMuYWJvcnQgPSBjb25uZWN0aW9uLmFib3J0ID0gYWJvcnRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXQgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXF1ZXN0IHN0YXJ0IHRpbWUgdG8gdGhlIGNvYXJzZW5lZCBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuXG4gICAgICAgICAgLy8gZmV0Y2hQYXJhbXPigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZCBjYXBhYmlsaXR5LlxuICAgICAgICAgIHRpbWluZ0luZm8uZmluYWxOZXR3b3JrUmVxdWVzdFN0YXJ0VGltZSA9IGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKGZldGNoUGFyYW1zLmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVzcG9uc2VTdGFydGVkICgpIHtcbiAgICAgICAgICAvLyBTZXQgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXNwb25zZSBzdGFydCB0aW1lIHRvIHRoZSBjb2Fyc2VuZWQgc2hhcmVkIGN1cnJlbnRcbiAgICAgICAgICAvLyB0aW1lIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eSwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlXG4gICAgICAgICAgLy8gdXNlciBhZ2VudOKAmXMgSFRUUCBwYXJzZXIgcmVjZWl2ZXMgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIHJlc3BvbnNlIChlLmcuLCBmcmFtZSBoZWFkZXJcbiAgICAgICAgICAvLyBieXRlcyBmb3IgSFRUUC8yIG9yIHJlc3BvbnNlIHN0YXR1cyBsaW5lIGZvciBIVFRQLzEueCkuXG4gICAgICAgICAgdGltaW5nSW5mby5maW5hbE5ldHdvcmtSZXNwb25zZVN0YXJ0VGltZSA9IGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKGZldGNoUGFyYW1zLmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uSGVhZGVycyAoc3RhdHVzLCByYXdIZWFkZXJzLCByZXN1bWUsIHN0YXR1c1RleHQpIHtcbiAgICAgICAgICBpZiAoc3RhdHVzIDwgMjAwKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuICAgICAgICAgIGxldCBjb2RpbmdzID0gW11cbiAgICAgICAgICBsZXQgbG9jYXRpb24gPSAnJ1xuXG4gICAgICAgICAgY29uc3QgaGVhZGVyc0xpc3QgPSBuZXcgSGVhZGVyc0xpc3QoKVxuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdIZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBoZWFkZXJzTGlzdC5hcHBlbmQoYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZShyYXdIZWFkZXJzW2ldKSwgcmF3SGVhZGVyc1tpICsgMV0udG9TdHJpbmcoJ2xhdGluMScpLCB0cnVlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjb250ZW50RW5jb2RpbmcgPSBoZWFkZXJzTGlzdC5nZXQoJ2NvbnRlbnQtZW5jb2RpbmcnLCB0cnVlKVxuICAgICAgICAgIGlmIChjb250ZW50RW5jb2RpbmcpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3MjMxI3NlY3Rpb24tMy4xLjIuMVxuICAgICAgICAgICAgLy8gXCJBbGwgY29udGVudC1jb2RpbmcgdmFsdWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlLi4uXCJcbiAgICAgICAgICAgIGNvZGluZ3MgPSBjb250ZW50RW5jb2RpbmcudG9Mb3dlckNhc2UoKS5zcGxpdCgnLCcpLm1hcCgoeCkgPT4geC50cmltKCkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGxvY2F0aW9uID0gaGVhZGVyc0xpc3QuZ2V0KCdsb2NhdGlvbicsIHRydWUpXG5cbiAgICAgICAgICB0aGlzLmJvZHkgPSBuZXcgUmVhZGFibGUoeyByZWFkOiByZXN1bWUgfSlcblxuICAgICAgICAgIGNvbnN0IGRlY29kZXJzID0gW11cblxuICAgICAgICAgIGNvbnN0IHdpbGxGb2xsb3cgPSBsb2NhdGlvbiAmJiByZXF1ZXN0LnJlZGlyZWN0ID09PSAnZm9sbG93JyAmJlxuICAgICAgICAgICAgcmVkaXJlY3RTdGF0dXNTZXQuaGFzKHN0YXR1cylcblxuICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9Db250ZW50LUVuY29kaW5nXG4gICAgICAgICAgaWYgKGNvZGluZ3MubGVuZ3RoICE9PSAwICYmIHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcgJiYgcmVxdWVzdC5tZXRob2QgIT09ICdDT05ORUNUJyAmJiAhbnVsbEJvZHlTdGF0dXMuaW5jbHVkZXMoc3RhdHVzKSAmJiAhd2lsbEZvbGxvdykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvZGluZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgY29uc3QgY29kaW5nID0gY29kaW5nc1tpXVxuICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMi5odG1sI3NlY3Rpb24tNy4yXG4gICAgICAgICAgICAgIGlmIChjb2RpbmcgPT09ICd4LWd6aXAnIHx8IGNvZGluZyA9PT0gJ2d6aXAnKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcnMucHVzaCh6bGliLmNyZWF0ZUd1bnppcCh7XG4gICAgICAgICAgICAgICAgICAvLyBCZSBsZXNzIHN0cmljdCB3aGVuIGRlY29kaW5nIGNvbXByZXNzZWQgcmVzcG9uc2VzLCBzaW5jZSBzb21ldGltZXNcbiAgICAgICAgICAgICAgICAgIC8vIHNlcnZlcnMgc2VuZCBzbGlnaHRseSBpbnZhbGlkIHJlc3BvbnNlcyB0aGF0IGFyZSBzdGlsbCBhY2NlcHRlZFxuICAgICAgICAgICAgICAgICAgLy8gYnkgY29tbW9uIGJyb3dzZXJzLlxuICAgICAgICAgICAgICAgICAgLy8gQWx3YXlzIHVzaW5nIFpfU1lOQ19GTFVTSCBpcyB3aGF0IGNVUkwgZG9lcy5cbiAgICAgICAgICAgICAgICAgIGZsdXNoOiB6bGliLmNvbnN0YW50cy5aX1NZTkNfRkxVU0gsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hGbHVzaDogemxpYi5jb25zdGFudHMuWl9TWU5DX0ZMVVNIXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kaW5nID09PSAnZGVmbGF0ZScpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVycy5wdXNoKGNyZWF0ZUluZmxhdGUoe1xuICAgICAgICAgICAgICAgICAgZmx1c2g6IHpsaWIuY29uc3RhbnRzLlpfU1lOQ19GTFVTSCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaEZsdXNoOiB6bGliLmNvbnN0YW50cy5aX1NZTkNfRkxVU0hcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RpbmcgPT09ICdicicpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVycy5wdXNoKHpsaWIuY3JlYXRlQnJvdGxpRGVjb21wcmVzcyh7XG4gICAgICAgICAgICAgICAgICBmbHVzaDogemxpYi5jb25zdGFudHMuQlJPVExJX09QRVJBVElPTl9GTFVTSCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaEZsdXNoOiB6bGliLmNvbnN0YW50cy5CUk9UTElfT1BFUkFUSU9OX0ZMVVNIXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kaW5nID09PSAnenN0ZCcgJiYgdHlwZW9mIHpsaWIuY3JlYXRlWnN0ZERlY29tcHJlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBOb2RlLmpzIHYyMy44LjArIGFuZCB2MjIuMTUuMCsgc3VwcG9ydHMgWnN0YW5kYXJkXG4gICAgICAgICAgICAgICAgZGVjb2RlcnMucHVzaCh6bGliLmNyZWF0ZVpzdGREZWNvbXByZXNzKHtcbiAgICAgICAgICAgICAgICAgIGZsdXNoOiB6bGliLmNvbnN0YW50cy5aU1REX2VfY29udGludWUsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hGbHVzaDogemxpYi5jb25zdGFudHMuWlNURF9lX2VuZFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlY29kZXJzLmxlbmd0aCA9IDBcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgb25FcnJvciA9IHRoaXMub25FcnJvci5iaW5kKHRoaXMpXG5cbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQsXG4gICAgICAgICAgICBoZWFkZXJzTGlzdCxcbiAgICAgICAgICAgIGJvZHk6IGRlY29kZXJzLmxlbmd0aFxuICAgICAgICAgICAgICA/IHBpcGVsaW5lKHRoaXMuYm9keSwgLi4uZGVjb2RlcnMsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkub24oJ2Vycm9yJywgb25FcnJvcilcbiAgICAgICAgICAgICAgOiB0aGlzLmJvZHkub24oJ2Vycm9yJywgb25FcnJvcilcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRhdGEgKGNodW5rKSB7XG4gICAgICAgICAgaWYgKGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZHVtcCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gMS4gSWYgb25lIG9yIG1vcmUgYnl0ZXMgaGF2ZSBiZWVuIHRyYW5zbWl0dGVkIGZyb20gcmVzcG9uc2XigJlzXG4gICAgICAgICAgLy8gbWVzc2FnZSBib2R5LCB0aGVuOlxuXG4gICAgICAgICAgLy8gIDEuIExldCBieXRlcyBiZSB0aGUgdHJhbnNtaXR0ZWQgYnl0ZXMuXG4gICAgICAgICAgY29uc3QgYnl0ZXMgPSBjaHVua1xuXG4gICAgICAgICAgLy8gIDIuIExldCBjb2RpbmdzIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBoZWFkZXIgbGlzdCB2YWx1ZXNcbiAgICAgICAgICAvLyAgZ2l2ZW4gYENvbnRlbnQtRW5jb2RpbmdgIGFuZCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gICAgICAgICAgLy8gIFNlZSBwdWxsQWxnb3JpdGhtLlxuXG4gICAgICAgICAgLy8gIDMuIEluY3JlYXNlIHRpbWluZ0luZm/igJlzIGVuY29kZWQgYm9keSBzaXplIGJ5IGJ5dGVz4oCZcyBsZW5ndGguXG4gICAgICAgICAgdGltaW5nSW5mby5lbmNvZGVkQm9keVNpemUgKz0gYnl0ZXMuYnl0ZUxlbmd0aFxuXG4gICAgICAgICAgLy8gIDQuIFNlZSBwdWxsQWxnb3JpdGhtLi4uXG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnB1c2goYnl0ZXMpXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Db21wbGV0ZSAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYWJvcnQpIHtcbiAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub2ZmKCd0ZXJtaW5hdGVkJywgdGhpcy5hYm9ydClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmVuZGVkID0gdHJ1ZVxuXG4gICAgICAgICAgdGhpcy5ib2R5LnB1c2gobnVsbClcbiAgICAgICAgfSxcblxuICAgICAgICBvbkVycm9yIChlcnJvcikge1xuICAgICAgICAgIGlmICh0aGlzLmFib3J0KSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9mZigndGVybWluYXRlZCcsIHRoaXMuYWJvcnQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ib2R5Py5kZXN0cm95KGVycm9yKVxuXG4gICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoZXJyb3IpXG5cbiAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25VcGdyYWRlIChzdGF0dXMsIHJhd0hlYWRlcnMsIHNvY2tldCkge1xuICAgICAgICAgIGlmIChzdGF0dXMgIT09IDEwMSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaGVhZGVyc0xpc3QgPSBuZXcgSGVhZGVyc0xpc3QoKVxuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdIZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBoZWFkZXJzTGlzdC5hcHBlbmQoYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZShyYXdIZWFkZXJzW2ldKSwgcmF3SGVhZGVyc1tpICsgMV0udG9TdHJpbmcoJ2xhdGluMScpLCB0cnVlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogU1RBVFVTX0NPREVTW3N0YXR1c10sXG4gICAgICAgICAgICBoZWFkZXJzTGlzdCxcbiAgICAgICAgICAgIHNvY2tldFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmV0Y2gsXG4gIEZldGNoLFxuICBmZXRjaGluZyxcbiAgZmluYWxpemVBbmRSZXBvcnRUaW1pbmdcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/request.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/request.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* globals AbortController */\n\n\n\nconst { extractBody, mixinBody, cloneBody, bodyUnusable } = __webpack_require__(/*! ./body */ \"(rsc)/./node_modules/undici/lib/web/fetch/body.js\")\nconst { Headers, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\")\nconst { FinalizationRegistry } = __webpack_require__(/*! ./dispatcher-weakref */ \"(rsc)/./node_modules/undici/lib/web/fetch/dispatcher-weakref.js\")()\nconst util = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\")\nconst {\n  isValidHTTPToken,\n  sameOrigin,\n  environmentSettingsObject\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst {\n  forbiddenMethodsSet,\n  corsSafeListedMethodsSet,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache,\n  requestDuplex\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/fetch/constants.js\")\nconst { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { URLSerializer } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { getMaxListeners, setMaxListeners, defaultMaxListeners } = __webpack_require__(/*! node:events */ \"node:events\")\n\nconst kAbortController = Symbol('abortController')\n\nconst requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {\n  signal.removeEventListener('abort', abort)\n})\n\nconst dependentControllerMap = new WeakMap()\n\nlet abortSignalHasEventHandlerLeakWarning\n\ntry {\n  abortSignalHasEventHandlerLeakWarning = getMaxListeners(new AbortController().signal) > 0\n} catch {\n  abortSignalHasEventHandlerLeakWarning = false\n}\n\nfunction buildAbort (acRef) {\n  return abort\n\n  function abort () {\n    const ac = acRef.deref()\n    if (ac !== undefined) {\n      // Currently, there is a problem with FinalizationRegistry.\n      // https://github.com/nodejs/node/issues/49344\n      // https://github.com/nodejs/node/issues/47748\n      // In the case of abort, the first step is to unregister from it.\n      // If the controller can refer to it, it is still registered.\n      // It will be removed in the future.\n      requestFinalizer.unregister(abort)\n\n      // Unsubscribe a listener.\n      // FinalizationRegistry will no longer be called, so this must be done.\n      this.removeEventListener('abort', abort)\n\n      ac.abort(this.reason)\n\n      const controllerList = dependentControllerMap.get(ac.signal)\n\n      if (controllerList !== undefined) {\n        if (controllerList.size !== 0) {\n          for (const ref of controllerList) {\n            const ctrl = ref.deref()\n            if (ctrl !== undefined) {\n              ctrl.abort(this.reason)\n            }\n          }\n          controllerList.clear()\n        }\n        dependentControllerMap.delete(ac.signal)\n      }\n    }\n  }\n}\n\nlet patchMethodWarning = false\n\n// https://fetch.spec.whatwg.org/#request-class\nclass Request {\n  /** @type {AbortSignal} */\n  #signal\n\n  /** @type {import('../../dispatcher/dispatcher')} */\n  #dispatcher\n\n  /** @type {Headers} */\n  #headers\n\n  #state\n\n  // https://fetch.spec.whatwg.org/#dom-request\n  constructor (input, init = undefined) {\n    webidl.util.markAsUncloneable(this)\n\n    if (input === kConstruct) {\n      return\n    }\n\n    const prefix = 'Request constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    input = webidl.converters.RequestInfo(input, prefix, 'input')\n    init = webidl.converters.RequestInit(init, prefix, 'init')\n\n    // 1. Let request be null.\n    let request = null\n\n    // 2. Let fallbackMode be null.\n    let fallbackMode = null\n\n    // 3. Let baseURL be thiss relevant settings objects API base URL.\n    const baseUrl = environmentSettingsObject.settingsObject.baseUrl\n\n    // 4. Let signal be null.\n    let signal = null\n\n    // 5. If input is a string, then:\n    if (typeof input === 'string') {\n      this.#dispatcher = init.dispatcher\n\n      // 1. Let parsedURL be the result of parsing input with baseURL.\n      // 2. If parsedURL is failure, then throw a TypeError.\n      let parsedURL\n      try {\n        parsedURL = new URL(input, baseUrl)\n      } catch (err) {\n        throw new TypeError('Failed to parse URL from ' + input, { cause: err })\n      }\n\n      // 3. If parsedURL includes credentials, then throw a TypeError.\n      if (parsedURL.username || parsedURL.password) {\n        throw new TypeError(\n          'Request cannot be constructed from a URL that includes credentials: ' +\n            input\n        )\n      }\n\n      // 4. Set request to a new request whose URL is parsedURL.\n      request = makeRequest({ urlList: [parsedURL] })\n\n      // 5. Set fallbackMode to \"cors\".\n      fallbackMode = 'cors'\n    } else {\n      // 6. Otherwise:\n\n      // 7. Assert: input is a Request object.\n      assert(webidl.is.Request(input))\n\n      // 8. Set request to inputs request.\n      request = input.#state\n\n      // 9. Set signal to inputs signal.\n      signal = input.#signal\n\n      this.#dispatcher = init.dispatcher || input.#dispatcher\n    }\n\n    // 7. Let origin be thiss relevant settings objects origin.\n    const origin = environmentSettingsObject.settingsObject.origin\n\n    // 8. Let window be \"client\".\n    let window = 'client'\n\n    // 9. If requests window is an environment settings object and its origin\n    // is same origin with origin, then set window to requests window.\n    if (\n      request.window?.constructor?.name === 'EnvironmentSettingsObject' &&\n      sameOrigin(request.window, origin)\n    ) {\n      window = request.window\n    }\n\n    // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n    if (init.window != null) {\n      throw new TypeError(`'window' option '${window}' must be null`)\n    }\n\n    // 11. If init[\"window\"] exists, then set window to \"no-window\".\n    if ('window' in init) {\n      window = 'no-window'\n    }\n\n    // 12. Set request to a new request with the following properties:\n    request = makeRequest({\n      // URL requests URL.\n      // undici implementation note: this is set as the first item in request's urlList in makeRequest\n      // method requests method.\n      method: request.method,\n      // header list A copy of requests header list.\n      // undici implementation note: headersList is cloned in makeRequest\n      headersList: request.headersList,\n      // unsafe-request flag Set.\n      unsafeRequest: request.unsafeRequest,\n      // client Thiss relevant settings object.\n      client: environmentSettingsObject.settingsObject,\n      // window window.\n      window,\n      // priority requests priority.\n      priority: request.priority,\n      // origin requests origin. The propagation of the origin is only significant for navigation requests\n      // being handled by a service worker. In this scenario a request can have an origin that is different\n      // from the current client.\n      origin: request.origin,\n      // referrer requests referrer.\n      referrer: request.referrer,\n      // referrer policy requests referrer policy.\n      referrerPolicy: request.referrerPolicy,\n      // mode requests mode.\n      mode: request.mode,\n      // credentials mode requests credentials mode.\n      credentials: request.credentials,\n      // cache mode requests cache mode.\n      cache: request.cache,\n      // redirect mode requests redirect mode.\n      redirect: request.redirect,\n      // integrity metadata requests integrity metadata.\n      integrity: request.integrity,\n      // keepalive requests keepalive.\n      keepalive: request.keepalive,\n      // reload-navigation flag requests reload-navigation flag.\n      reloadNavigation: request.reloadNavigation,\n      // history-navigation flag requests history-navigation flag.\n      historyNavigation: request.historyNavigation,\n      // URL list A clone of requests URL list.\n      urlList: [...request.urlList]\n    })\n\n    const initHasKey = Object.keys(init).length !== 0\n\n    // 13. If init is not empty, then:\n    if (initHasKey) {\n      // 1. If requests mode is \"navigate\", then set it to \"same-origin\".\n      if (request.mode === 'navigate') {\n        request.mode = 'same-origin'\n      }\n\n      // 2. Unset requests reload-navigation flag.\n      request.reloadNavigation = false\n\n      // 3. Unset requests history-navigation flag.\n      request.historyNavigation = false\n\n      // 4. Set requests origin to \"client\".\n      request.origin = 'client'\n\n      // 5. Set requests referrer to \"client\"\n      request.referrer = 'client'\n\n      // 6. Set requests referrer policy to the empty string.\n      request.referrerPolicy = ''\n\n      // 7. Set requests URL to requests current URL.\n      request.url = request.urlList[request.urlList.length - 1]\n\n      // 8. Set requests URL list to  requests URL .\n      request.urlList = [request.url]\n    }\n\n    // 14. If init[\"referrer\"] exists, then:\n    if (init.referrer !== undefined) {\n      // 1. Let referrer be init[\"referrer\"].\n      const referrer = init.referrer\n\n      // 2. If referrer is the empty string, then set requests referrer to \"no-referrer\".\n      if (referrer === '') {\n        request.referrer = 'no-referrer'\n      } else {\n        // 1. Let parsedReferrer be the result of parsing referrer with\n        // baseURL.\n        // 2. If parsedReferrer is failure, then throw a TypeError.\n        let parsedReferrer\n        try {\n          parsedReferrer = new URL(referrer, baseUrl)\n        } catch (err) {\n          throw new TypeError(`Referrer \"${referrer}\" is not a valid URL.`, { cause: err })\n        }\n\n        // 3. If one of the following is true\n        // - parsedReferrers scheme is \"about\" and path is the string \"client\"\n        // - parsedReferrers origin is not same origin with origin\n        // then set requests referrer to \"client\".\n        if (\n          (parsedReferrer.protocol === 'about:' && parsedReferrer.hostname === 'client') ||\n          (origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl))\n        ) {\n          request.referrer = 'client'\n        } else {\n          // 4. Otherwise, set requests referrer to parsedReferrer.\n          request.referrer = parsedReferrer\n        }\n      }\n    }\n\n    // 15. If init[\"referrerPolicy\"] exists, then set requests referrer policy\n    // to it.\n    if (init.referrerPolicy !== undefined) {\n      request.referrerPolicy = init.referrerPolicy\n    }\n\n    // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n    let mode\n    if (init.mode !== undefined) {\n      mode = init.mode\n    } else {\n      mode = fallbackMode\n    }\n\n    // 17. If mode is \"navigate\", then throw a TypeError.\n    if (mode === 'navigate') {\n      throw webidl.errors.exception({\n        header: 'Request constructor',\n        message: 'invalid request mode navigate.'\n      })\n    }\n\n    // 18. If mode is non-null, set requests mode to mode.\n    if (mode != null) {\n      request.mode = mode\n    }\n\n    // 19. If init[\"credentials\"] exists, then set requests credentials mode\n    // to it.\n    if (init.credentials !== undefined) {\n      request.credentials = init.credentials\n    }\n\n    // 18. If init[\"cache\"] exists, then set requests cache mode to it.\n    if (init.cache !== undefined) {\n      request.cache = init.cache\n    }\n\n    // 21. If requests cache mode is \"only-if-cached\" and requests mode is\n    // not \"same-origin\", then throw a TypeError.\n    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n      throw new TypeError(\n        \"'only-if-cached' can be set only with 'same-origin' mode\"\n      )\n    }\n\n    // 22. If init[\"redirect\"] exists, then set requests redirect mode to it.\n    if (init.redirect !== undefined) {\n      request.redirect = init.redirect\n    }\n\n    // 23. If init[\"integrity\"] exists, then set requests integrity metadata to it.\n    if (init.integrity != null) {\n      request.integrity = String(init.integrity)\n    }\n\n    // 24. If init[\"keepalive\"] exists, then set requests keepalive to it.\n    if (init.keepalive !== undefined) {\n      request.keepalive = Boolean(init.keepalive)\n    }\n\n    // 25. If init[\"method\"] exists, then:\n    if (init.method !== undefined) {\n      // 1. Let method be init[\"method\"].\n      let method = init.method\n\n      const mayBeNormalized = normalizedMethodRecords[method]\n\n      if (mayBeNormalized !== undefined) {\n        // Note: Bypass validation DELETE, GET, HEAD, OPTIONS, POST, PUT, PATCH and these lowercase ones\n        request.method = mayBeNormalized\n      } else {\n        // 2. If method is not a method or method is a forbidden method, then\n        // throw a TypeError.\n        if (!isValidHTTPToken(method)) {\n          throw new TypeError(`'${method}' is not a valid HTTP method.`)\n        }\n\n        const upperCase = method.toUpperCase()\n\n        if (forbiddenMethodsSet.has(upperCase)) {\n          throw new TypeError(`'${method}' HTTP method is unsupported.`)\n        }\n\n        // 3. Normalize method.\n        // https://fetch.spec.whatwg.org/#concept-method-normalize\n        // Note: must be in uppercase\n        method = normalizedMethodRecordsBase[upperCase] ?? method\n\n        // 4. Set requests method to method.\n        request.method = method\n      }\n\n      if (!patchMethodWarning && request.method === 'patch') {\n        process.emitWarning('Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.', {\n          code: 'UNDICI-FETCH-patch'\n        })\n\n        patchMethodWarning = true\n      }\n    }\n\n    // 26. If init[\"signal\"] exists, then set signal to it.\n    if (init.signal !== undefined) {\n      signal = init.signal\n    }\n\n    // 27. Set thiss request to request.\n    this.#state = request\n\n    // 28. Set thiss signal to a new AbortSignal object with thiss relevant\n    // Realm.\n    // TODO: could this be simplified with AbortSignal.any\n    // (https://dom.spec.whatwg.org/#dom-abortsignal-any)\n    const ac = new AbortController()\n    this.#signal = ac.signal\n\n    // 29. If signal is not null, then make thiss signal follow signal.\n    if (signal != null) {\n      if (signal.aborted) {\n        ac.abort(signal.reason)\n      } else {\n        // Keep a strong ref to ac while request object\n        // is alive. This is needed to prevent AbortController\n        // from being prematurely garbage collected.\n        // See, https://github.com/nodejs/undici/issues/1926.\n        this[kAbortController] = ac\n\n        const acRef = new WeakRef(ac)\n        const abort = buildAbort(acRef)\n\n        // If the max amount of listeners is equal to the default, increase it\n        if (abortSignalHasEventHandlerLeakWarning && getMaxListeners(signal) === defaultMaxListeners) {\n          setMaxListeners(1500, signal)\n        }\n\n        util.addAbortListener(signal, abort)\n        // The third argument must be a registry key to be unregistered.\n        // Without it, you cannot unregister.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n        // abort is used as the unregister key. (because it is unique)\n        requestFinalizer.register(ac, { signal, abort }, abort)\n      }\n    }\n\n    // 30. Set thiss headers to a new Headers object with thiss relevant\n    // Realm, whose header list is requests header list and guard is\n    // \"request\".\n    this.#headers = new Headers(kConstruct)\n    setHeadersList(this.#headers, request.headersList)\n    setHeadersGuard(this.#headers, 'request')\n\n    // 31. If thiss requests mode is \"no-cors\", then:\n    if (mode === 'no-cors') {\n      // 1. If thiss requests method is not a CORS-safelisted method,\n      // then throw a TypeError.\n      if (!corsSafeListedMethodsSet.has(request.method)) {\n        throw new TypeError(\n          `'${request.method} is unsupported in no-cors mode.`\n        )\n      }\n\n      // 2. Set thiss headerss guard to \"request-no-cors\".\n      setHeadersGuard(this.#headers, 'request-no-cors')\n    }\n\n    // 32. If init is not empty, then:\n    if (initHasKey) {\n      /** @type {HeadersList} */\n      const headersList = getHeadersList(this.#headers)\n      // 1. Let headers be a copy of thiss headers and its associated header\n      // list.\n      // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n      const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList)\n\n      // 3. Empty thiss headerss header list.\n      headersList.clear()\n\n      // 4. If headers is a Headers object, then for each header in its header\n      // list, append headers name/headers value to thiss headers.\n      if (headers instanceof HeadersList) {\n        for (const { name, value } of headers.rawValues()) {\n          headersList.append(name, value, false)\n        }\n        // Note: Copy the `set-cookie` meta-data.\n        headersList.cookies = headers.cookies\n      } else {\n        // 5. Otherwise, fill thiss headers with headers.\n        fillHeaders(this.#headers, headers)\n      }\n    }\n\n    // 33. Let inputBody be inputs requests body if input is a Request\n    // object; otherwise null.\n    const inputBody = webidl.is.Request(input) ? input.#state.body : null\n\n    // 34. If either init[\"body\"] exists and is non-null or inputBody is\n    // non-null, and requests method is `GET` or `HEAD`, then throw a\n    // TypeError.\n    if (\n      (init.body != null || inputBody != null) &&\n      (request.method === 'GET' || request.method === 'HEAD')\n    ) {\n      throw new TypeError('Request with GET/HEAD method cannot have body.')\n    }\n\n    // 35. Let initBody be null.\n    let initBody = null\n\n    // 36. If init[\"body\"] exists and is non-null, then:\n    if (init.body != null) {\n      // 1. Let Content-Type be null.\n      // 2. Set initBody and Content-Type to the result of extracting\n      // init[\"body\"], with keepalive set to requests keepalive.\n      const [extractedBody, contentType] = extractBody(\n        init.body,\n        request.keepalive\n      )\n      initBody = extractedBody\n\n      // 3, If Content-Type is non-null and thiss headerss header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n      // thiss headers.\n      if (contentType && !getHeadersList(this.#headers).contains('content-type', true)) {\n        this.#headers.append('content-type', contentType, true)\n      }\n    }\n\n    // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n    // inputBody.\n    const inputOrInitBody = initBody ?? inputBody\n\n    // 38. If inputOrInitBody is non-null and inputOrInitBodys source is\n    // null, then:\n    if (inputOrInitBody != null && inputOrInitBody.source == null) {\n      // 1. If initBody is non-null and init[\"duplex\"] does not exist,\n      //    then throw a TypeError.\n      if (initBody != null && init.duplex == null) {\n        throw new TypeError('RequestInit: duplex option is required when sending a body.')\n      }\n\n      // 2. If thiss requests mode is neither \"same-origin\" nor \"cors\",\n      // then throw a TypeError.\n      if (request.mode !== 'same-origin' && request.mode !== 'cors') {\n        throw new TypeError(\n          'If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"'\n        )\n      }\n\n      // 3. Set thiss requests use-CORS-preflight flag.\n      request.useCORSPreflightFlag = true\n    }\n\n    // 39. Let finalBody be inputOrInitBody.\n    let finalBody = inputOrInitBody\n\n    // 40. If initBody is null and inputBody is non-null, then:\n    if (initBody == null && inputBody != null) {\n      // 1. If input is unusable, then throw a TypeError.\n      if (bodyUnusable(input.#state)) {\n        throw new TypeError(\n          'Cannot construct a Request with a Request object that has already been used.'\n        )\n      }\n\n      // 2. Set finalBody to the result of creating a proxy for inputBody.\n      // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n      const identityTransform = new TransformStream()\n      inputBody.stream.pipeThrough(identityTransform)\n      finalBody = {\n        source: inputBody.source,\n        length: inputBody.length,\n        stream: identityTransform.readable\n      }\n    }\n\n    // 41. Set thiss requests body to finalBody.\n    this.#state.body = finalBody\n  }\n\n  // Returns requests HTTP method, which is \"GET\" by default.\n  get method () {\n    webidl.brandCheck(this, Request)\n\n    // The method getter steps are to return thiss requests method.\n    return this.#state.method\n  }\n\n  // Returns the URL of request as a string.\n  get url () {\n    webidl.brandCheck(this, Request)\n\n    // The url getter steps are to return thiss requests URL, serialized.\n    return URLSerializer(this.#state.url)\n  }\n\n  // Returns a Headers object consisting of the headers associated with request.\n  // Note that headers added in the network layer by the user agent will not\n  // be accounted for in this object, e.g., the \"Host\" header.\n  get headers () {\n    webidl.brandCheck(this, Request)\n\n    // The headers getter steps are to return thiss headers.\n    return this.#headers\n  }\n\n  // Returns the kind of resource requested by request, e.g., \"document\"\n  // or \"script\".\n  get destination () {\n    webidl.brandCheck(this, Request)\n\n    // The destination getter are to return thiss requests destination.\n    return this.#state.destination\n  }\n\n  // Returns the referrer of request. Its value can be a same-origin URL if\n  // explicitly set in init, the empty string to indicate no referrer, and\n  // \"about:client\" when defaulting to the globals default. This is used\n  // during fetching to determine the value of the `Referer` header of the\n  // request being made.\n  get referrer () {\n    webidl.brandCheck(this, Request)\n\n    // 1. If thiss requests referrer is \"no-referrer\", then return the\n    // empty string.\n    if (this.#state.referrer === 'no-referrer') {\n      return ''\n    }\n\n    // 2. If thiss requests referrer is \"client\", then return\n    // \"about:client\".\n    if (this.#state.referrer === 'client') {\n      return 'about:client'\n    }\n\n    // Return thiss requests referrer, serialized.\n    return this.#state.referrer.toString()\n  }\n\n  // Returns the referrer policy associated with request.\n  // This is used during fetching to compute the value of the requests\n  // referrer.\n  get referrerPolicy () {\n    webidl.brandCheck(this, Request)\n\n    // The referrerPolicy getter steps are to return thiss requests referrer policy.\n    return this.#state.referrerPolicy\n  }\n\n  // Returns the mode associated with request, which is a string indicating\n  // whether the request will use CORS, or will be restricted to same-origin\n  // URLs.\n  get mode () {\n    webidl.brandCheck(this, Request)\n\n    // The mode getter steps are to return thiss requests mode.\n    return this.#state.mode\n  }\n\n  // Returns the credentials mode associated with request,\n  // which is a string indicating whether credentials will be sent with the\n  // request always, never, or only when sent to a same-origin URL.\n  get credentials () {\n    webidl.brandCheck(this, Request)\n\n    // The credentials getter steps are to return thiss requests credentials mode.\n    return this.#state.credentials\n  }\n\n  // Returns the cache mode associated with request,\n  // which is a string indicating how the request will\n  // interact with the browsers cache when fetching.\n  get cache () {\n    webidl.brandCheck(this, Request)\n\n    // The cache getter steps are to return thiss requests cache mode.\n    return this.#state.cache\n  }\n\n  // Returns the redirect mode associated with request,\n  // which is a string indicating how redirects for the\n  // request will be handled during fetching. A request\n  // will follow redirects by default.\n  get redirect () {\n    webidl.brandCheck(this, Request)\n\n    // The redirect getter steps are to return thiss requests redirect mode.\n    return this.#state.redirect\n  }\n\n  // Returns requests subresource integrity metadata, which is a\n  // cryptographic hash of the resource being fetched. Its value\n  // consists of multiple hashes separated by whitespace. [SRI]\n  get integrity () {\n    webidl.brandCheck(this, Request)\n\n    // The integrity getter steps are to return thiss requests integrity\n    // metadata.\n    return this.#state.integrity\n  }\n\n  // Returns a boolean indicating whether or not request can outlive the\n  // global in which it was created.\n  get keepalive () {\n    webidl.brandCheck(this, Request)\n\n    // The keepalive getter steps are to return thiss requests keepalive.\n    return this.#state.keepalive\n  }\n\n  // Returns a boolean indicating whether or not request is for a reload\n  // navigation.\n  get isReloadNavigation () {\n    webidl.brandCheck(this, Request)\n\n    // The isReloadNavigation getter steps are to return true if thiss\n    // requests reload-navigation flag is set; otherwise false.\n    return this.#state.reloadNavigation\n  }\n\n  // Returns a boolean indicating whether or not request is for a history\n  // navigation (a.k.a. back-forward navigation).\n  get isHistoryNavigation () {\n    webidl.brandCheck(this, Request)\n\n    // The isHistoryNavigation getter steps are to return true if thiss requests\n    // history-navigation flag is set; otherwise false.\n    return this.#state.historyNavigation\n  }\n\n  // Returns the signal associated with request, which is an AbortSignal\n  // object indicating whether or not request has been aborted, and its\n  // abort event handler.\n  get signal () {\n    webidl.brandCheck(this, Request)\n\n    // The signal getter steps are to return thiss signal.\n    return this.#signal\n  }\n\n  get body () {\n    webidl.brandCheck(this, Request)\n\n    return this.#state.body ? this.#state.body.stream : null\n  }\n\n  get bodyUsed () {\n    webidl.brandCheck(this, Request)\n\n    return !!this.#state.body && util.isDisturbed(this.#state.body.stream)\n  }\n\n  get duplex () {\n    webidl.brandCheck(this, Request)\n\n    return 'half'\n  }\n\n  // Returns a clone of request.\n  clone () {\n    webidl.brandCheck(this, Request)\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (bodyUnusable(this.#state)) {\n      throw new TypeError('unusable')\n    }\n\n    // 2. Let clonedRequest be the result of cloning thiss request.\n    const clonedRequest = cloneRequest(this.#state)\n\n    // 3. Let clonedRequestObject be the result of creating a Request object,\n    // given clonedRequest, thiss headerss guard, and thiss relevant Realm.\n    // 4. Make clonedRequestObjects signal follow thiss signal.\n    const ac = new AbortController()\n    if (this.signal.aborted) {\n      ac.abort(this.signal.reason)\n    } else {\n      let list = dependentControllerMap.get(this.signal)\n      if (list === undefined) {\n        list = new Set()\n        dependentControllerMap.set(this.signal, list)\n      }\n      const acRef = new WeakRef(ac)\n      list.add(acRef)\n      util.addAbortListener(\n        ac.signal,\n        buildAbort(acRef)\n      )\n    }\n\n    // 4. Return clonedRequestObject.\n    return fromInnerRequest(clonedRequest, this.#dispatcher, ac.signal, getHeadersGuard(this.#headers))\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    if (options.depth === null) {\n      options.depth = 2\n    }\n\n    options.colors ??= true\n\n    const properties = {\n      method: this.method,\n      url: this.url,\n      headers: this.headers,\n      destination: this.destination,\n      referrer: this.referrer,\n      referrerPolicy: this.referrerPolicy,\n      mode: this.mode,\n      credentials: this.credentials,\n      cache: this.cache,\n      redirect: this.redirect,\n      integrity: this.integrity,\n      keepalive: this.keepalive,\n      isReloadNavigation: this.isReloadNavigation,\n      isHistoryNavigation: this.isHistoryNavigation,\n      signal: this.signal\n    }\n\n    return `Request ${nodeUtil.formatWithOptions(options, properties)}`\n  }\n\n  /**\n   * @param {Request} request\n   * @param {AbortSignal} newSignal\n   */\n  static setRequestSignal (request, newSignal) {\n    request.#signal = newSignal\n    return request\n  }\n\n  /**\n   * @param {Request} request\n   */\n  static getRequestDispatcher (request) {\n    return request.#dispatcher\n  }\n\n  /**\n   * @param {Request} request\n   * @param {import('../../dispatcher/dispatcher')} newDispatcher\n   */\n  static setRequestDispatcher (request, newDispatcher) {\n    request.#dispatcher = newDispatcher\n  }\n\n  /**\n   * @param {Request} request\n   * @param {Headers} newHeaders\n   */\n  static setRequestHeaders (request, newHeaders) {\n    request.#headers = newHeaders\n  }\n\n  /**\n   * @param {Request} request\n   */\n  static getRequestState (request) {\n    return request.#state\n  }\n\n  /**\n   * @param {Request} request\n   * @param {any} newState\n   */\n  static setRequestState (request, newState) {\n    request.#state = newState\n  }\n}\n\nconst { setRequestSignal, getRequestDispatcher, setRequestDispatcher, setRequestHeaders, getRequestState, setRequestState } = Request\nReflect.deleteProperty(Request, 'setRequestSignal')\nReflect.deleteProperty(Request, 'getRequestDispatcher')\nReflect.deleteProperty(Request, 'setRequestDispatcher')\nReflect.deleteProperty(Request, 'setRequestHeaders')\nReflect.deleteProperty(Request, 'getRequestState')\nReflect.deleteProperty(Request, 'setRequestState')\n\nmixinBody(Request, getRequestState)\n\n// https://fetch.spec.whatwg.org/#requests\nfunction makeRequest (init) {\n  return {\n    method: init.method ?? 'GET',\n    localURLsOnly: init.localURLsOnly ?? false,\n    unsafeRequest: init.unsafeRequest ?? false,\n    body: init.body ?? null,\n    client: init.client ?? null,\n    reservedClient: init.reservedClient ?? null,\n    replacesClientId: init.replacesClientId ?? '',\n    window: init.window ?? 'client',\n    keepalive: init.keepalive ?? false,\n    serviceWorkers: init.serviceWorkers ?? 'all',\n    initiator: init.initiator ?? '',\n    destination: init.destination ?? '',\n    priority: init.priority ?? null,\n    origin: init.origin ?? 'client',\n    policyContainer: init.policyContainer ?? 'client',\n    referrer: init.referrer ?? 'client',\n    referrerPolicy: init.referrerPolicy ?? '',\n    mode: init.mode ?? 'no-cors',\n    useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,\n    credentials: init.credentials ?? 'same-origin',\n    useCredentials: init.useCredentials ?? false,\n    cache: init.cache ?? 'default',\n    redirect: init.redirect ?? 'follow',\n    integrity: init.integrity ?? '',\n    cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? '',\n    parserMetadata: init.parserMetadata ?? '',\n    reloadNavigation: init.reloadNavigation ?? false,\n    historyNavigation: init.historyNavigation ?? false,\n    userActivation: init.userActivation ?? false,\n    taintedOrigin: init.taintedOrigin ?? false,\n    redirectCount: init.redirectCount ?? 0,\n    responseTainting: init.responseTainting ?? 'basic',\n    preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,\n    done: init.done ?? false,\n    timingAllowFailed: init.timingAllowFailed ?? false,\n    urlList: init.urlList,\n    url: init.urlList[0],\n    headersList: init.headersList\n      ? new HeadersList(init.headersList)\n      : new HeadersList()\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-request-clone\nfunction cloneRequest (request) {\n  // To clone a request request, run these steps:\n\n  // 1. Let newRequest be a copy of request, except for its body.\n  const newRequest = makeRequest({ ...request, body: null })\n\n  // 2. If requests body is non-null, set newRequests body to the\n  // result of cloning requests body.\n  if (request.body != null) {\n    newRequest.body = cloneBody(newRequest, request.body)\n  }\n\n  // 3. Return newRequest.\n  return newRequest\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#request-create\n * @param {any} innerRequest\n * @param {import('../../dispatcher/agent')} dispatcher\n * @param {AbortSignal} signal\n * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard\n * @returns {Request}\n */\nfunction fromInnerRequest (innerRequest, dispatcher, signal, guard) {\n  const request = new Request(kConstruct)\n  setRequestState(request, innerRequest)\n  setRequestDispatcher(request, dispatcher)\n  setRequestSignal(request, signal)\n  const headers = new Headers(kConstruct)\n  setRequestHeaders(request, headers)\n  setHeadersList(headers, innerRequest.headersList)\n  setHeadersGuard(headers, guard)\n  return request\n}\n\nObject.defineProperties(Request.prototype, {\n  method: kEnumerableProperty,\n  url: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  signal: kEnumerableProperty,\n  duplex: kEnumerableProperty,\n  destination: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  isHistoryNavigation: kEnumerableProperty,\n  isReloadNavigation: kEnumerableProperty,\n  keepalive: kEnumerableProperty,\n  integrity: kEnumerableProperty,\n  cache: kEnumerableProperty,\n  credentials: kEnumerableProperty,\n  attribute: kEnumerableProperty,\n  referrerPolicy: kEnumerableProperty,\n  referrer: kEnumerableProperty,\n  mode: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Request',\n    configurable: true\n  }\n})\n\nwebidl.is.Request = webidl.util.MakeTypeAssertion(Request)\n\n// https://fetch.spec.whatwg.org/#requestinfo\nwebidl.converters.RequestInfo = function (V, prefix, argument) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V)\n  }\n\n  if (webidl.is.Request(V)) {\n    return V\n  }\n\n  return webidl.converters.USVString(V)\n}\n\n// https://fetch.spec.whatwg.org/#requestinit\nwebidl.converters.RequestInit = webidl.dictionaryConverter([\n  {\n    key: 'method',\n    converter: webidl.converters.ByteString\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  },\n  {\n    key: 'body',\n    converter: webidl.nullableConverter(\n      webidl.converters.BodyInit\n    )\n  },\n  {\n    key: 'referrer',\n    converter: webidl.converters.USVString\n  },\n  {\n    key: 'referrerPolicy',\n    converter: webidl.converters.DOMString,\n    // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\n    allowedValues: referrerPolicy\n  },\n  {\n    key: 'mode',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#concept-request-mode\n    allowedValues: requestMode\n  },\n  {\n    key: 'credentials',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestcredentials\n    allowedValues: requestCredentials\n  },\n  {\n    key: 'cache',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestcache\n    allowedValues: requestCache\n  },\n  {\n    key: 'redirect',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestredirect\n    allowedValues: requestRedirect\n  },\n  {\n    key: 'integrity',\n    converter: webidl.converters.DOMString\n  },\n  {\n    key: 'keepalive',\n    converter: webidl.converters.boolean\n  },\n  {\n    key: 'signal',\n    converter: webidl.nullableConverter(\n      (signal) => webidl.converters.AbortSignal(\n        signal,\n        'RequestInit',\n        'signal'\n      )\n    )\n  },\n  {\n    key: 'window',\n    converter: webidl.converters.any\n  },\n  {\n    key: 'duplex',\n    converter: webidl.converters.DOMString,\n    allowedValues: requestDuplex\n  },\n  {\n    key: 'dispatcher', // undici specific option\n    converter: webidl.converters.any\n  }\n])\n\nmodule.exports = {\n  Request,\n  makeRequest,\n  fromInnerRequest,\n  cloneRequest,\n  getRequestDispatcher,\n  getRequestState\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvcmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFWTs7QUFFWixRQUFRLGtEQUFrRCxFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDNUUsUUFBUSw0R0FBNEcsRUFBRSxtQkFBTyxDQUFDLHVFQUFXO0FBQ3pJLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyw2RkFBc0I7QUFDL0QsYUFBYSxtQkFBTyxDQUFDLHFFQUFpQjtBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyw0QkFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJFQUFhO0FBQ3pCLFFBQVEsNEVBQTRFO0FBQ3BGLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0VBQVc7QUFDdEMsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLHlFQUFZO0FBQzlDLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsMkVBQW9CO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxRQUFRLHdEQUF3RCxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7O0FBRXZGOztBQUVBLHFEQUFxRCxlQUFlO0FBQ3BFO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7O0FBRUEsYUFBYSx1Q0FBdUM7QUFDcEQ7O0FBRUEsYUFBYSxTQUFTO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsbUVBQW1FLFlBQVk7QUFDL0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsc0JBQXNCOztBQUVwRDtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMkNBQTJDLFNBQVMsMEJBQTBCLFlBQVk7QUFDMUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0MsT0FBTztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhEQUE4RDtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGdEQUFnRDtBQUN0RTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLHVDQUF1QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxvSEFBb0g7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsd0JBQXdCOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsa0NBQWtDO0FBQzdDLFdBQVcsYUFBYTtBQUN4QixXQUFXLG1FQUFtRTtBQUM5RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9mZXRjaC9yZXF1ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgQWJvcnRDb250cm9sbGVyICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGV4dHJhY3RCb2R5LCBtaXhpbkJvZHksIGNsb25lQm9keSwgYm9keVVudXNhYmxlIH0gPSByZXF1aXJlKCcuL2JvZHknKVxuY29uc3QgeyBIZWFkZXJzLCBmaWxsOiBmaWxsSGVhZGVycywgSGVhZGVyc0xpc3QsIHNldEhlYWRlcnNHdWFyZCwgZ2V0SGVhZGVyc0d1YXJkLCBzZXRIZWFkZXJzTGlzdCwgZ2V0SGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4vaGVhZGVycycpXG5jb25zdCB7IEZpbmFsaXphdGlvblJlZ2lzdHJ5IH0gPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItd2Vha3JlZicpKClcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3Qgbm9kZVV0aWwgPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3Qge1xuICBpc1ZhbGlkSFRUUFRva2VuLFxuICBzYW1lT3JpZ2luLFxuICBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0XG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHtcbiAgZm9yYmlkZGVuTWV0aG9kc1NldCxcbiAgY29yc1NhZmVMaXN0ZWRNZXRob2RzU2V0LFxuICByZWZlcnJlclBvbGljeSxcbiAgcmVxdWVzdFJlZGlyZWN0LFxuICByZXF1ZXN0TW9kZSxcbiAgcmVxdWVzdENyZWRlbnRpYWxzLFxuICByZXF1ZXN0Q2FjaGUsXG4gIHJlcXVlc3REdXBsZXhcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHksIG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSwgbm9ybWFsaXplZE1ldGhvZFJlY29yZHMgfSA9IHV0aWxcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi93ZWJpZGwnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuL2RhdGEtdXJsJylcbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgZ2V0TWF4TGlzdGVuZXJzLCBzZXRNYXhMaXN0ZW5lcnMsIGRlZmF1bHRNYXhMaXN0ZW5lcnMgfSA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJylcblxuY29uc3Qga0Fib3J0Q29udHJvbGxlciA9IFN5bWJvbCgnYWJvcnRDb250cm9sbGVyJylcblxuY29uc3QgcmVxdWVzdEZpbmFsaXplciA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoeyBzaWduYWwsIGFib3J0IH0pID0+IHtcbiAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnQpXG59KVxuXG5jb25zdCBkZXBlbmRlbnRDb250cm9sbGVyTWFwID0gbmV3IFdlYWtNYXAoKVxuXG5sZXQgYWJvcnRTaWduYWxIYXNFdmVudEhhbmRsZXJMZWFrV2FybmluZ1xuXG50cnkge1xuICBhYm9ydFNpZ25hbEhhc0V2ZW50SGFuZGxlckxlYWtXYXJuaW5nID0gZ2V0TWF4TGlzdGVuZXJzKG5ldyBBYm9ydENvbnRyb2xsZXIoKS5zaWduYWwpID4gMFxufSBjYXRjaCB7XG4gIGFib3J0U2lnbmFsSGFzRXZlbnRIYW5kbGVyTGVha1dhcm5pbmcgPSBmYWxzZVxufVxuXG5mdW5jdGlvbiBidWlsZEFib3J0IChhY1JlZikge1xuICByZXR1cm4gYWJvcnRcblxuICBmdW5jdGlvbiBhYm9ydCAoKSB7XG4gICAgY29uc3QgYWMgPSBhY1JlZi5kZXJlZigpXG4gICAgaWYgKGFjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEN1cnJlbnRseSwgdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggRmluYWxpemF0aW9uUmVnaXN0cnkuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ5MzQ0XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ3NzQ4XG4gICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhYm9ydCwgdGhlIGZpcnN0IHN0ZXAgaXMgdG8gdW5yZWdpc3RlciBmcm9tIGl0LlxuICAgICAgLy8gSWYgdGhlIGNvbnRyb2xsZXIgY2FuIHJlZmVyIHRvIGl0LCBpdCBpcyBzdGlsbCByZWdpc3RlcmVkLlxuICAgICAgLy8gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gICAgICByZXF1ZXN0RmluYWxpemVyLnVucmVnaXN0ZXIoYWJvcnQpXG5cbiAgICAgIC8vIFVuc3Vic2NyaWJlIGEgbGlzdGVuZXIuXG4gICAgICAvLyBGaW5hbGl6YXRpb25SZWdpc3RyeSB3aWxsIG5vIGxvbmdlciBiZSBjYWxsZWQsIHNvIHRoaXMgbXVzdCBiZSBkb25lLlxuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0KVxuXG4gICAgICBhYy5hYm9ydCh0aGlzLnJlYXNvbilcblxuICAgICAgY29uc3QgY29udHJvbGxlckxpc3QgPSBkZXBlbmRlbnRDb250cm9sbGVyTWFwLmdldChhYy5zaWduYWwpXG5cbiAgICAgIGlmIChjb250cm9sbGVyTGlzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChjb250cm9sbGVyTGlzdC5zaXplICE9PSAwKSB7XG4gICAgICAgICAgZm9yIChjb25zdCByZWYgb2YgY29udHJvbGxlckxpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0cmwgPSByZWYuZGVyZWYoKVxuICAgICAgICAgICAgaWYgKGN0cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjdHJsLmFib3J0KHRoaXMucmVhc29uKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyTGlzdC5jbGVhcigpXG4gICAgICAgIH1cbiAgICAgICAgZGVwZW5kZW50Q29udHJvbGxlck1hcC5kZWxldGUoYWMuc2lnbmFsKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5sZXQgcGF0Y2hNZXRob2RXYXJuaW5nID0gZmFsc2VcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3QtY2xhc3NcbmNsYXNzIFJlcXVlc3Qge1xuICAvKiogQHR5cGUge0Fib3J0U2lnbmFsfSAqL1xuICAjc2lnbmFsXG5cbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlcicpfSAqL1xuICAjZGlzcGF0Y2hlclxuXG4gIC8qKiBAdHlwZSB7SGVhZGVyc30gKi9cbiAgI2hlYWRlcnNcblxuICAjc3RhdGVcblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3RcbiAgY29uc3RydWN0b3IgKGlucHV0LCBpbml0ID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLnV0aWwubWFya0FzVW5jbG9uZWFibGUodGhpcylcblxuICAgIGlmIChpbnB1dCA9PT0ga0NvbnN0cnVjdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ1JlcXVlc3QgY29uc3RydWN0b3InXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBpbnB1dCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKGlucHV0LCBwcmVmaXgsICdpbnB1dCcpXG4gICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbml0KGluaXQsIHByZWZpeCwgJ2luaXQnKVxuXG4gICAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgbnVsbC5cbiAgICBsZXQgcmVxdWVzdCA9IG51bGxcblxuICAgIC8vIDIuIExldCBmYWxsYmFja01vZGUgYmUgbnVsbC5cbiAgICBsZXQgZmFsbGJhY2tNb2RlID0gbnVsbFxuXG4gICAgLy8gMy4gTGV0IGJhc2VVUkwgYmUgdGhpc+KAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN04oCZcyBBUEkgYmFzZSBVUkwuXG4gICAgY29uc3QgYmFzZVVybCA9IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3QuYmFzZVVybFxuXG4gICAgLy8gNC4gTGV0IHNpZ25hbCBiZSBudWxsLlxuICAgIGxldCBzaWduYWwgPSBudWxsXG5cbiAgICAvLyA1LiBJZiBpbnB1dCBpcyBhIHN0cmluZywgdGhlbjpcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hlciA9IGluaXQuZGlzcGF0Y2hlclxuXG4gICAgICAvLyAxLiBMZXQgcGFyc2VkVVJMIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyBpbnB1dCB3aXRoIGJhc2VVUkwuXG4gICAgICAvLyAyLiBJZiBwYXJzZWRVUkwgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGxldCBwYXJzZWRVUkxcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZFVSTCA9IG5ldyBVUkwoaW5wdXQsIGJhc2VVcmwpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIHBhcnNlIFVSTCBmcm9tICcgKyBpbnB1dCwgeyBjYXVzZTogZXJyIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIElmIHBhcnNlZFVSTCBpbmNsdWRlcyBjcmVkZW50aWFscywgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChwYXJzZWRVUkwudXNlcm5hbWUgfHwgcGFyc2VkVVJMLnBhc3N3b3JkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1JlcXVlc3QgY2Fubm90IGJlIGNvbnN0cnVjdGVkIGZyb20gYSBVUkwgdGhhdCBpbmNsdWRlcyBjcmVkZW50aWFsczogJyArXG4gICAgICAgICAgICBpbnB1dFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIDQuIFNldCByZXF1ZXN0IHRvIGEgbmV3IHJlcXVlc3Qgd2hvc2UgVVJMIGlzIHBhcnNlZFVSTC5cbiAgICAgIHJlcXVlc3QgPSBtYWtlUmVxdWVzdCh7IHVybExpc3Q6IFtwYXJzZWRVUkxdIH0pXG5cbiAgICAgIC8vIDUuIFNldCBmYWxsYmFja01vZGUgdG8gXCJjb3JzXCIuXG4gICAgICBmYWxsYmFja01vZGUgPSAnY29ycydcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gNi4gT3RoZXJ3aXNlOlxuXG4gICAgICAvLyA3LiBBc3NlcnQ6IGlucHV0IGlzIGEgUmVxdWVzdCBvYmplY3QuXG4gICAgICBhc3NlcnQod2ViaWRsLmlzLlJlcXVlc3QoaW5wdXQpKVxuXG4gICAgICAvLyA4LiBTZXQgcmVxdWVzdCB0byBpbnB1dOKAmXMgcmVxdWVzdC5cbiAgICAgIHJlcXVlc3QgPSBpbnB1dC4jc3RhdGVcblxuICAgICAgLy8gOS4gU2V0IHNpZ25hbCB0byBpbnB1dOKAmXMgc2lnbmFsLlxuICAgICAgc2lnbmFsID0gaW5wdXQuI3NpZ25hbFxuXG4gICAgICB0aGlzLiNkaXNwYXRjaGVyID0gaW5pdC5kaXNwYXRjaGVyIHx8IGlucHV0LiNkaXNwYXRjaGVyXG4gICAgfVxuXG4gICAgLy8gNy4gTGV0IG9yaWdpbiBiZSB0aGlz4oCZcyByZWxldmFudCBzZXR0aW5ncyBvYmplY3TigJlzIG9yaWdpbi5cbiAgICBjb25zdCBvcmlnaW4gPSBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0LnNldHRpbmdzT2JqZWN0Lm9yaWdpblxuXG4gICAgLy8gOC4gTGV0IHdpbmRvdyBiZSBcImNsaWVudFwiLlxuICAgIGxldCB3aW5kb3cgPSAnY2xpZW50J1xuXG4gICAgLy8gOS4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIGFuIGVudmlyb25tZW50IHNldHRpbmdzIG9iamVjdCBhbmQgaXRzIG9yaWdpblxuICAgIC8vIGlzIHNhbWUgb3JpZ2luIHdpdGggb3JpZ2luLCB0aGVuIHNldCB3aW5kb3cgdG8gcmVxdWVzdOKAmXMgd2luZG93LlxuICAgIGlmIChcbiAgICAgIHJlcXVlc3Qud2luZG93Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ0Vudmlyb25tZW50U2V0dGluZ3NPYmplY3QnICYmXG4gICAgICBzYW1lT3JpZ2luKHJlcXVlc3Qud2luZG93LCBvcmlnaW4pXG4gICAgKSB7XG4gICAgICB3aW5kb3cgPSByZXF1ZXN0LndpbmRvd1xuICAgIH1cblxuICAgIC8vIDEwLiBJZiBpbml0W1wid2luZG93XCJdIGV4aXN0cyBhbmQgaXMgbm9uLW51bGwsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKGluaXQud2luZG93ICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCd3aW5kb3cnIG9wdGlvbiAnJHt3aW5kb3d9JyBtdXN0IGJlIG51bGxgKVxuICAgIH1cblxuICAgIC8vIDExLiBJZiBpbml0W1wid2luZG93XCJdIGV4aXN0cywgdGhlbiBzZXQgd2luZG93IHRvIFwibm8td2luZG93XCIuXG4gICAgaWYgKCd3aW5kb3cnIGluIGluaXQpIHtcbiAgICAgIHdpbmRvdyA9ICduby13aW5kb3cnXG4gICAgfVxuXG4gICAgLy8gMTIuIFNldCByZXF1ZXN0IHRvIGEgbmV3IHJlcXVlc3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHtcbiAgICAgIC8vIFVSTCByZXF1ZXN04oCZcyBVUkwuXG4gICAgICAvLyB1bmRpY2kgaW1wbGVtZW50YXRpb24gbm90ZTogdGhpcyBpcyBzZXQgYXMgdGhlIGZpcnN0IGl0ZW0gaW4gcmVxdWVzdCdzIHVybExpc3QgaW4gbWFrZVJlcXVlc3RcbiAgICAgIC8vIG1ldGhvZCByZXF1ZXN04oCZcyBtZXRob2QuXG4gICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgLy8gaGVhZGVyIGxpc3QgQSBjb3B5IG9mIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgICAgLy8gdW5kaWNpIGltcGxlbWVudGF0aW9uIG5vdGU6IGhlYWRlcnNMaXN0IGlzIGNsb25lZCBpbiBtYWtlUmVxdWVzdFxuICAgICAgaGVhZGVyc0xpc3Q6IHJlcXVlc3QuaGVhZGVyc0xpc3QsXG4gICAgICAvLyB1bnNhZmUtcmVxdWVzdCBmbGFnIFNldC5cbiAgICAgIHVuc2FmZVJlcXVlc3Q6IHJlcXVlc3QudW5zYWZlUmVxdWVzdCxcbiAgICAgIC8vIGNsaWVudCBUaGlz4oCZcyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QuXG4gICAgICBjbGllbnQ6IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3QsXG4gICAgICAvLyB3aW5kb3cgd2luZG93LlxuICAgICAgd2luZG93LFxuICAgICAgLy8gcHJpb3JpdHkgcmVxdWVzdOKAmXMgcHJpb3JpdHkuXG4gICAgICBwcmlvcml0eTogcmVxdWVzdC5wcmlvcml0eSxcbiAgICAgIC8vIG9yaWdpbiByZXF1ZXN04oCZcyBvcmlnaW4uIFRoZSBwcm9wYWdhdGlvbiBvZiB0aGUgb3JpZ2luIGlzIG9ubHkgc2lnbmlmaWNhbnQgZm9yIG5hdmlnYXRpb24gcmVxdWVzdHNcbiAgICAgIC8vIGJlaW5nIGhhbmRsZWQgYnkgYSBzZXJ2aWNlIHdvcmtlci4gSW4gdGhpcyBzY2VuYXJpbyBhIHJlcXVlc3QgY2FuIGhhdmUgYW4gb3JpZ2luIHRoYXQgaXMgZGlmZmVyZW50XG4gICAgICAvLyBmcm9tIHRoZSBjdXJyZW50IGNsaWVudC5cbiAgICAgIG9yaWdpbjogcmVxdWVzdC5vcmlnaW4sXG4gICAgICAvLyByZWZlcnJlciByZXF1ZXN04oCZcyByZWZlcnJlci5cbiAgICAgIHJlZmVycmVyOiByZXF1ZXN0LnJlZmVycmVyLFxuICAgICAgLy8gcmVmZXJyZXIgcG9saWN5IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeS5cbiAgICAgIHJlZmVycmVyUG9saWN5OiByZXF1ZXN0LnJlZmVycmVyUG9saWN5LFxuICAgICAgLy8gbW9kZSByZXF1ZXN04oCZcyBtb2RlLlxuICAgICAgbW9kZTogcmVxdWVzdC5tb2RlLFxuICAgICAgLy8gY3JlZGVudGlhbHMgbW9kZSByZXF1ZXN04oCZcyBjcmVkZW50aWFscyBtb2RlLlxuICAgICAgY3JlZGVudGlhbHM6IHJlcXVlc3QuY3JlZGVudGlhbHMsXG4gICAgICAvLyBjYWNoZSBtb2RlIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUuXG4gICAgICBjYWNoZTogcmVxdWVzdC5jYWNoZSxcbiAgICAgIC8vIHJlZGlyZWN0IG1vZGUgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZS5cbiAgICAgIHJlZGlyZWN0OiByZXF1ZXN0LnJlZGlyZWN0LFxuICAgICAgLy8gaW50ZWdyaXR5IG1ldGFkYXRhIHJlcXVlc3TigJlzIGludGVncml0eSBtZXRhZGF0YS5cbiAgICAgIGludGVncml0eTogcmVxdWVzdC5pbnRlZ3JpdHksXG4gICAgICAvLyBrZWVwYWxpdmUgcmVxdWVzdOKAmXMga2VlcGFsaXZlLlxuICAgICAga2VlcGFsaXZlOiByZXF1ZXN0LmtlZXBhbGl2ZSxcbiAgICAgIC8vIHJlbG9hZC1uYXZpZ2F0aW9uIGZsYWcgcmVxdWVzdOKAmXMgcmVsb2FkLW5hdmlnYXRpb24gZmxhZy5cbiAgICAgIHJlbG9hZE5hdmlnYXRpb246IHJlcXVlc3QucmVsb2FkTmF2aWdhdGlvbixcbiAgICAgIC8vIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnIHJlcXVlc3TigJlzIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnLlxuICAgICAgaGlzdG9yeU5hdmlnYXRpb246IHJlcXVlc3QuaGlzdG9yeU5hdmlnYXRpb24sXG4gICAgICAvLyBVUkwgbGlzdCBBIGNsb25lIG9mIHJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICAgICAgdXJsTGlzdDogWy4uLnJlcXVlc3QudXJsTGlzdF1cbiAgICB9KVxuXG4gICAgY29uc3QgaW5pdEhhc0tleSA9IE9iamVjdC5rZXlzKGluaXQpLmxlbmd0aCAhPT0gMFxuXG4gICAgLy8gMTMuIElmIGluaXQgaXMgbm90IGVtcHR5LCB0aGVuOlxuICAgIGlmIChpbml0SGFzS2V5KSB7XG4gICAgICAvLyAxLiBJZiByZXF1ZXN04oCZcyBtb2RlIGlzIFwibmF2aWdhdGVcIiwgdGhlbiBzZXQgaXQgdG8gXCJzYW1lLW9yaWdpblwiLlxuICAgICAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ25hdmlnYXRlJykge1xuICAgICAgICByZXF1ZXN0Lm1vZGUgPSAnc2FtZS1vcmlnaW4nXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFVuc2V0IHJlcXVlc3TigJlzIHJlbG9hZC1uYXZpZ2F0aW9uIGZsYWcuXG4gICAgICByZXF1ZXN0LnJlbG9hZE5hdmlnYXRpb24gPSBmYWxzZVxuXG4gICAgICAvLyAzLiBVbnNldCByZXF1ZXN04oCZcyBoaXN0b3J5LW5hdmlnYXRpb24gZmxhZy5cbiAgICAgIHJlcXVlc3QuaGlzdG9yeU5hdmlnYXRpb24gPSBmYWxzZVxuXG4gICAgICAvLyA0LiBTZXQgcmVxdWVzdOKAmXMgb3JpZ2luIHRvIFwiY2xpZW50XCIuXG4gICAgICByZXF1ZXN0Lm9yaWdpbiA9ICdjbGllbnQnXG5cbiAgICAgIC8vIDUuIFNldCByZXF1ZXN04oCZcyByZWZlcnJlciB0byBcImNsaWVudFwiXG4gICAgICByZXF1ZXN0LnJlZmVycmVyID0gJ2NsaWVudCdcblxuICAgICAgLy8gNi4gU2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9ICcnXG5cbiAgICAgIC8vIDcuIFNldCByZXF1ZXN04oCZcyBVUkwgdG8gcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gICAgICByZXF1ZXN0LnVybCA9IHJlcXVlc3QudXJsTGlzdFtyZXF1ZXN0LnVybExpc3QubGVuZ3RoIC0gMV1cblxuICAgICAgLy8gOC4gU2V0IHJlcXVlc3TigJlzIFVSTCBsaXN0IHRvIMKrIHJlcXVlc3TigJlzIFVSTCDCuy5cbiAgICAgIHJlcXVlc3QudXJsTGlzdCA9IFtyZXF1ZXN0LnVybF1cbiAgICB9XG5cbiAgICAvLyAxNC4gSWYgaW5pdFtcInJlZmVycmVyXCJdIGV4aXN0cywgdGhlbjpcbiAgICBpZiAoaW5pdC5yZWZlcnJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAxLiBMZXQgcmVmZXJyZXIgYmUgaW5pdFtcInJlZmVycmVyXCJdLlxuICAgICAgY29uc3QgcmVmZXJyZXIgPSBpbml0LnJlZmVycmVyXG5cbiAgICAgIC8vIDIuIElmIHJlZmVycmVyIGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHRvIFwibm8tcmVmZXJyZXJcIi5cbiAgICAgIGlmIChyZWZlcnJlciA9PT0gJycpIHtcbiAgICAgICAgcmVxdWVzdC5yZWZlcnJlciA9ICduby1yZWZlcnJlcidcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDEuIExldCBwYXJzZWRSZWZlcnJlciBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgcmVmZXJyZXIgd2l0aFxuICAgICAgICAvLyBiYXNlVVJMLlxuICAgICAgICAvLyAyLiBJZiBwYXJzZWRSZWZlcnJlciBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgICBsZXQgcGFyc2VkUmVmZXJyZXJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWRSZWZlcnJlciA9IG5ldyBVUkwocmVmZXJyZXIsIGJhc2VVcmwpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFJlZmVycmVyIFwiJHtyZWZlcnJlcn1cIiBpcyBub3QgYSB2YWxpZCBVUkwuYCwgeyBjYXVzZTogZXJyIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBJZiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlXG4gICAgICAgIC8vIC0gcGFyc2VkUmVmZXJyZXLigJlzIHNjaGVtZSBpcyBcImFib3V0XCIgYW5kIHBhdGggaXMgdGhlIHN0cmluZyBcImNsaWVudFwiXG4gICAgICAgIC8vIC0gcGFyc2VkUmVmZXJyZXLigJlzIG9yaWdpbiBpcyBub3Qgc2FtZSBvcmlnaW4gd2l0aCBvcmlnaW5cbiAgICAgICAgLy8gdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgdG8gXCJjbGllbnRcIi5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIChwYXJzZWRSZWZlcnJlci5wcm90b2NvbCA9PT0gJ2Fib3V0OicgJiYgcGFyc2VkUmVmZXJyZXIuaG9zdG5hbWUgPT09ICdjbGllbnQnKSB8fFxuICAgICAgICAgIChvcmlnaW4gJiYgIXNhbWVPcmlnaW4ocGFyc2VkUmVmZXJyZXIsIGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3QuYmFzZVVybCkpXG4gICAgICAgICkge1xuICAgICAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSAnY2xpZW50J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIDQuIE90aGVyd2lzZSwgc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHRvIHBhcnNlZFJlZmVycmVyLlxuICAgICAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSBwYXJzZWRSZWZlcnJlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMTUuIElmIGluaXRbXCJyZWZlcnJlclBvbGljeVwiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeVxuICAgIC8vIHRvIGl0LlxuICAgIGlmIChpbml0LnJlZmVycmVyUG9saWN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPSBpbml0LnJlZmVycmVyUG9saWN5XG4gICAgfVxuXG4gICAgLy8gMTYuIExldCBtb2RlIGJlIGluaXRbXCJtb2RlXCJdIGlmIGl0IGV4aXN0cywgYW5kIGZhbGxiYWNrTW9kZSBvdGhlcndpc2UuXG4gICAgbGV0IG1vZGVcbiAgICBpZiAoaW5pdC5tb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1vZGUgPSBpbml0Lm1vZGVcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZSA9IGZhbGxiYWNrTW9kZVxuICAgIH1cblxuICAgIC8vIDE3LiBJZiBtb2RlIGlzIFwibmF2aWdhdGVcIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAobW9kZSA9PT0gJ25hdmlnYXRlJykge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdSZXF1ZXN0IGNvbnN0cnVjdG9yJyxcbiAgICAgICAgbWVzc2FnZTogJ2ludmFsaWQgcmVxdWVzdCBtb2RlIG5hdmlnYXRlLidcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMTguIElmIG1vZGUgaXMgbm9uLW51bGwsIHNldCByZXF1ZXN04oCZcyBtb2RlIHRvIG1vZGUuXG4gICAgaWYgKG1vZGUgIT0gbnVsbCkge1xuICAgICAgcmVxdWVzdC5tb2RlID0gbW9kZVxuICAgIH1cblxuICAgIC8vIDE5LiBJZiBpbml0W1wiY3JlZGVudGlhbHNcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyBjcmVkZW50aWFscyBtb2RlXG4gICAgLy8gdG8gaXQuXG4gICAgaWYgKGluaXQuY3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5jcmVkZW50aWFscyA9IGluaXQuY3JlZGVudGlhbHNcbiAgICB9XG5cbiAgICAvLyAxOC4gSWYgaW5pdFtcImNhY2hlXCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZSB0byBpdC5cbiAgICBpZiAoaW5pdC5jYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0LmNhY2hlID0gaW5pdC5jYWNoZVxuICAgIH1cblxuICAgIC8vIDIxLiBJZiByZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwib25seS1pZi1jYWNoZWRcIiBhbmQgcmVxdWVzdOKAmXMgbW9kZSBpc1xuICAgIC8vIG5vdCBcInNhbWUtb3JpZ2luXCIsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHJlcXVlc3QuY2FjaGUgPT09ICdvbmx5LWlmLWNhY2hlZCcgJiYgcmVxdWVzdC5tb2RlICE9PSAnc2FtZS1vcmlnaW4nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIidvbmx5LWlmLWNhY2hlZCcgY2FuIGJlIHNldCBvbmx5IHdpdGggJ3NhbWUtb3JpZ2luJyBtb2RlXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyAyMi4gSWYgaW5pdFtcInJlZGlyZWN0XCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZSB0byBpdC5cbiAgICBpZiAoaW5pdC5yZWRpcmVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0LnJlZGlyZWN0ID0gaW5pdC5yZWRpcmVjdFxuICAgIH1cblxuICAgIC8vIDIzLiBJZiBpbml0W1wiaW50ZWdyaXR5XCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgaW50ZWdyaXR5IG1ldGFkYXRhIHRvIGl0LlxuICAgIGlmIChpbml0LmludGVncml0eSAhPSBudWxsKSB7XG4gICAgICByZXF1ZXN0LmludGVncml0eSA9IFN0cmluZyhpbml0LmludGVncml0eSlcbiAgICB9XG5cbiAgICAvLyAyNC4gSWYgaW5pdFtcImtlZXBhbGl2ZVwiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGtlZXBhbGl2ZSB0byBpdC5cbiAgICBpZiAoaW5pdC5rZWVwYWxpdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5rZWVwYWxpdmUgPSBCb29sZWFuKGluaXQua2VlcGFsaXZlKVxuICAgIH1cblxuICAgIC8vIDI1LiBJZiBpbml0W1wibWV0aG9kXCJdIGV4aXN0cywgdGhlbjpcbiAgICBpZiAoaW5pdC5tZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gMS4gTGV0IG1ldGhvZCBiZSBpbml0W1wibWV0aG9kXCJdLlxuICAgICAgbGV0IG1ldGhvZCA9IGluaXQubWV0aG9kXG5cbiAgICAgIGNvbnN0IG1heUJlTm9ybWFsaXplZCA9IG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzW21ldGhvZF1cblxuICAgICAgaWYgKG1heUJlTm9ybWFsaXplZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE5vdGU6IEJ5cGFzcyB2YWxpZGF0aW9uIERFTEVURSwgR0VULCBIRUFELCBPUFRJT05TLCBQT1NULCBQVVQsIFBBVENIIGFuZCB0aGVzZSBsb3dlcmNhc2Ugb25lc1xuICAgICAgICByZXF1ZXN0Lm1ldGhvZCA9IG1heUJlTm9ybWFsaXplZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMi4gSWYgbWV0aG9kIGlzIG5vdCBhIG1ldGhvZCBvciBtZXRob2QgaXMgYSBmb3JiaWRkZW4gbWV0aG9kLCB0aGVuXG4gICAgICAgIC8vIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgICBpZiAoIWlzVmFsaWRIVFRQVG9rZW4obWV0aG9kKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCcke21ldGhvZH0nIGlzIG5vdCBhIHZhbGlkIEhUVFAgbWV0aG9kLmApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cHBlckNhc2UgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuXG4gICAgICAgIGlmIChmb3JiaWRkZW5NZXRob2RzU2V0Lmhhcyh1cHBlckNhc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJyR7bWV0aG9kfScgSFRUUCBtZXRob2QgaXMgdW5zdXBwb3J0ZWQuYClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIE5vcm1hbGl6ZSBtZXRob2QuXG4gICAgICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW1ldGhvZC1ub3JtYWxpemVcbiAgICAgICAgLy8gTm90ZTogbXVzdCBiZSBpbiB1cHBlcmNhc2VcbiAgICAgICAgbWV0aG9kID0gbm9ybWFsaXplZE1ldGhvZFJlY29yZHNCYXNlW3VwcGVyQ2FzZV0gPz8gbWV0aG9kXG5cbiAgICAgICAgLy8gNC4gU2V0IHJlcXVlc3TigJlzIG1ldGhvZCB0byBtZXRob2QuXG4gICAgICAgIHJlcXVlc3QubWV0aG9kID0gbWV0aG9kXG4gICAgICB9XG5cbiAgICAgIGlmICghcGF0Y2hNZXRob2RXYXJuaW5nICYmIHJlcXVlc3QubWV0aG9kID09PSAncGF0Y2gnKSB7XG4gICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoJ1VzaW5nIGBwYXRjaGAgaXMgaGlnaGx5IGxpa2VseSB0byByZXN1bHQgaW4gYSBgNDA1IE1ldGhvZCBOb3QgQWxsb3dlZGAuIGBQQVRDSGAgaXMgbXVjaCBtb3JlIGxpa2VseSB0byBzdWNjZWVkLicsIHtcbiAgICAgICAgICBjb2RlOiAnVU5ESUNJLUZFVENILXBhdGNoJ1xuICAgICAgICB9KVxuXG4gICAgICAgIHBhdGNoTWV0aG9kV2FybmluZyA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAyNi4gSWYgaW5pdFtcInNpZ25hbFwiXSBleGlzdHMsIHRoZW4gc2V0IHNpZ25hbCB0byBpdC5cbiAgICBpZiAoaW5pdC5zaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2lnbmFsID0gaW5pdC5zaWduYWxcbiAgICB9XG5cbiAgICAvLyAyNy4gU2V0IHRoaXPigJlzIHJlcXVlc3QgdG8gcmVxdWVzdC5cbiAgICB0aGlzLiNzdGF0ZSA9IHJlcXVlc3RcblxuICAgIC8vIDI4LiBTZXQgdGhpc+KAmXMgc2lnbmFsIHRvIGEgbmV3IEFib3J0U2lnbmFsIG9iamVjdCB3aXRoIHRoaXPigJlzIHJlbGV2YW50XG4gICAgLy8gUmVhbG0uXG4gICAgLy8gVE9ETzogY291bGQgdGhpcyBiZSBzaW1wbGlmaWVkIHdpdGggQWJvcnRTaWduYWwuYW55XG4gICAgLy8gKGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWFib3J0c2lnbmFsLWFueSlcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIHRoaXMuI3NpZ25hbCA9IGFjLnNpZ25hbFxuXG4gICAgLy8gMjkuIElmIHNpZ25hbCBpcyBub3QgbnVsbCwgdGhlbiBtYWtlIHRoaXPigJlzIHNpZ25hbCBmb2xsb3cgc2lnbmFsLlxuICAgIGlmIChzaWduYWwgIT0gbnVsbCkge1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGFjLmFib3J0KHNpZ25hbC5yZWFzb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBLZWVwIGEgc3Ryb25nIHJlZiB0byBhYyB3aGlsZSByZXF1ZXN0IG9iamVjdFxuICAgICAgICAvLyBpcyBhbGl2ZS4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudCBBYm9ydENvbnRyb2xsZXJcbiAgICAgICAgLy8gZnJvbSBiZWluZyBwcmVtYXR1cmVseSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICAgICAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTkyNi5cbiAgICAgICAgdGhpc1trQWJvcnRDb250cm9sbGVyXSA9IGFjXG5cbiAgICAgICAgY29uc3QgYWNSZWYgPSBuZXcgV2Vha1JlZihhYylcbiAgICAgICAgY29uc3QgYWJvcnQgPSBidWlsZEFib3J0KGFjUmVmKVxuXG4gICAgICAgIC8vIElmIHRoZSBtYXggYW1vdW50IG9mIGxpc3RlbmVycyBpcyBlcXVhbCB0byB0aGUgZGVmYXVsdCwgaW5jcmVhc2UgaXRcbiAgICAgICAgaWYgKGFib3J0U2lnbmFsSGFzRXZlbnRIYW5kbGVyTGVha1dhcm5pbmcgJiYgZ2V0TWF4TGlzdGVuZXJzKHNpZ25hbCkgPT09IGRlZmF1bHRNYXhMaXN0ZW5lcnMpIHtcbiAgICAgICAgICBzZXRNYXhMaXN0ZW5lcnMoMTUwMCwgc2lnbmFsKVxuICAgICAgICB9XG5cbiAgICAgICAgdXRpbC5hZGRBYm9ydExpc3RlbmVyKHNpZ25hbCwgYWJvcnQpXG4gICAgICAgIC8vIFRoZSB0aGlyZCBhcmd1bWVudCBtdXN0IGJlIGEgcmVnaXN0cnkga2V5IHRvIGJlIHVucmVnaXN0ZXJlZC5cbiAgICAgICAgLy8gV2l0aG91dCBpdCwgeW91IGNhbm5vdCB1bnJlZ2lzdGVyLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GaW5hbGl6YXRpb25SZWdpc3RyeVxuICAgICAgICAvLyBhYm9ydCBpcyB1c2VkIGFzIHRoZSB1bnJlZ2lzdGVyIGtleS4gKGJlY2F1c2UgaXQgaXMgdW5pcXVlKVxuICAgICAgICByZXF1ZXN0RmluYWxpemVyLnJlZ2lzdGVyKGFjLCB7IHNpZ25hbCwgYWJvcnQgfSwgYWJvcnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMzAuIFNldCB0aGlz4oCZcyBoZWFkZXJzIHRvIGEgbmV3IEhlYWRlcnMgb2JqZWN0IHdpdGggdGhpc+KAmXMgcmVsZXZhbnRcbiAgICAvLyBSZWFsbSwgd2hvc2UgaGVhZGVyIGxpc3QgaXMgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgYW5kIGd1YXJkIGlzXG4gICAgLy8gXCJyZXF1ZXN0XCIuXG4gICAgdGhpcy4jaGVhZGVycyA9IG5ldyBIZWFkZXJzKGtDb25zdHJ1Y3QpXG4gICAgc2V0SGVhZGVyc0xpc3QodGhpcy4jaGVhZGVycywgcmVxdWVzdC5oZWFkZXJzTGlzdClcbiAgICBzZXRIZWFkZXJzR3VhcmQodGhpcy4jaGVhZGVycywgJ3JlcXVlc3QnKVxuXG4gICAgLy8gMzEuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJuby1jb3JzXCIsIHRoZW46XG4gICAgaWYgKG1vZGUgPT09ICduby1jb3JzJykge1xuICAgICAgLy8gMS4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIG5vdCBhIENPUlMtc2FmZWxpc3RlZCBtZXRob2QsXG4gICAgICAvLyB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKCFjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQuaGFzKHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGAnJHtyZXF1ZXN0Lm1ldGhvZH0gaXMgdW5zdXBwb3J0ZWQgaW4gbm8tY29ycyBtb2RlLmBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBTZXQgdGhpc+KAmXMgaGVhZGVyc+KAmXMgZ3VhcmQgdG8gXCJyZXF1ZXN0LW5vLWNvcnNcIi5cbiAgICAgIHNldEhlYWRlcnNHdWFyZCh0aGlzLiNoZWFkZXJzLCAncmVxdWVzdC1uby1jb3JzJylcbiAgICB9XG5cbiAgICAvLyAzMi4gSWYgaW5pdCBpcyBub3QgZW1wdHksIHRoZW46XG4gICAgaWYgKGluaXRIYXNLZXkpIHtcbiAgICAgIC8qKiBAdHlwZSB7SGVhZGVyc0xpc3R9ICovXG4gICAgICBjb25zdCBoZWFkZXJzTGlzdCA9IGdldEhlYWRlcnNMaXN0KHRoaXMuI2hlYWRlcnMpXG4gICAgICAvLyAxLiBMZXQgaGVhZGVycyBiZSBhIGNvcHkgb2YgdGhpc+KAmXMgaGVhZGVycyBhbmQgaXRzIGFzc29jaWF0ZWQgaGVhZGVyXG4gICAgICAvLyBsaXN0LlxuICAgICAgLy8gMi4gSWYgaW5pdFtcImhlYWRlcnNcIl0gZXhpc3RzLCB0aGVuIHNldCBoZWFkZXJzIHRvIGluaXRbXCJoZWFkZXJzXCJdLlxuICAgICAgY29uc3QgaGVhZGVycyA9IGluaXQuaGVhZGVycyAhPT0gdW5kZWZpbmVkID8gaW5pdC5oZWFkZXJzIDogbmV3IEhlYWRlcnNMaXN0KGhlYWRlcnNMaXN0KVxuXG4gICAgICAvLyAzLiBFbXB0eSB0aGlz4oCZcyBoZWFkZXJz4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgIGhlYWRlcnNMaXN0LmNsZWFyKClcblxuICAgICAgLy8gNC4gSWYgaGVhZGVycyBpcyBhIEhlYWRlcnMgb2JqZWN0LCB0aGVuIGZvciBlYWNoIGhlYWRlciBpbiBpdHMgaGVhZGVyXG4gICAgICAvLyBsaXN0LCBhcHBlbmQgaGVhZGVy4oCZcyBuYW1lL2hlYWRlcuKAmXMgdmFsdWUgdG8gdGhpc+KAmXMgaGVhZGVycy5cbiAgICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVyc0xpc3QpIHtcbiAgICAgICAgZm9yIChjb25zdCB7IG5hbWUsIHZhbHVlIH0gb2YgaGVhZGVycy5yYXdWYWx1ZXMoKSkge1xuICAgICAgICAgIGhlYWRlcnNMaXN0LmFwcGVuZChuYW1lLCB2YWx1ZSwgZmFsc2UpXG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogQ29weSB0aGUgYHNldC1jb29raWVgIG1ldGEtZGF0YS5cbiAgICAgICAgaGVhZGVyc0xpc3QuY29va2llcyA9IGhlYWRlcnMuY29va2llc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gNS4gT3RoZXJ3aXNlLCBmaWxsIHRoaXPigJlzIGhlYWRlcnMgd2l0aCBoZWFkZXJzLlxuICAgICAgICBmaWxsSGVhZGVycyh0aGlzLiNoZWFkZXJzLCBoZWFkZXJzKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDMzLiBMZXQgaW5wdXRCb2R5IGJlIGlucHV04oCZcyByZXF1ZXN04oCZcyBib2R5IGlmIGlucHV0IGlzIGEgUmVxdWVzdFxuICAgIC8vIG9iamVjdDsgb3RoZXJ3aXNlIG51bGwuXG4gICAgY29uc3QgaW5wdXRCb2R5ID0gd2ViaWRsLmlzLlJlcXVlc3QoaW5wdXQpID8gaW5wdXQuI3N0YXRlLmJvZHkgOiBudWxsXG5cbiAgICAvLyAzNC4gSWYgZWl0aGVyIGluaXRbXCJib2R5XCJdIGV4aXN0cyBhbmQgaXMgbm9uLW51bGwgb3IgaW5wdXRCb2R5IGlzXG4gICAgLy8gbm9uLW51bGwsIGFuZCByZXF1ZXN04oCZcyBtZXRob2QgaXMgYEdFVGAgb3IgYEhFQURgLCB0aGVuIHRocm93IGFcbiAgICAvLyBUeXBlRXJyb3IuXG4gICAgaWYgKFxuICAgICAgKGluaXQuYm9keSAhPSBudWxsIHx8IGlucHV0Qm9keSAhPSBudWxsKSAmJlxuICAgICAgKHJlcXVlc3QubWV0aG9kID09PSAnR0VUJyB8fCByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVxdWVzdCB3aXRoIEdFVC9IRUFEIG1ldGhvZCBjYW5ub3QgaGF2ZSBib2R5LicpXG4gICAgfVxuXG4gICAgLy8gMzUuIExldCBpbml0Qm9keSBiZSBudWxsLlxuICAgIGxldCBpbml0Qm9keSA9IG51bGxcblxuICAgIC8vIDM2LiBJZiBpbml0W1wiYm9keVwiXSBleGlzdHMgYW5kIGlzIG5vbi1udWxsLCB0aGVuOlxuICAgIGlmIChpbml0LmJvZHkgIT0gbnVsbCkge1xuICAgICAgLy8gMS4gTGV0IENvbnRlbnQtVHlwZSBiZSBudWxsLlxuICAgICAgLy8gMi4gU2V0IGluaXRCb2R5IGFuZCBDb250ZW50LVR5cGUgdG8gdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nXG4gICAgICAvLyBpbml0W1wiYm9keVwiXSwgd2l0aCBrZWVwYWxpdmUgc2V0IHRvIHJlcXVlc3TigJlzIGtlZXBhbGl2ZS5cbiAgICAgIGNvbnN0IFtleHRyYWN0ZWRCb2R5LCBjb250ZW50VHlwZV0gPSBleHRyYWN0Qm9keShcbiAgICAgICAgaW5pdC5ib2R5LFxuICAgICAgICByZXF1ZXN0LmtlZXBhbGl2ZVxuICAgICAgKVxuICAgICAgaW5pdEJvZHkgPSBleHRyYWN0ZWRCb2R5XG5cbiAgICAgIC8vIDMsIElmIENvbnRlbnQtVHlwZSBpcyBub24tbnVsbCBhbmQgdGhpc+KAmXMgaGVhZGVyc+KAmXMgaGVhZGVyIGxpc3QgZG9lc1xuICAgICAgLy8gbm90IGNvbnRhaW4gYENvbnRlbnQtVHlwZWAsIHRoZW4gYXBwZW5kIGBDb250ZW50LVR5cGVgL0NvbnRlbnQtVHlwZSB0b1xuICAgICAgLy8gdGhpc+KAmXMgaGVhZGVycy5cbiAgICAgIGlmIChjb250ZW50VHlwZSAmJiAhZ2V0SGVhZGVyc0xpc3QodGhpcy4jaGVhZGVycykuY29udGFpbnMoJ2NvbnRlbnQtdHlwZScsIHRydWUpKSB7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMuYXBwZW5kKCdjb250ZW50LXR5cGUnLCBjb250ZW50VHlwZSwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzNy4gTGV0IGlucHV0T3JJbml0Qm9keSBiZSBpbml0Qm9keSBpZiBpdCBpcyBub24tbnVsbDsgb3RoZXJ3aXNlXG4gICAgLy8gaW5wdXRCb2R5LlxuICAgIGNvbnN0IGlucHV0T3JJbml0Qm9keSA9IGluaXRCb2R5ID8/IGlucHV0Qm9keVxuXG4gICAgLy8gMzguIElmIGlucHV0T3JJbml0Qm9keSBpcyBub24tbnVsbCBhbmQgaW5wdXRPckluaXRCb2R54oCZcyBzb3VyY2UgaXNcbiAgICAvLyBudWxsLCB0aGVuOlxuICAgIGlmIChpbnB1dE9ySW5pdEJvZHkgIT0gbnVsbCAmJiBpbnB1dE9ySW5pdEJvZHkuc291cmNlID09IG51bGwpIHtcbiAgICAgIC8vIDEuIElmIGluaXRCb2R5IGlzIG5vbi1udWxsIGFuZCBpbml0W1wiZHVwbGV4XCJdIGRvZXMgbm90IGV4aXN0LFxuICAgICAgLy8gICAgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChpbml0Qm9keSAhPSBudWxsICYmIGluaXQuZHVwbGV4ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVxdWVzdEluaXQ6IGR1cGxleCBvcHRpb24gaXMgcmVxdWlyZWQgd2hlbiBzZW5kaW5nIGEgYm9keS4nKVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtb2RlIGlzIG5laXRoZXIgXCJzYW1lLW9yaWdpblwiIG5vciBcImNvcnNcIixcbiAgICAgIC8vIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAocmVxdWVzdC5tb2RlICE9PSAnc2FtZS1vcmlnaW4nICYmIHJlcXVlc3QubW9kZSAhPT0gJ2NvcnMnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0lmIHJlcXVlc3QgaXMgbWFkZSBmcm9tIFJlYWRhYmxlU3RyZWFtLCBtb2RlIHNob3VsZCBiZSBcInNhbWUtb3JpZ2luXCIgb3IgXCJjb3JzXCInXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gMy4gU2V0IHRoaXPigJlzIHJlcXVlc3TigJlzIHVzZS1DT1JTLXByZWZsaWdodCBmbGFnLlxuICAgICAgcmVxdWVzdC51c2VDT1JTUHJlZmxpZ2h0RmxhZyA9IHRydWVcbiAgICB9XG5cbiAgICAvLyAzOS4gTGV0IGZpbmFsQm9keSBiZSBpbnB1dE9ySW5pdEJvZHkuXG4gICAgbGV0IGZpbmFsQm9keSA9IGlucHV0T3JJbml0Qm9keVxuXG4gICAgLy8gNDAuIElmIGluaXRCb2R5IGlzIG51bGwgYW5kIGlucHV0Qm9keSBpcyBub24tbnVsbCwgdGhlbjpcbiAgICBpZiAoaW5pdEJvZHkgPT0gbnVsbCAmJiBpbnB1dEJvZHkgIT0gbnVsbCkge1xuICAgICAgLy8gMS4gSWYgaW5wdXQgaXMgdW51c2FibGUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAoYm9keVVudXNhYmxlKGlucHV0LiNzdGF0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IGNvbnN0cnVjdCBhIFJlcXVlc3Qgd2l0aCBhIFJlcXVlc3Qgb2JqZWN0IHRoYXQgaGFzIGFscmVhZHkgYmVlbiB1c2VkLidcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBTZXQgZmluYWxCb2R5IHRvIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYSBwcm94eSBmb3IgaW5wdXRCb2R5LlxuICAgICAgLy8gaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZGFibGVzdHJlYW0tY3JlYXRlLWEtcHJveHlcbiAgICAgIGNvbnN0IGlkZW50aXR5VHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpXG4gICAgICBpbnB1dEJvZHkuc3RyZWFtLnBpcGVUaHJvdWdoKGlkZW50aXR5VHJhbnNmb3JtKVxuICAgICAgZmluYWxCb2R5ID0ge1xuICAgICAgICBzb3VyY2U6IGlucHV0Qm9keS5zb3VyY2UsXG4gICAgICAgIGxlbmd0aDogaW5wdXRCb2R5Lmxlbmd0aCxcbiAgICAgICAgc3RyZWFtOiBpZGVudGl0eVRyYW5zZm9ybS5yZWFkYWJsZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQxLiBTZXQgdGhpc+KAmXMgcmVxdWVzdOKAmXMgYm9keSB0byBmaW5hbEJvZHkuXG4gICAgdGhpcy4jc3RhdGUuYm9keSA9IGZpbmFsQm9keVxuICB9XG5cbiAgLy8gUmV0dXJucyByZXF1ZXN04oCZcyBIVFRQIG1ldGhvZCwgd2hpY2ggaXMgXCJHRVRcIiBieSBkZWZhdWx0LlxuICBnZXQgbWV0aG9kICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIG1ldGhvZCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtZXRob2QuXG4gICAgcmV0dXJuIHRoaXMuI3N0YXRlLm1ldGhvZFxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgVVJMIG9mIHJlcXVlc3QgYXMgYSBzdHJpbmcuXG4gIGdldCB1cmwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgdXJsIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIFVSTCwgc2VyaWFsaXplZC5cbiAgICByZXR1cm4gVVJMU2VyaWFsaXplcih0aGlzLiNzdGF0ZS51cmwpXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgSGVhZGVycyBvYmplY3QgY29uc2lzdGluZyBvZiB0aGUgaGVhZGVycyBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdC5cbiAgLy8gTm90ZSB0aGF0IGhlYWRlcnMgYWRkZWQgaW4gdGhlIG5ldHdvcmsgbGF5ZXIgYnkgdGhlIHVzZXIgYWdlbnQgd2lsbCBub3RcbiAgLy8gYmUgYWNjb3VudGVkIGZvciBpbiB0aGlzIG9iamVjdCwgZS5nLiwgdGhlIFwiSG9zdFwiIGhlYWRlci5cbiAgZ2V0IGhlYWRlcnMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgaGVhZGVycyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyBoZWFkZXJzLlxuICAgIHJldHVybiB0aGlzLiNoZWFkZXJzXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBraW5kIG9mIHJlc291cmNlIHJlcXVlc3RlZCBieSByZXF1ZXN0LCBlLmcuLCBcImRvY3VtZW50XCJcbiAgLy8gb3IgXCJzY3JpcHRcIi5cbiAgZ2V0IGRlc3RpbmF0aW9uICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGRlc3RpbmF0aW9uIGdldHRlciBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIGRlc3RpbmF0aW9uLlxuICAgIHJldHVybiB0aGlzLiNzdGF0ZS5kZXN0aW5hdGlvblxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVmZXJyZXIgb2YgcmVxdWVzdC4gSXRzIHZhbHVlIGNhbiBiZSBhIHNhbWUtb3JpZ2luIFVSTCBpZlxuICAvLyBleHBsaWNpdGx5IHNldCBpbiBpbml0LCB0aGUgZW1wdHkgc3RyaW5nIHRvIGluZGljYXRlIG5vIHJlZmVycmVyLCBhbmRcbiAgLy8gXCJhYm91dDpjbGllbnRcIiB3aGVuIGRlZmF1bHRpbmcgdG8gdGhlIGdsb2JhbOKAmXMgZGVmYXVsdC4gVGhpcyBpcyB1c2VkXG4gIC8vIGR1cmluZyBmZXRjaGluZyB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIHRoZSBgUmVmZXJlcmAgaGVhZGVyIG9mIHRoZVxuICAvLyByZXF1ZXN0IGJlaW5nIG1hZGUuXG4gIGdldCByZWZlcnJlciAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIDEuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIHJlZmVycmVyIGlzIFwibm8tcmVmZXJyZXJcIiwgdGhlbiByZXR1cm4gdGhlXG4gICAgLy8gZW1wdHkgc3RyaW5nLlxuICAgIGlmICh0aGlzLiNzdGF0ZS5yZWZlcnJlciA9PT0gJ25vLXJlZmVycmVyJykge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgaXMgXCJjbGllbnRcIiwgdGhlbiByZXR1cm5cbiAgICAvLyBcImFib3V0OmNsaWVudFwiLlxuICAgIGlmICh0aGlzLiNzdGF0ZS5yZWZlcnJlciA9PT0gJ2NsaWVudCcpIHtcbiAgICAgIHJldHVybiAnYWJvdXQ6Y2xpZW50J1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyByZWZlcnJlciwgc2VyaWFsaXplZC5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUucmVmZXJyZXIudG9TdHJpbmcoKVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVmZXJyZXIgcG9saWN5IGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LlxuICAvLyBUaGlzIGlzIHVzZWQgZHVyaW5nIGZldGNoaW5nIHRvIGNvbXB1dGUgdGhlIHZhbHVlIG9mIHRoZSByZXF1ZXN04oCZc1xuICAvLyByZWZlcnJlci5cbiAgZ2V0IHJlZmVycmVyUG9saWN5ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIHJlZmVycmVyUG9saWN5IGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeS5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUucmVmZXJyZXJQb2xpY3lcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIG1vZGUgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsIHdoaWNoIGlzIGEgc3RyaW5nIGluZGljYXRpbmdcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCB3aWxsIHVzZSBDT1JTLCBvciB3aWxsIGJlIHJlc3RyaWN0ZWQgdG8gc2FtZS1vcmlnaW5cbiAgLy8gVVJMcy5cbiAgZ2V0IG1vZGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgbW9kZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtb2RlLlxuICAgIHJldHVybiB0aGlzLiNzdGF0ZS5tb2RlXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBjcmVkZW50aWFscyBtb2RlIGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LFxuICAvLyB3aGljaCBpcyBhIHN0cmluZyBpbmRpY2F0aW5nIHdoZXRoZXIgY3JlZGVudGlhbHMgd2lsbCBiZSBzZW50IHdpdGggdGhlXG4gIC8vIHJlcXVlc3QgYWx3YXlzLCBuZXZlciwgb3Igb25seSB3aGVuIHNlbnQgdG8gYSBzYW1lLW9yaWdpbiBVUkwuXG4gIGdldCBjcmVkZW50aWFscyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBjcmVkZW50aWFscyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBjcmVkZW50aWFscyBtb2RlLlxuICAgIHJldHVybiB0aGlzLiNzdGF0ZS5jcmVkZW50aWFsc1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgY2FjaGUgbW9kZSBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCxcbiAgLy8gd2hpY2ggaXMgYSBzdHJpbmcgaW5kaWNhdGluZyBob3cgdGhlIHJlcXVlc3Qgd2lsbFxuICAvLyBpbnRlcmFjdCB3aXRoIHRoZSBicm93c2Vy4oCZcyBjYWNoZSB3aGVuIGZldGNoaW5nLlxuICBnZXQgY2FjaGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgY2FjaGUgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZS5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUuY2FjaGVcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHJlZGlyZWN0IG1vZGUgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsXG4gIC8vIHdoaWNoIGlzIGEgc3RyaW5nIGluZGljYXRpbmcgaG93IHJlZGlyZWN0cyBmb3IgdGhlXG4gIC8vIHJlcXVlc3Qgd2lsbCBiZSBoYW5kbGVkIGR1cmluZyBmZXRjaGluZy4gQSByZXF1ZXN0XG4gIC8vIHdpbGwgZm9sbG93IHJlZGlyZWN0cyBieSBkZWZhdWx0LlxuICBnZXQgcmVkaXJlY3QgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgcmVkaXJlY3QgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZS5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUucmVkaXJlY3RcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVxdWVzdOKAmXMgc3VicmVzb3VyY2UgaW50ZWdyaXR5IG1ldGFkYXRhLCB3aGljaCBpcyBhXG4gIC8vIGNyeXB0b2dyYXBoaWMgaGFzaCBvZiB0aGUgcmVzb3VyY2UgYmVpbmcgZmV0Y2hlZC4gSXRzIHZhbHVlXG4gIC8vIGNvbnNpc3RzIG9mIG11bHRpcGxlIGhhc2hlcyBzZXBhcmF0ZWQgYnkgd2hpdGVzcGFjZS4gW1NSSV1cbiAgZ2V0IGludGVncml0eSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBpbnRlZ3JpdHkgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgaW50ZWdyaXR5XG4gICAgLy8gbWV0YWRhdGEuXG4gICAgcmV0dXJuIHRoaXMuI3N0YXRlLmludGVncml0eVxuICB9XG5cbiAgLy8gUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCByZXF1ZXN0IGNhbiBvdXRsaXZlIHRoZVxuICAvLyBnbG9iYWwgaW4gd2hpY2ggaXQgd2FzIGNyZWF0ZWQuXG4gIGdldCBrZWVwYWxpdmUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUga2VlcGFsaXZlIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIGtlZXBhbGl2ZS5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUua2VlcGFsaXZlXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHJlcXVlc3QgaXMgZm9yIGEgcmVsb2FkXG4gIC8vIG5hdmlnYXRpb24uXG4gIGdldCBpc1JlbG9hZE5hdmlnYXRpb24gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgaXNSZWxvYWROYXZpZ2F0aW9uIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXNcbiAgICAvLyByZXF1ZXN04oCZcyByZWxvYWQtbmF2aWdhdGlvbiBmbGFnIGlzIHNldDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzLiNzdGF0ZS5yZWxvYWROYXZpZ2F0aW9uXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHJlcXVlc3QgaXMgZm9yIGEgaGlzdG9yeVxuICAvLyBuYXZpZ2F0aW9uIChhLmsuYS4gYmFjay1mb3J3YXJkIG5hdmlnYXRpb24pLlxuICBnZXQgaXNIaXN0b3J5TmF2aWdhdGlvbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBpc0hpc3RvcnlOYXZpZ2F0aW9uIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgcmVxdWVzdOKAmXNcbiAgICAvLyBoaXN0b3J5LW5hdmlnYXRpb24gZmxhZyBpcyBzZXQ7IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUuaGlzdG9yeU5hdmlnYXRpb25cbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHNpZ25hbCBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCwgd2hpY2ggaXMgYW4gQWJvcnRTaWduYWxcbiAgLy8gb2JqZWN0IGluZGljYXRpbmcgd2hldGhlciBvciBub3QgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkLCBhbmQgaXRzXG4gIC8vIGFib3J0IGV2ZW50IGhhbmRsZXIuXG4gIGdldCBzaWduYWwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgc2lnbmFsIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHNpZ25hbC5cbiAgICByZXR1cm4gdGhpcy4jc2lnbmFsXG4gIH1cblxuICBnZXQgYm9keSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIHJldHVybiB0aGlzLiNzdGF0ZS5ib2R5ID8gdGhpcy4jc3RhdGUuYm9keS5zdHJlYW0gOiBudWxsXG4gIH1cblxuICBnZXQgYm9keVVzZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICByZXR1cm4gISF0aGlzLiNzdGF0ZS5ib2R5ICYmIHV0aWwuaXNEaXN0dXJiZWQodGhpcy4jc3RhdGUuYm9keS5zdHJlYW0pXG4gIH1cblxuICBnZXQgZHVwbGV4ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgcmV0dXJuICdoYWxmJ1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIGNsb25lIG9mIHJlcXVlc3QuXG4gIGNsb25lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gMS4gSWYgdGhpcyBpcyB1bnVzYWJsZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoYm9keVVudXNhYmxlKHRoaXMuI3N0YXRlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW51c2FibGUnKVxuICAgIH1cblxuICAgIC8vIDIuIExldCBjbG9uZWRSZXF1ZXN0IGJlIHRoZSByZXN1bHQgb2YgY2xvbmluZyB0aGlz4oCZcyByZXF1ZXN0LlxuICAgIGNvbnN0IGNsb25lZFJlcXVlc3QgPSBjbG9uZVJlcXVlc3QodGhpcy4jc3RhdGUpXG5cbiAgICAvLyAzLiBMZXQgY2xvbmVkUmVxdWVzdE9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVxdWVzdCBvYmplY3QsXG4gICAgLy8gZ2l2ZW4gY2xvbmVkUmVxdWVzdCwgdGhpc+KAmXMgaGVhZGVyc+KAmXMgZ3VhcmQsIGFuZCB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgICAvLyA0LiBNYWtlIGNsb25lZFJlcXVlc3RPYmplY3TigJlzIHNpZ25hbCBmb2xsb3cgdGhpc+KAmXMgc2lnbmFsLlxuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgaWYgKHRoaXMuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGFjLmFib3J0KHRoaXMuc2lnbmFsLnJlYXNvbilcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGxpc3QgPSBkZXBlbmRlbnRDb250cm9sbGVyTWFwLmdldCh0aGlzLnNpZ25hbClcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGlzdCA9IG5ldyBTZXQoKVxuICAgICAgICBkZXBlbmRlbnRDb250cm9sbGVyTWFwLnNldCh0aGlzLnNpZ25hbCwgbGlzdClcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjUmVmID0gbmV3IFdlYWtSZWYoYWMpXG4gICAgICBsaXN0LmFkZChhY1JlZilcbiAgICAgIHV0aWwuYWRkQWJvcnRMaXN0ZW5lcihcbiAgICAgICAgYWMuc2lnbmFsLFxuICAgICAgICBidWlsZEFib3J0KGFjUmVmKVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIDQuIFJldHVybiBjbG9uZWRSZXF1ZXN0T2JqZWN0LlxuICAgIHJldHVybiBmcm9tSW5uZXJSZXF1ZXN0KGNsb25lZFJlcXVlc3QsIHRoaXMuI2Rpc3BhdGNoZXIsIGFjLnNpZ25hbCwgZ2V0SGVhZGVyc0d1YXJkKHRoaXMuI2hlYWRlcnMpKVxuICB9XG5cbiAgW25vZGVVdGlsLmluc3BlY3QuY3VzdG9tXSAoZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kZXB0aCA9PT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5kZXB0aCA9IDJcbiAgICB9XG5cbiAgICBvcHRpb25zLmNvbG9ycyA/Pz0gdHJ1ZVxuXG4gICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgZGVzdGluYXRpb246IHRoaXMuZGVzdGluYXRpb24sXG4gICAgICByZWZlcnJlcjogdGhpcy5yZWZlcnJlcixcbiAgICAgIHJlZmVycmVyUG9saWN5OiB0aGlzLnJlZmVycmVyUG9saWN5LFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgY3JlZGVudGlhbHM6IHRoaXMuY3JlZGVudGlhbHMsXG4gICAgICBjYWNoZTogdGhpcy5jYWNoZSxcbiAgICAgIHJlZGlyZWN0OiB0aGlzLnJlZGlyZWN0LFxuICAgICAgaW50ZWdyaXR5OiB0aGlzLmludGVncml0eSxcbiAgICAgIGtlZXBhbGl2ZTogdGhpcy5rZWVwYWxpdmUsXG4gICAgICBpc1JlbG9hZE5hdmlnYXRpb246IHRoaXMuaXNSZWxvYWROYXZpZ2F0aW9uLFxuICAgICAgaXNIaXN0b3J5TmF2aWdhdGlvbjogdGhpcy5pc0hpc3RvcnlOYXZpZ2F0aW9uLFxuICAgICAgc2lnbmFsOiB0aGlzLnNpZ25hbFxuICAgIH1cblxuICAgIHJldHVybiBgUmVxdWVzdCAke25vZGVVdGlsLmZvcm1hdFdpdGhPcHRpb25zKG9wdGlvbnMsIHByb3BlcnRpZXMpfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gbmV3U2lnbmFsXG4gICAqL1xuICBzdGF0aWMgc2V0UmVxdWVzdFNpZ25hbCAocmVxdWVzdCwgbmV3U2lnbmFsKSB7XG4gICAgcmVxdWVzdC4jc2lnbmFsID0gbmV3U2lnbmFsXG4gICAgcmV0dXJuIHJlcXVlc3RcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICovXG4gIHN0YXRpYyBnZXRSZXF1ZXN0RGlzcGF0Y2hlciAocmVxdWVzdCkge1xuICAgIHJldHVybiByZXF1ZXN0LiNkaXNwYXRjaGVyXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXInKX0gbmV3RGlzcGF0Y2hlclxuICAgKi9cbiAgc3RhdGljIHNldFJlcXVlc3REaXNwYXRjaGVyIChyZXF1ZXN0LCBuZXdEaXNwYXRjaGVyKSB7XG4gICAgcmVxdWVzdC4jZGlzcGF0Y2hlciA9IG5ld0Rpc3BhdGNoZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICogQHBhcmFtIHtIZWFkZXJzfSBuZXdIZWFkZXJzXG4gICAqL1xuICBzdGF0aWMgc2V0UmVxdWVzdEhlYWRlcnMgKHJlcXVlc3QsIG5ld0hlYWRlcnMpIHtcbiAgICByZXF1ZXN0LiNoZWFkZXJzID0gbmV3SGVhZGVyc1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICAgKi9cbiAgc3RhdGljIGdldFJlcXVlc3RTdGF0ZSAocmVxdWVzdCkge1xuICAgIHJldHVybiByZXF1ZXN0LiNzdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICAgKiBAcGFyYW0ge2FueX0gbmV3U3RhdGVcbiAgICovXG4gIHN0YXRpYyBzZXRSZXF1ZXN0U3RhdGUgKHJlcXVlc3QsIG5ld1N0YXRlKSB7XG4gICAgcmVxdWVzdC4jc3RhdGUgPSBuZXdTdGF0ZVxuICB9XG59XG5cbmNvbnN0IHsgc2V0UmVxdWVzdFNpZ25hbCwgZ2V0UmVxdWVzdERpc3BhdGNoZXIsIHNldFJlcXVlc3REaXNwYXRjaGVyLCBzZXRSZXF1ZXN0SGVhZGVycywgZ2V0UmVxdWVzdFN0YXRlLCBzZXRSZXF1ZXN0U3RhdGUgfSA9IFJlcXVlc3RcblJlZmxlY3QuZGVsZXRlUHJvcGVydHkoUmVxdWVzdCwgJ3NldFJlcXVlc3RTaWduYWwnKVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShSZXF1ZXN0LCAnZ2V0UmVxdWVzdERpc3BhdGNoZXInKVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShSZXF1ZXN0LCAnc2V0UmVxdWVzdERpc3BhdGNoZXInKVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShSZXF1ZXN0LCAnc2V0UmVxdWVzdEhlYWRlcnMnKVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShSZXF1ZXN0LCAnZ2V0UmVxdWVzdFN0YXRlJylcblJlZmxlY3QuZGVsZXRlUHJvcGVydHkoUmVxdWVzdCwgJ3NldFJlcXVlc3RTdGF0ZScpXG5cbm1peGluQm9keShSZXF1ZXN0LCBnZXRSZXF1ZXN0U3RhdGUpXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0c1xuZnVuY3Rpb24gbWFrZVJlcXVlc3QgKGluaXQpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IGluaXQubWV0aG9kID8/ICdHRVQnLFxuICAgIGxvY2FsVVJMc09ubHk6IGluaXQubG9jYWxVUkxzT25seSA/PyBmYWxzZSxcbiAgICB1bnNhZmVSZXF1ZXN0OiBpbml0LnVuc2FmZVJlcXVlc3QgPz8gZmFsc2UsXG4gICAgYm9keTogaW5pdC5ib2R5ID8/IG51bGwsXG4gICAgY2xpZW50OiBpbml0LmNsaWVudCA/PyBudWxsLFxuICAgIHJlc2VydmVkQ2xpZW50OiBpbml0LnJlc2VydmVkQ2xpZW50ID8/IG51bGwsXG4gICAgcmVwbGFjZXNDbGllbnRJZDogaW5pdC5yZXBsYWNlc0NsaWVudElkID8/ICcnLFxuICAgIHdpbmRvdzogaW5pdC53aW5kb3cgPz8gJ2NsaWVudCcsXG4gICAga2VlcGFsaXZlOiBpbml0LmtlZXBhbGl2ZSA/PyBmYWxzZSxcbiAgICBzZXJ2aWNlV29ya2VyczogaW5pdC5zZXJ2aWNlV29ya2VycyA/PyAnYWxsJyxcbiAgICBpbml0aWF0b3I6IGluaXQuaW5pdGlhdG9yID8/ICcnLFxuICAgIGRlc3RpbmF0aW9uOiBpbml0LmRlc3RpbmF0aW9uID8/ICcnLFxuICAgIHByaW9yaXR5OiBpbml0LnByaW9yaXR5ID8/IG51bGwsXG4gICAgb3JpZ2luOiBpbml0Lm9yaWdpbiA/PyAnY2xpZW50JyxcbiAgICBwb2xpY3lDb250YWluZXI6IGluaXQucG9saWN5Q29udGFpbmVyID8/ICdjbGllbnQnLFxuICAgIHJlZmVycmVyOiBpbml0LnJlZmVycmVyID8/ICdjbGllbnQnLFxuICAgIHJlZmVycmVyUG9saWN5OiBpbml0LnJlZmVycmVyUG9saWN5ID8/ICcnLFxuICAgIG1vZGU6IGluaXQubW9kZSA/PyAnbm8tY29ycycsXG4gICAgdXNlQ09SU1ByZWZsaWdodEZsYWc6IGluaXQudXNlQ09SU1ByZWZsaWdodEZsYWcgPz8gZmFsc2UsXG4gICAgY3JlZGVudGlhbHM6IGluaXQuY3JlZGVudGlhbHMgPz8gJ3NhbWUtb3JpZ2luJyxcbiAgICB1c2VDcmVkZW50aWFsczogaW5pdC51c2VDcmVkZW50aWFscyA/PyBmYWxzZSxcbiAgICBjYWNoZTogaW5pdC5jYWNoZSA/PyAnZGVmYXVsdCcsXG4gICAgcmVkaXJlY3Q6IGluaXQucmVkaXJlY3QgPz8gJ2ZvbGxvdycsXG4gICAgaW50ZWdyaXR5OiBpbml0LmludGVncml0eSA/PyAnJyxcbiAgICBjcnlwdG9HcmFwaGljc05vbmNlTWV0YWRhdGE6IGluaXQuY3J5cHRvR3JhcGhpY3NOb25jZU1ldGFkYXRhID8/ICcnLFxuICAgIHBhcnNlck1ldGFkYXRhOiBpbml0LnBhcnNlck1ldGFkYXRhID8/ICcnLFxuICAgIHJlbG9hZE5hdmlnYXRpb246IGluaXQucmVsb2FkTmF2aWdhdGlvbiA/PyBmYWxzZSxcbiAgICBoaXN0b3J5TmF2aWdhdGlvbjogaW5pdC5oaXN0b3J5TmF2aWdhdGlvbiA/PyBmYWxzZSxcbiAgICB1c2VyQWN0aXZhdGlvbjogaW5pdC51c2VyQWN0aXZhdGlvbiA/PyBmYWxzZSxcbiAgICB0YWludGVkT3JpZ2luOiBpbml0LnRhaW50ZWRPcmlnaW4gPz8gZmFsc2UsXG4gICAgcmVkaXJlY3RDb3VudDogaW5pdC5yZWRpcmVjdENvdW50ID8/IDAsXG4gICAgcmVzcG9uc2VUYWludGluZzogaW5pdC5yZXNwb25zZVRhaW50aW5nID8/ICdiYXNpYycsXG4gICAgcHJldmVudE5vQ2FjaGVDYWNoZUNvbnRyb2xIZWFkZXJNb2RpZmljYXRpb246IGluaXQucHJldmVudE5vQ2FjaGVDYWNoZUNvbnRyb2xIZWFkZXJNb2RpZmljYXRpb24gPz8gZmFsc2UsXG4gICAgZG9uZTogaW5pdC5kb25lID8/IGZhbHNlLFxuICAgIHRpbWluZ0FsbG93RmFpbGVkOiBpbml0LnRpbWluZ0FsbG93RmFpbGVkID8/IGZhbHNlLFxuICAgIHVybExpc3Q6IGluaXQudXJsTGlzdCxcbiAgICB1cmw6IGluaXQudXJsTGlzdFswXSxcbiAgICBoZWFkZXJzTGlzdDogaW5pdC5oZWFkZXJzTGlzdFxuICAgICAgPyBuZXcgSGVhZGVyc0xpc3QoaW5pdC5oZWFkZXJzTGlzdClcbiAgICAgIDogbmV3IEhlYWRlcnNMaXN0KClcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1yZXF1ZXN0LWNsb25lXG5mdW5jdGlvbiBjbG9uZVJlcXVlc3QgKHJlcXVlc3QpIHtcbiAgLy8gVG8gY2xvbmUgYSByZXF1ZXN0IHJlcXVlc3QsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBMZXQgbmV3UmVxdWVzdCBiZSBhIGNvcHkgb2YgcmVxdWVzdCwgZXhjZXB0IGZvciBpdHMgYm9keS5cbiAgY29uc3QgbmV3UmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHsgLi4ucmVxdWVzdCwgYm9keTogbnVsbCB9KVxuXG4gIC8vIDIuIElmIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwsIHNldCBuZXdSZXF1ZXN04oCZcyBib2R5IHRvIHRoZVxuICAvLyByZXN1bHQgb2YgY2xvbmluZyByZXF1ZXN04oCZcyBib2R5LlxuICBpZiAocmVxdWVzdC5ib2R5ICE9IG51bGwpIHtcbiAgICBuZXdSZXF1ZXN0LmJvZHkgPSBjbG9uZUJvZHkobmV3UmVxdWVzdCwgcmVxdWVzdC5ib2R5KVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIG5ld1JlcXVlc3QuXG4gIHJldHVybiBuZXdSZXF1ZXN0XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdC1jcmVhdGVcbiAqIEBwYXJhbSB7YW55fSBpbm5lclJlcXVlc3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9kaXNwYXRjaGVyL2FnZW50Jyl9IGRpc3BhdGNoZXJcbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IHNpZ25hbFxuICogQHBhcmFtIHsncmVxdWVzdCcgfCAnaW1tdXRhYmxlJyB8ICdyZXF1ZXN0LW5vLWNvcnMnIHwgJ3Jlc3BvbnNlJyB8ICdub25lJ30gZ3VhcmRcbiAqIEByZXR1cm5zIHtSZXF1ZXN0fVxuICovXG5mdW5jdGlvbiBmcm9tSW5uZXJSZXF1ZXN0IChpbm5lclJlcXVlc3QsIGRpc3BhdGNoZXIsIHNpZ25hbCwgZ3VhcmQpIHtcbiAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGtDb25zdHJ1Y3QpXG4gIHNldFJlcXVlc3RTdGF0ZShyZXF1ZXN0LCBpbm5lclJlcXVlc3QpXG4gIHNldFJlcXVlc3REaXNwYXRjaGVyKHJlcXVlc3QsIGRpc3BhdGNoZXIpXG4gIHNldFJlcXVlc3RTaWduYWwocmVxdWVzdCwgc2lnbmFsKVxuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoa0NvbnN0cnVjdClcbiAgc2V0UmVxdWVzdEhlYWRlcnMocmVxdWVzdCwgaGVhZGVycylcbiAgc2V0SGVhZGVyc0xpc3QoaGVhZGVycywgaW5uZXJSZXF1ZXN0LmhlYWRlcnNMaXN0KVxuICBzZXRIZWFkZXJzR3VhcmQoaGVhZGVycywgZ3VhcmQpXG4gIHJldHVybiByZXF1ZXN0XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlcXVlc3QucHJvdG90eXBlLCB7XG4gIG1ldGhvZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoZWFkZXJzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWRpcmVjdDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2xvbmU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNpZ25hbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZHVwbGV4OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZXN0aW5hdGlvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keVVzZWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGlzSGlzdG9yeU5hdmlnYXRpb246IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGlzUmVsb2FkTmF2aWdhdGlvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAga2VlcGFsaXZlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBpbnRlZ3JpdHk6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNhY2hlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjcmVkZW50aWFsczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYXR0cmlidXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWZlcnJlclBvbGljeToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVmZXJyZXI6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG1vZGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdSZXF1ZXN0JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxud2ViaWRsLmlzLlJlcXVlc3QgPSB3ZWJpZGwudXRpbC5NYWtlVHlwZUFzc2VydGlvbihSZXF1ZXN0KVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGluZm9cbndlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBWID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoVilcbiAgfVxuXG4gIGlmICh3ZWJpZGwuaXMuUmVxdWVzdChWKSkge1xuICAgIHJldHVybiBWXG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYpXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0aW5pdFxud2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICdtZXRob2QnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZ1xuICB9LFxuICB7XG4gICAga2V5OiAnaGVhZGVycycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdFxuICB9LFxuICB7XG4gICAga2V5OiAnYm9keScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIoXG4gICAgICB3ZWJpZGwuY29udmVydGVycy5Cb2R5SW5pdFxuICAgIClcbiAgfSxcbiAge1xuICAgIGtleTogJ3JlZmVycmVyJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZ1xuICB9LFxuICB7XG4gICAga2V5OiAncmVmZXJyZXJQb2xpY3knLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNyZWZlcnJlci1wb2xpY3lcbiAgICBhbGxvd2VkVmFsdWVzOiByZWZlcnJlclBvbGljeVxuICB9LFxuICB7XG4gICAga2V5OiAnbW9kZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVxdWVzdC1tb2RlXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdE1vZGVcbiAgfSxcbiAge1xuICAgIGtleTogJ2NyZWRlbnRpYWxzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGNyZWRlbnRpYWxzXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdENyZWRlbnRpYWxzXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjYWNoZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RjYWNoZVxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlcXVlc3RDYWNoZVxuICB9LFxuICB7XG4gICAga2V5OiAncmVkaXJlY3QnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0cmVkaXJlY3RcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0UmVkaXJlY3RcbiAgfSxcbiAge1xuICAgIGtleTogJ2ludGVncml0eScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmdcbiAgfSxcbiAge1xuICAgIGtleTogJ2tlZXBhbGl2ZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdzaWduYWwnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKFxuICAgICAgKHNpZ25hbCkgPT4gd2ViaWRsLmNvbnZlcnRlcnMuQWJvcnRTaWduYWwoXG4gICAgICAgIHNpZ25hbCxcbiAgICAgICAgJ1JlcXVlc3RJbml0JyxcbiAgICAgICAgJ3NpZ25hbCdcbiAgICAgIClcbiAgICApXG4gIH0sXG4gIHtcbiAgICBrZXk6ICd3aW5kb3cnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdkdXBsZXgnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlcXVlc3REdXBsZXhcbiAgfSxcbiAge1xuICAgIGtleTogJ2Rpc3BhdGNoZXInLCAvLyB1bmRpY2kgc3BlY2lmaWMgb3B0aW9uXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5hbnlcbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJlcXVlc3QsXG4gIG1ha2VSZXF1ZXN0LFxuICBmcm9tSW5uZXJSZXF1ZXN0LFxuICBjbG9uZVJlcXVlc3QsXG4gIGdldFJlcXVlc3REaXNwYXRjaGVyLFxuICBnZXRSZXF1ZXN0U3RhdGVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/response.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/response.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Headers, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\")\nconst { extractBody, cloneBody, mixinBody, hasFinalizationRegistry, streamRegistry, bodyUnusable } = __webpack_require__(/*! ./body */ \"(rsc)/./node_modules/undici/lib/web/fetch/body.js\")\nconst util = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\")\nconst { kEnumerableProperty } = util\nconst {\n  isValidReasonPhrase,\n  isCancelled,\n  isAborted,\n  serializeJavascriptValueToJSONString,\n  isErrorLike,\n  isomorphicEncode,\n  environmentSettingsObject: relevantRealm\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst {\n  redirectStatusSet,\n  nullBodyStatus\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/fetch/constants.js\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { URLSerializer } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { types } = __webpack_require__(/*! node:util */ \"node:util\")\n\nconst textEncoder = new TextEncoder('utf-8')\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  /** @type {Headers} */\n  #headers\n\n  #state\n\n  // Creates network error Response.\n  static error () {\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and thiss\n    // relevant Realm.\n    const responseObject = fromInnerResponse(makeNetworkError(), 'immutable')\n\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-json\n  static json (data, init = undefined) {\n    webidl.argumentLengthCheck(arguments, 1, 'Response.json')\n\n    if (init !== null) {\n      init = webidl.converters.ResponseInit(init)\n    }\n\n    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n    const bytes = textEncoder.encode(\n      serializeJavascriptValueToJSONString(data)\n    )\n\n    // 2. Let body be the result of extracting bytes.\n    const body = extractBody(bytes)\n\n    // 3. Let responseObject be the result of creating a Response object, given a new response,\n    //    \"response\", and thiss relevant Realm.\n    const responseObject = fromInnerResponse(makeResponse({}), 'response')\n\n    // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n    initializeResponse(responseObject, init, { body: body[0], type: 'application/json' })\n\n    // 5. Return responseObject.\n    return responseObject\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect (url, status = 302) {\n    webidl.argumentLengthCheck(arguments, 1, 'Response.redirect')\n\n    url = webidl.converters.USVString(url)\n    status = webidl.converters['unsigned short'](status)\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // objects API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL\n    try {\n      parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl)\n    } catch (err) {\n      throw new TypeError(`Failed to parse URL from ${url}`, { cause: err })\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatusSet.has(status)) {\n      throw new RangeError(`Invalid status code ${status}`)\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and thiss relevant Realm.\n    const responseObject = fromInnerResponse(makeResponse({}), 'immutable')\n\n    // 5. Set responseObjects responses status to status.\n    responseObject.#state.status = status\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    const value = isomorphicEncode(URLSerializer(parsedURL))\n\n    // 7. Append `Location`/value to responseObjects responses header list.\n    responseObject.#state.headersList.append('location', value, true)\n\n    // 8. Return responseObject.\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor (body = null, init = undefined) {\n    webidl.util.markAsUncloneable(this)\n\n    if (body === kConstruct) {\n      return\n    }\n\n    if (body !== null) {\n      body = webidl.converters.BodyInit(body)\n    }\n\n    init = webidl.converters.ResponseInit(init)\n\n    // 1. Set thiss response to a new response.\n    this.#state = makeResponse({})\n\n    // 2. Set thiss headers to a new Headers object with thiss relevant\n    // Realm, whose header list is thiss responses header list and guard\n    // is \"response\".\n    this.#headers = new Headers(kConstruct)\n    setHeadersGuard(this.#headers, 'response')\n    setHeadersList(this.#headers, this.#state.headersList)\n\n    // 3. Let bodyWithType be null.\n    let bodyWithType = null\n\n    // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n    if (body != null) {\n      const [extractedBody, type] = extractBody(body)\n      bodyWithType = { body: extractedBody, type }\n    }\n\n    // 5. Perform initialize a response given this, init, and bodyWithType.\n    initializeResponse(this, init, bodyWithType)\n  }\n\n  // Returns responses type, e.g., \"cors\".\n  get type () {\n    webidl.brandCheck(this, Response)\n\n    // The type getter steps are to return thiss responses type.\n    return this.#state.type\n  }\n\n  // Returns responses URL, if it has one; otherwise the empty string.\n  get url () {\n    webidl.brandCheck(this, Response)\n\n    const urlList = this.#state.urlList\n\n    // The url getter steps are to return the empty string if thiss\n    // responses URL is null; otherwise thiss responses URL,\n    // serialized with exclude fragment set to true.\n    const url = urlList[urlList.length - 1] ?? null\n\n    if (url === null) {\n      return ''\n    }\n\n    return URLSerializer(url, true)\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected () {\n    webidl.brandCheck(this, Response)\n\n    // The redirected getter steps are to return true if thiss responses URL\n    // list has more than one item; otherwise false.\n    return this.#state.urlList.length > 1\n  }\n\n  // Returns responses status.\n  get status () {\n    webidl.brandCheck(this, Response)\n\n    // The status getter steps are to return thiss responses status.\n    return this.#state.status\n  }\n\n  // Returns whether responses status is an ok status.\n  get ok () {\n    webidl.brandCheck(this, Response)\n\n    // The ok getter steps are to return true if thiss responses status is an\n    // ok status; otherwise false.\n    return this.#state.status >= 200 && this.#state.status <= 299\n  }\n\n  // Returns responses status message.\n  get statusText () {\n    webidl.brandCheck(this, Response)\n\n    // The statusText getter steps are to return thiss responses status\n    // message.\n    return this.#state.statusText\n  }\n\n  // Returns responses headers as Headers.\n  get headers () {\n    webidl.brandCheck(this, Response)\n\n    // The headers getter steps are to return thiss headers.\n    return this.#headers\n  }\n\n  get body () {\n    webidl.brandCheck(this, Response)\n\n    return this.#state.body ? this.#state.body.stream : null\n  }\n\n  get bodyUsed () {\n    webidl.brandCheck(this, Response)\n\n    return !!this.#state.body && util.isDisturbed(this.#state.body.stream)\n  }\n\n  // Returns a clone of response.\n  clone () {\n    webidl.brandCheck(this, Response)\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (bodyUnusable(this.#state)) {\n      throw webidl.errors.exception({\n        header: 'Response.clone',\n        message: 'Body has already been consumed.'\n      })\n    }\n\n    // 2. Let clonedResponse be the result of cloning thiss response.\n    const clonedResponse = cloneResponse(this.#state)\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, thiss headerss guard, and thiss relevant Realm.\n    return fromInnerResponse(clonedResponse, getHeadersGuard(this.#headers))\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    if (options.depth === null) {\n      options.depth = 2\n    }\n\n    options.colors ??= true\n\n    const properties = {\n      status: this.status,\n      statusText: this.statusText,\n      headers: this.headers,\n      body: this.body,\n      bodyUsed: this.bodyUsed,\n      ok: this.ok,\n      redirected: this.redirected,\n      type: this.type,\n      url: this.url\n    }\n\n    return `Response ${nodeUtil.formatWithOptions(options, properties)}`\n  }\n\n  /**\n   * @param {Response} response\n   */\n  static getResponseHeaders (response) {\n    return response.#headers\n  }\n\n  /**\n   * @param {Response} response\n   * @param {Headers} newHeaders\n   */\n  static setResponseHeaders (response, newHeaders) {\n    response.#headers = newHeaders\n  }\n\n  /**\n   * @param {Response} response\n   */\n  static getResponseState (response) {\n    return response.#state\n  }\n\n  /**\n   * @param {Response} response\n   * @param {any} newState\n   */\n  static setResponseState (response, newState) {\n    response.#state = newState\n  }\n}\n\nconst { getResponseHeaders, setResponseHeaders, getResponseState, setResponseState } = Response\nReflect.deleteProperty(Response, 'getResponseHeaders')\nReflect.deleteProperty(Response, 'setResponseHeaders')\nReflect.deleteProperty(Response, 'getResponseState')\nReflect.deleteProperty(Response, 'setResponseState')\n\nmixinBody(Response, getResponseState)\n\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Response',\n    configurable: true\n  }\n})\n\nObject.defineProperties(Response, {\n  json: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  error: kEnumerableProperty\n})\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse (response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of responses\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(\n      cloneResponse(response.internalResponse),\n      response.type\n    )\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({ ...response, body: null })\n\n  // 3. If responses body is non-null, then set newResponses body to the\n  // result of cloning responses body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(newResponse, response.body)\n  }\n\n  // 4. Return newResponse.\n  return newResponse\n}\n\nfunction makeResponse (init) {\n  return {\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    requestIncludesCredentials: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init?.headersList\n      ? new HeadersList(init?.headersList)\n      : new HeadersList(),\n    urlList: init?.urlList ? [...init.urlList] : []\n  }\n}\n\nfunction makeNetworkError (reason) {\n  const isError = isErrorLike(reason)\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: isError\n      ? reason\n      : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  })\n}\n\n// @see https://fetch.spec.whatwg.org/#concept-network-error\nfunction isNetworkError (response) {\n  return (\n    // A network error is a response whose type is \"error\",\n    response.type === 'error' &&\n    // status is 0\n    response.status === 0\n  )\n}\n\nfunction makeFilteredResponse (response, state) {\n  state = {\n    internalResponse: response,\n    ...state\n  }\n\n  return new Proxy(response, {\n    get (target, p) {\n      return p in state ? state[p] : target[p]\n    },\n    set (target, p, value) {\n      assert(!(p in state))\n      target[p] = value\n      return true\n    }\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse (response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on requests response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal responses header list\n    // whose name is a forbidden response-header name.\n\n    // Note: undici does not implement forbidden response-header names\n    return makeFilteredResponse(response, {\n      type: 'basic',\n      headersList: response.headersList\n    })\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal responses header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal responses CORS-exposed header-name list.\n\n    // Note: undici does not implement CORS-safelisted response-header names\n    return makeFilteredResponse(response, {\n      type: 'cors',\n      headersList: response.headersList\n    })\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaque',\n      urlList: Object.freeze([]),\n      status: 0,\n      statusText: '',\n      body: null\n    })\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: [],\n      body: null\n    })\n  } else {\n    assert(false)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError (fetchParams, err = null) {\n  // 1. Assert: fetchParams is canceled.\n  assert(isCancelled(fetchParams))\n\n  // 2. Return an aborted network error if fetchParams is aborted;\n  // otherwise return a network error.\n  return isAborted(fetchParams)\n    ? makeNetworkError(Object.assign(new DOMException('The operation was aborted.', 'AbortError'), { cause: err }))\n    : makeNetworkError(Object.assign(new DOMException('Request was cancelled.'), { cause: err }))\n}\n\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse (response, init, body) {\n  // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n  //    throw a RangeError.\n  if (init.status !== null && (init.status < 200 || init.status > 599)) {\n    throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.')\n  }\n\n  // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n  //    then throw a TypeError.\n  if ('statusText' in init && init.statusText != null) {\n    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n    if (!isValidReasonPhrase(String(init.statusText))) {\n      throw new TypeError('Invalid statusText')\n    }\n  }\n\n  // 3. Set responses responses status to init[\"status\"].\n  if ('status' in init && init.status != null) {\n    getResponseState(response).status = init.status\n  }\n\n  // 4. Set responses responses status message to init[\"statusText\"].\n  if ('statusText' in init && init.statusText != null) {\n    getResponseState(response).statusText = init.statusText\n  }\n\n  // 5. If init[\"headers\"] exists, then fill responses headers with init[\"headers\"].\n  if ('headers' in init && init.headers != null) {\n    fill(getResponseHeaders(response), init.headers)\n  }\n\n  // 6. If body was given, then:\n  if (body) {\n    // 1. If response's status is a null body status, then throw a TypeError.\n    if (nullBodyStatus.includes(response.status)) {\n      throw webidl.errors.exception({\n        header: 'Response constructor',\n        message: `Invalid response status code ${response.status}`\n      })\n    }\n\n    // 2. Set response's body to body's body.\n    getResponseState(response).body = body.body\n\n    // 3. If body's type is non-null and response's header list does not contain\n    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n    if (body.type != null && !getResponseState(response).headersList.contains('content-type', true)) {\n      getResponseState(response).headersList.append('content-type', body.type, true)\n    }\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#response-create\n * @param {any} innerResponse\n * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard\n * @returns {Response}\n */\nfunction fromInnerResponse (innerResponse, guard) {\n  const response = new Response(kConstruct)\n  setResponseState(response, innerResponse)\n  const headers = new Headers(kConstruct)\n  setResponseHeaders(response, headers)\n  setHeadersList(headers, innerResponse.headersList)\n  setHeadersGuard(headers, guard)\n\n  if (hasFinalizationRegistry && innerResponse.body?.stream) {\n    // If the target (response) is reclaimed, the cleanup callback may be called at some point with\n    // the held value provided for it (innerResponse.body.stream). The held value can be any value:\n    // a primitive or an object, even undefined. If the held value is an object, the registry keeps\n    // a strong reference to it (so it can pass it to the cleanup callback later). Reworded from\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n    streamRegistry.register(response, new WeakRef(innerResponse.body.stream))\n  }\n\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function (V, prefix, name) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V, prefix, name)\n  }\n\n  if (webidl.is.Blob(V)) {\n    return V\n  }\n\n  if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {\n    return V\n  }\n\n  if (webidl.is.FormData(V)) {\n    return V\n  }\n\n  if (webidl.is.URLSearchParams(V)) {\n    return V\n  }\n\n  return webidl.converters.DOMString(V, prefix, name)\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function (V, prefix, argument) {\n  if (webidl.is.ReadableStream(V)) {\n    return V\n  }\n\n  // Note: the spec doesn't include async iterables,\n  // this is an undici extension.\n  if (V?.[Symbol.asyncIterator]) {\n    return V\n  }\n\n  return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument)\n}\n\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([\n  {\n    key: 'status',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: () => 200\n  },\n  {\n    key: 'statusText',\n    converter: webidl.converters.ByteString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  }\n])\n\nwebidl.is.Response = webidl.util.MakeTypeAssertion(Response)\n\nmodule.exports = {\n  isNetworkError,\n  makeNetworkError,\n  makeResponse,\n  makeAppropriateNetworkError,\n  filterResponse,\n  Response,\n  cloneResponse,\n  fromInnerResponse,\n  getResponseState\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvcmVzcG9uc2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSwrRUFBK0UsRUFBRSxtQkFBTyxDQUFDLHVFQUFXO0FBQzVHLFFBQVEsMkZBQTJGLEVBQUUsbUJBQU8sQ0FBQyxpRUFBUTtBQUNySCxhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDLGlCQUFpQixtQkFBTyxDQUFDLDRCQUFXO0FBQ3BDLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxpRUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywyRUFBYTtBQUN6QixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNFQUFXO0FBQ3RDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUM5QyxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLDJFQUFvQjtBQUNuRCxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSxRQUFRLEVBQUUsbUJBQU8sQ0FBQyw0QkFBVzs7QUFFckM7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQSwrQ0FBK0MseUNBQXlDOztBQUV4RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0RBQXNELElBQUksS0FBSyxZQUFZO0FBQzNFOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDs7QUFFQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGdEQUFnRDtBQUN2RTs7QUFFQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSw2RUFBNkU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyx5QkFBeUI7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcsWUFBWTtBQUNqSCxtRkFBbUYsWUFBWTtBQUMvRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsbUVBQW1FO0FBQzlFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9mZXRjaC9yZXNwb25zZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBIZWFkZXJzLCBIZWFkZXJzTGlzdCwgZmlsbCwgZ2V0SGVhZGVyc0d1YXJkLCBzZXRIZWFkZXJzR3VhcmQsIHNldEhlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuL2hlYWRlcnMnKVxuY29uc3QgeyBleHRyYWN0Qm9keSwgY2xvbmVCb2R5LCBtaXhpbkJvZHksIGhhc0ZpbmFsaXphdGlvblJlZ2lzdHJ5LCBzdHJlYW1SZWdpc3RyeSwgYm9keVVudXNhYmxlIH0gPSByZXF1aXJlKCcuL2JvZHknKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCBub2RlVXRpbCA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHV0aWxcbmNvbnN0IHtcbiAgaXNWYWxpZFJlYXNvblBocmFzZSxcbiAgaXNDYW5jZWxsZWQsXG4gIGlzQWJvcnRlZCxcbiAgc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nLFxuICBpc0Vycm9yTGlrZSxcbiAgaXNvbW9ycGhpY0VuY29kZSxcbiAgZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdDogcmVsZXZhbnRSZWFsbVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7XG4gIHJlZGlyZWN0U3RhdHVzU2V0LFxuICBudWxsQm9keVN0YXR1c1xufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi93ZWJpZGwnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuL2RhdGEtdXJsJylcbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgdHlwZXMgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5cbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZS1jbGFzc1xuY2xhc3MgUmVzcG9uc2Uge1xuICAvKiogQHR5cGUge0hlYWRlcnN9ICovXG4gICNoZWFkZXJzXG5cbiAgI3N0YXRlXG5cbiAgLy8gQ3JlYXRlcyBuZXR3b3JrIGVycm9yIFJlc3BvbnNlLlxuICBzdGF0aWMgZXJyb3IgKCkge1xuICAgIC8vIFRoZSBzdGF0aWMgZXJyb3IoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFcbiAgICAvLyBSZXNwb25zZSBvYmplY3QsIGdpdmVuIGEgbmV3IG5ldHdvcmsgZXJyb3IsIFwiaW1tdXRhYmxlXCIsIGFuZCB0aGlz4oCZc1xuICAgIC8vIHJlbGV2YW50IFJlYWxtLlxuICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0gZnJvbUlubmVyUmVzcG9uc2UobWFrZU5ldHdvcmtFcnJvcigpLCAnaW1tdXRhYmxlJylcblxuICAgIHJldHVybiByZXNwb25zZU9iamVjdFxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXNwb25zZS1qc29uXG4gIHN0YXRpYyBqc29uIChkYXRhLCBpbml0ID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnUmVzcG9uc2UuanNvbicpXG5cbiAgICBpZiAoaW5pdCAhPT0gbnVsbCkge1xuICAgICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlSW5pdChpbml0KVxuICAgIH1cblxuICAgIC8vIDEuIExldCBieXRlcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgc2VyaWFsaXplIGEgSmF2YVNjcmlwdCB2YWx1ZSB0byBKU09OIGJ5dGVzIG9uIGRhdGEuXG4gICAgY29uc3QgYnl0ZXMgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICBzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmcoZGF0YSlcbiAgICApXG5cbiAgICAvLyAyLiBMZXQgYm9keSBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgYnl0ZXMuXG4gICAgY29uc3QgYm9keSA9IGV4dHJhY3RCb2R5KGJ5dGVzKVxuXG4gICAgLy8gMy4gTGV0IHJlc3BvbnNlT2JqZWN0IGJlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYSBSZXNwb25zZSBvYmplY3QsIGdpdmVuIGEgbmV3IHJlc3BvbnNlLFxuICAgIC8vICAgIFwicmVzcG9uc2VcIiwgYW5kIHRoaXPigJlzIHJlbGV2YW50IFJlYWxtLlxuICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0gZnJvbUlubmVyUmVzcG9uc2UobWFrZVJlc3BvbnNlKHt9KSwgJ3Jlc3BvbnNlJylcblxuICAgIC8vIDQuIFBlcmZvcm0gaW5pdGlhbGl6ZSBhIHJlc3BvbnNlIGdpdmVuIHJlc3BvbnNlT2JqZWN0LCBpbml0LCBhbmQgKGJvZHksIFwiYXBwbGljYXRpb24vanNvblwiKS5cbiAgICBpbml0aWFsaXplUmVzcG9uc2UocmVzcG9uc2VPYmplY3QsIGluaXQsIHsgYm9keTogYm9keVswXSwgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nIH0pXG5cbiAgICAvLyA1LiBSZXR1cm4gcmVzcG9uc2VPYmplY3QuXG4gICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0XG4gIH1cblxuICAvLyBDcmVhdGVzIGEgcmVkaXJlY3QgUmVzcG9uc2UgdGhhdCByZWRpcmVjdHMgdG8gdXJsIHdpdGggc3RhdHVzIHN0YXR1cy5cbiAgc3RhdGljIHJlZGlyZWN0ICh1cmwsIHN0YXR1cyA9IDMwMikge1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ1Jlc3BvbnNlLnJlZGlyZWN0JylcblxuICAgIHVybCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh1cmwpXG4gICAgc3RhdHVzID0gd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIHNob3J0J10oc3RhdHVzKVxuXG4gICAgLy8gMS4gTGV0IHBhcnNlZFVSTCBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgdXJsIHdpdGggY3VycmVudCBzZXR0aW5nc1xuICAgIC8vIG9iamVjdOKAmXMgQVBJIGJhc2UgVVJMLlxuICAgIC8vIDIuIElmIHBhcnNlZFVSTCBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIC8vIFRPRE86IGJhc2UtVVJMP1xuICAgIGxldCBwYXJzZWRVUkxcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVVJMID0gbmV3IFVSTCh1cmwsIHJlbGV2YW50UmVhbG0uc2V0dGluZ3NPYmplY3QuYmFzZVVybClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBVUkwgZnJvbSAke3VybH1gLCB7IGNhdXNlOiBlcnIgfSlcbiAgICB9XG5cbiAgICAvLyAzLiBJZiBzdGF0dXMgaXMgbm90IGEgcmVkaXJlY3Qgc3RhdHVzLCB0aGVuIHRocm93IGEgUmFuZ2VFcnJvci5cbiAgICBpZiAoIXJlZGlyZWN0U3RhdHVzU2V0LmhhcyhzdGF0dXMpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBzdGF0dXMgY29kZSAke3N0YXR1c31gKVxuICAgIH1cblxuICAgIC8vIDQuIExldCByZXNwb25zZU9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LFxuICAgIC8vIGdpdmVuIGEgbmV3IHJlc3BvbnNlLCBcImltbXV0YWJsZVwiLCBhbmQgdGhpc+KAmXMgcmVsZXZhbnQgUmVhbG0uXG4gICAgY29uc3QgcmVzcG9uc2VPYmplY3QgPSBmcm9tSW5uZXJSZXNwb25zZShtYWtlUmVzcG9uc2Uoe30pLCAnaW1tdXRhYmxlJylcblxuICAgIC8vIDUuIFNldCByZXNwb25zZU9iamVjdOKAmXMgcmVzcG9uc2XigJlzIHN0YXR1cyB0byBzdGF0dXMuXG4gICAgcmVzcG9uc2VPYmplY3QuI3N0YXRlLnN0YXR1cyA9IHN0YXR1c1xuXG4gICAgLy8gNi4gTGV0IHZhbHVlIGJlIHBhcnNlZFVSTCwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLlxuICAgIGNvbnN0IHZhbHVlID0gaXNvbW9ycGhpY0VuY29kZShVUkxTZXJpYWxpemVyKHBhcnNlZFVSTCkpXG5cbiAgICAvLyA3LiBBcHBlbmQgYExvY2F0aW9uYC92YWx1ZSB0byByZXNwb25zZU9iamVjdOKAmXMgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgIHJlc3BvbnNlT2JqZWN0LiNzdGF0ZS5oZWFkZXJzTGlzdC5hcHBlbmQoJ2xvY2F0aW9uJywgdmFsdWUsIHRydWUpXG5cbiAgICAvLyA4LiBSZXR1cm4gcmVzcG9uc2VPYmplY3QuXG4gICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0XG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlc3BvbnNlXG4gIGNvbnN0cnVjdG9yIChib2R5ID0gbnVsbCwgaW5pdCA9IHVuZGVmaW5lZCkge1xuICAgIHdlYmlkbC51dGlsLm1hcmtBc1VuY2xvbmVhYmxlKHRoaXMpXG5cbiAgICBpZiAoYm9keSA9PT0ga0NvbnN0cnVjdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGJvZHkgIT09IG51bGwpIHtcbiAgICAgIGJvZHkgPSB3ZWJpZGwuY29udmVydGVycy5Cb2R5SW5pdChib2R5KVxuICAgIH1cblxuICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5SZXNwb25zZUluaXQoaW5pdClcblxuICAgIC8vIDEuIFNldCB0aGlz4oCZcyByZXNwb25zZSB0byBhIG5ldyByZXNwb25zZS5cbiAgICB0aGlzLiNzdGF0ZSA9IG1ha2VSZXNwb25zZSh7fSlcblxuICAgIC8vIDIuIFNldCB0aGlz4oCZcyBoZWFkZXJzIHRvIGEgbmV3IEhlYWRlcnMgb2JqZWN0IHdpdGggdGhpc+KAmXMgcmVsZXZhbnRcbiAgICAvLyBSZWFsbSwgd2hvc2UgaGVhZGVyIGxpc3QgaXMgdGhpc+KAmXMgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0IGFuZCBndWFyZFxuICAgIC8vIGlzIFwicmVzcG9uc2VcIi5cbiAgICB0aGlzLiNoZWFkZXJzID0gbmV3IEhlYWRlcnMoa0NvbnN0cnVjdClcbiAgICBzZXRIZWFkZXJzR3VhcmQodGhpcy4jaGVhZGVycywgJ3Jlc3BvbnNlJylcbiAgICBzZXRIZWFkZXJzTGlzdCh0aGlzLiNoZWFkZXJzLCB0aGlzLiNzdGF0ZS5oZWFkZXJzTGlzdClcblxuICAgIC8vIDMuIExldCBib2R5V2l0aFR5cGUgYmUgbnVsbC5cbiAgICBsZXQgYm9keVdpdGhUeXBlID0gbnVsbFxuXG4gICAgLy8gNC4gSWYgYm9keSBpcyBub24tbnVsbCwgdGhlbiBzZXQgYm9keVdpdGhUeXBlIHRvIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBib2R5LlxuICAgIGlmIChib2R5ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IFtleHRyYWN0ZWRCb2R5LCB0eXBlXSA9IGV4dHJhY3RCb2R5KGJvZHkpXG4gICAgICBib2R5V2l0aFR5cGUgPSB7IGJvZHk6IGV4dHJhY3RlZEJvZHksIHR5cGUgfVxuICAgIH1cblxuICAgIC8vIDUuIFBlcmZvcm0gaW5pdGlhbGl6ZSBhIHJlc3BvbnNlIGdpdmVuIHRoaXMsIGluaXQsIGFuZCBib2R5V2l0aFR5cGUuXG4gICAgaW5pdGlhbGl6ZVJlc3BvbnNlKHRoaXMsIGluaXQsIGJvZHlXaXRoVHlwZSlcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIHR5cGUsIGUuZy4sIFwiY29yc1wiLlxuICBnZXQgdHlwZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgdHlwZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXNwb25zZeKAmXMgdHlwZS5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUudHlwZVxuICB9XG5cbiAgLy8gUmV0dXJucyByZXNwb25zZeKAmXMgVVJMLCBpZiBpdCBoYXMgb25lOyBvdGhlcndpc2UgdGhlIGVtcHR5IHN0cmluZy5cbiAgZ2V0IHVybCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICBjb25zdCB1cmxMaXN0ID0gdGhpcy4jc3RhdGUudXJsTGlzdFxuXG4gICAgLy8gVGhlIHVybCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nIGlmIHRoaXPigJlzXG4gICAgLy8gcmVzcG9uc2XigJlzIFVSTCBpcyBudWxsOyBvdGhlcndpc2UgdGhpc+KAmXMgcmVzcG9uc2XigJlzIFVSTCxcbiAgICAvLyBzZXJpYWxpemVkIHdpdGggZXhjbHVkZSBmcmFnbWVudCBzZXQgdG8gdHJ1ZS5cbiAgICBjb25zdCB1cmwgPSB1cmxMaXN0W3VybExpc3QubGVuZ3RoIC0gMV0gPz8gbnVsbFxuXG4gICAgaWYgKHVybCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgcmV0dXJuIFVSTFNlcmlhbGl6ZXIodXJsLCB0cnVlKVxuICB9XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIHJlc3BvbnNlIHdhcyBvYnRhaW5lZCB0aHJvdWdoIGEgcmVkaXJlY3QuXG4gIGdldCByZWRpcmVjdGVkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSByZWRpcmVjdGVkIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgcmVzcG9uc2XigJlzIFVSTFxuICAgIC8vIGxpc3QgaGFzIG1vcmUgdGhhbiBvbmUgaXRlbTsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzLiNzdGF0ZS51cmxMaXN0Lmxlbmd0aCA+IDFcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIHN0YXR1cy5cbiAgZ2V0IHN0YXR1cyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgc3RhdHVzIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMuXG4gICAgcmV0dXJuIHRoaXMuI3N0YXRlLnN0YXR1c1xuICB9XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgYW4gb2sgc3RhdHVzLlxuICBnZXQgb2sgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIG9rIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgcmVzcG9uc2XigJlzIHN0YXR1cyBpcyBhblxuICAgIC8vIG9rIHN0YXR1czsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzLiNzdGF0ZS5zdGF0dXMgPj0gMjAwICYmIHRoaXMuI3N0YXRlLnN0YXR1cyA8PSAyOTlcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVzcG9uc2XigJlzIHN0YXR1cyBtZXNzYWdlLlxuICBnZXQgc3RhdHVzVGV4dCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgc3RhdHVzVGV4dCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXNwb25zZeKAmXMgc3RhdHVzXG4gICAgLy8gbWVzc2FnZS5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUuc3RhdHVzVGV4dFxuICB9XG5cbiAgLy8gUmV0dXJucyByZXNwb25zZeKAmXMgaGVhZGVycyBhcyBIZWFkZXJzLlxuICBnZXQgaGVhZGVycyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgaGVhZGVycyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyBoZWFkZXJzLlxuICAgIHJldHVybiB0aGlzLiNoZWFkZXJzXG4gIH1cblxuICBnZXQgYm9keSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICByZXR1cm4gdGhpcy4jc3RhdGUuYm9keSA/IHRoaXMuI3N0YXRlLmJvZHkuc3RyZWFtIDogbnVsbFxuICB9XG5cbiAgZ2V0IGJvZHlVc2VkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIHJldHVybiAhIXRoaXMuI3N0YXRlLmJvZHkgJiYgdXRpbC5pc0Rpc3R1cmJlZCh0aGlzLiNzdGF0ZS5ib2R5LnN0cmVhbSlcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBjbG9uZSBvZiByZXNwb25zZS5cbiAgY2xvbmUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gMS4gSWYgdGhpcyBpcyB1bnVzYWJsZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoYm9keVVudXNhYmxlKHRoaXMuI3N0YXRlKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdSZXNwb25zZS5jbG9uZScsXG4gICAgICAgIG1lc3NhZ2U6ICdCb2R5IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQuJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgY2xvbmVkUmVzcG9uc2UgYmUgdGhlIHJlc3VsdCBvZiBjbG9uaW5nIHRoaXPigJlzIHJlc3BvbnNlLlxuICAgIGNvbnN0IGNsb25lZFJlc3BvbnNlID0gY2xvbmVSZXNwb25zZSh0aGlzLiNzdGF0ZSlcblxuICAgIC8vIDMuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LCBnaXZlblxuICAgIC8vIGNsb25lZFJlc3BvbnNlLCB0aGlz4oCZcyBoZWFkZXJz4oCZcyBndWFyZCwgYW5kIHRoaXPigJlzIHJlbGV2YW50IFJlYWxtLlxuICAgIHJldHVybiBmcm9tSW5uZXJSZXNwb25zZShjbG9uZWRSZXNwb25zZSwgZ2V0SGVhZGVyc0d1YXJkKHRoaXMuI2hlYWRlcnMpKVxuICB9XG5cbiAgW25vZGVVdGlsLmluc3BlY3QuY3VzdG9tXSAoZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kZXB0aCA9PT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5kZXB0aCA9IDJcbiAgICB9XG5cbiAgICBvcHRpb25zLmNvbG9ycyA/Pz0gdHJ1ZVxuXG4gICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBib2R5OiB0aGlzLmJvZHksXG4gICAgICBib2R5VXNlZDogdGhpcy5ib2R5VXNlZCxcbiAgICAgIG9rOiB0aGlzLm9rLFxuICAgICAgcmVkaXJlY3RlZDogdGhpcy5yZWRpcmVjdGVkLFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH1cblxuICAgIHJldHVybiBgUmVzcG9uc2UgJHtub2RlVXRpbC5mb3JtYXRXaXRoT3B0aW9ucyhvcHRpb25zLCBwcm9wZXJ0aWVzKX1gXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAgICovXG4gIHN0YXRpYyBnZXRSZXNwb25zZUhlYWRlcnMgKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLiNoZWFkZXJzXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAgICogQHBhcmFtIHtIZWFkZXJzfSBuZXdIZWFkZXJzXG4gICAqL1xuICBzdGF0aWMgc2V0UmVzcG9uc2VIZWFkZXJzIChyZXNwb25zZSwgbmV3SGVhZGVycykge1xuICAgIHJlc3BvbnNlLiNoZWFkZXJzID0gbmV3SGVhZGVyc1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3BvbnNlXG4gICAqL1xuICBzdGF0aWMgZ2V0UmVzcG9uc2VTdGF0ZSAocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuI3N0YXRlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAgICogQHBhcmFtIHthbnl9IG5ld1N0YXRlXG4gICAqL1xuICBzdGF0aWMgc2V0UmVzcG9uc2VTdGF0ZSAocmVzcG9uc2UsIG5ld1N0YXRlKSB7XG4gICAgcmVzcG9uc2UuI3N0YXRlID0gbmV3U3RhdGVcbiAgfVxufVxuXG5jb25zdCB7IGdldFJlc3BvbnNlSGVhZGVycywgc2V0UmVzcG9uc2VIZWFkZXJzLCBnZXRSZXNwb25zZVN0YXRlLCBzZXRSZXNwb25zZVN0YXRlIH0gPSBSZXNwb25zZVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShSZXNwb25zZSwgJ2dldFJlc3BvbnNlSGVhZGVycycpXG5SZWZsZWN0LmRlbGV0ZVByb3BlcnR5KFJlc3BvbnNlLCAnc2V0UmVzcG9uc2VIZWFkZXJzJylcblJlZmxlY3QuZGVsZXRlUHJvcGVydHkoUmVzcG9uc2UsICdnZXRSZXNwb25zZVN0YXRlJylcblJlZmxlY3QuZGVsZXRlUHJvcGVydHkoUmVzcG9uc2UsICdzZXRSZXNwb25zZVN0YXRlJylcblxubWl4aW5Cb2R5KFJlc3BvbnNlLCBnZXRSZXNwb25zZVN0YXRlKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXNwb25zZS5wcm90b3R5cGUsIHtcbiAgdHlwZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzdGF0dXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9rOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWRpcmVjdGVkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzdGF0dXNUZXh0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoZWFkZXJzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjbG9uZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keVVzZWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdSZXNwb25zZScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlc3BvbnNlLCB7XG4gIGpzb246IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlZGlyZWN0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBlcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVzcG9uc2UtY2xvbmVcbmZ1bmN0aW9uIGNsb25lUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gIC8vIFRvIGNsb25lIGEgcmVzcG9uc2UgcmVzcG9uc2UsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBJZiByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlLCB0aGVuIHJldHVybiBhIG5ldyBpZGVudGljYWxcbiAgLy8gZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgaW50ZXJuYWwgcmVzcG9uc2UgaXMgYSBjbG9uZSBvZiByZXNwb25zZeKAmXNcbiAgLy8gaW50ZXJuYWwgcmVzcG9uc2UuXG4gIGlmIChyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIGZpbHRlclJlc3BvbnNlKFxuICAgICAgY2xvbmVSZXNwb25zZShyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlKSxcbiAgICAgIHJlc3BvbnNlLnR5cGVcbiAgICApXG4gIH1cblxuICAvLyAyLiBMZXQgbmV3UmVzcG9uc2UgYmUgYSBjb3B5IG9mIHJlc3BvbnNlLCBleGNlcHQgZm9yIGl0cyBib2R5LlxuICBjb25zdCBuZXdSZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7IC4uLnJlc3BvbnNlLCBib2R5OiBudWxsIH0pXG5cbiAgLy8gMy4gSWYgcmVzcG9uc2XigJlzIGJvZHkgaXMgbm9uLW51bGwsIHRoZW4gc2V0IG5ld1Jlc3BvbnNl4oCZcyBib2R5IHRvIHRoZVxuICAvLyByZXN1bHQgb2YgY2xvbmluZyByZXNwb25zZeKAmXMgYm9keS5cbiAgaWYgKHJlc3BvbnNlLmJvZHkgIT0gbnVsbCkge1xuICAgIG5ld1Jlc3BvbnNlLmJvZHkgPSBjbG9uZUJvZHkobmV3UmVzcG9uc2UsIHJlc3BvbnNlLmJvZHkpXG4gIH1cblxuICAvLyA0LiBSZXR1cm4gbmV3UmVzcG9uc2UuXG4gIHJldHVybiBuZXdSZXNwb25zZVxufVxuXG5mdW5jdGlvbiBtYWtlUmVzcG9uc2UgKGluaXQpIHtcbiAgcmV0dXJuIHtcbiAgICBhYm9ydGVkOiBmYWxzZSxcbiAgICByYW5nZVJlcXVlc3RlZDogZmFsc2UsXG4gICAgdGltaW5nQWxsb3dQYXNzZWQ6IGZhbHNlLFxuICAgIHJlcXVlc3RJbmNsdWRlc0NyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICB0eXBlOiAnZGVmYXVsdCcsXG4gICAgc3RhdHVzOiAyMDAsXG4gICAgdGltaW5nSW5mbzogbnVsbCxcbiAgICBjYWNoZVN0YXRlOiAnJyxcbiAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAuLi5pbml0LFxuICAgIGhlYWRlcnNMaXN0OiBpbml0Py5oZWFkZXJzTGlzdFxuICAgICAgPyBuZXcgSGVhZGVyc0xpc3QoaW5pdD8uaGVhZGVyc0xpc3QpXG4gICAgICA6IG5ldyBIZWFkZXJzTGlzdCgpLFxuICAgIHVybExpc3Q6IGluaXQ/LnVybExpc3QgPyBbLi4uaW5pdC51cmxMaXN0XSA6IFtdXG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZU5ldHdvcmtFcnJvciAocmVhc29uKSB7XG4gIGNvbnN0IGlzRXJyb3IgPSBpc0Vycm9yTGlrZShyZWFzb24pXG4gIHJldHVybiBtYWtlUmVzcG9uc2Uoe1xuICAgIHR5cGU6ICdlcnJvcicsXG4gICAgc3RhdHVzOiAwLFxuICAgIGVycm9yOiBpc0Vycm9yXG4gICAgICA/IHJlYXNvblxuICAgICAgOiBuZXcgRXJyb3IocmVhc29uID8gU3RyaW5nKHJlYXNvbikgOiByZWFzb24pLFxuICAgIGFib3J0ZWQ6IHJlYXNvbiAmJiByZWFzb24ubmFtZSA9PT0gJ0Fib3J0RXJyb3InXG4gIH0pXG59XG5cbi8vIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbmV0d29yay1lcnJvclxuZnVuY3Rpb24gaXNOZXR3b3JrRXJyb3IgKHJlc3BvbnNlKSB7XG4gIHJldHVybiAoXG4gICAgLy8gQSBuZXR3b3JrIGVycm9yIGlzIGEgcmVzcG9uc2Ugd2hvc2UgdHlwZSBpcyBcImVycm9yXCIsXG4gICAgcmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJyAmJlxuICAgIC8vIHN0YXR1cyBpcyAwXG4gICAgcmVzcG9uc2Uuc3RhdHVzID09PSAwXG4gIClcbn1cblxuZnVuY3Rpb24gbWFrZUZpbHRlcmVkUmVzcG9uc2UgKHJlc3BvbnNlLCBzdGF0ZSkge1xuICBzdGF0ZSA9IHtcbiAgICBpbnRlcm5hbFJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAuLi5zdGF0ZVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm94eShyZXNwb25zZSwge1xuICAgIGdldCAodGFyZ2V0LCBwKSB7XG4gICAgICByZXR1cm4gcCBpbiBzdGF0ZSA/IHN0YXRlW3BdIDogdGFyZ2V0W3BdXG4gICAgfSxcbiAgICBzZXQgKHRhcmdldCwgcCwgdmFsdWUpIHtcbiAgICAgIGFzc2VydCghKHAgaW4gc3RhdGUpKVxuICAgICAgdGFyZ2V0W3BdID0gdmFsdWVcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9KVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1maWx0ZXJlZC1yZXNwb25zZVxuZnVuY3Rpb24gZmlsdGVyUmVzcG9uc2UgKHJlc3BvbnNlLCB0eXBlKSB7XG4gIC8vIFNldCByZXNwb25zZSB0byB0aGUgZm9sbG93aW5nIGZpbHRlcmVkIHJlc3BvbnNlIHdpdGggcmVzcG9uc2UgYXMgaXRzXG4gIC8vIGludGVybmFsIHJlc3BvbnNlLCBkZXBlbmRpbmcgb24gcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmc6XG4gIGlmICh0eXBlID09PSAnYmFzaWMnKSB7XG4gICAgLy8gQSBiYXNpYyBmaWx0ZXJlZCByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIHR5cGUgaXMgXCJiYXNpY1wiXG4gICAgLy8gYW5kIGhlYWRlciBsaXN0IGV4Y2x1ZGVzIGFueSBoZWFkZXJzIGluIGludGVybmFsIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdFxuICAgIC8vIHdob3NlIG5hbWUgaXMgYSBmb3JiaWRkZW4gcmVzcG9uc2UtaGVhZGVyIG5hbWUuXG5cbiAgICAvLyBOb3RlOiB1bmRpY2kgZG9lcyBub3QgaW1wbGVtZW50IGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZXNcbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdiYXNpYycsXG4gICAgICBoZWFkZXJzTGlzdDogcmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb3JzJykge1xuICAgIC8vIEEgQ09SUyBmaWx0ZXJlZCByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIHR5cGUgaXMgXCJjb3JzXCJcbiAgICAvLyBhbmQgaGVhZGVyIGxpc3QgZXhjbHVkZXMgYW55IGhlYWRlcnMgaW4gaW50ZXJuYWwgcmVzcG9uc2XigJlzIGhlYWRlclxuICAgIC8vIGxpc3Qgd2hvc2UgbmFtZSBpcyBub3QgYSBDT1JTLXNhZmVsaXN0ZWQgcmVzcG9uc2UtaGVhZGVyIG5hbWUsIGdpdmVuXG4gICAgLy8gaW50ZXJuYWwgcmVzcG9uc2XigJlzIENPUlMtZXhwb3NlZCBoZWFkZXItbmFtZSBsaXN0LlxuXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBDT1JTLXNhZmVsaXN0ZWQgcmVzcG9uc2UtaGVhZGVyIG5hbWVzXG4gICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICB0eXBlOiAnY29ycycsXG4gICAgICBoZWFkZXJzTGlzdDogcmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGFxdWUnKSB7XG4gICAgLy8gQW4gb3BhcXVlIGZpbHRlcmVkIHJlc3BvbnNlIGlzIGEgZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgdHlwZSBpc1xuICAgIC8vIFwib3BhcXVlXCIsIFVSTCBsaXN0IGlzIHRoZSBlbXB0eSBsaXN0LCBzdGF0dXMgaXMgMCwgc3RhdHVzIG1lc3NhZ2VcbiAgICAvLyBpcyB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZSwgaGVhZGVyIGxpc3QgaXMgZW1wdHksIGFuZCBib2R5IGlzIG51bGwuXG5cbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdvcGFxdWUnLFxuICAgICAgdXJsTGlzdDogT2JqZWN0LmZyZWV6ZShbXSksXG4gICAgICBzdGF0dXM6IDAsXG4gICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgIGJvZHk6IG51bGxcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGFxdWVyZWRpcmVjdCcpIHtcbiAgICAvLyBBbiBvcGFxdWUtcmVkaXJlY3QgZmlsdGVyZWQgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSB0eXBlXG4gICAgLy8gaXMgXCJvcGFxdWVyZWRpcmVjdFwiLCBzdGF0dXMgaXMgMCwgc3RhdHVzIG1lc3NhZ2UgaXMgdGhlIGVtcHR5IGJ5dGVcbiAgICAvLyBzZXF1ZW5jZSwgaGVhZGVyIGxpc3QgaXMgZW1wdHksIGFuZCBib2R5IGlzIG51bGwuXG5cbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdvcGFxdWVyZWRpcmVjdCcsXG4gICAgICBzdGF0dXM6IDAsXG4gICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgIGhlYWRlcnNMaXN0OiBbXSxcbiAgICAgIGJvZHk6IG51bGxcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSlcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYXBwcm9wcmlhdGUtbmV0d29yay1lcnJvclxuZnVuY3Rpb24gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yIChmZXRjaFBhcmFtcywgZXJyID0gbnVsbCkge1xuICAvLyAxLiBBc3NlcnQ6IGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLlxuICBhc3NlcnQoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKVxuXG4gIC8vIDIuIFJldHVybiBhbiBhYm9ydGVkIG5ldHdvcmsgZXJyb3IgaWYgZmV0Y2hQYXJhbXMgaXMgYWJvcnRlZDtcbiAgLy8gb3RoZXJ3aXNlIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIHJldHVybiBpc0Fib3J0ZWQoZmV0Y2hQYXJhbXMpXG4gICAgPyBtYWtlTmV0d29ya0Vycm9yKE9iamVjdC5hc3NpZ24obmV3IERPTUV4Y2VwdGlvbignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nLCAnQWJvcnRFcnJvcicpLCB7IGNhdXNlOiBlcnIgfSkpXG4gICAgOiBtYWtlTmV0d29ya0Vycm9yKE9iamVjdC5hc3NpZ24obmV3IERPTUV4Y2VwdGlvbignUmVxdWVzdCB3YXMgY2FuY2VsbGVkLicpLCB7IGNhdXNlOiBlcnIgfSkpXG59XG5cbi8vIGh0dHBzOi8vd2hhdHByLm9yZy9mZXRjaC8xMzkyLmh0bWwjaW5pdGlhbGl6ZS1hLXJlc3BvbnNlXG5mdW5jdGlvbiBpbml0aWFsaXplUmVzcG9uc2UgKHJlc3BvbnNlLCBpbml0LCBib2R5KSB7XG4gIC8vIDEuIElmIGluaXRbXCJzdGF0dXNcIl0gaXMgbm90IGluIHRoZSByYW5nZSAyMDAgdG8gNTk5LCBpbmNsdXNpdmUsIHRoZW5cbiAgLy8gICAgdGhyb3cgYSBSYW5nZUVycm9yLlxuICBpZiAoaW5pdC5zdGF0dXMgIT09IG51bGwgJiYgKGluaXQuc3RhdHVzIDwgMjAwIHx8IGluaXQuc3RhdHVzID4gNTk5KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbml0W1wic3RhdHVzXCJdIG11c3QgYmUgaW4gdGhlIHJhbmdlIG9mIDIwMCB0byA1OTksIGluY2x1c2l2ZS4nKVxuICB9XG5cbiAgLy8gMi4gSWYgaW5pdFtcInN0YXR1c1RleHRcIl0gZG9lcyBub3QgbWF0Y2ggdGhlIHJlYXNvbi1waHJhc2UgdG9rZW4gcHJvZHVjdGlvbixcbiAgLy8gICAgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKCdzdGF0dXNUZXh0JyBpbiBpbml0ICYmIGluaXQuc3RhdHVzVGV4dCAhPSBudWxsKSB7XG4gICAgLy8gU2VlLCBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjEuMjpcbiAgICAvLyAgIHJlYXNvbi1waHJhc2UgID0gKiggSFRBQiAvIFNQIC8gVkNIQVIgLyBvYnMtdGV4dCApXG4gICAgaWYgKCFpc1ZhbGlkUmVhc29uUGhyYXNlKFN0cmluZyhpbml0LnN0YXR1c1RleHQpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdGF0dXNUZXh0JylcbiAgICB9XG4gIH1cblxuICAvLyAzLiBTZXQgcmVzcG9uc2XigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgdG8gaW5pdFtcInN0YXR1c1wiXS5cbiAgaWYgKCdzdGF0dXMnIGluIGluaXQgJiYgaW5pdC5zdGF0dXMgIT0gbnVsbCkge1xuICAgIGdldFJlc3BvbnNlU3RhdGUocmVzcG9uc2UpLnN0YXR1cyA9IGluaXQuc3RhdHVzXG4gIH1cblxuICAvLyA0LiBTZXQgcmVzcG9uc2XigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgbWVzc2FnZSB0byBpbml0W1wic3RhdHVzVGV4dFwiXS5cbiAgaWYgKCdzdGF0dXNUZXh0JyBpbiBpbml0ICYmIGluaXQuc3RhdHVzVGV4dCAhPSBudWxsKSB7XG4gICAgZ2V0UmVzcG9uc2VTdGF0ZShyZXNwb25zZSkuc3RhdHVzVGV4dCA9IGluaXQuc3RhdHVzVGV4dFxuICB9XG5cbiAgLy8gNS4gSWYgaW5pdFtcImhlYWRlcnNcIl0gZXhpc3RzLCB0aGVuIGZpbGwgcmVzcG9uc2XigJlzIGhlYWRlcnMgd2l0aCBpbml0W1wiaGVhZGVyc1wiXS5cbiAgaWYgKCdoZWFkZXJzJyBpbiBpbml0ICYmIGluaXQuaGVhZGVycyAhPSBudWxsKSB7XG4gICAgZmlsbChnZXRSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpLCBpbml0LmhlYWRlcnMpXG4gIH1cblxuICAvLyA2LiBJZiBib2R5IHdhcyBnaXZlbiwgdGhlbjpcbiAgaWYgKGJvZHkpIHtcbiAgICAvLyAxLiBJZiByZXNwb25zZSdzIHN0YXR1cyBpcyBhIG51bGwgYm9keSBzdGF0dXMsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKG51bGxCb2R5U3RhdHVzLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnUmVzcG9uc2UgY29uc3RydWN0b3InLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCByZXNwb25zZSBzdGF0dXMgY29kZSAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIFNldCByZXNwb25zZSdzIGJvZHkgdG8gYm9keSdzIGJvZHkuXG4gICAgZ2V0UmVzcG9uc2VTdGF0ZShyZXNwb25zZSkuYm9keSA9IGJvZHkuYm9keVxuXG4gICAgLy8gMy4gSWYgYm9keSdzIHR5cGUgaXMgbm9uLW51bGwgYW5kIHJlc3BvbnNlJ3MgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpblxuICAgIC8vICAgIGBDb250ZW50LVR5cGVgLCB0aGVuIGFwcGVuZCAoYENvbnRlbnQtVHlwZWAsIGJvZHkncyB0eXBlKSB0byByZXNwb25zZSdzIGhlYWRlciBsaXN0LlxuICAgIGlmIChib2R5LnR5cGUgIT0gbnVsbCAmJiAhZ2V0UmVzcG9uc2VTdGF0ZShyZXNwb25zZSkuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2NvbnRlbnQtdHlwZScsIHRydWUpKSB7XG4gICAgICBnZXRSZXNwb25zZVN0YXRlKHJlc3BvbnNlKS5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NvbnRlbnQtdHlwZScsIGJvZHkudHlwZSwgdHJ1ZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZS1jcmVhdGVcbiAqIEBwYXJhbSB7YW55fSBpbm5lclJlc3BvbnNlXG4gKiBAcGFyYW0geydyZXF1ZXN0JyB8ICdpbW11dGFibGUnIHwgJ3JlcXVlc3Qtbm8tY29ycycgfCAncmVzcG9uc2UnIHwgJ25vbmUnfSBndWFyZFxuICogQHJldHVybnMge1Jlc3BvbnNlfVxuICovXG5mdW5jdGlvbiBmcm9tSW5uZXJSZXNwb25zZSAoaW5uZXJSZXNwb25zZSwgZ3VhcmQpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2Uoa0NvbnN0cnVjdClcbiAgc2V0UmVzcG9uc2VTdGF0ZShyZXNwb25zZSwgaW5uZXJSZXNwb25zZSlcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGtDb25zdHJ1Y3QpXG4gIHNldFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSwgaGVhZGVycylcbiAgc2V0SGVhZGVyc0xpc3QoaGVhZGVycywgaW5uZXJSZXNwb25zZS5oZWFkZXJzTGlzdClcbiAgc2V0SGVhZGVyc0d1YXJkKGhlYWRlcnMsIGd1YXJkKVxuXG4gIGlmIChoYXNGaW5hbGl6YXRpb25SZWdpc3RyeSAmJiBpbm5lclJlc3BvbnNlLmJvZHk/LnN0cmVhbSkge1xuICAgIC8vIElmIHRoZSB0YXJnZXQgKHJlc3BvbnNlKSBpcyByZWNsYWltZWQsIHRoZSBjbGVhbnVwIGNhbGxiYWNrIG1heSBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCB3aXRoXG4gICAgLy8gdGhlIGhlbGQgdmFsdWUgcHJvdmlkZWQgZm9yIGl0IChpbm5lclJlc3BvbnNlLmJvZHkuc3RyZWFtKS4gVGhlIGhlbGQgdmFsdWUgY2FuIGJlIGFueSB2YWx1ZTpcbiAgICAvLyBhIHByaW1pdGl2ZSBvciBhbiBvYmplY3QsIGV2ZW4gdW5kZWZpbmVkLiBJZiB0aGUgaGVsZCB2YWx1ZSBpcyBhbiBvYmplY3QsIHRoZSByZWdpc3RyeSBrZWVwc1xuICAgIC8vIGEgc3Ryb25nIHJlZmVyZW5jZSB0byBpdCAoc28gaXQgY2FuIHBhc3MgaXQgdG8gdGhlIGNsZWFudXAgY2FsbGJhY2sgbGF0ZXIpLiBSZXdvcmRlZCBmcm9tXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRmluYWxpemF0aW9uUmVnaXN0cnlcbiAgICBzdHJlYW1SZWdpc3RyeS5yZWdpc3RlcihyZXNwb25zZSwgbmV3IFdlYWtSZWYoaW5uZXJSZXNwb25zZS5ib2R5LnN0cmVhbSkpXG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3R5cGVkZWZkZWYteG1saHR0cHJlcXVlc3Rib2R5aW5pdFxud2ViaWRsLmNvbnZlcnRlcnMuWE1MSHR0cFJlcXVlc3RCb2R5SW5pdCA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBWID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoViwgcHJlZml4LCBuYW1lKVxuICB9XG5cbiAgaWYgKHdlYmlkbC5pcy5CbG9iKFYpKSB7XG4gICAgcmV0dXJuIFZcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoVikgfHwgdHlwZXMuaXNBcnJheUJ1ZmZlcihWKSkge1xuICAgIHJldHVybiBWXG4gIH1cblxuICBpZiAod2ViaWRsLmlzLkZvcm1EYXRhKFYpKSB7XG4gICAgcmV0dXJuIFZcbiAgfVxuXG4gIGlmICh3ZWJpZGwuaXMuVVJMU2VhcmNoUGFyYW1zKFYpKSB7XG4gICAgcmV0dXJuIFZcbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoViwgcHJlZml4LCBuYW1lKVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keWluaXRcbndlYmlkbC5jb252ZXJ0ZXJzLkJvZHlJbml0ID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgaWYgKHdlYmlkbC5pcy5SZWFkYWJsZVN0cmVhbShWKSkge1xuICAgIHJldHVybiBWXG4gIH1cblxuICAvLyBOb3RlOiB0aGUgc3BlYyBkb2Vzbid0IGluY2x1ZGUgYXN5bmMgaXRlcmFibGVzLFxuICAvLyB0aGlzIGlzIGFuIHVuZGljaSBleHRlbnNpb24uXG4gIGlmIChWPy5bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgcmV0dXJuIFZcbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5YTUxIdHRwUmVxdWVzdEJvZHlJbml0KFYsIHByZWZpeCwgYXJndW1lbnQpXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlSW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ3N0YXR1cycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IDIwMFxuICB9LFxuICB7XG4gICAga2V5OiAnc3RhdHVzVGV4dCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2hlYWRlcnMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXRcbiAgfVxuXSlcblxud2ViaWRsLmlzLlJlc3BvbnNlID0gd2ViaWRsLnV0aWwuTWFrZVR5cGVBc3NlcnRpb24oUmVzcG9uc2UpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc05ldHdvcmtFcnJvcixcbiAgbWFrZU5ldHdvcmtFcnJvcixcbiAgbWFrZVJlc3BvbnNlLFxuICBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IsXG4gIGZpbHRlclJlc3BvbnNlLFxuICBSZXNwb25zZSxcbiAgY2xvbmVSZXNwb25zZSxcbiAgZnJvbUlubmVyUmVzcG9uc2UsXG4gIGdldFJlc3BvbnNlU3RhdGVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/util.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\")\nconst { redirectStatusSet, referrerPolicyTokens, badPortsSet } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/fetch/constants.js\")\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(rsc)/./node_modules/undici/lib/web/fetch/global.js\")\nconst { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { performance } = __webpack_require__(/*! node:perf_hooks */ \"node:perf_hooks\")\nconst { ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { isUint8Array } = __webpack_require__(/*! node:util/types */ \"node:util/types\")\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\n\nlet supportedHashes = []\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\")\n  const possibleRelevantHashes = ['sha256', 'sha384', 'sha512']\n  supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash))\n/* c8 ignore next 3 */\n} catch {\n\n}\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in responses URL list and null if responses URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If responses status is not a redirect status, then return null.\n  if (!redirectStatusSet.has(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and responses header list.\n  let location = response.headersList.get('location', true)\n\n  // 3. If location is a header value, then set location to the result of\n  //    parsing location with responses URL.\n  if (location !== null && isValidHeaderValue(location)) {\n    if (!isValidEncodedURL(location)) {\n      // Some websites respond location header in UTF-8 form without encoding them as ASCII\n      // and major browsers redirect them to correctly UTF-8 encoded addresses.\n      // Here, we handle that behavior in the same way.\n      location = normalizeBinaryStringToUtf8(location)\n    }\n    location = new URL(location, responseURL(response))\n  }\n\n  // 4. If location is a URL whose fragment is null, then set locations\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc1738#section-2.2\n * @param {string} url\n * @returns {boolean}\n */\nfunction isValidEncodedURL (url) {\n  for (let i = 0; i < url.length; ++i) {\n    const code = url.charCodeAt(i)\n\n    if (\n      code > 0x7E || // Non-US-ASCII + DEL\n      code < 0x20 // Control characters NUL - US\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * If string contains non-ASCII characters, assumes it's UTF-8 encoded and decodes it.\n * Since UTF-8 is a superset of ASCII, this will work for ASCII strings as well.\n * @param {string} value\n * @returns {string}\n */\nfunction normalizeBinaryStringToUtf8 (value) {\n  return Buffer.from(value, 'binary').toString('utf8')\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be requests current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If urls scheme is an HTTP(S) scheme and urls port is a bad port,\n  // then return blocked.\n  if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\nfunction isErrorLike (object) {\n  return object instanceof Error || (\n    object?.constructor?.name === 'Error' ||\n    object?.constructor?.name === 'DOMException'\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-name\n * @param {string} potentialValue\n */\nconst isValidHeaderName = isValidHTTPToken\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue (potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  return (\n    potentialValue[0] === '\\t' ||\n    potentialValue[0] === ' ' ||\n    potentialValue[potentialValue.length - 1] === '\\t' ||\n    potentialValue[potentialValue.length - 1] === ' ' ||\n    potentialValue.includes('\\n') ||\n    potentialValue.includes('\\r') ||\n    potentialValue.includes('\\0')\n  ) === false\n}\n\n/**\n * Parse a referrer policy from a Referrer-Policy header\n * @see https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header\n */\nfunction parseReferrerPolicy (actualResponse) {\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and responses header list.\n  const policyHeader = (actualResponse.headersList.get('referrer-policy', true) ?? '').split(',')\n\n  // 2. Let policy be the empty string.\n  let policy = ''\n\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n\n  // Note: As the referrer-policy can contain multiple policies\n  // separated by comma, we need to loop through all of them\n  // and pick the first valid one.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n  if (policyHeader.length) {\n    // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for (let i = policyHeader.length; i !== 0; i--) {\n      const token = policyHeader[i - 1].trim()\n      if (referrerPolicyTokens.has(token)) {\n        policy = token\n        break\n      }\n    }\n  }\n\n  // 4. Return policy.\n  return policy\n}\n\n/**\n * Given a request request and a response actualResponse, this algorithm\n * updates requests referrer policy according to the Referrer-Policy\n * header (if any) in actualResponse.\n * @see https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\n * @param {import('./request').Request} request\n * @param {import('./response').Response} actualResponse\n */\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  // 1. Let policy be the result of executing  8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n  const policy = parseReferrerPolicy(actualResponse)\n\n  // 2. If policy is not the empty string, then set requests referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: rs url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set headers value to rs mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in rs header list.\n  httpRequest.headersList.set('sec-fetch-mode', header, true)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin\n  //    with request.\n  // TODO: implement \"byte-serializing a request origin\"\n  let serializedOrigin = request.origin\n\n  // - \"'client' is changed to an origin during fetching.\"\n  //   This doesn't happen in undici (in most cases) because undici, by default,\n  //   has no concept of origin.\n  // - request.origin can also be set to request.client.origin (client being\n  //   an environment settings object), which is undefined without using\n  //   setGlobalOrigin.\n  if (serializedOrigin === 'client' || serializedOrigin === undefined) {\n    return\n  }\n\n  // 2. If requests response tainting is \"cors\" or requests mode is \"websocket\",\n  //    then append (`Origin`, serializedOrigin) to requests header list.\n  // 3. Otherwise, if requests method is neither `GET` nor `HEAD`, then:\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    request.headersList.append('origin', serializedOrigin, true)\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on requests referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If requests origin is a tuple origin, its scheme is \"https\", and\n        // requests current URLs scheme is not \"https\", then set\n        // serializedOrigin to `null`.\n        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If requests origin is not same origin with requests current URLs\n        // origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    // 2. Append (`Origin`, serializedOrigin) to requests header list.\n    request.headersList.append('origin', serializedOrigin, true)\n  }\n}\n\n// https://w3c.github.io/hr-time/#dfn-coarsen-time\nfunction coarsenTime (timestamp, crossOriginIsolatedCapability) {\n  // TODO\n  return timestamp\n}\n\n// https://fetch.spec.whatwg.org/#clamp-and-coarsen-connection-timing-info\nfunction clampAndCoarsenConnectionTimingInfo (connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {\n  if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {\n    return {\n      domainLookupStartTime: defaultStartTime,\n      domainLookupEndTime: defaultStartTime,\n      connectionStartTime: defaultStartTime,\n      connectionEndTime: defaultStartTime,\n      secureConnectionStartTime: defaultStartTime,\n      ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol\n    }\n  }\n\n  return {\n    domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),\n    domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),\n    connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),\n    connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),\n    secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),\n    ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol\n  }\n}\n\n// https://w3c.github.io/hr-time/#dfn-coarsened-shared-current-time\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  return coarsenTime(performance.now(), crossOriginIsolatedCapability)\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo (timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // Note: the fetch spec doesn't make use of embedder policy or CSP list\n  return {\n    referrerPolicy: 'strict-origin-when-cross-origin'\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer (policyContainer) {\n  return {\n    referrerPolicy: policyContainer.referrerPolicy\n  }\n}\n\n/**\n * Determine requests Referrer\n *\n * @see https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\n */\nfunction determineRequestsReferrer (request) {\n  // Given a request request, we can determine the correct referrer information\n  // to send by examining its referrer policy as detailed in the following\n  // steps, which return either no referrer or a URL:\n\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy\n\n  // Note: policy cannot (shouldn't) be null or an empty string.\n  assert(policy)\n\n  // 2. Let environment be requests client.\n\n  let referrerSource = null\n\n  // 3. Switch on requests referrer:\n\n  // \"client\"\n  if (request.referrer === 'client') {\n    // Note: node isn't a browser and doesn't implement document/iframes,\n    // so we bypass this step and replace it with our own.\n\n    const globalOrigin = getGlobalOrigin()\n\n    if (!globalOrigin || globalOrigin.origin === 'null') {\n      return 'no-referrer'\n    }\n\n    // Note: we need to clone it as it's mutated\n    referrerSource = new URL(globalOrigin)\n  // a URL\n  } else if (webidl.is.URL(request.referrer)) {\n    // Let referrerSource be requests referrer.\n    referrerSource = request.referrer\n  }\n\n  // 4. Let requests referrerURL be the result of stripping referrerSource for\n  //    use as a referrer.\n  let referrerURL = stripURLForReferrer(referrerSource)\n\n  // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n  //    a referrer, with the origin-only flag set to true.\n  const referrerOrigin = stripURLForReferrer(referrerSource, true)\n\n  // 6. If the result of serializing referrerURL is a string whose length is\n  //    greater than 4096, set referrerURL to referrerOrigin.\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin\n  }\n\n  // 7. The user agent MAY alter referrerURL or referrerOrigin at this point\n  // to enforce arbitrary policy considerations in the interests of minimizing\n  // data leakage. For example, the user agent could strip the URL down to an\n  // origin, modify its host, replace it with an empty string, etc.\n\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'no-referrer':\n      // Return no referrer\n      return 'no-referrer'\n    case 'origin':\n      // Return referrerOrigin\n      if (referrerOrigin != null) {\n        return referrerOrigin\n      }\n      return stripURLForReferrer(referrerSource, true)\n    case 'unsafe-url':\n      // Return referrerURL.\n      return referrerURL\n    case 'strict-origin': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If referrerURL is a potentially trustworthy URL and requests\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n      // 2. Return referrerOrigin\n      return referrerOrigin\n    }\n    case 'strict-origin-when-cross-origin': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If the origin of referrerURL and the origin of requests current\n      //    URL are the same, then return referrerURL.\n      if (sameOrigin(referrerURL, currentURL)) {\n        return referrerURL\n      }\n\n      // 2. If referrerURL is a potentially trustworthy URL and requests\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n\n      // 3. Return referrerOrigin.\n      return referrerOrigin\n    }\n    case 'same-origin':\n      // 1. If the origin of referrerURL and the origin of requests current\n      // URL are the same, then return referrerURL.\n      if (sameOrigin(request, referrerURL)) {\n        return referrerURL\n      }\n      // 2. Return no referrer.\n      return 'no-referrer'\n    case 'origin-when-cross-origin':\n      // 1. If the origin of referrerURL and the origin of requests current\n      // URL are the same, then return referrerURL.\n      if (sameOrigin(request, referrerURL)) {\n        return referrerURL\n      }\n      // 2. Return referrerOrigin.\n      return referrerOrigin\n    case 'no-referrer-when-downgrade': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If referrerURL is a potentially trustworthy URL and requests\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n      // 2. Return referrerOrigin\n      return referrerOrigin\n    }\n  }\n}\n\n/**\n * Certain portions of URLs must not be included when sending a URL as the\n * value of a `Referer` header: a URLs fragment, username, and password\n * components must be stripped from the URL before its sent out. This\n * algorithm accepts a origin-only flag, which defaults to false. If set to\n * true, the algorithm will additionally remove the URLs path and query\n * components, leaving only the scheme, host, and port.\n *\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean} [originOnly=false]\n */\nfunction stripURLForReferrer (url, originOnly = false) {\n  // 1. Assert: url is a URL.\n  assert(webidl.is.URL(url))\n\n  // Note: Create a new URL instance to avoid mutating the original URL.\n  url = new URL(url)\n\n  // 2. If urls scheme is a local scheme, then return no referrer.\n  if (urlIsLocal(url)) {\n    return 'no-referrer'\n  }\n\n  // 3. Set urls username to the empty string.\n  url.username = ''\n\n  // 4. Set urls password to the empty string.\n  url.password = ''\n\n  // 5. Set urls fragment to null.\n  url.hash = ''\n\n  // 6. If the origin-only flag is true, then:\n  if (originOnly === true) {\n    // 1. Set urls path to  the empty string .\n    url.pathname = ''\n\n    // 2. Set urls query to null.\n    url.search = ''\n  }\n\n  // 7. Return url.\n  return url\n}\n\nconst potentialleTrustworthyIPv4RegExp = new RegExp('^(?:' +\n  '(?:127\\\\.)' +\n  '(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){2}' +\n  '(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9])' +\n')$')\n\nconst potentialleTrustworthyIPv6RegExp = new RegExp('^(?:' +\n  '(?:(?:0{1,4}):){7}(?:(?:0{0,3}1))|' +\n  '(?:(?:0{1,4}):){1,6}(?::(?:0{0,3}1))|' +\n  '(?:::(?:0{0,3}1))|' +\n')$')\n\n/**\n * Check if host matches one of the CIDR notations 127.0.0.0/8 or ::1/128.\n *\n * @param {string} origin\n * @returns {boolean}\n */\nfunction isOriginIPPotentiallyTrustworthy (origin) {\n  // IPv6\n  if (origin.includes(':')) {\n    // Remove brackets from IPv6 addresses\n    if (origin[0] === '[' && origin[origin.length - 1] === ']') {\n      origin = origin.slice(1, -1)\n    }\n    return potentialleTrustworthyIPv6RegExp.test(origin)\n  }\n\n  // IPv4\n  return potentialleTrustworthyIPv4RegExp.test(origin)\n}\n\n/**\n * A potentially trustworthy origin is one which a user agent can generally\n * trust as delivering data securely.\n *\n * Return value `true` means `Potentially Trustworthy`.\n * Return value `false` means `Not Trustworthy`.\n *\n * @see https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy\n * @param {string} origin\n * @returns {boolean}\n */\nfunction isOriginPotentiallyTrustworthy (origin) {\n  // 1. If origin is an opaque origin, return \"Not Trustworthy\".\n  if (origin == null || origin === 'null') {\n    return false\n  }\n\n  // 2. Assert: origin is a tuple origin.\n  origin = new URL(origin)\n\n  // 3. If origins scheme is either \"https\" or \"wss\",\n  //    return \"Potentially Trustworthy\".\n  if (origin.protocol === 'https:' || origin.protocol === 'wss:') {\n    return true\n  }\n\n  // 4. If origins host matches one of the CIDR notations 127.0.0.0/8 or\n  // ::1/128 [RFC4632], return \"Potentially Trustworthy\".\n  if (isOriginIPPotentiallyTrustworthy(origin.hostname)) {\n    return true\n  }\n\n  // 5. If the user agent conforms to the name resolution rules in\n  //    [let-localhost-be-localhost] and one of the following is true:\n\n  //    origins host is \"localhost\" or \"localhost.\"\n  if (origin.hostname === 'localhost' || origin.hostname === 'localhost.') {\n    return true\n  }\n\n  //    origins host ends with \".localhost\" or \".localhost.\"\n  if (origin.hostname.endsWith('.localhost') || origin.hostname.endsWith('.localhost.')) {\n    return true\n  }\n\n  // 6. If origins scheme is \"file\", return \"Potentially Trustworthy\".\n  if (origin.protocol === 'file:') {\n    return true\n  }\n\n  // 7. If origins scheme component is one which the user agent considers to\n  // be authenticated, return \"Potentially Trustworthy\".\n\n  // 8. If origin has been configured as a trustworthy origin, return\n  //    \"Potentially Trustworthy\".\n\n  // 9. Return \"Not Trustworthy\".\n  return false\n}\n\n/**\n * A potentially trustworthy URL is one which either inherits context from its\n * creator (about:blank, about:srcdoc, data) or one whose origin is a\n * potentially trustworthy origin.\n *\n * Return value `true` means `Potentially Trustworthy`.\n * Return value `false` means `Not Trustworthy`.\n *\n * @see https://www.w3.org/TR/secure-contexts/#is-url-trustworthy\n * @param {URL} url\n * @returns {boolean}\n */\nfunction isURLPotentiallyTrustworthy (url) {\n  // Given a URL record (url), the following algorithm returns \"Potentially\n  // Trustworthy\" or \"Not Trustworthy\" as appropriate:\n  if (!webidl.is.URL(url)) {\n    return false\n  }\n\n  // 1. If url is \"about:blank\" or \"about:srcdoc\",\n  //    return \"Potentially Trustworthy\".\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true\n  }\n\n  // 2. If urls scheme is \"data\", return \"Potentially Trustworthy\".\n  if (url.protocol === 'data:') return true\n\n  // Note: The origin of blob: URLs is the origin of the context in which they\n  // were created. Therefore, blobs created in a trustworthy origin will\n  // themselves be potentially trustworthy.\n  if (url.protocol === 'blob:') return true\n\n  // 3. Return the result of executing  3.1 Is origin potentially trustworthy?\n  // on urls origin.\n  return isOriginPotentiallyTrustworthy(url.origin)\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch (bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList)\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true\n  }\n\n  // 3. If response is not eligible for integrity validation, return false.\n  // TODO\n\n  // 4. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true\n  }\n\n  // 5. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  const strongest = getStrongestMetadata(parsedMetadata)\n  const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest)\n\n  // 6. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo\n\n    // 2. Let expectedValue be the val component of item.\n    const expectedValue = item.hash\n\n    // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n    // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64')\n\n    if (actualValue[actualValue.length - 1] === '=') {\n      if (actualValue[actualValue.length - 2] === '=') {\n        actualValue = actualValue.slice(0, -2)\n      } else {\n        actualValue = actualValue.slice(0, -1)\n      }\n    }\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (compareBase64Mixed(actualValue, expectedValue)) {\n      return true\n    }\n  }\n\n  // 7. Return false.\n  return false\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\\s|$)( +[!-~]*)?)?/i\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata (metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = []\n\n  // 2. Let empty be equal to true.\n  let empty = true\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token)\n\n    // 3. If token does not parse, continue to the next token.\n    if (\n      parsedToken === null ||\n      parsedToken.groups === undefined ||\n      parsedToken.groups.algo === undefined\n    ) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo.toLowerCase()\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm)) {\n      result.push(parsedToken.groups)\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata'\n  }\n\n  return result\n}\n\n/**\n * @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList\n */\nfunction getStrongestMetadata (metadataList) {\n  // Let algorithm be the algo component of the first item in metadataList.\n  // Can be sha256\n  let algorithm = metadataList[0].algo\n  // If the algorithm is sha512, then it is the strongest\n  // and we can return immediately\n  if (algorithm[3] === '5') {\n    return algorithm\n  }\n\n  for (let i = 1; i < metadataList.length; ++i) {\n    const metadata = metadataList[i]\n    // If the algorithm is sha512, then it is the strongest\n    // and we can break the loop immediately\n    if (metadata.algo[3] === '5') {\n      algorithm = 'sha512'\n      break\n    // If the algorithm is sha384, then a potential sha256 or sha384 is ignored\n    } else if (algorithm[3] === '3') {\n      continue\n    // algorithm is sha256, check if algorithm is sha384 and if so, set it as\n    // the strongest\n    } else if (metadata.algo[3] === '3') {\n      algorithm = 'sha384'\n    }\n  }\n  return algorithm\n}\n\nfunction filterMetadataListByAlgorithm (metadataList, algorithm) {\n  if (metadataList.length === 1) {\n    return metadataList\n  }\n\n  let pos = 0\n  for (let i = 0; i < metadataList.length; ++i) {\n    if (metadataList[i].algo === algorithm) {\n      metadataList[pos++] = metadataList[i]\n    }\n  }\n\n  metadataList.length = pos\n\n  return metadataList\n}\n\n/**\n * Compares two base64 strings, allowing for base64url\n * in the second string.\n *\n* @param {string} actualValue always base64\n * @param {string} expectedValue base64 or base64url\n * @returns {boolean}\n */\nfunction compareBase64Mixed (actualValue, expectedValue) {\n  if (actualValue.length !== expectedValue.length) {\n    return false\n  }\n  for (let i = 0; i < actualValue.length; ++i) {\n    if (actualValue[i] !== expectedValue[i]) {\n      if (\n        (actualValue[i] === '+' && expectedValue[i] === '-') ||\n        (actualValue[i] === '/' && expectedValue[i] === '_')\n      ) {\n        continue\n      }\n      return false\n    }\n  }\n\n  return true\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin (A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  if (A.origin === B.origin && A.origin === 'null') {\n    return true\n  }\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true\n  }\n\n  // 3. Return false.\n  return false\n}\n\nfunction createDeferredPromise () {\n  let res\n  let rej\n  const promise = new Promise((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  return { promise, resolve: res, reject: rej }\n}\n\nfunction isAborted (fetchParams) {\n  return fetchParams.controller.state === 'aborted'\n}\n\nfunction isCancelled (fetchParams) {\n  return fetchParams.controller.state === 'aborted' ||\n    fetchParams.controller.state === 'terminated'\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-method-normalize\n * @param {string} method\n */\nfunction normalizeMethod (method) {\n  return normalizedMethodRecordsBase[method.toLowerCase()] ?? method\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString (value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined,  value ).\n  const result = JSON.stringify(value)\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable')\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string')\n\n  // 4. Return result.\n  return result\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {((target: any) => any)} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */\nfunction createIterator (name, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n  class FastIterableIterator {\n    /** @type {any} */\n    #target\n    /** @type {'key' | 'value' | 'key+value'} */\n    #kind\n    /** @type {number} */\n    #index\n\n    /**\n     * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object\n     * @param {unknown} target\n     * @param {'key' | 'value' | 'key+value'} kind\n     */\n    constructor (target, kind) {\n      this.#target = target\n      this.#kind = kind\n      this.#index = 0\n    }\n\n    next () {\n      // 1. Let interface be the interface for which the iterator prototype object exists.\n      // 2. Let thisValue be the this value.\n      // 3. Let object be ? ToObject(thisValue).\n      // 4. If object is a platform object, then perform a security\n      //    check, passing:\n      // 5. If object is not a default iterator object for interface,\n      //    then throw a TypeError.\n      if (typeof this !== 'object' || this === null || !(#target in this)) {\n        throw new TypeError(\n          `'next' called on an object that does not implement interface ${name} Iterator.`\n        )\n      }\n\n      // 6. Let index be objects index.\n      // 7. Let kind be objects kind.\n      // 8. Let values be objects target's value pairs to iterate over.\n      const index = this.#index\n      const values = kInternalIterator(this.#target)\n\n      // 9. Let len be the length of values.\n      const len = values.length\n\n      // 10. If index is greater than or equal to len, then return\n      //     CreateIterResultObject(undefined, true).\n      if (index >= len) {\n        return {\n          value: undefined,\n          done: true\n        }\n      }\n\n      // 11. Let pair be the entry in values at index index.\n      const { [keyIndex]: key, [valueIndex]: value } = values[index]\n\n      // 12. Set objects index to index + 1.\n      this.#index = index + 1\n\n      // 13. Return the iterator result for pair and kind.\n\n      // https://webidl.spec.whatwg.org/#iterator-result\n\n      // 1. Let result be a value determined by the value of kind:\n      let result\n      switch (this.#kind) {\n        case 'key':\n          // 1. Let idlKey be pairs key.\n          // 2. Let key be the result of converting idlKey to an\n          //    ECMAScript value.\n          // 3. result is key.\n          result = key\n          break\n        case 'value':\n          // 1. Let idlValue be pairs value.\n          // 2. Let value be the result of converting idlValue to\n          //    an ECMAScript value.\n          // 3. result is value.\n          result = value\n          break\n        case 'key+value':\n          // 1. Let idlKey be pairs key.\n          // 2. Let idlValue be pairs value.\n          // 3. Let key be the result of converting idlKey to an\n          //    ECMAScript value.\n          // 4. Let value be the result of converting idlValue to\n          //    an ECMAScript value.\n          // 5. Let array be ! ArrayCreate(2).\n          // 6. Call ! CreateDataProperty(array, \"0\", key).\n          // 7. Call ! CreateDataProperty(array, \"1\", value).\n          // 8. result is array.\n          result = [key, value]\n          break\n      }\n\n      // 2. Return CreateIterResultObject(result, false).\n      return {\n        value: result,\n        done: false\n      }\n    }\n  }\n\n  // https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n  // @ts-ignore\n  delete FastIterableIterator.prototype.constructor\n\n  Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype)\n\n  Object.defineProperties(FastIterableIterator.prototype, {\n    [Symbol.toStringTag]: {\n      writable: false,\n      enumerable: false,\n      configurable: true,\n      value: `${name} Iterator`\n    },\n    next: { writable: true, enumerable: true, configurable: true }\n  })\n\n  /**\n   * @param {unknown} target\n   * @param {'key' | 'value' | 'key+value'} kind\n   * @returns {IterableIterator<any>}\n   */\n  return function (target, kind) {\n    return new FastIterableIterator(target, kind)\n  }\n}\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {any} object class\n * @param {(target: any) => any} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */\nfunction iteratorMixin (name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n  const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex)\n\n  const properties = {\n    keys: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function keys () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'key')\n      }\n    },\n    values: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function values () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'value')\n      }\n    },\n    entries: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function entries () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'key+value')\n      }\n    },\n    forEach: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function forEach (callbackfn, thisArg = globalThis) {\n        webidl.brandCheck(this, object)\n        webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`)\n        if (typeof callbackfn !== 'function') {\n          throw new TypeError(\n            `Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`\n          )\n        }\n        for (const { 0: key, 1: value } of makeIterator(this, 'key+value')) {\n          callbackfn.call(thisArg, value, key, this)\n        }\n      }\n    }\n  }\n\n  return Object.defineProperties(object.prototype, {\n    ...properties,\n    [Symbol.iterator]: {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: properties.entries.value\n    }\n  })\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nfunction fullyReadBody (body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let successSteps given a byte sequence bytes be to queue a\n  //    fetch task to run processBody given bytes, with taskDestination.\n  const successSteps = processBody\n\n  // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n  //    with taskDestination.\n  const errorSteps = processBodyError\n\n  // 4. Let reader be the result of getting a reader for bodys stream.\n  //    If that threw an exception, then run errorSteps with that\n  //    exception and return.\n  let reader\n\n  try {\n    reader = body.stream.getReader()\n  } catch (e) {\n    errorSteps(e)\n    return\n  }\n\n  // 5. Read all bytes from reader, given successSteps and errorSteps.\n  readAllBytes(reader, successSteps, errorSteps)\n}\n\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */\nfunction readableStreamClose (controller) {\n  try {\n    controller.close()\n    controller.byobRequest?.respond(0)\n  } catch (err) {\n    // TODO: add comment explaining why this error occurs.\n    if (!err.message.includes('Controller is already closed') && !err.message.includes('ReadableStream is already closed')) {\n      throw err\n    }\n  }\n}\n\nconst invalidIsomorphicEncodeValueRegex = /[^\\x00-\\xFF]/ // eslint-disable-line\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */\nfunction isomorphicEncode (input) {\n  // 1. Assert: input contains no code points greater than U+00FF.\n  assert(!invalidIsomorphicEncodeValueRegex.test(input))\n\n  // 2. Return a byte sequence whose length is equal to inputs code\n  //    point length and whose bytes have the same values as the\n  //    values of inputs code points, in the same order\n  return input\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n * @param {(bytes: Uint8Array) => void} successSteps\n * @param {(error: Error) => void} failureSteps\n */\nasync function readAllBytes (reader, successSteps, failureSteps) {\n  const bytes = []\n  let byteLength = 0\n\n  try {\n    do {\n      const { done, value: chunk } = await reader.read()\n\n      if (done) {\n        // 1. Call successSteps with bytes.\n        successSteps(Buffer.concat(bytes, byteLength))\n        return\n      }\n\n      // 1. If chunk is not a Uint8Array object, call failureSteps\n      //    with a TypeError and abort these steps.\n      if (!isUint8Array(chunk)) {\n        failureSteps(new TypeError('Received non-Uint8Array chunk'))\n        return\n      }\n\n      // 2. Append the bytes represented by chunk to bytes.\n      bytes.push(chunk)\n      byteLength += chunk.length\n\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n    } while (true)\n  } catch (e) {\n    // 1. Call failureSteps with e.\n    failureSteps(e)\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n * @returns {boolean}\n */\nfunction urlIsLocal (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  // A URL is local if its scheme is a local scheme.\n  // A local scheme is \"about\", \"blob\", or \"data\".\n  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:'\n}\n\n/**\n * @param {string|URL} url\n * @returns {boolean}\n */\nfunction urlHasHttpsScheme (url) {\n  return (\n    (\n      typeof url === 'string' &&\n      url[5] === ':' &&\n      url[0] === 'h' &&\n      url[1] === 't' &&\n      url[2] === 't' &&\n      url[3] === 'p' &&\n      url[4] === 's'\n    ) ||\n    url.protocol === 'https:'\n  )\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */\nfunction urlIsHttpHttpsScheme (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'http:' || protocol === 'https:'\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#simple-range-header-value\n * @param {string} value\n * @param {boolean} allowWhitespace\n */\nfunction simpleRangeHeaderValue (value, allowWhitespace) {\n  // 1. Let data be the isomorphic decoding of value.\n  // Note: isomorphic decoding takes a sequence of bytes (ie. a Uint8Array) and turns it into a string,\n  // nothing more. We obviously don't need to do that if value is a string already.\n  const data = value\n\n  // 2. If data does not start with \"bytes\", then return failure.\n  if (!data.startsWith('bytes')) {\n    return 'failure'\n  }\n\n  // 3. Let position be a position variable for data, initially pointing at the 5th code point of data.\n  const position = { position: 5 }\n\n  // 4. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n  //    from data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 5. If the code point at position within data is not U+003D (=), then return failure.\n  if (data.charCodeAt(position.position) !== 0x3D) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1.\n  position.position++\n\n  // 7. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space, from\n  //    data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 8. Let rangeStart be the result of collecting a sequence of code points that are ASCII digits,\n  //    from data given position.\n  const rangeStart = collectASequenceOfCodePoints(\n    (char) => {\n      const code = char.charCodeAt(0)\n\n      return code >= 0x30 && code <= 0x39\n    },\n    data,\n    position\n  )\n\n  // 9. Let rangeStartValue be rangeStart, interpreted as decimal number, if rangeStart is not the\n  //    empty string; otherwise null.\n  const rangeStartValue = rangeStart.length ? Number(rangeStart) : null\n\n  // 10. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n  //     from data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 11. If the code point at position within data is not U+002D (-), then return failure.\n  if (data.charCodeAt(position.position) !== 0x2D) {\n    return 'failure'\n  }\n\n  // 12. Advance position by 1.\n  position.position++\n\n  // 13. If allowWhitespace is true, collect a sequence of code points that are HTTP tab\n  //     or space, from data given position.\n  // Note from Khafra: its the same step as in #8 again lol\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 14. Let rangeEnd be the result of collecting a sequence of code points that are\n  //     ASCII digits, from data given position.\n  // Note from Khafra: you wouldn't guess it, but this is also the same step as #8\n  const rangeEnd = collectASequenceOfCodePoints(\n    (char) => {\n      const code = char.charCodeAt(0)\n\n      return code >= 0x30 && code <= 0x39\n    },\n    data,\n    position\n  )\n\n  // 15. Let rangeEndValue be rangeEnd, interpreted as decimal number, if rangeEnd\n  //     is not the empty string; otherwise null.\n  // Note from Khafra: THE SAME STEP, AGAIN!!!\n  // Note: why interpret as a decimal if we only collect ascii digits?\n  const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null\n\n  // 16. If position is not past the end of data, then return failure.\n  if (position.position < data.length) {\n    return 'failure'\n  }\n\n  // 17. If rangeEndValue and rangeStartValue are null, then return failure.\n  if (rangeEndValue === null && rangeStartValue === null) {\n    return 'failure'\n  }\n\n  // 18. If rangeStartValue and rangeEndValue are numbers, and rangeStartValue is\n  //     greater than rangeEndValue, then return failure.\n  // Note: ... when can they not be numbers?\n  if (rangeStartValue > rangeEndValue) {\n    return 'failure'\n  }\n\n  // 19. Return (rangeStartValue, rangeEndValue).\n  return { rangeStartValue, rangeEndValue }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#build-a-content-range\n * @param {number} rangeStart\n * @param {number} rangeEnd\n * @param {number} fullLength\n */\nfunction buildContentRange (rangeStart, rangeEnd, fullLength) {\n  // 1. Let contentRange be `bytes `.\n  let contentRange = 'bytes '\n\n  // 2. Append rangeStart, serialized and isomorphic encoded, to contentRange.\n  contentRange += isomorphicEncode(`${rangeStart}`)\n\n  // 3. Append 0x2D (-) to contentRange.\n  contentRange += '-'\n\n  // 4. Append rangeEnd, serialized and isomorphic encoded to contentRange.\n  contentRange += isomorphicEncode(`${rangeEnd}`)\n\n  // 5. Append 0x2F (/) to contentRange.\n  contentRange += '/'\n\n  // 6. Append fullLength, serialized and isomorphic encoded to contentRange.\n  contentRange += isomorphicEncode(`${fullLength}`)\n\n  // 7. Return contentRange.\n  return contentRange\n}\n\n// A Stream, which pipes the response to zlib.createInflate() or\n// zlib.createInflateRaw() depending on the first byte of the Buffer.\n// If the lower byte of the first byte is 0x08, then the stream is\n// interpreted as a zlib stream, otherwise it's interpreted as a\n// raw deflate stream.\nclass InflateStream extends Transform {\n  #zlibOptions\n\n  /** @param {zlib.ZlibOptions} [zlibOptions] */\n  constructor (zlibOptions) {\n    super()\n    this.#zlibOptions = zlibOptions\n  }\n\n  _transform (chunk, encoding, callback) {\n    if (!this._inflateStream) {\n      if (chunk.length === 0) {\n        callback()\n        return\n      }\n      this._inflateStream = (chunk[0] & 0x0F) === 0x08\n        ? zlib.createInflate(this.#zlibOptions)\n        : zlib.createInflateRaw(this.#zlibOptions)\n\n      this._inflateStream.on('data', this.push.bind(this))\n      this._inflateStream.on('end', () => this.push(null))\n      this._inflateStream.on('error', (err) => this.destroy(err))\n    }\n\n    this._inflateStream.write(chunk, encoding, callback)\n  }\n\n  _final (callback) {\n    if (this._inflateStream) {\n      this._inflateStream.end()\n      this._inflateStream = null\n    }\n    callback()\n  }\n}\n\n/**\n * @param {zlib.ZlibOptions} [zlibOptions]\n * @returns {InflateStream}\n */\nfunction createInflate (zlibOptions) {\n  return new InflateStream(zlibOptions)\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-extract-mime-type\n * @param {import('./headers').HeadersList} headers\n */\nfunction extractMimeType (headers) {\n  // 1. Let charset be null.\n  let charset = null\n\n  // 2. Let essence be null.\n  let essence = null\n\n  // 3. Let mimeType be null.\n  let mimeType = null\n\n  // 4. Let values be the result of getting, decoding, and splitting `Content-Type` from headers.\n  const values = getDecodeSplit('content-type', headers)\n\n  // 5. If values is null, then return failure.\n  if (values === null) {\n    return 'failure'\n  }\n\n  // 6. For each value of values:\n  for (const value of values) {\n    // 6.1. Let temporaryMimeType be the result of parsing value.\n    const temporaryMimeType = parseMIMEType(value)\n\n    // 6.2. If temporaryMimeType is failure or its essence is \"*/*\", then continue.\n    if (temporaryMimeType === 'failure' || temporaryMimeType.essence === '*/*') {\n      continue\n    }\n\n    // 6.3. Set mimeType to temporaryMimeType.\n    mimeType = temporaryMimeType\n\n    // 6.4. If mimeTypes essence is not essence, then:\n    if (mimeType.essence !== essence) {\n      // 6.4.1. Set charset to null.\n      charset = null\n\n      // 6.4.2. If mimeTypes parameters[\"charset\"] exists, then set charset to\n      //        mimeTypes parameters[\"charset\"].\n      if (mimeType.parameters.has('charset')) {\n        charset = mimeType.parameters.get('charset')\n      }\n\n      // 6.4.3. Set essence to mimeTypes essence.\n      essence = mimeType.essence\n    } else if (!mimeType.parameters.has('charset') && charset !== null) {\n      // 6.5. Otherwise, if mimeTypes parameters[\"charset\"] does not exist, and\n      //      charset is non-null, set mimeTypes parameters[\"charset\"] to charset.\n      mimeType.parameters.set('charset', charset)\n    }\n  }\n\n  // 7. If mimeType is null, then return failure.\n  if (mimeType == null) {\n    return 'failure'\n  }\n\n  // 8. Return mimeType.\n  return mimeType\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value-get-decode-and-split\n * @param {string|null} value\n */\nfunction gettingDecodingSplitting (value) {\n  // 1. Let input be the result of isomorphic decoding value.\n  const input = value\n\n  // 2. Let position be a position variable for input, initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let values be a list of strings, initially empty.\n  const values = []\n\n  // 4. Let temporaryValue be the empty string.\n  let temporaryValue = ''\n\n  // 5. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 5.1. Append the result of collecting a sequence of code points that are not U+0022 (\")\n    //      or U+002C (,) from input, given position, to temporaryValue.\n    temporaryValue += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== ',',\n      input,\n      position\n    )\n\n    // 5.2. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 5.2.1. If the code point at position within input is U+0022 (\"), then:\n      if (input.charCodeAt(position.position) === 0x22) {\n        // 5.2.1.1. Append the result of collecting an HTTP quoted string from input, given position, to temporaryValue.\n        temporaryValue += collectAnHTTPQuotedString(\n          input,\n          position\n        )\n\n        // 5.2.1.2. If position is not past the end of input, then continue.\n        if (position.position < input.length) {\n          continue\n        }\n      } else {\n        // 5.2.2. Otherwise:\n\n        // 5.2.2.1. Assert: the code point at position within input is U+002C (,).\n        assert(input.charCodeAt(position.position) === 0x2C)\n\n        // 5.2.2.2. Advance position by 1.\n        position.position++\n      }\n    }\n\n    // 5.3. Remove all HTTP tab or space from the start and end of temporaryValue.\n    temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 0x9 || char === 0x20)\n\n    // 5.4. Append temporaryValue to values.\n    values.push(temporaryValue)\n\n    // 5.6. Set temporaryValue to the empty string.\n    temporaryValue = ''\n  }\n\n  // 6. Return values.\n  return values\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-list-get-decode-split\n * @param {string} name lowercase header name\n * @param {import('./headers').HeadersList} list\n */\nfunction getDecodeSplit (name, list) {\n  // 1. Let value be the result of getting name from list.\n  const value = list.get(name, true)\n\n  // 2. If value is null, then return null.\n  if (value === null) {\n    return null\n  }\n\n  // 3. Return the result of getting, decoding, and splitting value.\n  return gettingDecodingSplitting(value)\n}\n\nconst textDecoder = new TextDecoder()\n\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */\nfunction utf8DecodeBytes (buffer) {\n  if (buffer.length === 0) {\n    return ''\n  }\n\n  // 1. Let buffer be the result of peeking three bytes from\n  //    ioQueue, converted to a byte sequence.\n\n  // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n  //    bytes from ioQueue. (Do nothing with those bytes.)\n  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n    buffer = buffer.subarray(3)\n  }\n\n  // 3. Process a queue with an instance of UTF-8s\n  //    decoder, ioQueue, output, and \"replacement\".\n  const output = textDecoder.decode(buffer)\n\n  // 4. Return output.\n  return output\n}\n\nclass EnvironmentSettingsObjectBase {\n  get baseUrl () {\n    return getGlobalOrigin()\n  }\n\n  get origin () {\n    return this.baseUrl?.origin\n  }\n\n  policyContainer = makePolicyContainer()\n}\n\nclass EnvironmentSettingsObject {\n  settingsObject = new EnvironmentSettingsObjectBase()\n}\n\nconst environmentSettingsObject = new EnvironmentSettingsObject()\n\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  isValidEncodedURL,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  clampAndCoarsenConnectionTimingInfo,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  iteratorMixin,\n  createIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch,\n  readableStreamClose,\n  isomorphicEncode,\n  urlIsLocal,\n  urlHasHttpsScheme,\n  urlIsHttpHttpsScheme,\n  readAllBytes,\n  simpleRangeHeaderValue,\n  buildContentRange,\n  parseMetadata,\n  createInflate,\n  extractMimeType,\n  getDecodeSplit,\n  utf8DecodeBytes,\n  environmentSettingsObject,\n  isOriginIPPotentiallyTrustworthy\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyw0QkFBVztBQUNoQyxRQUFRLHVEQUF1RCxFQUFFLG1CQUFPLENBQUMsMkVBQWE7QUFDdEYsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLHFFQUFVO0FBQzlDLFFBQVEsc0ZBQXNGLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUNwSCxRQUFRLGNBQWMsRUFBRSxtQkFBTyxDQUFDLHdDQUFpQjtBQUNqRCxRQUFRLG9FQUFvRSxFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQ3ZHLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLHdDQUFpQjtBQUNsRCxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNFQUFXOztBQUV0Qzs7QUFFQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsZ0NBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtEQUErRCxFQUFFO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLElBQUksSUFBSSxFQUFFLFFBQVEsSUFBSTtBQUNqQyxXQUFXLElBQUksSUFBSSxJQUFJLFNBQVMsSUFBSTtBQUNwQyxhQUFhLElBQUk7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcsSUFBSTs7QUFFekc7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QixJQUFJO0FBQy9DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsc0NBQXNDLElBQUk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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aUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL3V0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgVHJhbnNmb3JtIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB6bGliID0gcmVxdWlyZSgnbm9kZTp6bGliJylcbmNvbnN0IHsgcmVkaXJlY3RTdGF0dXNTZXQsIHJlZmVycmVyUG9saWN5VG9rZW5zLCBiYWRQb3J0c1NldCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBnZXRHbG9iYWxPcmlnaW4gfSA9IHJlcXVpcmUoJy4vZ2xvYmFsJylcbmNvbnN0IHsgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cywgY29sbGVjdEFuSFRUUFF1b3RlZFN0cmluZywgcmVtb3ZlQ2hhcnMsIHBhcnNlTUlNRVR5cGUgfSA9IHJlcXVpcmUoJy4vZGF0YS11cmwnKVxuY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gcmVxdWlyZSgnbm9kZTpwZXJmX2hvb2tzJylcbmNvbnN0IHsgUmVhZGFibGVTdHJlYW1Gcm9tLCBpc1ZhbGlkSFRUUFRva2VuLCBub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2UgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IGlzVWludDhBcnJheSB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsL3R5cGVzJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi93ZWJpZGwnKVxuXG5sZXQgc3VwcG9ydGVkSGFzaGVzID0gW11cblxuLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9jcnlwdG8uaHRtbCNkZXRlcm1pbmluZy1pZi1jcnlwdG8tc3VwcG9ydC1pcy11bmF2YWlsYWJsZVxuLyoqIEB0eXBlIHtpbXBvcnQoJ2NyeXB0bycpfSAqL1xubGV0IGNyeXB0b1xudHJ5IHtcbiAgY3J5cHRvID0gcmVxdWlyZSgnbm9kZTpjcnlwdG8nKVxuICBjb25zdCBwb3NzaWJsZVJlbGV2YW50SGFzaGVzID0gWydzaGEyNTYnLCAnc2hhMzg0JywgJ3NoYTUxMiddXG4gIHN1cHBvcnRlZEhhc2hlcyA9IGNyeXB0by5nZXRIYXNoZXMoKS5maWx0ZXIoKGhhc2gpID0+IHBvc3NpYmxlUmVsZXZhbnRIYXNoZXMuaW5jbHVkZXMoaGFzaCkpXG4vKiBjOCBpZ25vcmUgbmV4dCAzICovXG59IGNhdGNoIHtcblxufVxuXG5mdW5jdGlvbiByZXNwb25zZVVSTCAocmVzcG9uc2UpIHtcbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3Jlc3BvbnNlc1xuICAvLyBBIHJlc3BvbnNlIGhhcyBhbiBhc3NvY2lhdGVkIFVSTC4gSXQgaXMgYSBwb2ludGVyIHRvIHRoZSBsYXN0IFVSTFxuICAvLyBpbiByZXNwb25zZeKAmXMgVVJMIGxpc3QgYW5kIG51bGwgaWYgcmVzcG9uc2XigJlzIFVSTCBsaXN0IGlzIGVtcHR5LlxuICBjb25zdCB1cmxMaXN0ID0gcmVzcG9uc2UudXJsTGlzdFxuICBjb25zdCBsZW5ndGggPSB1cmxMaXN0Lmxlbmd0aFxuICByZXR1cm4gbGVuZ3RoID09PSAwID8gbnVsbCA6IHVybExpc3RbbGVuZ3RoIC0gMV0udG9TdHJpbmcoKVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1yZXNwb25zZS1sb2NhdGlvbi11cmxcbmZ1bmN0aW9uIHJlc3BvbnNlTG9jYXRpb25VUkwgKHJlc3BvbnNlLCByZXF1ZXN0RnJhZ21lbnQpIHtcbiAgLy8gMS4gSWYgcmVzcG9uc2XigJlzIHN0YXR1cyBpcyBub3QgYSByZWRpcmVjdCBzdGF0dXMsIHRoZW4gcmV0dXJuIG51bGwuXG4gIGlmICghcmVkaXJlY3RTdGF0dXNTZXQuaGFzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gMi4gTGV0IGxvY2F0aW9uIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBoZWFkZXIgbGlzdCB2YWx1ZXMgZ2l2ZW5cbiAgLy8gYExvY2F0aW9uYCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICBsZXQgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ2xvY2F0aW9uJywgdHJ1ZSlcblxuICAvLyAzLiBJZiBsb2NhdGlvbiBpcyBhIGhlYWRlciB2YWx1ZSwgdGhlbiBzZXQgbG9jYXRpb24gdG8gdGhlIHJlc3VsdCBvZlxuICAvLyAgICBwYXJzaW5nIGxvY2F0aW9uIHdpdGggcmVzcG9uc2XigJlzIFVSTC5cbiAgaWYgKGxvY2F0aW9uICE9PSBudWxsICYmIGlzVmFsaWRIZWFkZXJWYWx1ZShsb2NhdGlvbikpIHtcbiAgICBpZiAoIWlzVmFsaWRFbmNvZGVkVVJMKGxvY2F0aW9uKSkge1xuICAgICAgLy8gU29tZSB3ZWJzaXRlcyByZXNwb25kIGxvY2F0aW9uIGhlYWRlciBpbiBVVEYtOCBmb3JtIHdpdGhvdXQgZW5jb2RpbmcgdGhlbSBhcyBBU0NJSVxuICAgICAgLy8gYW5kIG1ham9yIGJyb3dzZXJzIHJlZGlyZWN0IHRoZW0gdG8gY29ycmVjdGx5IFVURi04IGVuY29kZWQgYWRkcmVzc2VzLlxuICAgICAgLy8gSGVyZSwgd2UgaGFuZGxlIHRoYXQgYmVoYXZpb3IgaW4gdGhlIHNhbWUgd2F5LlxuICAgICAgbG9jYXRpb24gPSBub3JtYWxpemVCaW5hcnlTdHJpbmdUb1V0ZjgobG9jYXRpb24pXG4gICAgfVxuICAgIGxvY2F0aW9uID0gbmV3IFVSTChsb2NhdGlvbiwgcmVzcG9uc2VVUkwocmVzcG9uc2UpKVxuICB9XG5cbiAgLy8gNC4gSWYgbG9jYXRpb24gaXMgYSBVUkwgd2hvc2UgZnJhZ21lbnQgaXMgbnVsbCwgdGhlbiBzZXQgbG9jYXRpb27igJlzXG4gIC8vIGZyYWdtZW50IHRvIHJlcXVlc3RGcmFnbWVudC5cbiAgaWYgKGxvY2F0aW9uICYmICFsb2NhdGlvbi5oYXNoKSB7XG4gICAgbG9jYXRpb24uaGFzaCA9IHJlcXVlc3RGcmFnbWVudFxuICB9XG5cbiAgLy8gNS4gUmV0dXJuIGxvY2F0aW9uLlxuICByZXR1cm4gbG9jYXRpb25cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmMxNzM4I3NlY3Rpb24tMi4yXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEVuY29kZWRVUkwgKHVybCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHVybC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSB1cmwuY2hhckNvZGVBdChpKVxuXG4gICAgaWYgKFxuICAgICAgY29kZSA+IDB4N0UgfHwgLy8gTm9uLVVTLUFTQ0lJICsgREVMXG4gICAgICBjb2RlIDwgMHgyMCAvLyBDb250cm9sIGNoYXJhY3RlcnMgTlVMIC0gVVNcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIElmIHN0cmluZyBjb250YWlucyBub24tQVNDSUkgY2hhcmFjdGVycywgYXNzdW1lcyBpdCdzIFVURi04IGVuY29kZWQgYW5kIGRlY29kZXMgaXQuXG4gKiBTaW5jZSBVVEYtOCBpcyBhIHN1cGVyc2V0IG9mIEFTQ0lJLCB0aGlzIHdpbGwgd29yayBmb3IgQVNDSUkgc3RyaW5ncyBhcyB3ZWxsLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVCaW5hcnlTdHJpbmdUb1V0ZjggKHZhbHVlKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgJ2JpbmFyeScpLnRvU3RyaW5nKCd1dGY4Jylcbn1cblxuLyoqIEByZXR1cm5zIHtVUkx9ICovXG5mdW5jdGlvbiByZXF1ZXN0Q3VycmVudFVSTCAocmVxdWVzdCkge1xuICByZXR1cm4gcmVxdWVzdC51cmxMaXN0W3JlcXVlc3QudXJsTGlzdC5sZW5ndGggLSAxXVxufVxuXG5mdW5jdGlvbiByZXF1ZXN0QmFkUG9ydCAocmVxdWVzdCkge1xuICAvLyAxLiBMZXQgdXJsIGJlIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMLlxuICBjb25zdCB1cmwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gIC8vIDIuIElmIHVybOKAmXMgc2NoZW1lIGlzIGFuIEhUVFAoUykgc2NoZW1lIGFuZCB1cmzigJlzIHBvcnQgaXMgYSBiYWQgcG9ydCxcbiAgLy8gdGhlbiByZXR1cm4gYmxvY2tlZC5cbiAgaWYgKHVybElzSHR0cEh0dHBzU2NoZW1lKHVybCkgJiYgYmFkUG9ydHNTZXQuaGFzKHVybC5wb3J0KSkge1xuICAgIHJldHVybiAnYmxvY2tlZCdcbiAgfVxuXG4gIC8vIDMuIFJldHVybiBhbGxvd2VkLlxuICByZXR1cm4gJ2FsbG93ZWQnXG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JMaWtlIChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEVycm9yIHx8IChcbiAgICBvYmplY3Q/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnRXJyb3InIHx8XG4gICAgb2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ0RPTUV4Y2VwdGlvbidcbiAgKVxufVxuXG4vLyBDaGVjayB3aGV0aGVyIHxzdGF0dXNUZXh0fCBpcyBhIEJ5dGVTdHJpbmcgYW5kXG4vLyBtYXRjaGVzIHRoZSBSZWFzb24tUGhyYXNlIHRva2VuIHByb2R1Y3Rpb24uXG4vLyBSRkMgMjYxNjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI2MTZcbi8vIFJGQyA3MjMwOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMFxuLy8gXCJyZWFzb24tcGhyYXNlID0gKiggSFRBQiAvIFNQIC8gVkNIQVIgLyBvYnMtdGV4dCApXCJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJvbWl1bS9jaHJvbWl1bS9ibG9iLzk0LjAuNDYwNC4xL3RoaXJkX3BhcnR5L2JsaW5rL3JlbmRlcmVyL2NvcmUvZmV0Y2gvcmVzcG9uc2UuY2MjTDExNlxuZnVuY3Rpb24gaXNWYWxpZFJlYXNvblBocmFzZSAoc3RhdHVzVGV4dCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXR1c1RleHQubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjID0gc3RhdHVzVGV4dC5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKFxuICAgICAgIShcbiAgICAgICAgKFxuICAgICAgICAgIGMgPT09IDB4MDkgfHwgLy8gSFRBQlxuICAgICAgICAgIChjID49IDB4MjAgJiYgYyA8PSAweDdlKSB8fCAvLyBTUCAvIFZDSEFSXG4gICAgICAgICAgKGMgPj0gMHg4MCAmJiBjIDw9IDB4ZmYpXG4gICAgICAgICkgLy8gb2JzLXRleHRcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlci1uYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gcG90ZW50aWFsVmFsdWVcbiAqL1xuY29uc3QgaXNWYWxpZEhlYWRlck5hbWUgPSBpc1ZhbGlkSFRUUFRva2VuXG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaGVhZGVyLXZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gcG90ZW50aWFsVmFsdWVcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEhlYWRlclZhbHVlIChwb3RlbnRpYWxWYWx1ZSkge1xuICAvLyAtIEhhcyBubyBsZWFkaW5nIG9yIHRyYWlsaW5nIEhUVFAgdGFiIG9yIHNwYWNlIGJ5dGVzLlxuICAvLyAtIENvbnRhaW5zIG5vIDB4MDAgKE5VTCkgb3IgSFRUUCBuZXdsaW5lIGJ5dGVzLlxuICByZXR1cm4gKFxuICAgIHBvdGVudGlhbFZhbHVlWzBdID09PSAnXFx0JyB8fFxuICAgIHBvdGVudGlhbFZhbHVlWzBdID09PSAnICcgfHxcbiAgICBwb3RlbnRpYWxWYWx1ZVtwb3RlbnRpYWxWYWx1ZS5sZW5ndGggLSAxXSA9PT0gJ1xcdCcgfHxcbiAgICBwb3RlbnRpYWxWYWx1ZVtwb3RlbnRpYWxWYWx1ZS5sZW5ndGggLSAxXSA9PT0gJyAnIHx8XG4gICAgcG90ZW50aWFsVmFsdWUuaW5jbHVkZXMoJ1xcbicpIHx8XG4gICAgcG90ZW50aWFsVmFsdWUuaW5jbHVkZXMoJ1xccicpIHx8XG4gICAgcG90ZW50aWFsVmFsdWUuaW5jbHVkZXMoJ1xcMCcpXG4gICkgPT09IGZhbHNlXG59XG5cbi8qKlxuICogUGFyc2UgYSByZWZlcnJlciBwb2xpY3kgZnJvbSBhIFJlZmVycmVyLVBvbGljeSBoZWFkZXJcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3BhcnNlLXJlZmVycmVyLXBvbGljeS1mcm9tLWhlYWRlclxuICovXG5mdW5jdGlvbiBwYXJzZVJlZmVycmVyUG9saWN5IChhY3R1YWxSZXNwb25zZSkge1xuICAvLyAxLiBMZXQgcG9saWN5LXRva2VucyBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgaGVhZGVyIGxpc3QgdmFsdWVzIGdpdmVuIGBSZWZlcnJlci1Qb2xpY3lgIGFuZCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gIGNvbnN0IHBvbGljeUhlYWRlciA9IChhY3R1YWxSZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ3JlZmVycmVyLXBvbGljeScsIHRydWUpID8/ICcnKS5zcGxpdCgnLCcpXG5cbiAgLy8gMi4gTGV0IHBvbGljeSBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICBsZXQgcG9saWN5ID0gJydcblxuICAvLyAzLiBGb3IgZWFjaCB0b2tlbiBpbiBwb2xpY3ktdG9rZW5zLCBpZiB0b2tlbiBpcyBhIHJlZmVycmVyIHBvbGljeSBhbmQgdG9rZW4gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHBvbGljeSB0byB0b2tlbi5cblxuICAvLyBOb3RlOiBBcyB0aGUgcmVmZXJyZXItcG9saWN5IGNhbiBjb250YWluIG11bHRpcGxlIHBvbGljaWVzXG4gIC8vIHNlcGFyYXRlZCBieSBjb21tYSwgd2UgbmVlZCB0byBsb29wIHRocm91Z2ggYWxsIG9mIHRoZW1cbiAgLy8gYW5kIHBpY2sgdGhlIGZpcnN0IHZhbGlkIG9uZS5cbiAgLy8gUmVmOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvUmVmZXJyZXItUG9saWN5I3NwZWNpZnlfYV9mYWxsYmFja19wb2xpY3lcbiAgaWYgKHBvbGljeUhlYWRlci5sZW5ndGgpIHtcbiAgICAvLyBUaGUgcmlnaHQtbW9zdCBwb2xpY3kgdGFrZXMgcHJlY2VkZW5jZS5cbiAgICAvLyBUaGUgbGVmdC1tb3N0IHBvbGljeSBpcyB0aGUgZmFsbGJhY2suXG4gICAgZm9yIChsZXQgaSA9IHBvbGljeUhlYWRlci5sZW5ndGg7IGkgIT09IDA7IGktLSkge1xuICAgICAgY29uc3QgdG9rZW4gPSBwb2xpY3lIZWFkZXJbaSAtIDFdLnRyaW0oKVxuICAgICAgaWYgKHJlZmVycmVyUG9saWN5VG9rZW5zLmhhcyh0b2tlbikpIHtcbiAgICAgICAgcG9saWN5ID0gdG9rZW5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyA0LiBSZXR1cm4gcG9saWN5LlxuICByZXR1cm4gcG9saWN5XG59XG5cbi8qKlxuICogR2l2ZW4gYSByZXF1ZXN0IHJlcXVlc3QgYW5kIGEgcmVzcG9uc2UgYWN0dWFsUmVzcG9uc2UsIHRoaXMgYWxnb3JpdGhtXG4gKiB1cGRhdGVzIHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeSBhY2NvcmRpbmcgdG8gdGhlIFJlZmVycmVyLVBvbGljeVxuICogaGVhZGVyIChpZiBhbnkpIGluIGFjdHVhbFJlc3BvbnNlLlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jc2V0LXJlcXVlc3RzLXJlZmVycmVyLXBvbGljeS1vbi1yZWRpcmVjdFxuICogQHBhcmFtIHtpbXBvcnQoJy4vcmVxdWVzdCcpLlJlcXVlc3R9IHJlcXVlc3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3Jlc3BvbnNlJykuUmVzcG9uc2V9IGFjdHVhbFJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QgKHJlcXVlc3QsIGFjdHVhbFJlc3BvbnNlKSB7XG4gIC8vIDEuIExldCBwb2xpY3kgYmUgdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgwqcgOC4xIFBhcnNlIGEgcmVmZXJyZXIgcG9saWN5XG4gIC8vIGZyb20gYSBSZWZlcnJlci1Qb2xpY3kgaGVhZGVyIG9uIGFjdHVhbFJlc3BvbnNlLlxuICBjb25zdCBwb2xpY3kgPSBwYXJzZVJlZmVycmVyUG9saWN5KGFjdHVhbFJlc3BvbnNlKVxuXG4gIC8vIDIuIElmIHBvbGljeSBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5IHRvIHBvbGljeS5cbiAgaWYgKHBvbGljeSAhPT0gJycpIHtcbiAgICByZXF1ZXN0LnJlZmVycmVyUG9saWN5ID0gcG9saWN5XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2Nyb3NzLW9yaWdpbi1yZXNvdXJjZS1wb2xpY3ktY2hlY2tcbmZ1bmN0aW9uIGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayAoKSB7XG4gIC8vIFRPRE9cbiAgcmV0dXJuICdhbGxvd2VkJ1xufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1jb3JzLWNoZWNrXG5mdW5jdGlvbiBjb3JzQ2hlY2sgKCkge1xuICAvLyBUT0RPXG4gIHJldHVybiAnc3VjY2Vzcydcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtdGFvLWNoZWNrXG5mdW5jdGlvbiBUQU9DaGVjayAoKSB7XG4gIC8vIFRPRE9cbiAgcmV0dXJuICdzdWNjZXNzJ1xufVxuXG5mdW5jdGlvbiBhcHBlbmRGZXRjaE1ldGFkYXRhIChodHRwUmVxdWVzdCkge1xuICAvLyAgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1mZXRjaC1tZXRhZGF0YS8jc2VjLWZldGNoLWRlc3QtaGVhZGVyXG4gIC8vICBUT0RPXG5cbiAgLy8gIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtZmV0Y2gtbWV0YWRhdGEvI3NlYy1mZXRjaC1tb2RlLWhlYWRlclxuXG4gIC8vICAxLiBBc3NlcnQ6IHLigJlzIHVybCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTC5cbiAgLy8gIFRPRE9cblxuICAvLyAgMi4gTGV0IGhlYWRlciBiZSBhIFN0cnVjdHVyZWQgSGVhZGVyIHdob3NlIHZhbHVlIGlzIGEgdG9rZW4uXG4gIGxldCBoZWFkZXIgPSBudWxsXG5cbiAgLy8gIDMuIFNldCBoZWFkZXLigJlzIHZhbHVlIHRvIHLigJlzIG1vZGUuXG4gIGhlYWRlciA9IGh0dHBSZXF1ZXN0Lm1vZGVcblxuICAvLyAgNC4gU2V0IGEgc3RydWN0dXJlZCBmaWVsZCB2YWx1ZSBgU2VjLUZldGNoLU1vZGVgL2hlYWRlciBpbiBy4oCZcyBoZWFkZXIgbGlzdC5cbiAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3Quc2V0KCdzZWMtZmV0Y2gtbW9kZScsIGhlYWRlciwgdHJ1ZSlcblxuICAvLyAgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1mZXRjaC1tZXRhZGF0YS8jc2VjLWZldGNoLXNpdGUtaGVhZGVyXG4gIC8vICBUT0RPXG5cbiAgLy8gIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtZmV0Y2gtbWV0YWRhdGEvI3NlYy1mZXRjaC11c2VyLWhlYWRlclxuICAvLyAgVE9ET1xufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYXBwZW5kLWEtcmVxdWVzdC1vcmlnaW4taGVhZGVyXG5mdW5jdGlvbiBhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyIChyZXF1ZXN0KSB7XG4gIC8vIDEuIExldCBzZXJpYWxpemVkT3JpZ2luIGJlIHRoZSByZXN1bHQgb2YgYnl0ZS1zZXJpYWxpemluZyBhIHJlcXVlc3Qgb3JpZ2luXG4gIC8vICAgIHdpdGggcmVxdWVzdC5cbiAgLy8gVE9ETzogaW1wbGVtZW50IFwiYnl0ZS1zZXJpYWxpemluZyBhIHJlcXVlc3Qgb3JpZ2luXCJcbiAgbGV0IHNlcmlhbGl6ZWRPcmlnaW4gPSByZXF1ZXN0Lm9yaWdpblxuXG4gIC8vIC0gXCInY2xpZW50JyBpcyBjaGFuZ2VkIHRvIGFuIG9yaWdpbiBkdXJpbmcgZmV0Y2hpbmcuXCJcbiAgLy8gICBUaGlzIGRvZXNuJ3QgaGFwcGVuIGluIHVuZGljaSAoaW4gbW9zdCBjYXNlcykgYmVjYXVzZSB1bmRpY2ksIGJ5IGRlZmF1bHQsXG4gIC8vICAgaGFzIG5vIGNvbmNlcHQgb2Ygb3JpZ2luLlxuICAvLyAtIHJlcXVlc3Qub3JpZ2luIGNhbiBhbHNvIGJlIHNldCB0byByZXF1ZXN0LmNsaWVudC5vcmlnaW4gKGNsaWVudCBiZWluZ1xuICAvLyAgIGFuIGVudmlyb25tZW50IHNldHRpbmdzIG9iamVjdCksIHdoaWNoIGlzIHVuZGVmaW5lZCB3aXRob3V0IHVzaW5nXG4gIC8vICAgc2V0R2xvYmFsT3JpZ2luLlxuICBpZiAoc2VyaWFsaXplZE9yaWdpbiA9PT0gJ2NsaWVudCcgfHwgc2VyaWFsaXplZE9yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyAyLiBJZiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcImNvcnNcIiBvciByZXF1ZXN04oCZcyBtb2RlIGlzIFwid2Vic29ja2V0XCIsXG4gIC8vICAgIHRoZW4gYXBwZW5kIChgT3JpZ2luYCwgc2VyaWFsaXplZE9yaWdpbikgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIC8vIDMuIE90aGVyd2lzZSwgaWYgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIG5laXRoZXIgYEdFVGAgbm9yIGBIRUFEYCwgdGhlbjpcbiAgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2NvcnMnIHx8IHJlcXVlc3QubW9kZSA9PT0gJ3dlYnNvY2tldCcpIHtcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnb3JpZ2luJywgc2VyaWFsaXplZE9yaWdpbiwgdHJ1ZSlcbiAgfSBlbHNlIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcgJiYgcmVxdWVzdC5tZXRob2QgIT09ICdIRUFEJykge1xuICAgIC8vIDEuIFN3aXRjaCBvbiByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3k6XG4gICAgc3dpdGNoIChyZXF1ZXN0LnJlZmVycmVyUG9saWN5KSB7XG4gICAgICBjYXNlICduby1yZWZlcnJlcic6XG4gICAgICAgIC8vIFNldCBzZXJpYWxpemVkT3JpZ2luIHRvIGBudWxsYC5cbiAgICAgICAgc2VyaWFsaXplZE9yaWdpbiA9IG51bGxcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJzpcbiAgICAgIGNhc2UgJ3N0cmljdC1vcmlnaW4nOlxuICAgICAgY2FzZSAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbic6XG4gICAgICAgIC8vIElmIHJlcXVlc3TigJlzIG9yaWdpbiBpcyBhIHR1cGxlIG9yaWdpbiwgaXRzIHNjaGVtZSBpcyBcImh0dHBzXCIsIGFuZFxuICAgICAgICAvLyByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGlzIG5vdCBcImh0dHBzXCIsIHRoZW4gc2V0XG4gICAgICAgIC8vIHNlcmlhbGl6ZWRPcmlnaW4gdG8gYG51bGxgLlxuICAgICAgICBpZiAocmVxdWVzdC5vcmlnaW4gJiYgdXJsSGFzSHR0cHNTY2hlbWUocmVxdWVzdC5vcmlnaW4pICYmICF1cmxIYXNIdHRwc1NjaGVtZShyZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KSkpIHtcbiAgICAgICAgICBzZXJpYWxpemVkT3JpZ2luID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzYW1lLW9yaWdpbic6XG4gICAgICAgIC8vIElmIHJlcXVlc3TigJlzIG9yaWdpbiBpcyBub3Qgc2FtZSBvcmlnaW4gd2l0aCByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXNcbiAgICAgICAgLy8gb3JpZ2luLCB0aGVuIHNldCBzZXJpYWxpemVkT3JpZ2luIHRvIGBudWxsYC5cbiAgICAgICAgaWYgKCFzYW1lT3JpZ2luKHJlcXVlc3QsIHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpKSkge1xuICAgICAgICAgIHNlcmlhbGl6ZWRPcmlnaW4gPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgfVxuXG4gICAgLy8gMi4gQXBwZW5kIChgT3JpZ2luYCwgc2VyaWFsaXplZE9yaWdpbikgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ29yaWdpbicsIHNlcmlhbGl6ZWRPcmlnaW4sIHRydWUpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL2hyLXRpbWUvI2Rmbi1jb2Fyc2VuLXRpbWVcbmZ1bmN0aW9uIGNvYXJzZW5UaW1lICh0aW1lc3RhbXAsIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSB7XG4gIC8vIFRPRE9cbiAgcmV0dXJuIHRpbWVzdGFtcFxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY2xhbXAtYW5kLWNvYXJzZW4tY29ubmVjdGlvbi10aW1pbmctaW5mb1xuZnVuY3Rpb24gY2xhbXBBbmRDb2Fyc2VuQ29ubmVjdGlvblRpbWluZ0luZm8gKGNvbm5lY3Rpb25UaW1pbmdJbmZvLCBkZWZhdWx0U3RhcnRUaW1lLCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSkge1xuICBpZiAoIWNvbm5lY3Rpb25UaW1pbmdJbmZvPy5zdGFydFRpbWUgfHwgY29ubmVjdGlvblRpbWluZ0luZm8uc3RhcnRUaW1lIDwgZGVmYXVsdFN0YXJ0VGltZSkge1xuICAgIHJldHVybiB7XG4gICAgICBkb21haW5Mb29rdXBTdGFydFRpbWU6IGRlZmF1bHRTdGFydFRpbWUsXG4gICAgICBkb21haW5Mb29rdXBFbmRUaW1lOiBkZWZhdWx0U3RhcnRUaW1lLFxuICAgICAgY29ubmVjdGlvblN0YXJ0VGltZTogZGVmYXVsdFN0YXJ0VGltZSxcbiAgICAgIGNvbm5lY3Rpb25FbmRUaW1lOiBkZWZhdWx0U3RhcnRUaW1lLFxuICAgICAgc2VjdXJlQ29ubmVjdGlvblN0YXJ0VGltZTogZGVmYXVsdFN0YXJ0VGltZSxcbiAgICAgIEFMUE5OZWdvdGlhdGVkUHJvdG9jb2w6IGNvbm5lY3Rpb25UaW1pbmdJbmZvPy5BTFBOTmVnb3RpYXRlZFByb3RvY29sXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkb21haW5Mb29rdXBTdGFydFRpbWU6IGNvYXJzZW5UaW1lKGNvbm5lY3Rpb25UaW1pbmdJbmZvLmRvbWFpbkxvb2t1cFN0YXJ0VGltZSwgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpLFxuICAgIGRvbWFpbkxvb2t1cEVuZFRpbWU6IGNvYXJzZW5UaW1lKGNvbm5lY3Rpb25UaW1pbmdJbmZvLmRvbWFpbkxvb2t1cEVuZFRpbWUsIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSxcbiAgICBjb25uZWN0aW9uU3RhcnRUaW1lOiBjb2Fyc2VuVGltZShjb25uZWN0aW9uVGltaW5nSW5mby5jb25uZWN0aW9uU3RhcnRUaW1lLCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSksXG4gICAgY29ubmVjdGlvbkVuZFRpbWU6IGNvYXJzZW5UaW1lKGNvbm5lY3Rpb25UaW1pbmdJbmZvLmNvbm5lY3Rpb25FbmRUaW1lLCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSksXG4gICAgc2VjdXJlQ29ubmVjdGlvblN0YXJ0VGltZTogY29hcnNlblRpbWUoY29ubmVjdGlvblRpbWluZ0luZm8uc2VjdXJlQ29ubmVjdGlvblN0YXJ0VGltZSwgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpLFxuICAgIEFMUE5OZWdvdGlhdGVkUHJvdG9jb2w6IGNvbm5lY3Rpb25UaW1pbmdJbmZvLkFMUE5OZWdvdGlhdGVkUHJvdG9jb2xcbiAgfVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vaHItdGltZS8jZGZuLWNvYXJzZW5lZC1zaGFyZWQtY3VycmVudC10aW1lXG5mdW5jdGlvbiBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSAoY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpIHtcbiAgcmV0dXJuIGNvYXJzZW5UaW1lKHBlcmZvcm1hbmNlLm5vdygpLCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSlcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NyZWF0ZS1hbi1vcGFxdWUtdGltaW5nLWluZm9cbmZ1bmN0aW9uIGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8gKHRpbWluZ0luZm8pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydFRpbWU6IHRpbWluZ0luZm8uc3RhcnRUaW1lID8/IDAsXG4gICAgcmVkaXJlY3RTdGFydFRpbWU6IDAsXG4gICAgcmVkaXJlY3RFbmRUaW1lOiAwLFxuICAgIHBvc3RSZWRpcmVjdFN0YXJ0VGltZTogdGltaW5nSW5mby5zdGFydFRpbWUgPz8gMCxcbiAgICBmaW5hbFNlcnZpY2VXb3JrZXJTdGFydFRpbWU6IDAsXG4gICAgZmluYWxOZXR3b3JrUmVzcG9uc2VTdGFydFRpbWU6IDAsXG4gICAgZmluYWxOZXR3b3JrUmVxdWVzdFN0YXJ0VGltZTogMCxcbiAgICBlbmRUaW1lOiAwLFxuICAgIGVuY29kZWRCb2R5U2l6ZTogMCxcbiAgICBkZWNvZGVkQm9keVNpemU6IDAsXG4gICAgZmluYWxDb25uZWN0aW9uVGltaW5nSW5mbzogbnVsbFxuICB9XG59XG5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL29yaWdpbi5odG1sI3BvbGljeS1jb250YWluZXJcbmZ1bmN0aW9uIG1ha2VQb2xpY3lDb250YWluZXIgKCkge1xuICAvLyBOb3RlOiB0aGUgZmV0Y2ggc3BlYyBkb2Vzbid0IG1ha2UgdXNlIG9mIGVtYmVkZGVyIHBvbGljeSBvciBDU1AgbGlzdFxuICByZXR1cm4ge1xuICAgIHJlZmVycmVyUG9saWN5OiAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbidcbiAgfVxufVxuXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9vcmlnaW4uaHRtbCNjbG9uZS1hLXBvbGljeS1jb250YWluZXJcbmZ1bmN0aW9uIGNsb25lUG9saWN5Q29udGFpbmVyIChwb2xpY3lDb250YWluZXIpIHtcbiAgcmV0dXJuIHtcbiAgICByZWZlcnJlclBvbGljeTogcG9saWN5Q29udGFpbmVyLnJlZmVycmVyUG9saWN5XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgcmVxdWVzdOKAmXMgUmVmZXJyZXJcbiAqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNkZXRlcm1pbmUtcmVxdWVzdHMtcmVmZXJyZXJcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlciAocmVxdWVzdCkge1xuICAvLyBHaXZlbiBhIHJlcXVlc3QgcmVxdWVzdCwgd2UgY2FuIGRldGVybWluZSB0aGUgY29ycmVjdCByZWZlcnJlciBpbmZvcm1hdGlvblxuICAvLyB0byBzZW5kIGJ5IGV4YW1pbmluZyBpdHMgcmVmZXJyZXIgcG9saWN5IGFzIGRldGFpbGVkIGluIHRoZSBmb2xsb3dpbmdcbiAgLy8gc3RlcHMsIHdoaWNoIHJldHVybiBlaXRoZXIgbm8gcmVmZXJyZXIgb3IgYSBVUkw6XG5cbiAgLy8gMS4gTGV0IHBvbGljeSBiZSByZXF1ZXN0J3MgcmVmZXJyZXIgcG9saWN5LlxuICBjb25zdCBwb2xpY3kgPSByZXF1ZXN0LnJlZmVycmVyUG9saWN5XG5cbiAgLy8gTm90ZTogcG9saWN5IGNhbm5vdCAoc2hvdWxkbid0KSBiZSBudWxsIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAgYXNzZXJ0KHBvbGljeSlcblxuICAvLyAyLiBMZXQgZW52aXJvbm1lbnQgYmUgcmVxdWVzdOKAmXMgY2xpZW50LlxuXG4gIGxldCByZWZlcnJlclNvdXJjZSA9IG51bGxcblxuICAvLyAzLiBTd2l0Y2ggb24gcmVxdWVzdOKAmXMgcmVmZXJyZXI6XG5cbiAgLy8gXCJjbGllbnRcIlxuICBpZiAocmVxdWVzdC5yZWZlcnJlciA9PT0gJ2NsaWVudCcpIHtcbiAgICAvLyBOb3RlOiBub2RlIGlzbid0IGEgYnJvd3NlciBhbmQgZG9lc24ndCBpbXBsZW1lbnQgZG9jdW1lbnQvaWZyYW1lcyxcbiAgICAvLyBzbyB3ZSBieXBhc3MgdGhpcyBzdGVwIGFuZCByZXBsYWNlIGl0IHdpdGggb3VyIG93bi5cblxuICAgIGNvbnN0IGdsb2JhbE9yaWdpbiA9IGdldEdsb2JhbE9yaWdpbigpXG5cbiAgICBpZiAoIWdsb2JhbE9yaWdpbiB8fCBnbG9iYWxPcmlnaW4ub3JpZ2luID09PSAnbnVsbCcpIHtcbiAgICAgIHJldHVybiAnbm8tcmVmZXJyZXInXG4gICAgfVxuXG4gICAgLy8gTm90ZTogd2UgbmVlZCB0byBjbG9uZSBpdCBhcyBpdCdzIG11dGF0ZWRcbiAgICByZWZlcnJlclNvdXJjZSA9IG5ldyBVUkwoZ2xvYmFsT3JpZ2luKVxuICAvLyBhIFVSTFxuICB9IGVsc2UgaWYgKHdlYmlkbC5pcy5VUkwocmVxdWVzdC5yZWZlcnJlcikpIHtcbiAgICAvLyBMZXQgcmVmZXJyZXJTb3VyY2UgYmUgcmVxdWVzdOKAmXMgcmVmZXJyZXIuXG4gICAgcmVmZXJyZXJTb3VyY2UgPSByZXF1ZXN0LnJlZmVycmVyXG4gIH1cblxuICAvLyA0LiBMZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXJVUkwgYmUgdGhlIHJlc3VsdCBvZiBzdHJpcHBpbmcgcmVmZXJyZXJTb3VyY2UgZm9yXG4gIC8vICAgIHVzZSBhcyBhIHJlZmVycmVyLlxuICBsZXQgcmVmZXJyZXJVUkwgPSBzdHJpcFVSTEZvclJlZmVycmVyKHJlZmVycmVyU291cmNlKVxuXG4gIC8vIDUuIExldCByZWZlcnJlck9yaWdpbiBiZSB0aGUgcmVzdWx0IG9mIHN0cmlwcGluZyByZWZlcnJlclNvdXJjZSBmb3IgdXNlIGFzXG4gIC8vICAgIGEgcmVmZXJyZXIsIHdpdGggdGhlIG9yaWdpbi1vbmx5IGZsYWcgc2V0IHRvIHRydWUuXG4gIGNvbnN0IHJlZmVycmVyT3JpZ2luID0gc3RyaXBVUkxGb3JSZWZlcnJlcihyZWZlcnJlclNvdXJjZSwgdHJ1ZSlcblxuICAvLyA2LiBJZiB0aGUgcmVzdWx0IG9mIHNlcmlhbGl6aW5nIHJlZmVycmVyVVJMIGlzIGEgc3RyaW5nIHdob3NlIGxlbmd0aCBpc1xuICAvLyAgICBncmVhdGVyIHRoYW4gNDA5Niwgc2V0IHJlZmVycmVyVVJMIHRvIHJlZmVycmVyT3JpZ2luLlxuICBpZiAocmVmZXJyZXJVUkwudG9TdHJpbmcoKS5sZW5ndGggPiA0MDk2KSB7XG4gICAgcmVmZXJyZXJVUkwgPSByZWZlcnJlck9yaWdpblxuICB9XG5cbiAgLy8gNy4gVGhlIHVzZXIgYWdlbnQgTUFZIGFsdGVyIHJlZmVycmVyVVJMIG9yIHJlZmVycmVyT3JpZ2luIGF0IHRoaXMgcG9pbnRcbiAgLy8gdG8gZW5mb3JjZSBhcmJpdHJhcnkgcG9saWN5IGNvbnNpZGVyYXRpb25zIGluIHRoZSBpbnRlcmVzdHMgb2YgbWluaW1pemluZ1xuICAvLyBkYXRhIGxlYWthZ2UuIEZvciBleGFtcGxlLCB0aGUgdXNlciBhZ2VudCBjb3VsZCBzdHJpcCB0aGUgVVJMIGRvd24gdG8gYW5cbiAgLy8gb3JpZ2luLCBtb2RpZnkgaXRzIGhvc3QsIHJlcGxhY2UgaXQgd2l0aCBhbiBlbXB0eSBzdHJpbmcsIGV0Yy5cblxuICAvLyA4LiBFeGVjdXRlIHRoZSBzd2l0Y2ggc3RhdGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSB2YWx1ZSBvZiBwb2xpY3k6XG4gIHN3aXRjaCAocG9saWN5KSB7XG4gICAgY2FzZSAnbm8tcmVmZXJyZXInOlxuICAgICAgLy8gUmV0dXJuIG5vIHJlZmVycmVyXG4gICAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICAgIGNhc2UgJ29yaWdpbic6XG4gICAgICAvLyBSZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICAgIGlmIChyZWZlcnJlck9yaWdpbiAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZWZlcnJlck9yaWdpblxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmlwVVJMRm9yUmVmZXJyZXIocmVmZXJyZXJTb3VyY2UsIHRydWUpXG4gICAgY2FzZSAndW5zYWZlLXVybCc6XG4gICAgICAvLyBSZXR1cm4gcmVmZXJyZXJVUkwuXG4gICAgICByZXR1cm4gcmVmZXJyZXJVUkxcbiAgICBjYXNlICdzdHJpY3Qtb3JpZ2luJzoge1xuICAgICAgY29uc3QgY3VycmVudFVSTCA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG5cbiAgICAgIC8vIDEuIElmIHJlZmVycmVyVVJMIGlzIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMIGFuZCByZXF1ZXN04oCZc1xuICAgICAgLy8gICAgY3VycmVudCBVUkwgaXMgbm90IGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLCB0aGVuIHJldHVybiBub1xuICAgICAgLy8gICAgcmVmZXJyZXIuXG4gICAgICBpZiAoaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5KHJlZmVycmVyVVJMKSAmJiAhaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5KGN1cnJlbnRVUkwpKSB7XG4gICAgICAgIHJldHVybiAnbm8tcmVmZXJyZXInXG4gICAgICB9XG4gICAgICAvLyAyLiBSZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICAgIHJldHVybiByZWZlcnJlck9yaWdpblxuICAgIH1cbiAgICBjYXNlICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJzoge1xuICAgICAgY29uc3QgY3VycmVudFVSTCA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG5cbiAgICAgIC8vIDEuIElmIHRoZSBvcmlnaW4gb2YgcmVmZXJyZXJVUkwgYW5kIHRoZSBvcmlnaW4gb2YgcmVxdWVzdOKAmXMgY3VycmVudFxuICAgICAgLy8gICAgVVJMIGFyZSB0aGUgc2FtZSwgdGhlbiByZXR1cm4gcmVmZXJyZXJVUkwuXG4gICAgICBpZiAoc2FtZU9yaWdpbihyZWZlcnJlclVSTCwgY3VycmVudFVSTCkpIHtcbiAgICAgICAgcmV0dXJuIHJlZmVycmVyVVJMXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIHJlZmVycmVyVVJMIGlzIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMIGFuZCByZXF1ZXN04oCZc1xuICAgICAgLy8gICAgY3VycmVudCBVUkwgaXMgbm90IGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLCB0aGVuIHJldHVybiBub1xuICAgICAgLy8gICAgcmVmZXJyZXIuXG4gICAgICBpZiAoaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5KHJlZmVycmVyVVJMKSAmJiAhaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5KGN1cnJlbnRVUkwpKSB7XG4gICAgICAgIHJldHVybiAnbm8tcmVmZXJyZXInXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIFJldHVybiByZWZlcnJlck9yaWdpbi5cbiAgICAgIHJldHVybiByZWZlcnJlck9yaWdpblxuICAgIH1cbiAgICBjYXNlICdzYW1lLW9yaWdpbic6XG4gICAgICAvLyAxLiBJZiB0aGUgb3JpZ2luIG9mIHJlZmVycmVyVVJMIGFuZCB0aGUgb3JpZ2luIG9mIHJlcXVlc3TigJlzIGN1cnJlbnRcbiAgICAgIC8vIFVSTCBhcmUgdGhlIHNhbWUsIHRoZW4gcmV0dXJuIHJlZmVycmVyVVJMLlxuICAgICAgaWYgKHNhbWVPcmlnaW4ocmVxdWVzdCwgcmVmZXJyZXJVUkwpKSB7XG4gICAgICAgIHJldHVybiByZWZlcnJlclVSTFxuICAgICAgfVxuICAgICAgLy8gMi4gUmV0dXJuIG5vIHJlZmVycmVyLlxuICAgICAgcmV0dXJuICduby1yZWZlcnJlcidcbiAgICBjYXNlICdvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nOlxuICAgICAgLy8gMS4gSWYgdGhlIG9yaWdpbiBvZiByZWZlcnJlclVSTCBhbmQgdGhlIG9yaWdpbiBvZiByZXF1ZXN04oCZcyBjdXJyZW50XG4gICAgICAvLyBVUkwgYXJlIHRoZSBzYW1lLCB0aGVuIHJldHVybiByZWZlcnJlclVSTC5cbiAgICAgIGlmIChzYW1lT3JpZ2luKHJlcXVlc3QsIHJlZmVycmVyVVJMKSkge1xuICAgICAgICByZXR1cm4gcmVmZXJyZXJVUkxcbiAgICAgIH1cbiAgICAgIC8vIDIuIFJldHVybiByZWZlcnJlck9yaWdpbi5cbiAgICAgIHJldHVybiByZWZlcnJlck9yaWdpblxuICAgIGNhc2UgJ25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJzoge1xuICAgICAgY29uc3QgY3VycmVudFVSTCA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG5cbiAgICAgIC8vIDEuIElmIHJlZmVycmVyVVJMIGlzIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMIGFuZCByZXF1ZXN04oCZc1xuICAgICAgLy8gICAgY3VycmVudCBVUkwgaXMgbm90IGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLCB0aGVuIHJldHVybiBub1xuICAgICAgLy8gICAgcmVmZXJyZXIuXG4gICAgICBpZiAoaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5KHJlZmVycmVyVVJMKSAmJiAhaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5KGN1cnJlbnRVUkwpKSB7XG4gICAgICAgIHJldHVybiAnbm8tcmVmZXJyZXInXG4gICAgICB9XG4gICAgICAvLyAyLiBSZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICAgIHJldHVybiByZWZlcnJlck9yaWdpblxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENlcnRhaW4gcG9ydGlvbnMgb2YgVVJMcyBtdXN0IG5vdCBiZSBpbmNsdWRlZCB3aGVuIHNlbmRpbmcgYSBVUkwgYXMgdGhlXG4gKiB2YWx1ZSBvZiBhIGBSZWZlcmVyYCBoZWFkZXI6IGEgVVJMcyBmcmFnbWVudCwgdXNlcm5hbWUsIGFuZCBwYXNzd29yZFxuICogY29tcG9uZW50cyBtdXN0IGJlIHN0cmlwcGVkIGZyb20gdGhlIFVSTCBiZWZvcmUgaXTigJlzIHNlbnQgb3V0LiBUaGlzXG4gKiBhbGdvcml0aG0gYWNjZXB0cyBhIG9yaWdpbi1vbmx5IGZsYWcsIHdoaWNoIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiBzZXQgdG9cbiAqIHRydWUsIHRoZSBhbGdvcml0aG0gd2lsbCBhZGRpdGlvbmFsbHkgcmVtb3ZlIHRoZSBVUkzigJlzIHBhdGggYW5kIHF1ZXJ5XG4gKiBjb21wb25lbnRzLCBsZWF2aW5nIG9ubHkgdGhlIHNjaGVtZSwgaG9zdCwgYW5kIHBvcnQuXG4gKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jc3RyaXAtdXJsXG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcmlnaW5Pbmx5PWZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHJpcFVSTEZvclJlZmVycmVyICh1cmwsIG9yaWdpbk9ubHkgPSBmYWxzZSkge1xuICAvLyAxLiBBc3NlcnQ6IHVybCBpcyBhIFVSTC5cbiAgYXNzZXJ0KHdlYmlkbC5pcy5VUkwodXJsKSlcblxuICAvLyBOb3RlOiBDcmVhdGUgYSBuZXcgVVJMIGluc3RhbmNlIHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbCBVUkwuXG4gIHVybCA9IG5ldyBVUkwodXJsKVxuXG4gIC8vIDIuIElmIHVybOKAmXMgc2NoZW1lIGlzIGEgbG9jYWwgc2NoZW1lLCB0aGVuIHJldHVybiBubyByZWZlcnJlci5cbiAgaWYgKHVybElzTG9jYWwodXJsKSkge1xuICAgIHJldHVybiAnbm8tcmVmZXJyZXInXG4gIH1cblxuICAvLyAzLiBTZXQgdXJs4oCZcyB1c2VybmFtZSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICB1cmwudXNlcm5hbWUgPSAnJ1xuXG4gIC8vIDQuIFNldCB1cmzigJlzIHBhc3N3b3JkIHRvIHRoZSBlbXB0eSBzdHJpbmcuXG4gIHVybC5wYXNzd29yZCA9ICcnXG5cbiAgLy8gNS4gU2V0IHVybOKAmXMgZnJhZ21lbnQgdG8gbnVsbC5cbiAgdXJsLmhhc2ggPSAnJ1xuXG4gIC8vIDYuIElmIHRoZSBvcmlnaW4tb25seSBmbGFnIGlzIHRydWUsIHRoZW46XG4gIGlmIChvcmlnaW5Pbmx5ID09PSB0cnVlKSB7XG4gICAgLy8gMS4gU2V0IHVybOKAmXMgcGF0aCB0byDCqyB0aGUgZW1wdHkgc3RyaW5nIMK7LlxuICAgIHVybC5wYXRobmFtZSA9ICcnXG5cbiAgICAvLyAyLiBTZXQgdXJs4oCZcyBxdWVyeSB0byBudWxsLlxuICAgIHVybC5zZWFyY2ggPSAnJ1xuICB9XG5cbiAgLy8gNy4gUmV0dXJuIHVybC5cbiAgcmV0dXJuIHVybFxufVxuXG5jb25zdCBwb3RlbnRpYWxsZVRydXN0d29ydGh5SVB2NFJlZ0V4cCA9IG5ldyBSZWdFeHAoJ14oPzonICtcbiAgJyg/OjEyN1xcXFwuKScgK1xuICAnKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcXFwuKXsyfScgK1xuICAnKD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFsxLTldKScgK1xuJykkJylcblxuY29uc3QgcG90ZW50aWFsbGVUcnVzdHdvcnRoeUlQdjZSZWdFeHAgPSBuZXcgUmVnRXhwKCdeKD86JyArXG4gICcoPzooPzowezEsNH0pOil7N30oPzooPzowezAsM30xKSl8JyArXG4gICcoPzooPzowezEsNH0pOil7MSw2fSg/OjooPzowezAsM30xKSl8JyArXG4gICcoPzo6Oig/OjB7MCwzfTEpKXwnICtcbicpJCcpXG5cbi8qKlxuICogQ2hlY2sgaWYgaG9zdCBtYXRjaGVzIG9uZSBvZiB0aGUgQ0lEUiBub3RhdGlvbnMgMTI3LjAuMC4wLzggb3IgOjoxLzEyOC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNPcmlnaW5JUFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkgKG9yaWdpbikge1xuICAvLyBJUHY2XG4gIGlmIChvcmlnaW4uaW5jbHVkZXMoJzonKSkge1xuICAgIC8vIFJlbW92ZSBicmFja2V0cyBmcm9tIElQdjYgYWRkcmVzc2VzXG4gICAgaWYgKG9yaWdpblswXSA9PT0gJ1snICYmIG9yaWdpbltvcmlnaW4ubGVuZ3RoIC0gMV0gPT09ICddJykge1xuICAgICAgb3JpZ2luID0gb3JpZ2luLnNsaWNlKDEsIC0xKVxuICAgIH1cbiAgICByZXR1cm4gcG90ZW50aWFsbGVUcnVzdHdvcnRoeUlQdjZSZWdFeHAudGVzdChvcmlnaW4pXG4gIH1cblxuICAvLyBJUHY0XG4gIHJldHVybiBwb3RlbnRpYWxsZVRydXN0d29ydGh5SVB2NFJlZ0V4cC50ZXN0KG9yaWdpbilcbn1cblxuLyoqXG4gKiBBIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IG9yaWdpbiBpcyBvbmUgd2hpY2ggYSB1c2VyIGFnZW50IGNhbiBnZW5lcmFsbHlcbiAqIHRydXN0IGFzIGRlbGl2ZXJpbmcgZGF0YSBzZWN1cmVseS5cbiAqXG4gKiBSZXR1cm4gdmFsdWUgYHRydWVgIG1lYW5zIGBQb3RlbnRpYWxseSBUcnVzdHdvcnRoeWAuXG4gKiBSZXR1cm4gdmFsdWUgYGZhbHNlYCBtZWFucyBgTm90IFRydXN0d29ydGh5YC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc2VjdXJlLWNvbnRleHRzLyNpcy1vcmlnaW4tdHJ1c3R3b3J0aHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc09yaWdpblBvdGVudGlhbGx5VHJ1c3R3b3J0aHkgKG9yaWdpbikge1xuICAvLyAxLiBJZiBvcmlnaW4gaXMgYW4gb3BhcXVlIG9yaWdpbiwgcmV0dXJuIFwiTm90IFRydXN0d29ydGh5XCIuXG4gIGlmIChvcmlnaW4gPT0gbnVsbCB8fCBvcmlnaW4gPT09ICdudWxsJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gMi4gQXNzZXJ0OiBvcmlnaW4gaXMgYSB0dXBsZSBvcmlnaW4uXG4gIG9yaWdpbiA9IG5ldyBVUkwob3JpZ2luKVxuXG4gIC8vIDMuIElmIG9yaWdpbuKAmXMgc2NoZW1lIGlzIGVpdGhlciBcImh0dHBzXCIgb3IgXCJ3c3NcIixcbiAgLy8gICAgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cbiAgaWYgKG9yaWdpbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgfHwgb3JpZ2luLnByb3RvY29sID09PSAnd3NzOicpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gNC4gSWYgb3JpZ2lu4oCZcyBob3N0IG1hdGNoZXMgb25lIG9mIHRoZSBDSURSIG5vdGF0aW9ucyAxMjcuMC4wLjAvOCBvclxuICAvLyA6OjEvMTI4IFtSRkM0NjMyXSwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cbiAgaWYgKGlzT3JpZ2luSVBQb3RlbnRpYWxseVRydXN0d29ydGh5KG9yaWdpbi5ob3N0bmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gNS4gSWYgdGhlIHVzZXIgYWdlbnQgY29uZm9ybXMgdG8gdGhlIG5hbWUgcmVzb2x1dGlvbiBydWxlcyBpblxuICAvLyAgICBbbGV0LWxvY2FsaG9zdC1iZS1sb2NhbGhvc3RdIGFuZCBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuXG4gIC8vICAgIG9yaWdpbuKAmXMgaG9zdCBpcyBcImxvY2FsaG9zdFwiIG9yIFwibG9jYWxob3N0LlwiXG4gIGlmIChvcmlnaW4uaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnIHx8IG9yaWdpbi5ob3N0bmFtZSA9PT0gJ2xvY2FsaG9zdC4nKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vICAgIG9yaWdpbuKAmXMgaG9zdCBlbmRzIHdpdGggXCIubG9jYWxob3N0XCIgb3IgXCIubG9jYWxob3N0LlwiXG4gIGlmIChvcmlnaW4uaG9zdG5hbWUuZW5kc1dpdGgoJy5sb2NhbGhvc3QnKSB8fCBvcmlnaW4uaG9zdG5hbWUuZW5kc1dpdGgoJy5sb2NhbGhvc3QuJykpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gNi4gSWYgb3JpZ2lu4oCZcyBzY2hlbWUgaXMgXCJmaWxlXCIsIHJldHVybiBcIlBvdGVudGlhbGx5IFRydXN0d29ydGh5XCIuXG4gIGlmIChvcmlnaW4ucHJvdG9jb2wgPT09ICdmaWxlOicpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gNy4gSWYgb3JpZ2lu4oCZcyBzY2hlbWUgY29tcG9uZW50IGlzIG9uZSB3aGljaCB0aGUgdXNlciBhZ2VudCBjb25zaWRlcnMgdG9cbiAgLy8gYmUgYXV0aGVudGljYXRlZCwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblxuICAvLyA4LiBJZiBvcmlnaW4gaGFzIGJlZW4gY29uZmlndXJlZCBhcyBhIHRydXN0d29ydGh5IG9yaWdpbiwgcmV0dXJuXG4gIC8vICAgIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cblxuICAvLyA5LiBSZXR1cm4gXCJOb3QgVHJ1c3R3b3J0aHlcIi5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwgaXMgb25lIHdoaWNoIGVpdGhlciBpbmhlcml0cyBjb250ZXh0IGZyb20gaXRzXG4gKiBjcmVhdG9yIChhYm91dDpibGFuaywgYWJvdXQ6c3JjZG9jLCBkYXRhKSBvciBvbmUgd2hvc2Ugb3JpZ2luIGlzIGFcbiAqIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IG9yaWdpbi5cbiAqXG4gKiBSZXR1cm4gdmFsdWUgYHRydWVgIG1lYW5zIGBQb3RlbnRpYWxseSBUcnVzdHdvcnRoeWAuXG4gKiBSZXR1cm4gdmFsdWUgYGZhbHNlYCBtZWFucyBgTm90IFRydXN0d29ydGh5YC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zZWN1cmUtY29udGV4dHMvI2lzLXVybC10cnVzdHdvcnRoeVxuICogQHBhcmFtIHtVUkx9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeSAodXJsKSB7XG4gIC8vIEdpdmVuIGEgVVJMIHJlY29yZCAodXJsKSwgdGhlIGZvbGxvd2luZyBhbGdvcml0aG0gcmV0dXJucyBcIlBvdGVudGlhbGx5XG4gIC8vIFRydXN0d29ydGh5XCIgb3IgXCJOb3QgVHJ1c3R3b3J0aHlcIiBhcyBhcHByb3ByaWF0ZTpcbiAgaWYgKCF3ZWJpZGwuaXMuVVJMKHVybCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIDEuIElmIHVybCBpcyBcImFib3V0OmJsYW5rXCIgb3IgXCJhYm91dDpzcmNkb2NcIixcbiAgLy8gICAgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cbiAgaWYgKHVybC5ocmVmID09PSAnYWJvdXQ6YmxhbmsnIHx8IHVybC5ocmVmID09PSAnYWJvdXQ6c3JjZG9jJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAyLiBJZiB1cmzigJlzIHNjaGVtZSBpcyBcImRhdGFcIiwgcmV0dXJuIFwiUG90ZW50aWFsbHkgVHJ1c3R3b3J0aHlcIi5cbiAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2RhdGE6JykgcmV0dXJuIHRydWVcblxuICAvLyBOb3RlOiBUaGUgb3JpZ2luIG9mIGJsb2I6IFVSTHMgaXMgdGhlIG9yaWdpbiBvZiB0aGUgY29udGV4dCBpbiB3aGljaCB0aGV5XG4gIC8vIHdlcmUgY3JlYXRlZC4gVGhlcmVmb3JlLCBibG9icyBjcmVhdGVkIGluIGEgdHJ1c3R3b3J0aHkgb3JpZ2luIHdpbGxcbiAgLy8gdGhlbXNlbHZlcyBiZSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeS5cbiAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2Jsb2I6JykgcmV0dXJuIHRydWVcblxuICAvLyAzLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgwqcgMy4xIElzIG9yaWdpbiBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeT9cbiAgLy8gb24gdXJs4oCZcyBvcmlnaW4uXG4gIHJldHVybiBpc09yaWdpblBvdGVudGlhbGx5VHJ1c3R3b3J0aHkodXJsLm9yaWdpbilcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc3VicmVzb3VyY2UtaW50ZWdyaXR5LyNkb2VzLXJlc3BvbnNlLW1hdGNoLW1ldGFkYXRhbGlzdFxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IG1ldGFkYXRhTGlzdFxuICovXG5mdW5jdGlvbiBieXRlc01hdGNoIChieXRlcywgbWV0YWRhdGFMaXN0KSB7XG4gIC8vIElmIG5vZGUgaXMgbm90IGJ1aWx0IHdpdGggT3BlblNTTCBzdXBwb3J0LCB3ZSBjYW5ub3QgY2hlY2tcbiAgLy8gYSByZXF1ZXN0J3MgaW50ZWdyaXR5LCBzbyBhbGxvdyBpdCBieSBkZWZhdWx0ICh0aGUgc3BlYyB3aWxsXG4gIC8vIGFsbG93IHJlcXVlc3RzIGlmIGFuIGludmFsaWQgaGFzaCBpcyBnaXZlbiwgYXMgcHJlY2VkZW5jZSkuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogb25seSBpZiBub2RlIGlzIGJ1aWx0IHdpdGggLS13aXRob3V0LXNzbCAqL1xuICBpZiAoY3J5cHRvID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gMS4gTGV0IHBhcnNlZE1ldGFkYXRhIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyBtZXRhZGF0YUxpc3QuXG4gIGNvbnN0IHBhcnNlZE1ldGFkYXRhID0gcGFyc2VNZXRhZGF0YShtZXRhZGF0YUxpc3QpXG5cbiAgLy8gMi4gSWYgcGFyc2VkTWV0YWRhdGEgaXMgbm8gbWV0YWRhdGEsIHJldHVybiB0cnVlLlxuICBpZiAocGFyc2VkTWV0YWRhdGEgPT09ICdubyBtZXRhZGF0YScpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gMy4gSWYgcmVzcG9uc2UgaXMgbm90IGVsaWdpYmxlIGZvciBpbnRlZ3JpdHkgdmFsaWRhdGlvbiwgcmV0dXJuIGZhbHNlLlxuICAvLyBUT0RPXG5cbiAgLy8gNC4gSWYgcGFyc2VkTWV0YWRhdGEgaXMgdGhlIGVtcHR5IHNldCwgcmV0dXJuIHRydWUuXG4gIGlmIChwYXJzZWRNZXRhZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gNS4gTGV0IG1ldGFkYXRhIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyB0aGUgc3Ryb25nZXN0XG4gIC8vICAgIG1ldGFkYXRhIGZyb20gcGFyc2VkTWV0YWRhdGEuXG4gIGNvbnN0IHN0cm9uZ2VzdCA9IGdldFN0cm9uZ2VzdE1ldGFkYXRhKHBhcnNlZE1ldGFkYXRhKVxuICBjb25zdCBtZXRhZGF0YSA9IGZpbHRlck1ldGFkYXRhTGlzdEJ5QWxnb3JpdGhtKHBhcnNlZE1ldGFkYXRhLCBzdHJvbmdlc3QpXG5cbiAgLy8gNi4gRm9yIGVhY2ggaXRlbSBpbiBtZXRhZGF0YTpcbiAgZm9yIChjb25zdCBpdGVtIG9mIG1ldGFkYXRhKSB7XG4gICAgLy8gMS4gTGV0IGFsZ29yaXRobSBiZSB0aGUgYWxnIGNvbXBvbmVudCBvZiBpdGVtLlxuICAgIGNvbnN0IGFsZ29yaXRobSA9IGl0ZW0uYWxnb1xuXG4gICAgLy8gMi4gTGV0IGV4cGVjdGVkVmFsdWUgYmUgdGhlIHZhbCBjb21wb25lbnQgb2YgaXRlbS5cbiAgICBjb25zdCBleHBlY3RlZFZhbHVlID0gaXRlbS5oYXNoXG5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYi1wbGF0Zm9ybS10ZXN0cy93cHQvY29tbWl0L2U0YzVjYzdhNWU0ODA5MzIyMDUyOGRmZGQxYzQwMTJkYzM4MzdhMGVcbiAgICAvLyBcImJlIGxpYmVyYWwgd2l0aCBwYWRkaW5nXCIuIFRoaXMgaXMgYW5ub3lpbmcsIGFuZCBpdCdzIG5vdCBldmVuIGluIHRoZSBzcGVjLlxuXG4gICAgLy8gMy4gTGV0IGFjdHVhbFZhbHVlIGJlIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYWxnb3JpdGhtIHRvIGJ5dGVzLlxuICAgIGxldCBhY3R1YWxWYWx1ZSA9IGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSkudXBkYXRlKGJ5dGVzKS5kaWdlc3QoJ2Jhc2U2NCcpXG5cbiAgICBpZiAoYWN0dWFsVmFsdWVbYWN0dWFsVmFsdWUubGVuZ3RoIC0gMV0gPT09ICc9Jykge1xuICAgICAgaWYgKGFjdHVhbFZhbHVlW2FjdHVhbFZhbHVlLmxlbmd0aCAtIDJdID09PSAnPScpIHtcbiAgICAgICAgYWN0dWFsVmFsdWUgPSBhY3R1YWxWYWx1ZS5zbGljZSgwLCAtMilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdHVhbFZhbHVlID0gYWN0dWFsVmFsdWUuc2xpY2UoMCwgLTEpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC4gSWYgYWN0dWFsVmFsdWUgaXMgYSBjYXNlLXNlbnNpdGl2ZSBtYXRjaCBmb3IgZXhwZWN0ZWRWYWx1ZSxcbiAgICAvLyAgICByZXR1cm4gdHJ1ZS5cbiAgICBpZiAoY29tcGFyZUJhc2U2NE1peGVkKGFjdHVhbFZhbHVlLCBleHBlY3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICAvLyA3LiBSZXR1cm4gZmFsc2UuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXN1YnJlc291cmNlLWludGVncml0eS8jZ3JhbW1hcmRlZi1oYXNoLXdpdGgtb3B0aW9uc1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0NTUDIvI3NvdXJjZS1saXN0LXN5bnRheFxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzUyMzQjYXBwZW5kaXgtQi4xXG5jb25zdCBwYXJzZUhhc2hXaXRoT3B0aW9ucyA9IC8oPzxhbGdvPnNoYTI1NnxzaGEzODR8c2hhNTEyKS0oKD88aGFzaD5bQS1aYS16MC05Ky9dK3xbQS1aYS16MC05Xy1dKyk9ezAsMn0oPzpcXHN8JCkoICtbIS1+XSopPyk/L2lcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc3VicmVzb3VyY2UtaW50ZWdyaXR5LyNwYXJzZS1tZXRhZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGFkYXRhXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTWV0YWRhdGEgKG1ldGFkYXRhKSB7XG4gIC8vIDEuIExldCByZXN1bHQgYmUgdGhlIGVtcHR5IHNldC5cbiAgLyoqIEB0eXBlIHt7IGFsZ286IHN0cmluZywgaGFzaDogc3RyaW5nIH1bXX0gKi9cbiAgY29uc3QgcmVzdWx0ID0gW11cblxuICAvLyAyLiBMZXQgZW1wdHkgYmUgZXF1YWwgdG8gdHJ1ZS5cbiAgbGV0IGVtcHR5ID0gdHJ1ZVxuXG4gIC8vIDMuIEZvciBlYWNoIHRva2VuIHJldHVybmVkIGJ5IHNwbGl0dGluZyBtZXRhZGF0YSBvbiBzcGFjZXM6XG4gIGZvciAoY29uc3QgdG9rZW4gb2YgbWV0YWRhdGEuc3BsaXQoJyAnKSkge1xuICAgIC8vIDEuIFNldCBlbXB0eSB0byBmYWxzZS5cbiAgICBlbXB0eSA9IGZhbHNlXG5cbiAgICAvLyAyLiBQYXJzZSB0b2tlbiBhcyBhIGhhc2gtd2l0aC1vcHRpb25zLlxuICAgIGNvbnN0IHBhcnNlZFRva2VuID0gcGFyc2VIYXNoV2l0aE9wdGlvbnMuZXhlYyh0b2tlbilcblxuICAgIC8vIDMuIElmIHRva2VuIGRvZXMgbm90IHBhcnNlLCBjb250aW51ZSB0byB0aGUgbmV4dCB0b2tlbi5cbiAgICBpZiAoXG4gICAgICBwYXJzZWRUb2tlbiA9PT0gbnVsbCB8fFxuICAgICAgcGFyc2VkVG9rZW4uZ3JvdXBzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHBhcnNlZFRva2VuLmdyb3Vwcy5hbGdvID09PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIC8vIE5vdGU6IENocm9taXVtIGJsb2NrcyB0aGUgcmVxdWVzdCBhdCB0aGlzIHBvaW50LCBidXQgRmlyZWZveFxuICAgICAgLy8gZ2l2ZXMgYSB3YXJuaW5nIHRoYXQgYW4gaW52YWxpZCBpbnRlZ3JpdHkgd2FzIGdpdmVuLiBUaGVcbiAgICAgIC8vIGNvcnJlY3QgYmVoYXZpb3IgaXMgdG8gaWdub3JlIHRoZXNlLCBhbmQgc3Vic2VxdWVudGx5IG5vdFxuICAgICAgLy8gY2hlY2sgdGhlIGludGVncml0eSBvZiB0aGUgcmVzb3VyY2UuXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vIDQuIExldCBhbGdvcml0aG0gYmUgdGhlIGhhc2gtYWxnbyBjb21wb25lbnQgb2YgdG9rZW4uXG4gICAgY29uc3QgYWxnb3JpdGhtID0gcGFyc2VkVG9rZW4uZ3JvdXBzLmFsZ28udG9Mb3dlckNhc2UoKVxuXG4gICAgLy8gNS4gSWYgYWxnb3JpdGhtIGlzIGEgaGFzaCBmdW5jdGlvbiByZWNvZ25pemVkIGJ5IHRoZSB1c2VyXG4gICAgLy8gICAgYWdlbnQsIGFkZCB0aGUgcGFyc2VkIHRva2VuIHRvIHJlc3VsdC5cbiAgICBpZiAoc3VwcG9ydGVkSGFzaGVzLmluY2x1ZGVzKGFsZ29yaXRobSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHBhcnNlZFRva2VuLmdyb3VwcylcbiAgICB9XG4gIH1cblxuICAvLyA0LiBSZXR1cm4gbm8gbWV0YWRhdGEgaWYgZW1wdHkgaXMgdHJ1ZSwgb3RoZXJ3aXNlIHJldHVybiByZXN1bHQuXG4gIGlmIChlbXB0eSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAnbm8gbWV0YWRhdGEnXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogQHBhcmFtIHt7IGFsZ286ICdzaGEyNTYnIHwgJ3NoYTM4NCcgfCAnc2hhNTEyJyB9W119IG1ldGFkYXRhTGlzdFxuICovXG5mdW5jdGlvbiBnZXRTdHJvbmdlc3RNZXRhZGF0YSAobWV0YWRhdGFMaXN0KSB7XG4gIC8vIExldCBhbGdvcml0aG0gYmUgdGhlIGFsZ28gY29tcG9uZW50IG9mIHRoZSBmaXJzdCBpdGVtIGluIG1ldGFkYXRhTGlzdC5cbiAgLy8gQ2FuIGJlIHNoYTI1NlxuICBsZXQgYWxnb3JpdGhtID0gbWV0YWRhdGFMaXN0WzBdLmFsZ29cbiAgLy8gSWYgdGhlIGFsZ29yaXRobSBpcyBzaGE1MTIsIHRoZW4gaXQgaXMgdGhlIHN0cm9uZ2VzdFxuICAvLyBhbmQgd2UgY2FuIHJldHVybiBpbW1lZGlhdGVseVxuICBpZiAoYWxnb3JpdGhtWzNdID09PSAnNScpIHtcbiAgICByZXR1cm4gYWxnb3JpdGhtXG4gIH1cblxuICBmb3IgKGxldCBpID0gMTsgaSA8IG1ldGFkYXRhTGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gbWV0YWRhdGFMaXN0W2ldXG4gICAgLy8gSWYgdGhlIGFsZ29yaXRobSBpcyBzaGE1MTIsIHRoZW4gaXQgaXMgdGhlIHN0cm9uZ2VzdFxuICAgIC8vIGFuZCB3ZSBjYW4gYnJlYWsgdGhlIGxvb3AgaW1tZWRpYXRlbHlcbiAgICBpZiAobWV0YWRhdGEuYWxnb1szXSA9PT0gJzUnKSB7XG4gICAgICBhbGdvcml0aG0gPSAnc2hhNTEyJ1xuICAgICAgYnJlYWtcbiAgICAvLyBJZiB0aGUgYWxnb3JpdGhtIGlzIHNoYTM4NCwgdGhlbiBhIHBvdGVudGlhbCBzaGEyNTYgb3Igc2hhMzg0IGlzIGlnbm9yZWRcbiAgICB9IGVsc2UgaWYgKGFsZ29yaXRobVszXSA9PT0gJzMnKSB7XG4gICAgICBjb250aW51ZVxuICAgIC8vIGFsZ29yaXRobSBpcyBzaGEyNTYsIGNoZWNrIGlmIGFsZ29yaXRobSBpcyBzaGEzODQgYW5kIGlmIHNvLCBzZXQgaXQgYXNcbiAgICAvLyB0aGUgc3Ryb25nZXN0XG4gICAgfSBlbHNlIGlmIChtZXRhZGF0YS5hbGdvWzNdID09PSAnMycpIHtcbiAgICAgIGFsZ29yaXRobSA9ICdzaGEzODQnXG4gICAgfVxuICB9XG4gIHJldHVybiBhbGdvcml0aG1cbn1cblxuZnVuY3Rpb24gZmlsdGVyTWV0YWRhdGFMaXN0QnlBbGdvcml0aG0gKG1ldGFkYXRhTGlzdCwgYWxnb3JpdGhtKSB7XG4gIGlmIChtZXRhZGF0YUxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG1ldGFkYXRhTGlzdFxuICB9XG5cbiAgbGV0IHBvcyA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRhZGF0YUxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobWV0YWRhdGFMaXN0W2ldLmFsZ28gPT09IGFsZ29yaXRobSkge1xuICAgICAgbWV0YWRhdGFMaXN0W3BvcysrXSA9IG1ldGFkYXRhTGlzdFtpXVxuICAgIH1cbiAgfVxuXG4gIG1ldGFkYXRhTGlzdC5sZW5ndGggPSBwb3NcblxuICByZXR1cm4gbWV0YWRhdGFMaXN0XG59XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIGJhc2U2NCBzdHJpbmdzLCBhbGxvd2luZyBmb3IgYmFzZTY0dXJsXG4gKiBpbiB0aGUgc2Vjb25kIHN0cmluZy5cbiAqXG4qIEBwYXJhbSB7c3RyaW5nfSBhY3R1YWxWYWx1ZSBhbHdheXMgYmFzZTY0XG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRWYWx1ZSBiYXNlNjQgb3IgYmFzZTY0dXJsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJhc2U2NE1peGVkIChhY3R1YWxWYWx1ZSwgZXhwZWN0ZWRWYWx1ZSkge1xuICBpZiAoYWN0dWFsVmFsdWUubGVuZ3RoICE9PSBleHBlY3RlZFZhbHVlLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0dWFsVmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYWN0dWFsVmFsdWVbaV0gIT09IGV4cGVjdGVkVmFsdWVbaV0pIHtcbiAgICAgIGlmIChcbiAgICAgICAgKGFjdHVhbFZhbHVlW2ldID09PSAnKycgJiYgZXhwZWN0ZWRWYWx1ZVtpXSA9PT0gJy0nKSB8fFxuICAgICAgICAoYWN0dWFsVmFsdWVbaV0gPT09ICcvJyAmJiBleHBlY3RlZFZhbHVlW2ldID09PSAnXycpXG4gICAgICApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtdXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cy8jdXBncmFkZS1yZXF1ZXN0XG5mdW5jdGlvbiB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwgKHJlcXVlc3QpIHtcbiAgLy8gVE9ET1xufVxuXG4vKipcbiAqIEBsaW5rIHtodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9vcmlnaW4uaHRtbCNzYW1lLW9yaWdpbn1cbiAqIEBwYXJhbSB7VVJMfSBBXG4gKiBAcGFyYW0ge1VSTH0gQlxuICovXG5mdW5jdGlvbiBzYW1lT3JpZ2luIChBLCBCKSB7XG4gIC8vIDEuIElmIEEgYW5kIEIgYXJlIHRoZSBzYW1lIG9wYXF1ZSBvcmlnaW4sIHRoZW4gcmV0dXJuIHRydWUuXG4gIGlmIChBLm9yaWdpbiA9PT0gQi5vcmlnaW4gJiYgQS5vcmlnaW4gPT09ICdudWxsJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAyLiBJZiBBIGFuZCBCIGFyZSBib3RoIHR1cGxlIG9yaWdpbnMgYW5kIHRoZWlyIHNjaGVtZXMsXG4gIC8vICAgIGhvc3RzLCBhbmQgcG9ydCBhcmUgaWRlbnRpY2FsLCB0aGVuIHJldHVybiB0cnVlLlxuICBpZiAoQS5wcm90b2NvbCA9PT0gQi5wcm90b2NvbCAmJiBBLmhvc3RuYW1lID09PSBCLmhvc3RuYW1lICYmIEEucG9ydCA9PT0gQi5wb3J0KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIDMuIFJldHVybiBmYWxzZS5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkUHJvbWlzZSAoKSB7XG4gIGxldCByZXNcbiAgbGV0IHJlalxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlcyA9IHJlc29sdmVcbiAgICByZWogPSByZWplY3RcbiAgfSlcblxuICByZXR1cm4geyBwcm9taXNlLCByZXNvbHZlOiByZXMsIHJlamVjdDogcmVqIH1cbn1cblxuZnVuY3Rpb24gaXNBYm9ydGVkIChmZXRjaFBhcmFtcykge1xuICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gJ2Fib3J0ZWQnXG59XG5cbmZ1bmN0aW9uIGlzQ2FuY2VsbGVkIChmZXRjaFBhcmFtcykge1xuICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gJ2Fib3J0ZWQnIHx8XG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gJ3Rlcm1pbmF0ZWQnXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tZXRob2Qtbm9ybWFsaXplXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZCAobWV0aG9kKSB7XG4gIHJldHVybiBub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2VbbWV0aG9kLnRvTG93ZXJDYXNlKCldID8/IG1ldGhvZFxufVxuXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc2VyaWFsaXplLWEtamF2YXNjcmlwdC12YWx1ZS10by1hLWpzb24tc3RyaW5nXG5mdW5jdGlvbiBzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmcgKHZhbHVlKSB7XG4gIC8vIDEuIExldCByZXN1bHQgYmUgPyBDYWxsKCVKU09OLnN0cmluZ2lmeSUsIHVuZGVmaW5lZCwgwqsgdmFsdWUgwrspLlxuICBjb25zdCByZXN1bHQgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcblxuICAvLyAyLiBJZiByZXN1bHQgaXMgdW5kZWZpbmVkLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBpcyBub3QgSlNPTiBzZXJpYWxpemFibGUnKVxuICB9XG5cbiAgLy8gMy4gQXNzZXJ0OiByZXN1bHQgaXMgYSBzdHJpbmcuXG4gIGFzc2VydCh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJylcblxuICAvLyA0LiBSZXR1cm4gcmVzdWx0LlxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJTI1aXRlcmF0b3Jwcm90b3R5cGUlMjUtb2JqZWN0XG5jb25zdCBlc0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZihbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNkZm4taXRlcmF0b3ItcHJvdG90eXBlLW9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgaW5zdGFuY2VcbiAqIEBwYXJhbSB7KCh0YXJnZXQ6IGFueSkgPT4gYW55KX0ga0ludGVybmFsSXRlcmF0b3JcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBba2V5SW5kZXhdXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gW3ZhbHVlSW5kZXhdXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9yIChuYW1lLCBrSW50ZXJuYWxJdGVyYXRvciwga2V5SW5kZXggPSAwLCB2YWx1ZUluZGV4ID0gMSkge1xuICBjbGFzcyBGYXN0SXRlcmFibGVJdGVyYXRvciB7XG4gICAgLyoqIEB0eXBlIHthbnl9ICovXG4gICAgI3RhcmdldFxuICAgIC8qKiBAdHlwZSB7J2tleScgfCAndmFsdWUnIHwgJ2tleSt2YWx1ZSd9ICovXG4gICAgI2tpbmRcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAjaW5kZXhcblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNkZm4tZGVmYXVsdC1pdGVyYXRvci1vYmplY3RcbiAgICAgKiBAcGFyYW0ge3Vua25vd259IHRhcmdldFxuICAgICAqIEBwYXJhbSB7J2tleScgfCAndmFsdWUnIHwgJ2tleSt2YWx1ZSd9IGtpbmRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciAodGFyZ2V0LCBraW5kKSB7XG4gICAgICB0aGlzLiN0YXJnZXQgPSB0YXJnZXRcbiAgICAgIHRoaXMuI2tpbmQgPSBraW5kXG4gICAgICB0aGlzLiNpbmRleCA9IDBcbiAgICB9XG5cbiAgICBuZXh0ICgpIHtcbiAgICAgIC8vIDEuIExldCBpbnRlcmZhY2UgYmUgdGhlIGludGVyZmFjZSBmb3Igd2hpY2ggdGhlIGl0ZXJhdG9yIHByb3RvdHlwZSBvYmplY3QgZXhpc3RzLlxuICAgICAgLy8gMi4gTGV0IHRoaXNWYWx1ZSBiZSB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgIC8vIDMuIExldCBvYmplY3QgYmUgPyBUb09iamVjdCh0aGlzVmFsdWUpLlxuICAgICAgLy8gNC4gSWYgb2JqZWN0IGlzIGEgcGxhdGZvcm0gb2JqZWN0LCB0aGVuIHBlcmZvcm0gYSBzZWN1cml0eVxuICAgICAgLy8gICAgY2hlY2ssIHBhc3Npbmc6XG4gICAgICAvLyA1LiBJZiBvYmplY3QgaXMgbm90IGEgZGVmYXVsdCBpdGVyYXRvciBvYmplY3QgZm9yIGludGVyZmFjZSxcbiAgICAgIC8vICAgIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdvYmplY3QnIHx8IHRoaXMgPT09IG51bGwgfHwgISgjdGFyZ2V0IGluIHRoaXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgYCduZXh0JyBjYWxsZWQgb24gYW4gb2JqZWN0IHRoYXQgZG9lcyBub3QgaW1wbGVtZW50IGludGVyZmFjZSAke25hbWV9IEl0ZXJhdG9yLmBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyA2LiBMZXQgaW5kZXggYmUgb2JqZWN04oCZcyBpbmRleC5cbiAgICAgIC8vIDcuIExldCBraW5kIGJlIG9iamVjdOKAmXMga2luZC5cbiAgICAgIC8vIDguIExldCB2YWx1ZXMgYmUgb2JqZWN04oCZcyB0YXJnZXQncyB2YWx1ZSBwYWlycyB0byBpdGVyYXRlIG92ZXIuXG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuI2luZGV4XG4gICAgICBjb25zdCB2YWx1ZXMgPSBrSW50ZXJuYWxJdGVyYXRvcih0aGlzLiN0YXJnZXQpXG5cbiAgICAgIC8vIDkuIExldCBsZW4gYmUgdGhlIGxlbmd0aCBvZiB2YWx1ZXMuXG4gICAgICBjb25zdCBsZW4gPSB2YWx1ZXMubGVuZ3RoXG5cbiAgICAgIC8vIDEwLiBJZiBpbmRleCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gbGVuLCB0aGVuIHJldHVyblxuICAgICAgLy8gICAgIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKS5cbiAgICAgIGlmIChpbmRleCA+PSBsZW4pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAxMS4gTGV0IHBhaXIgYmUgdGhlIGVudHJ5IGluIHZhbHVlcyBhdCBpbmRleCBpbmRleC5cbiAgICAgIGNvbnN0IHsgW2tleUluZGV4XToga2V5LCBbdmFsdWVJbmRleF06IHZhbHVlIH0gPSB2YWx1ZXNbaW5kZXhdXG5cbiAgICAgIC8vIDEyLiBTZXQgb2JqZWN04oCZcyBpbmRleCB0byBpbmRleCArIDEuXG4gICAgICB0aGlzLiNpbmRleCA9IGluZGV4ICsgMVxuXG4gICAgICAvLyAxMy4gUmV0dXJuIHRoZSBpdGVyYXRvciByZXN1bHQgZm9yIHBhaXIgYW5kIGtpbmQuXG5cbiAgICAgIC8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jaXRlcmF0b3ItcmVzdWx0XG5cbiAgICAgIC8vIDEuIExldCByZXN1bHQgYmUgYSB2YWx1ZSBkZXRlcm1pbmVkIGJ5IHRoZSB2YWx1ZSBvZiBraW5kOlxuICAgICAgbGV0IHJlc3VsdFxuICAgICAgc3dpdGNoICh0aGlzLiNraW5kKSB7XG4gICAgICAgIGNhc2UgJ2tleSc6XG4gICAgICAgICAgLy8gMS4gTGV0IGlkbEtleSBiZSBwYWly4oCZcyBrZXkuXG4gICAgICAgICAgLy8gMi4gTGV0IGtleSBiZSB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmcgaWRsS2V5IHRvIGFuXG4gICAgICAgICAgLy8gICAgRUNNQVNjcmlwdCB2YWx1ZS5cbiAgICAgICAgICAvLyAzLiByZXN1bHQgaXMga2V5LlxuICAgICAgICAgIHJlc3VsdCA9IGtleVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAvLyAxLiBMZXQgaWRsVmFsdWUgYmUgcGFpcuKAmXMgdmFsdWUuXG4gICAgICAgICAgLy8gMi4gTGV0IHZhbHVlIGJlIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBpZGxWYWx1ZSB0b1xuICAgICAgICAgIC8vICAgIGFuIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAgICAgLy8gMy4gcmVzdWx0IGlzIHZhbHVlLlxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAna2V5K3ZhbHVlJzpcbiAgICAgICAgICAvLyAxLiBMZXQgaWRsS2V5IGJlIHBhaXLigJlzIGtleS5cbiAgICAgICAgICAvLyAyLiBMZXQgaWRsVmFsdWUgYmUgcGFpcuKAmXMgdmFsdWUuXG4gICAgICAgICAgLy8gMy4gTGV0IGtleSBiZSB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmcgaWRsS2V5IHRvIGFuXG4gICAgICAgICAgLy8gICAgRUNNQVNjcmlwdCB2YWx1ZS5cbiAgICAgICAgICAvLyA0LiBMZXQgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbFZhbHVlIHRvXG4gICAgICAgICAgLy8gICAgYW4gRUNNQVNjcmlwdCB2YWx1ZS5cbiAgICAgICAgICAvLyA1LiBMZXQgYXJyYXkgYmUgISBBcnJheUNyZWF0ZSgyKS5cbiAgICAgICAgICAvLyA2LiBDYWxsICEgQ3JlYXRlRGF0YVByb3BlcnR5KGFycmF5LCBcIjBcIiwga2V5KS5cbiAgICAgICAgICAvLyA3LiBDYWxsICEgQ3JlYXRlRGF0YVByb3BlcnR5KGFycmF5LCBcIjFcIiwgdmFsdWUpLlxuICAgICAgICAgIC8vIDguIHJlc3VsdCBpcyBhcnJheS5cbiAgICAgICAgICByZXN1bHQgPSBba2V5LCB2YWx1ZV1cbiAgICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICAvLyAyLiBSZXR1cm4gQ3JlYXRlSXRlclJlc3VsdE9iamVjdChyZXN1bHQsIGZhbHNlKS5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiByZXN1bHQsXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNkZm4taXRlcmF0b3ItcHJvdG90eXBlLW9iamVjdFxuICAvLyBAdHMtaWdub3JlXG4gIGRlbGV0ZSBGYXN0SXRlcmFibGVJdGVyYXRvci5wcm90b3R5cGUuY29uc3RydWN0b3JcblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoRmFzdEl0ZXJhYmxlSXRlcmF0b3IucHJvdG90eXBlLCBlc0l0ZXJhdG9yUHJvdG90eXBlKVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZhc3RJdGVyYWJsZUl0ZXJhdG9yLnByb3RvdHlwZSwge1xuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBgJHtuYW1lfSBJdGVyYXRvcmBcbiAgICB9LFxuICAgIG5leHQ6IHsgd3JpdGFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9XG4gIH0pXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7J2tleScgfCAndmFsdWUnIHwgJ2tleSt2YWx1ZSd9IGtpbmRcbiAgICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3I8YW55Pn1cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBraW5kKSB7XG4gICAgcmV0dXJuIG5ldyBGYXN0SXRlcmFibGVJdGVyYXRvcih0YXJnZXQsIGtpbmQpXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZGZuLWl0ZXJhdG9yLXByb3RvdHlwZS1vYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGluc3RhbmNlXG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0IGNsYXNzXG4gKiBAcGFyYW0geyh0YXJnZXQ6IGFueSkgPT4gYW55fSBrSW50ZXJuYWxJdGVyYXRvclxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IFtrZXlJbmRleF1cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBbdmFsdWVJbmRleF1cbiAqL1xuZnVuY3Rpb24gaXRlcmF0b3JNaXhpbiAobmFtZSwgb2JqZWN0LCBrSW50ZXJuYWxJdGVyYXRvciwga2V5SW5kZXggPSAwLCB2YWx1ZUluZGV4ID0gMSkge1xuICBjb25zdCBtYWtlSXRlcmF0b3IgPSBjcmVhdGVJdGVyYXRvcihuYW1lLCBrSW50ZXJuYWxJdGVyYXRvciwga2V5SW5kZXgsIHZhbHVlSW5kZXgpXG5cbiAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICBrZXlzOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24ga2V5cyAoKSB7XG4gICAgICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIG9iamVjdClcbiAgICAgICAgcmV0dXJuIG1ha2VJdGVyYXRvcih0aGlzLCAna2V5JylcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbHVlczoge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlcyAoKSB7XG4gICAgICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIG9iamVjdClcbiAgICAgICAgcmV0dXJuIG1ha2VJdGVyYXRvcih0aGlzLCAndmFsdWUnKVxuICAgICAgfVxuICAgIH0sXG4gICAgZW50cmllczoge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVudHJpZXMgKCkge1xuICAgICAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBvYmplY3QpXG4gICAgICAgIHJldHVybiBtYWtlSXRlcmF0b3IodGhpcywgJ2tleSt2YWx1ZScpXG4gICAgICB9XG4gICAgfSxcbiAgICBmb3JFYWNoOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaCAoY2FsbGJhY2tmbiwgdGhpc0FyZyA9IGdsb2JhbFRoaXMpIHtcbiAgICAgICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgb2JqZWN0KVxuICAgICAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIGAke25hbWV9LmZvckVhY2hgKVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBleGVjdXRlICdmb3JFYWNoJyBvbiAnJHtuYW1lfSc6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdGdW5jdGlvbicuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHsgMDoga2V5LCAxOiB2YWx1ZSB9IG9mIG1ha2VJdGVyYXRvcih0aGlzLCAna2V5K3ZhbHVlJykpIHtcbiAgICAgICAgICBjYWxsYmFja2ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIGtleSwgdGhpcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmplY3QucHJvdG90eXBlLCB7XG4gICAgLi4ucHJvcGVydGllcyxcbiAgICBbU3ltYm9sLml0ZXJhdG9yXToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmVudHJpZXMudmFsdWVcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keS1mdWxseS1yZWFkXG4gKi9cbmZ1bmN0aW9uIGZ1bGx5UmVhZEJvZHkgKGJvZHksIHByb2Nlc3NCb2R5LCBwcm9jZXNzQm9keUVycm9yKSB7XG4gIC8vIDEuIElmIHRhc2tEZXN0aW5hdGlvbiBpcyBudWxsLCB0aGVuIHNldCB0YXNrRGVzdGluYXRpb24gdG9cbiAgLy8gICAgdGhlIHJlc3VsdCBvZiBzdGFydGluZyBhIG5ldyBwYXJhbGxlbCBxdWV1ZS5cblxuICAvLyAyLiBMZXQgc3VjY2Vzc1N0ZXBzIGdpdmVuIGEgYnl0ZSBzZXF1ZW5jZSBieXRlcyBiZSB0byBxdWV1ZSBhXG4gIC8vICAgIGZldGNoIHRhc2sgdG8gcnVuIHByb2Nlc3NCb2R5IGdpdmVuIGJ5dGVzLCB3aXRoIHRhc2tEZXN0aW5hdGlvbi5cbiAgY29uc3Qgc3VjY2Vzc1N0ZXBzID0gcHJvY2Vzc0JvZHlcblxuICAvLyAzLiBMZXQgZXJyb3JTdGVwcyBiZSB0byBxdWV1ZSBhIGZldGNoIHRhc2sgdG8gcnVuIHByb2Nlc3NCb2R5RXJyb3IsXG4gIC8vICAgIHdpdGggdGFza0Rlc3RpbmF0aW9uLlxuICBjb25zdCBlcnJvclN0ZXBzID0gcHJvY2Vzc0JvZHlFcnJvclxuXG4gIC8vIDQuIExldCByZWFkZXIgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIGEgcmVhZGVyIGZvciBib2R54oCZcyBzdHJlYW0uXG4gIC8vICAgIElmIHRoYXQgdGhyZXcgYW4gZXhjZXB0aW9uLCB0aGVuIHJ1biBlcnJvclN0ZXBzIHdpdGggdGhhdFxuICAvLyAgICBleGNlcHRpb24gYW5kIHJldHVybi5cbiAgbGV0IHJlYWRlclxuXG4gIHRyeSB7XG4gICAgcmVhZGVyID0gYm9keS5zdHJlYW0uZ2V0UmVhZGVyKClcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yU3RlcHMoZSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDUuIFJlYWQgYWxsIGJ5dGVzIGZyb20gcmVhZGVyLCBnaXZlbiBzdWNjZXNzU3RlcHMgYW5kIGVycm9yU3RlcHMuXG4gIHJlYWRBbGxCeXRlcyhyZWFkZXIsIHN1Y2Nlc3NTdGVwcywgZXJyb3JTdGVwcylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjxVaW50OEFycmF5Pn0gY29udHJvbGxlclxuICovXG5mdW5jdGlvbiByZWFkYWJsZVN0cmVhbUNsb3NlIChjb250cm9sbGVyKSB7XG4gIHRyeSB7XG4gICAgY29udHJvbGxlci5jbG9zZSgpXG4gICAgY29udHJvbGxlci5ieW9iUmVxdWVzdD8ucmVzcG9uZCgwKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBUT0RPOiBhZGQgY29tbWVudCBleHBsYWluaW5nIHdoeSB0aGlzIGVycm9yIG9jY3Vycy5cbiAgICBpZiAoIWVyci5tZXNzYWdlLmluY2x1ZGVzKCdDb250cm9sbGVyIGlzIGFscmVhZHkgY2xvc2VkJykgJiYgIWVyci5tZXNzYWdlLmluY2x1ZGVzKCdSZWFkYWJsZVN0cmVhbSBpcyBhbHJlYWR5IGNsb3NlZCcpKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaW52YWxpZElzb21vcnBoaWNFbmNvZGVWYWx1ZVJlZ2V4ID0gL1teXFx4MDAtXFx4RkZdLyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jaXNvbW9ycGhpYy1lbmNvZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICovXG5mdW5jdGlvbiBpc29tb3JwaGljRW5jb2RlIChpbnB1dCkge1xuICAvLyAxLiBBc3NlcnQ6IGlucHV0IGNvbnRhaW5zIG5vIGNvZGUgcG9pbnRzIGdyZWF0ZXIgdGhhbiBVKzAwRkYuXG4gIGFzc2VydCghaW52YWxpZElzb21vcnBoaWNFbmNvZGVWYWx1ZVJlZ2V4LnRlc3QoaW5wdXQpKVxuXG4gIC8vIDIuIFJldHVybiBhIGJ5dGUgc2VxdWVuY2Ugd2hvc2UgbGVuZ3RoIGlzIGVxdWFsIHRvIGlucHV04oCZcyBjb2RlXG4gIC8vICAgIHBvaW50IGxlbmd0aCBhbmQgd2hvc2UgYnl0ZXMgaGF2ZSB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gIC8vICAgIHZhbHVlcyBvZiBpbnB1dOKAmXMgY29kZSBwb2ludHMsIGluIHRoZSBzYW1lIG9yZGVyXG4gIHJldHVybiBpbnB1dFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZGFibGVzdHJlYW1kZWZhdWx0cmVhZGVyLXJlYWQtYWxsLWJ5dGVzXG4gKiBAc2VlIGh0dHBzOi8vc3RyZWFtcy5zcGVjLndoYXR3Zy5vcmcvI3JlYWQtbG9vcFxuICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJ9IHJlYWRlclxuICogQHBhcmFtIHsoYnl0ZXM6IFVpbnQ4QXJyYXkpID0+IHZvaWR9IHN1Y2Nlc3NTdGVwc1xuICogQHBhcmFtIHsoZXJyb3I6IEVycm9yKSA9PiB2b2lkfSBmYWlsdXJlU3RlcHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVhZEFsbEJ5dGVzIChyZWFkZXIsIHN1Y2Nlc3NTdGVwcywgZmFpbHVyZVN0ZXBzKSB7XG4gIGNvbnN0IGJ5dGVzID0gW11cbiAgbGV0IGJ5dGVMZW5ndGggPSAwXG5cbiAgdHJ5IHtcbiAgICBkbyB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlOiBjaHVuayB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxuXG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICAvLyAxLiBDYWxsIHN1Y2Nlc3NTdGVwcyB3aXRoIGJ5dGVzLlxuICAgICAgICBzdWNjZXNzU3RlcHMoQnVmZmVyLmNvbmNhdChieXRlcywgYnl0ZUxlbmd0aCkpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAxLiBJZiBjaHVuayBpcyBub3QgYSBVaW50OEFycmF5IG9iamVjdCwgY2FsbCBmYWlsdXJlU3RlcHNcbiAgICAgIC8vICAgIHdpdGggYSBUeXBlRXJyb3IgYW5kIGFib3J0IHRoZXNlIHN0ZXBzLlxuICAgICAgaWYgKCFpc1VpbnQ4QXJyYXkoY2h1bmspKSB7XG4gICAgICAgIGZhaWx1cmVTdGVwcyhuZXcgVHlwZUVycm9yKCdSZWNlaXZlZCBub24tVWludDhBcnJheSBjaHVuaycpKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMi4gQXBwZW5kIHRoZSBieXRlcyByZXByZXNlbnRlZCBieSBjaHVuayB0byBieXRlcy5cbiAgICAgIGJ5dGVzLnB1c2goY2h1bmspXG4gICAgICBieXRlTGVuZ3RoICs9IGNodW5rLmxlbmd0aFxuXG4gICAgLy8gMy4gUmVhZC1sb29wIGdpdmVuIHJlYWRlciwgYnl0ZXMsIHN1Y2Nlc3NTdGVwcywgYW5kIGZhaWx1cmVTdGVwcy5cbiAgICB9IHdoaWxlICh0cnVlKVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gMS4gQ2FsbCBmYWlsdXJlU3RlcHMgd2l0aCBlLlxuICAgIGZhaWx1cmVTdGVwcyhlKVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaXMtbG9jYWxcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB1cmxJc0xvY2FsICh1cmwpIHtcbiAgYXNzZXJ0KCdwcm90b2NvbCcgaW4gdXJsKSAvLyBlbnN1cmUgaXQncyBhIHVybCBvYmplY3RcblxuICBjb25zdCBwcm90b2NvbCA9IHVybC5wcm90b2NvbFxuXG4gIC8vIEEgVVJMIGlzIGxvY2FsIGlmIGl0cyBzY2hlbWUgaXMgYSBsb2NhbCBzY2hlbWUuXG4gIC8vIEEgbG9jYWwgc2NoZW1lIGlzIFwiYWJvdXRcIiwgXCJibG9iXCIsIG9yIFwiZGF0YVwiLlxuICByZXR1cm4gcHJvdG9jb2wgPT09ICdhYm91dDonIHx8IHByb3RvY29sID09PSAnYmxvYjonIHx8IHByb3RvY29sID09PSAnZGF0YTonXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB1cmxIYXNIdHRwc1NjaGVtZSAodXJsKSB7XG4gIHJldHVybiAoXG4gICAgKFxuICAgICAgdHlwZW9mIHVybCA9PT0gJ3N0cmluZycgJiZcbiAgICAgIHVybFs1XSA9PT0gJzonICYmXG4gICAgICB1cmxbMF0gPT09ICdoJyAmJlxuICAgICAgdXJsWzFdID09PSAndCcgJiZcbiAgICAgIHVybFsyXSA9PT0gJ3QnICYmXG4gICAgICB1cmxbM10gPT09ICdwJyAmJlxuICAgICAgdXJsWzRdID09PSAncydcbiAgICApIHx8XG4gICAgdXJsLnByb3RvY29sID09PSAnaHR0cHM6J1xuICApXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1zY2hlbWVcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqL1xuZnVuY3Rpb24gdXJsSXNIdHRwSHR0cHNTY2hlbWUgKHVybCkge1xuICBhc3NlcnQoJ3Byb3RvY29sJyBpbiB1cmwpIC8vIGVuc3VyZSBpdCdzIGEgdXJsIG9iamVjdFxuXG4gIGNvbnN0IHByb3RvY29sID0gdXJsLnByb3RvY29sXG5cbiAgcmV0dXJuIHByb3RvY29sID09PSAnaHR0cDonIHx8IHByb3RvY29sID09PSAnaHR0cHM6J1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3NpbXBsZS1yYW5nZS1oZWFkZXItdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBhbGxvd1doaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gc2ltcGxlUmFuZ2VIZWFkZXJWYWx1ZSAodmFsdWUsIGFsbG93V2hpdGVzcGFjZSkge1xuICAvLyAxLiBMZXQgZGF0YSBiZSB0aGUgaXNvbW9ycGhpYyBkZWNvZGluZyBvZiB2YWx1ZS5cbiAgLy8gTm90ZTogaXNvbW9ycGhpYyBkZWNvZGluZyB0YWtlcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIChpZS4gYSBVaW50OEFycmF5KSBhbmQgdHVybnMgaXQgaW50byBhIHN0cmluZyxcbiAgLy8gbm90aGluZyBtb3JlLiBXZSBvYnZpb3VzbHkgZG9uJ3QgbmVlZCB0byBkbyB0aGF0IGlmIHZhbHVlIGlzIGEgc3RyaW5nIGFscmVhZHkuXG4gIGNvbnN0IGRhdGEgPSB2YWx1ZVxuXG4gIC8vIDIuIElmIGRhdGEgZG9lcyBub3Qgc3RhcnQgd2l0aCBcImJ5dGVzXCIsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmICghZGF0YS5zdGFydHNXaXRoKCdieXRlcycpKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gMy4gTGV0IHBvc2l0aW9uIGJlIGEgcG9zaXRpb24gdmFyaWFibGUgZm9yIGRhdGEsIGluaXRpYWxseSBwb2ludGluZyBhdCB0aGUgNXRoIGNvZGUgcG9pbnQgb2YgZGF0YS5cbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiA1IH1cblxuICAvLyA0LiBJZiBhbGxvd1doaXRlc3BhY2UgaXMgdHJ1ZSwgY29sbGVjdCBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIEhUVFAgdGFiIG9yIHNwYWNlLFxuICAvLyAgICBmcm9tIGRhdGEgZ2l2ZW4gcG9zaXRpb24uXG4gIGlmIChhbGxvd1doaXRlc3BhY2UpIHtcbiAgICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgPT09ICdcXHQnIHx8IGNoYXIgPT09ICcgJyxcbiAgICAgIGRhdGEsXG4gICAgICBwb3NpdGlvblxuICAgIClcbiAgfVxuXG4gIC8vIDUuIElmIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBkYXRhIGlzIG5vdCBVKzAwM0QgKD0pLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAoZGF0YS5jaGFyQ29kZUF0KHBvc2l0aW9uLnBvc2l0aW9uKSAhPT0gMHgzRCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDYuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gIC8vIDcuIElmIGFsbG93V2hpdGVzcGFjZSBpcyB0cnVlLCBjb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgSFRUUCB0YWIgb3Igc3BhY2UsIGZyb21cbiAgLy8gICAgZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgaWYgKGFsbG93V2hpdGVzcGFjZSkge1xuICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciA9PT0gJ1xcdCcgfHwgY2hhciA9PT0gJyAnLFxuICAgICAgZGF0YSxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICB9XG5cbiAgLy8gOC4gTGV0IHJhbmdlU3RhcnQgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgQVNDSUkgZGlnaXRzLFxuICAvLyAgICBmcm9tIGRhdGEgZ2l2ZW4gcG9zaXRpb24uXG4gIGNvbnN0IHJhbmdlU3RhcnQgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgIChjaGFyKSA9PiB7XG4gICAgICBjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApXG5cbiAgICAgIHJldHVybiBjb2RlID49IDB4MzAgJiYgY29kZSA8PSAweDM5XG4gICAgfSxcbiAgICBkYXRhLFxuICAgIHBvc2l0aW9uXG4gIClcblxuICAvLyA5LiBMZXQgcmFuZ2VTdGFydFZhbHVlIGJlIHJhbmdlU3RhcnQsIGludGVycHJldGVkIGFzIGRlY2ltYWwgbnVtYmVyLCBpZiByYW5nZVN0YXJ0IGlzIG5vdCB0aGVcbiAgLy8gICAgZW1wdHkgc3RyaW5nOyBvdGhlcndpc2UgbnVsbC5cbiAgY29uc3QgcmFuZ2VTdGFydFZhbHVlID0gcmFuZ2VTdGFydC5sZW5ndGggPyBOdW1iZXIocmFuZ2VTdGFydCkgOiBudWxsXG5cbiAgLy8gMTAuIElmIGFsbG93V2hpdGVzcGFjZSBpcyB0cnVlLCBjb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgSFRUUCB0YWIgb3Igc3BhY2UsXG4gIC8vICAgICBmcm9tIGRhdGEgZ2l2ZW4gcG9zaXRpb24uXG4gIGlmIChhbGxvd1doaXRlc3BhY2UpIHtcbiAgICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgPT09ICdcXHQnIHx8IGNoYXIgPT09ICcgJyxcbiAgICAgIGRhdGEsXG4gICAgICBwb3NpdGlvblxuICAgIClcbiAgfVxuXG4gIC8vIDExLiBJZiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gZGF0YSBpcyBub3QgVSswMDJEICgtKSwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKGRhdGEuY2hhckNvZGVBdChwb3NpdGlvbi5wb3NpdGlvbikgIT09IDB4MkQpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyAxMi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgLy8gMTMuIElmIGFsbG93V2hpdGVzcGFjZSBpcyB0cnVlLCBjb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgSFRUUCB0YWJcbiAgLy8gICAgIG9yIHNwYWNlLCBmcm9tIGRhdGEgZ2l2ZW4gcG9zaXRpb24uXG4gIC8vIE5vdGUgZnJvbSBLaGFmcmE6IGl0cyB0aGUgc2FtZSBzdGVwIGFzIGluICM4IGFnYWluIGxvbFxuICBpZiAoYWxsb3dXaGl0ZXNwYWNlKSB7XG4gICAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIChjaGFyKSA9PiBjaGFyID09PSAnXFx0JyB8fCBjaGFyID09PSAnICcsXG4gICAgICBkYXRhLFxuICAgICAgcG9zaXRpb25cbiAgICApXG4gIH1cblxuICAvLyAxNC4gTGV0IHJhbmdlRW5kIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlXG4gIC8vICAgICBBU0NJSSBkaWdpdHMsIGZyb20gZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgLy8gTm90ZSBmcm9tIEtoYWZyYTogeW91IHdvdWxkbid0IGd1ZXNzIGl0LCBidXQgdGhpcyBpcyBhbHNvIHRoZSBzYW1lIHN0ZXAgYXMgIzhcbiAgY29uc3QgcmFuZ2VFbmQgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgIChjaGFyKSA9PiB7XG4gICAgICBjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApXG5cbiAgICAgIHJldHVybiBjb2RlID49IDB4MzAgJiYgY29kZSA8PSAweDM5XG4gICAgfSxcbiAgICBkYXRhLFxuICAgIHBvc2l0aW9uXG4gIClcblxuICAvLyAxNS4gTGV0IHJhbmdlRW5kVmFsdWUgYmUgcmFuZ2VFbmQsIGludGVycHJldGVkIGFzIGRlY2ltYWwgbnVtYmVyLCBpZiByYW5nZUVuZFxuICAvLyAgICAgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmc7IG90aGVyd2lzZSBudWxsLlxuICAvLyBOb3RlIGZyb20gS2hhZnJhOiBUSEUgU0FNRSBTVEVQLCBBR0FJTiEhIVxuICAvLyBOb3RlOiB3aHkgaW50ZXJwcmV0IGFzIGEgZGVjaW1hbCBpZiB3ZSBvbmx5IGNvbGxlY3QgYXNjaWkgZGlnaXRzP1xuICBjb25zdCByYW5nZUVuZFZhbHVlID0gcmFuZ2VFbmQubGVuZ3RoID8gTnVtYmVyKHJhbmdlRW5kKSA6IG51bGxcblxuICAvLyAxNi4gSWYgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBkYXRhLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAocG9zaXRpb24ucG9zaXRpb24gPCBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDE3LiBJZiByYW5nZUVuZFZhbHVlIGFuZCByYW5nZVN0YXJ0VmFsdWUgYXJlIG51bGwsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChyYW5nZUVuZFZhbHVlID09PSBudWxsICYmIHJhbmdlU3RhcnRWYWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDE4LiBJZiByYW5nZVN0YXJ0VmFsdWUgYW5kIHJhbmdlRW5kVmFsdWUgYXJlIG51bWJlcnMsIGFuZCByYW5nZVN0YXJ0VmFsdWUgaXNcbiAgLy8gICAgIGdyZWF0ZXIgdGhhbiByYW5nZUVuZFZhbHVlLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICAvLyBOb3RlOiAuLi4gd2hlbiBjYW4gdGhleSBub3QgYmUgbnVtYmVycz9cbiAgaWYgKHJhbmdlU3RhcnRWYWx1ZSA+IHJhbmdlRW5kVmFsdWUpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyAxOS4gUmV0dXJuIChyYW5nZVN0YXJ0VmFsdWUsIHJhbmdlRW5kVmFsdWUpLlxuICByZXR1cm4geyByYW5nZVN0YXJ0VmFsdWUsIHJhbmdlRW5kVmFsdWUgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2J1aWxkLWEtY29udGVudC1yYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlU3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSByYW5nZUVuZFxuICogQHBhcmFtIHtudW1iZXJ9IGZ1bGxMZW5ndGhcbiAqL1xuZnVuY3Rpb24gYnVpbGRDb250ZW50UmFuZ2UgKHJhbmdlU3RhcnQsIHJhbmdlRW5kLCBmdWxsTGVuZ3RoKSB7XG4gIC8vIDEuIExldCBjb250ZW50UmFuZ2UgYmUgYGJ5dGVzIGAuXG4gIGxldCBjb250ZW50UmFuZ2UgPSAnYnl0ZXMgJ1xuXG4gIC8vIDIuIEFwcGVuZCByYW5nZVN0YXJ0LCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQsIHRvIGNvbnRlbnRSYW5nZS5cbiAgY29udGVudFJhbmdlICs9IGlzb21vcnBoaWNFbmNvZGUoYCR7cmFuZ2VTdGFydH1gKVxuXG4gIC8vIDMuIEFwcGVuZCAweDJEICgtKSB0byBjb250ZW50UmFuZ2UuXG4gIGNvbnRlbnRSYW5nZSArPSAnLSdcblxuICAvLyA0LiBBcHBlbmQgcmFuZ2VFbmQsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZCB0byBjb250ZW50UmFuZ2UuXG4gIGNvbnRlbnRSYW5nZSArPSBpc29tb3JwaGljRW5jb2RlKGAke3JhbmdlRW5kfWApXG5cbiAgLy8gNS4gQXBwZW5kIDB4MkYgKC8pIHRvIGNvbnRlbnRSYW5nZS5cbiAgY29udGVudFJhbmdlICs9ICcvJ1xuXG4gIC8vIDYuIEFwcGVuZCBmdWxsTGVuZ3RoLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQgdG8gY29udGVudFJhbmdlLlxuICBjb250ZW50UmFuZ2UgKz0gaXNvbW9ycGhpY0VuY29kZShgJHtmdWxsTGVuZ3RofWApXG5cbiAgLy8gNy4gUmV0dXJuIGNvbnRlbnRSYW5nZS5cbiAgcmV0dXJuIGNvbnRlbnRSYW5nZVxufVxuXG4vLyBBIFN0cmVhbSwgd2hpY2ggcGlwZXMgdGhlIHJlc3BvbnNlIHRvIHpsaWIuY3JlYXRlSW5mbGF0ZSgpIG9yXG4vLyB6bGliLmNyZWF0ZUluZmxhdGVSYXcoKSBkZXBlbmRpbmcgb24gdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIEJ1ZmZlci5cbi8vIElmIHRoZSBsb3dlciBieXRlIG9mIHRoZSBmaXJzdCBieXRlIGlzIDB4MDgsIHRoZW4gdGhlIHN0cmVhbSBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYSB6bGliIHN0cmVhbSwgb3RoZXJ3aXNlIGl0J3MgaW50ZXJwcmV0ZWQgYXMgYVxuLy8gcmF3IGRlZmxhdGUgc3RyZWFtLlxuY2xhc3MgSW5mbGF0ZVN0cmVhbSBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICN6bGliT3B0aW9uc1xuXG4gIC8qKiBAcGFyYW0ge3psaWIuWmxpYk9wdGlvbnN9IFt6bGliT3B0aW9uc10gKi9cbiAgY29uc3RydWN0b3IgKHpsaWJPcHRpb25zKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuI3psaWJPcHRpb25zID0gemxpYk9wdGlvbnNcbiAgfVxuXG4gIF90cmFuc2Zvcm0gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX2luZmxhdGVTdHJlYW0pIHtcbiAgICAgIGlmIChjaHVuay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuX2luZmxhdGVTdHJlYW0gPSAoY2h1bmtbMF0gJiAweDBGKSA9PT0gMHgwOFxuICAgICAgICA/IHpsaWIuY3JlYXRlSW5mbGF0ZSh0aGlzLiN6bGliT3B0aW9ucylcbiAgICAgICAgOiB6bGliLmNyZWF0ZUluZmxhdGVSYXcodGhpcy4jemxpYk9wdGlvbnMpXG5cbiAgICAgIHRoaXMuX2luZmxhdGVTdHJlYW0ub24oJ2RhdGEnLCB0aGlzLnB1c2guYmluZCh0aGlzKSlcbiAgICAgIHRoaXMuX2luZmxhdGVTdHJlYW0ub24oJ2VuZCcsICgpID0+IHRoaXMucHVzaChudWxsKSlcbiAgICAgIHRoaXMuX2luZmxhdGVTdHJlYW0ub24oJ2Vycm9yJywgKGVycikgPT4gdGhpcy5kZXN0cm95KGVycikpXG4gICAgfVxuXG4gICAgdGhpcy5faW5mbGF0ZVN0cmVhbS53cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKVxuICB9XG5cbiAgX2ZpbmFsIChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9pbmZsYXRlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9pbmZsYXRlU3RyZWFtLmVuZCgpXG4gICAgICB0aGlzLl9pbmZsYXRlU3RyZWFtID0gbnVsbFxuICAgIH1cbiAgICBjYWxsYmFjaygpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3psaWIuWmxpYk9wdGlvbnN9IFt6bGliT3B0aW9uc11cbiAqIEByZXR1cm5zIHtJbmZsYXRlU3RyZWFtfVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbmZsYXRlICh6bGliT3B0aW9ucykge1xuICByZXR1cm4gbmV3IEluZmxhdGVTdHJlYW0oemxpYk9wdGlvbnMpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItZXh0cmFjdC1taW1lLXR5cGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2hlYWRlcnMnKS5IZWFkZXJzTGlzdH0gaGVhZGVyc1xuICovXG5mdW5jdGlvbiBleHRyYWN0TWltZVR5cGUgKGhlYWRlcnMpIHtcbiAgLy8gMS4gTGV0IGNoYXJzZXQgYmUgbnVsbC5cbiAgbGV0IGNoYXJzZXQgPSBudWxsXG5cbiAgLy8gMi4gTGV0IGVzc2VuY2UgYmUgbnVsbC5cbiAgbGV0IGVzc2VuY2UgPSBudWxsXG5cbiAgLy8gMy4gTGV0IG1pbWVUeXBlIGJlIG51bGwuXG4gIGxldCBtaW1lVHlwZSA9IG51bGxcblxuICAvLyA0LiBMZXQgdmFsdWVzIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZywgZGVjb2RpbmcsIGFuZCBzcGxpdHRpbmcgYENvbnRlbnQtVHlwZWAgZnJvbSBoZWFkZXJzLlxuICBjb25zdCB2YWx1ZXMgPSBnZXREZWNvZGVTcGxpdCgnY29udGVudC10eXBlJywgaGVhZGVycylcblxuICAvLyA1LiBJZiB2YWx1ZXMgaXMgbnVsbCwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKHZhbHVlcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDYuIEZvciBlYWNoIHZhbHVlIG9mIHZhbHVlczpcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAvLyA2LjEuIExldCB0ZW1wb3JhcnlNaW1lVHlwZSBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgdmFsdWUuXG4gICAgY29uc3QgdGVtcG9yYXJ5TWltZVR5cGUgPSBwYXJzZU1JTUVUeXBlKHZhbHVlKVxuXG4gICAgLy8gNi4yLiBJZiB0ZW1wb3JhcnlNaW1lVHlwZSBpcyBmYWlsdXJlIG9yIGl0cyBlc3NlbmNlIGlzIFwiKi8qXCIsIHRoZW4gY29udGludWUuXG4gICAgaWYgKHRlbXBvcmFyeU1pbWVUeXBlID09PSAnZmFpbHVyZScgfHwgdGVtcG9yYXJ5TWltZVR5cGUuZXNzZW5jZSA9PT0gJyovKicpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy8gNi4zLiBTZXQgbWltZVR5cGUgdG8gdGVtcG9yYXJ5TWltZVR5cGUuXG4gICAgbWltZVR5cGUgPSB0ZW1wb3JhcnlNaW1lVHlwZVxuXG4gICAgLy8gNi40LiBJZiBtaW1lVHlwZeKAmXMgZXNzZW5jZSBpcyBub3QgZXNzZW5jZSwgdGhlbjpcbiAgICBpZiAobWltZVR5cGUuZXNzZW5jZSAhPT0gZXNzZW5jZSkge1xuICAgICAgLy8gNi40LjEuIFNldCBjaGFyc2V0IHRvIG51bGwuXG4gICAgICBjaGFyc2V0ID0gbnVsbFxuXG4gICAgICAvLyA2LjQuMi4gSWYgbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbXCJjaGFyc2V0XCJdIGV4aXN0cywgdGhlbiBzZXQgY2hhcnNldCB0b1xuICAgICAgLy8gICAgICAgIG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzW1wiY2hhcnNldFwiXS5cbiAgICAgIGlmIChtaW1lVHlwZS5wYXJhbWV0ZXJzLmhhcygnY2hhcnNldCcpKSB7XG4gICAgICAgIGNoYXJzZXQgPSBtaW1lVHlwZS5wYXJhbWV0ZXJzLmdldCgnY2hhcnNldCcpXG4gICAgICB9XG5cbiAgICAgIC8vIDYuNC4zLiBTZXQgZXNzZW5jZSB0byBtaW1lVHlwZeKAmXMgZXNzZW5jZS5cbiAgICAgIGVzc2VuY2UgPSBtaW1lVHlwZS5lc3NlbmNlXG4gICAgfSBlbHNlIGlmICghbWltZVR5cGUucGFyYW1ldGVycy5oYXMoJ2NoYXJzZXQnKSAmJiBjaGFyc2V0ICE9PSBudWxsKSB7XG4gICAgICAvLyA2LjUuIE90aGVyd2lzZSwgaWYgbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbXCJjaGFyc2V0XCJdIGRvZXMgbm90IGV4aXN0LCBhbmRcbiAgICAgIC8vICAgICAgY2hhcnNldCBpcyBub24tbnVsbCwgc2V0IG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzW1wiY2hhcnNldFwiXSB0byBjaGFyc2V0LlxuICAgICAgbWltZVR5cGUucGFyYW1ldGVycy5zZXQoJ2NoYXJzZXQnLCBjaGFyc2V0KVxuICAgIH1cbiAgfVxuXG4gIC8vIDcuIElmIG1pbWVUeXBlIGlzIG51bGwsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChtaW1lVHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gOC4gUmV0dXJuIG1pbWVUeXBlLlxuICByZXR1cm4gbWltZVR5cGVcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXItdmFsdWUtZ2V0LWRlY29kZS1hbmQtc3BsaXRcbiAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdldHRpbmdEZWNvZGluZ1NwbGl0dGluZyAodmFsdWUpIHtcbiAgLy8gMS4gTGV0IGlucHV0IGJlIHRoZSByZXN1bHQgb2YgaXNvbW9ycGhpYyBkZWNvZGluZyB2YWx1ZS5cbiAgY29uc3QgaW5wdXQgPSB2YWx1ZVxuXG4gIC8vIDIuIExldCBwb3NpdGlvbiBiZSBhIHBvc2l0aW9uIHZhcmlhYmxlIGZvciBpbnB1dCwgaW5pdGlhbGx5IHBvaW50aW5nIGF0IHRoZSBzdGFydCBvZiBpbnB1dC5cbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAvLyAzLiBMZXQgdmFsdWVzIGJlIGEgbGlzdCBvZiBzdHJpbmdzLCBpbml0aWFsbHkgZW1wdHkuXG4gIGNvbnN0IHZhbHVlcyA9IFtdXG5cbiAgLy8gNC4gTGV0IHRlbXBvcmFyeVZhbHVlIGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIGxldCB0ZW1wb3JhcnlWYWx1ZSA9ICcnXG5cbiAgLy8gNS4gV2hpbGUgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBpbnB1dDpcbiAgd2hpbGUgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgLy8gNS4xLiBBcHBlbmQgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAyMiAoXCIpXG4gICAgLy8gICAgICBvciBVKzAwMkMgKCwpIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLCB0byB0ZW1wb3JhcnlWYWx1ZS5cbiAgICB0ZW1wb3JhcnlWYWx1ZSArPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgIT09ICdcIicgJiYgY2hhciAhPT0gJywnLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDUuMi4gSWYgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbjpcbiAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIC8vIDUuMi4xLiBJZiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgaXMgVSswMDIyIChcIiksIHRoZW46XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3NpdGlvbi5wb3NpdGlvbikgPT09IDB4MjIpIHtcbiAgICAgICAgLy8gNS4yLjEuMS4gQXBwZW5kIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhbiBIVFRQIHF1b3RlZCBzdHJpbmcgZnJvbSBpbnB1dCwgZ2l2ZW4gcG9zaXRpb24sIHRvIHRlbXBvcmFyeVZhbHVlLlxuICAgICAgICB0ZW1wb3JhcnlWYWx1ZSArPSBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nKFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIClcblxuICAgICAgICAvLyA1LjIuMS4yLiBJZiBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuIGNvbnRpbnVlLlxuICAgICAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyA1LjIuMi4gT3RoZXJ3aXNlOlxuXG4gICAgICAgIC8vIDUuMi4yLjEuIEFzc2VydDogdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0IGlzIFUrMDAyQyAoLCkuXG4gICAgICAgIGFzc2VydChpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uLnBvc2l0aW9uKSA9PT0gMHgyQylcblxuICAgICAgICAvLyA1LjIuMi4yLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gICAgICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LjMuIFJlbW92ZSBhbGwgSFRUUCB0YWIgb3Igc3BhY2UgZnJvbSB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0ZW1wb3JhcnlWYWx1ZS5cbiAgICB0ZW1wb3JhcnlWYWx1ZSA9IHJlbW92ZUNoYXJzKHRlbXBvcmFyeVZhbHVlLCB0cnVlLCB0cnVlLCAoY2hhcikgPT4gY2hhciA9PT0gMHg5IHx8IGNoYXIgPT09IDB4MjApXG5cbiAgICAvLyA1LjQuIEFwcGVuZCB0ZW1wb3JhcnlWYWx1ZSB0byB2YWx1ZXMuXG4gICAgdmFsdWVzLnB1c2godGVtcG9yYXJ5VmFsdWUpXG5cbiAgICAvLyA1LjYuIFNldCB0ZW1wb3JhcnlWYWx1ZSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIHRlbXBvcmFyeVZhbHVlID0gJydcbiAgfVxuXG4gIC8vIDYuIFJldHVybiB2YWx1ZXMuXG4gIHJldHVybiB2YWx1ZXNcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWdldC1kZWNvZGUtc3BsaXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGxvd2VyY2FzZSBoZWFkZXIgbmFtZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaGVhZGVycycpLkhlYWRlcnNMaXN0fSBsaXN0XG4gKi9cbmZ1bmN0aW9uIGdldERlY29kZVNwbGl0IChuYW1lLCBsaXN0KSB7XG4gIC8vIDEuIExldCB2YWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGdldHRpbmcgbmFtZSBmcm9tIGxpc3QuXG4gIGNvbnN0IHZhbHVlID0gbGlzdC5nZXQobmFtZSwgdHJ1ZSlcblxuICAvLyAyLiBJZiB2YWx1ZSBpcyBudWxsLCB0aGVuIHJldHVybiBudWxsLlxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIHRoZSByZXN1bHQgb2YgZ2V0dGluZywgZGVjb2RpbmcsIGFuZCBzcGxpdHRpbmcgdmFsdWUuXG4gIHJldHVybiBnZXR0aW5nRGVjb2RpbmdTcGxpdHRpbmcodmFsdWUpXG59XG5cbmNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnLyN1dGYtOC1kZWNvZGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXJcbiAqL1xuZnVuY3Rpb24gdXRmOERlY29kZUJ5dGVzIChidWZmZXIpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIDEuIExldCBidWZmZXIgYmUgdGhlIHJlc3VsdCBvZiBwZWVraW5nIHRocmVlIGJ5dGVzIGZyb21cbiAgLy8gICAgaW9RdWV1ZSwgY29udmVydGVkIHRvIGEgYnl0ZSBzZXF1ZW5jZS5cblxuICAvLyAyLiBJZiBidWZmZXIgaXMgMHhFRiAweEJCIDB4QkYsIHRoZW4gcmVhZCB0aHJlZVxuICAvLyAgICBieXRlcyBmcm9tIGlvUXVldWUuIChEbyBub3RoaW5nIHdpdGggdGhvc2UgYnl0ZXMuKVxuICBpZiAoYnVmZmVyWzBdID09PSAweEVGICYmIGJ1ZmZlclsxXSA9PT0gMHhCQiAmJiBidWZmZXJbMl0gPT09IDB4QkYpIHtcbiAgICBidWZmZXIgPSBidWZmZXIuc3ViYXJyYXkoMylcbiAgfVxuXG4gIC8vIDMuIFByb2Nlc3MgYSBxdWV1ZSB3aXRoIGFuIGluc3RhbmNlIG9mIFVURi044oCZc1xuICAvLyAgICBkZWNvZGVyLCBpb1F1ZXVlLCBvdXRwdXQsIGFuZCBcInJlcGxhY2VtZW50XCIuXG4gIGNvbnN0IG91dHB1dCA9IHRleHREZWNvZGVyLmRlY29kZShidWZmZXIpXG5cbiAgLy8gNC4gUmV0dXJuIG91dHB1dC5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5jbGFzcyBFbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0QmFzZSB7XG4gIGdldCBiYXNlVXJsICgpIHtcbiAgICByZXR1cm4gZ2V0R2xvYmFsT3JpZ2luKClcbiAgfVxuXG4gIGdldCBvcmlnaW4gKCkge1xuICAgIHJldHVybiB0aGlzLmJhc2VVcmw/Lm9yaWdpblxuICB9XG5cbiAgcG9saWN5Q29udGFpbmVyID0gbWFrZVBvbGljeUNvbnRhaW5lcigpXG59XG5cbmNsYXNzIEVudmlyb25tZW50U2V0dGluZ3NPYmplY3Qge1xuICBzZXR0aW5nc09iamVjdCA9IG5ldyBFbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0QmFzZSgpXG59XG5cbmNvbnN0IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3QgPSBuZXcgRW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCgpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0Fib3J0ZWQsXG4gIGlzQ2FuY2VsbGVkLFxuICBpc1ZhbGlkRW5jb2RlZFVSTCxcbiAgY3JlYXRlRGVmZXJyZWRQcm9taXNlLFxuICBSZWFkYWJsZVN0cmVhbUZyb20sXG4gIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCxcbiAgY2xhbXBBbmRDb2Fyc2VuQ29ubmVjdGlvblRpbWluZ0luZm8sXG4gIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lLFxuICBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyLFxuICBtYWtlUG9saWN5Q29udGFpbmVyLFxuICBjbG9uZVBvbGljeUNvbnRhaW5lcixcbiAgYXBwZW5kRmV0Y2hNZXRhZGF0YSxcbiAgYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcixcbiAgVEFPQ2hlY2ssXG4gIGNvcnNDaGVjayxcbiAgY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrLFxuICBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvLFxuICBzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0LFxuICBpc1ZhbGlkSFRUUFRva2VuLFxuICByZXF1ZXN0QmFkUG9ydCxcbiAgcmVxdWVzdEN1cnJlbnRVUkwsXG4gIHJlc3BvbnNlVVJMLFxuICByZXNwb25zZUxvY2F0aW9uVVJMLFxuICBpc1VSTFBvdGVudGlhbGx5VHJ1c3R3b3J0aHksXG4gIGlzVmFsaWRSZWFzb25QaHJhc2UsXG4gIHNhbWVPcmlnaW4sXG4gIG5vcm1hbGl6ZU1ldGhvZCxcbiAgc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nLFxuICBpdGVyYXRvck1peGluLFxuICBjcmVhdGVJdGVyYXRvcixcbiAgaXNWYWxpZEhlYWRlck5hbWUsXG4gIGlzVmFsaWRIZWFkZXJWYWx1ZSxcbiAgaXNFcnJvckxpa2UsXG4gIGZ1bGx5UmVhZEJvZHksXG4gIGJ5dGVzTWF0Y2gsXG4gIHJlYWRhYmxlU3RyZWFtQ2xvc2UsXG4gIGlzb21vcnBoaWNFbmNvZGUsXG4gIHVybElzTG9jYWwsXG4gIHVybEhhc0h0dHBzU2NoZW1lLFxuICB1cmxJc0h0dHBIdHRwc1NjaGVtZSxcbiAgcmVhZEFsbEJ5dGVzLFxuICBzaW1wbGVSYW5nZUhlYWRlclZhbHVlLFxuICBidWlsZENvbnRlbnRSYW5nZSxcbiAgcGFyc2VNZXRhZGF0YSxcbiAgY3JlYXRlSW5mbGF0ZSxcbiAgZXh0cmFjdE1pbWVUeXBlLFxuICBnZXREZWNvZGVTcGxpdCxcbiAgdXRmOERlY29kZUJ5dGVzLFxuICBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0LFxuICBpc09yaWdpbklQUG90ZW50aWFsbHlUcnVzdHdvcnRoeVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/webidl/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/webidl/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { types, inspect } = __webpack_require__(/*! node:util */ \"node:util\")\nconst { markAsUncloneable } = __webpack_require__(/*! node:worker_threads */ \"node:worker_threads\")\n\nconst UNDEFINED = 1\nconst BOOLEAN = 2\nconst STRING = 3\nconst SYMBOL = 4\nconst NUMBER = 5\nconst BIGINT = 6\nconst NULL = 7\nconst OBJECT = 8 // function and object\n\nconst FunctionPrototypeSymbolHasInstance = Function.call.bind(Function.prototype[Symbol.hasInstance])\n\n/** @type {import('../../../types/webidl').Webidl} */\nconst webidl = {\n  converters: {},\n  util: {},\n  errors: {},\n  is: {}\n}\n\n/**\n * @description Instantiate an error.\n *\n * @param {Object} opts\n * @param {string} opts.header\n * @param {string} opts.message\n * @returns {TypeError}\n */\nwebidl.errors.exception = function (message) {\n  return new TypeError(`${message.header}: ${message.message}`)\n}\n\n/**\n * @description Instantiate an error when conversion from one type to another has failed.\n *\n * @param {Object} opts\n * @param {string} opts.prefix\n * @param {string} opts.argument\n * @param {string[]} opts.types\n * @returns {TypeError}\n */\nwebidl.errors.conversionFailed = function (opts) {\n  const plural = opts.types.length === 1 ? '' : ' one of'\n  const message =\n    `${opts.argument} could not be converted to` +\n    `${plural}: ${opts.types.join(', ')}.`\n\n  return webidl.errors.exception({\n    header: opts.prefix,\n    message\n  })\n}\n\n/**\n * @description Instantiate an error when an invalid argument is provided\n *\n * @param {Object} context\n * @param {string} context.prefix\n * @param {string} context.value\n * @param {string} context.type\n * @returns {TypeError}\n */\nwebidl.errors.invalidArgument = function (context) {\n  return webidl.errors.exception({\n    header: context.prefix,\n    message: `\"${context.value}\" is an invalid ${context.type}.`\n  })\n}\n\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function (V, I) {\n  if (!FunctionPrototypeSymbolHasInstance(I, V)) {\n    const err = new TypeError('Illegal invocation')\n    err.code = 'ERR_INVALID_THIS' // node compat.\n    throw err\n  }\n}\n\nwebidl.brandCheckMultiple = function (List) {\n  const prototypes = List.map((c) => webidl.util.MakeTypeAssertion(c))\n\n  return (V) => {\n    if (prototypes.every(typeCheck => !typeCheck(V))) {\n      const err = new TypeError('Illegal invocation')\n      err.code = 'ERR_INVALID_THIS' // node compat.\n      throw err\n    }\n  }\n}\n\nwebidl.argumentLengthCheck = function ({ length }, min, ctx) {\n  if (length < min) {\n    throw webidl.errors.exception({\n      message: `${min} argument${min !== 1 ? 's' : ''} required, ` +\n               `but${length ? ' only' : ''} ${length} found.`,\n      header: ctx\n    })\n  }\n}\n\nwebidl.illegalConstructor = function () {\n  throw webidl.errors.exception({\n    header: 'TypeError',\n    message: 'Illegal constructor'\n  })\n}\n\nwebidl.util.MakeTypeAssertion = function (I) {\n  return (O) => FunctionPrototypeSymbolHasInstance(I, O)\n}\n\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function (V) {\n  switch (typeof V) {\n    case 'undefined': return UNDEFINED\n    case 'boolean': return BOOLEAN\n    case 'string': return STRING\n    case 'symbol': return SYMBOL\n    case 'number': return NUMBER\n    case 'bigint': return BIGINT\n    case 'function':\n    case 'object': {\n      if (V === null) {\n        return NULL\n      }\n\n      return OBJECT\n    }\n  }\n}\n\nwebidl.util.Types = {\n  UNDEFINED,\n  BOOLEAN,\n  STRING,\n  SYMBOL,\n  NUMBER,\n  BIGINT,\n  NULL,\n  OBJECT\n}\n\nwebidl.util.TypeValueToString = function (o) {\n  switch (webidl.util.Type(o)) {\n    case UNDEFINED: return 'Undefined'\n    case BOOLEAN: return 'Boolean'\n    case STRING: return 'String'\n    case SYMBOL: return 'Symbol'\n    case NUMBER: return 'Number'\n    case BIGINT: return 'BigInt'\n    case NULL: return 'Null'\n    case OBJECT: return 'Object'\n  }\n}\n\nwebidl.util.markAsUncloneable = markAsUncloneable || (() => {})\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function (V, bitLength, signedness, opts) {\n  let upperBound\n  let lowerBound\n\n  // 1. If bitLength is 64, then:\n  if (bitLength === 64) {\n    // 1. Let upperBound be 2^53  1.\n    upperBound = Math.pow(2, 53) - 1\n\n    // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n    if (signedness === 'unsigned') {\n      lowerBound = 0\n    } else {\n      // 3. Otherwise let lowerBound be 2^53 + 1.\n      lowerBound = Math.pow(-2, 53) + 1\n    }\n  } else if (signedness === 'unsigned') {\n    // 2. Otherwise, if signedness is \"unsigned\", then:\n\n    // 1. Let lowerBound be 0.\n    lowerBound = 0\n\n    // 2. Let upperBound be 2^bitLength  1.\n    upperBound = Math.pow(2, bitLength) - 1\n  } else {\n    // 3. Otherwise:\n\n    // 1. Let lowerBound be -2^bitLength  1.\n    lowerBound = Math.pow(-2, bitLength) - 1\n\n    // 2. Let upperBound be 2^bitLength  1  1.\n    upperBound = Math.pow(2, bitLength - 1) - 1\n  }\n\n  // 4. Let x be ? ToNumber(V).\n  let x = Number(V)\n\n  // 5. If x is 0, then set x to +0.\n  if (x === 0) {\n    x = 0\n  }\n\n  // 6. If the conversion is to an IDL type associated\n  //    with the [EnforceRange] extended attribute, then:\n  if (opts?.enforceRange === true) {\n    // 1. If x is NaN, +, or , then throw a TypeError.\n    if (\n      Number.isNaN(x) ||\n      x === Number.POSITIVE_INFINITY ||\n      x === Number.NEGATIVE_INFINITY\n    ) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`\n      })\n    }\n\n    // 2. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x)\n\n    // 3. If x < lowerBound or x > upperBound, then\n    //    throw a TypeError.\n    if (x < lowerBound || x > upperBound) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n      })\n    }\n\n    // 4. Return x.\n    return x\n  }\n\n  // 7. If x is not NaN and the conversion is to an IDL\n  //    type associated with the [Clamp] extended\n  //    attribute, then:\n  if (!Number.isNaN(x) && opts?.clamp === true) {\n    // 1. Set x to min(max(x, lowerBound), upperBound).\n    x = Math.min(Math.max(x, lowerBound), upperBound)\n\n    // 2. Round x to the nearest integer, choosing the\n    //    even integer if it lies halfway between two,\n    //    and choosing +0 rather than 0.\n    if (Math.floor(x) % 2 === 0) {\n      x = Math.floor(x)\n    } else {\n      x = Math.ceil(x)\n    }\n\n    // 3. Return x.\n    return x\n  }\n\n  // 8. If x is NaN, +0, +, or , then return +0.\n  if (\n    Number.isNaN(x) ||\n    (x === 0 && Object.is(0, x)) ||\n    x === Number.POSITIVE_INFINITY ||\n    x === Number.NEGATIVE_INFINITY\n  ) {\n    return 0\n  }\n\n  // 9. Set x to IntegerPart(x).\n  x = webidl.util.IntegerPart(x)\n\n  // 10. Set x to x modulo 2^bitLength.\n  x = x % Math.pow(2, bitLength)\n\n  // 11. If signedness is \"signed\" and x  2^bitLength  1,\n  //    then return x  2^bitLength.\n  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n    return x - Math.pow(2, bitLength)\n  }\n\n  // 12. Otherwise, return x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function (n) {\n  // 1. Let r be floor(abs(n)).\n  const r = Math.floor(Math.abs(n))\n\n  // 2. If n < 0, then return -1  r.\n  if (n < 0) {\n    return -1 * r\n  }\n\n  // 3. Otherwise, return r.\n  return r\n}\n\nwebidl.util.Stringify = function (V) {\n  const type = webidl.util.Type(V)\n\n  switch (type) {\n    case SYMBOL:\n      return `Symbol(${V.description})`\n    case OBJECT:\n      return inspect(V)\n    case STRING:\n      return `\"${V}\"`\n    case BIGINT:\n      return `${V}n`\n    default:\n      return `${V}`\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function (converter) {\n  return (V, prefix, argument, Iterable) => {\n    // 1. If Type(V) is not Object, throw a TypeError.\n    if (webidl.util.Type(V) !== OBJECT) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`\n      })\n    }\n\n    // 2. Let method be ? GetMethod(V, @@iterator).\n    /** @type {Generator} */\n    const method = typeof Iterable === 'function' ? Iterable() : V?.[Symbol.iterator]?.()\n    const seq = []\n    let index = 0\n\n    // 3. If method is undefined, throw a TypeError.\n    if (\n      method === undefined ||\n      typeof method.next !== 'function'\n    ) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} is not iterable.`\n      })\n    }\n\n    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n    while (true) {\n      const { done, value } = method.next()\n\n      if (done) {\n        break\n      }\n\n      seq.push(converter(value, prefix, `${argument}[${index++}]`))\n    }\n\n    return seq\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function (keyConverter, valueConverter) {\n  return (O, prefix, argument) => {\n    // 1. If Type(O) is not Object, throw a TypeError.\n    if (webidl.util.Type(O) !== OBJECT) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} (\"${webidl.util.TypeValueToString(O)}\") is not an Object.`\n      })\n    }\n\n    // 2. Let result be a new empty instance of record<K, V>.\n    const result = {}\n\n    if (!types.isProxy(O)) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const keys = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)]\n\n      for (const key of keys) {\n        const keyName = webidl.util.Stringify(key)\n\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key, prefix, `Key ${keyName} in ${argument}`)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key], prefix, `${argument}[${keyName}]`)\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n\n      // 5. Return result.\n      return result\n    }\n\n    // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n    const keys = Reflect.ownKeys(O)\n\n    // 4. For each key of keys.\n    for (const key of keys) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const desc = Reflect.getOwnPropertyDescriptor(O, key)\n\n      // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n      if (desc?.enumerable) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key, prefix, argument)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key], prefix, argument)\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n    }\n\n    // 5. Return result.\n    return result\n  }\n}\n\nwebidl.interfaceConverter = function (TypeCheck, name) {\n  return (V, prefix, argument) => {\n    if (!TypeCheck(V)) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `Expected ${argument} (\"${webidl.util.Stringify(V)}\") to be an instance of ${name}.`\n      })\n    }\n\n    return V\n  }\n}\n\nwebidl.dictionaryConverter = function (converters) {\n  return (dictionary, prefix, argument) => {\n    const dict = {}\n\n    if (dictionary != null && webidl.util.Type(dictionary) !== OBJECT) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n      })\n    }\n\n    for (const options of converters) {\n      const { key, defaultValue, required, converter } = options\n\n      if (required === true) {\n        if (dictionary == null || !Object.hasOwn(dictionary, key)) {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: `Missing required key \"${key}\".`\n          })\n        }\n      }\n\n      let value = dictionary?.[key]\n      const hasDefault = defaultValue !== undefined\n\n      // Only use defaultValue if value is undefined and\n      // a defaultValue options was provided.\n      if (hasDefault && value === undefined) {\n        value = defaultValue()\n      }\n\n      // A key can be optional and have no default value.\n      // When this happens, do not perform a conversion,\n      // and do not assign the key a value.\n      if (required || hasDefault || value !== undefined) {\n        value = converter(value, prefix, `${argument}.${key}`)\n\n        if (\n          options.allowedValues &&\n          !options.allowedValues.includes(value)\n        ) {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n          })\n        }\n\n        dict[key] = value\n      }\n    }\n\n    return dict\n  }\n}\n\nwebidl.nullableConverter = function (converter) {\n  return (V, prefix, argument) => {\n    if (V === null) {\n      return V\n    }\n\n    return converter(V, prefix, argument)\n  }\n}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nwebidl.is.USVString = function (value) {\n  return (\n    typeof value === 'string' &&\n    value.isWellFormed()\n  )\n}\n\nwebidl.is.ReadableStream = webidl.util.MakeTypeAssertion(ReadableStream)\nwebidl.is.Blob = webidl.util.MakeTypeAssertion(Blob)\nwebidl.is.URLSearchParams = webidl.util.MakeTypeAssertion(URLSearchParams)\nwebidl.is.File = webidl.util.MakeTypeAssertion(globalThis.File ?? (__webpack_require__(/*! node:buffer */ \"node:buffer\").File))\nwebidl.is.URL = webidl.util.MakeTypeAssertion(URL)\nwebidl.is.AbortSignal = webidl.util.MakeTypeAssertion(AbortSignal)\nwebidl.is.MessagePort = webidl.util.MakeTypeAssertion(MessagePort)\n\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function (V, prefix, argument, opts) {\n  // 1. If V is null and the conversion is to an IDL type\n  //    associated with the [LegacyNullToEmptyString]\n  //    extended attribute, then return the DOMString value\n  //    that represents the empty string.\n  if (V === null && opts?.legacyNullToEmptyString) {\n    return ''\n  }\n\n  // 2. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} is a symbol, which cannot be converted to a DOMString.`\n    })\n  }\n\n  // 3. Return the IDL DOMString value that represents the\n  //    same sequence of code units as the one the\n  //    ECMAScript String value x represents.\n  return String(V)\n}\n\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function (V, prefix, argument) {\n  // 1. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} is a symbol, which cannot be converted to a ByteString.`\n    })\n  }\n\n  const x = String(V)\n\n  // 2. If the value of any element of x is greater than\n  //    255, then throw a TypeError.\n  for (let index = 0; index < x.length; index++) {\n    if (x.charCodeAt(index) > 255) {\n      throw new TypeError(\n        'Cannot convert argument to a ByteString because the character at ' +\n        `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`\n      )\n    }\n  }\n\n  // 3. Return an IDL ByteString value whose length is the\n  //    length of x, and where the value of each element is\n  //    the value of the corresponding element of x.\n  return x\n}\n\n/**\n * @param {unknown} value\n * @returns {string}\n * @see https://webidl.spec.whatwg.org/#es-USVString\n */\nwebidl.converters.USVString = function (value) {\n  // TODO: rewrite this so we can control the errors thrown\n  if (typeof value === 'string') {\n    return value.toWellFormed()\n  }\n  return `${value}`.toWellFormed()\n}\n\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function (V) {\n  // 1. Let x be the result of computing ToBoolean(V).\n  // https://262.ecma-international.org/10.0/index.html#table-10\n  const x = Boolean(V)\n\n  // 2. Return the IDL boolean value that is the one that represents\n  //    the same truth value as the ECMAScript Boolean value x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function (V) {\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters['long long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n  const x = webidl.util.ConvertToInt(V, 64, 'signed', undefined, prefix, argument)\n\n  // 2. Return the IDL long long value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters['unsigned long long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 64, 'unsigned', undefined, prefix, argument)\n\n  // 2. Return the IDL unsigned long long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters['unsigned long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 32, 'unsigned', undefined, prefix, argument)\n\n  // 2. Return the IDL unsigned long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters['unsigned short'] = function (V, prefix, argument, opts) {\n  // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts, prefix, argument)\n\n  // 2. Return the IDL unsigned short value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function (V, prefix, argument, opts) {\n  // 1. If Type(V) is not Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n  if (\n    webidl.util.Type(V) !== OBJECT ||\n    !types.isAnyArrayBuffer(V)\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n      types: ['ArrayBuffer']\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (V.resizable || V.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    })\n  }\n\n  // 4. Return the IDL ArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V\n}\n\nwebidl.converters.TypedArray = function (V, T, prefix, name, opts) {\n  // 1. Let T be the IDL type V is being converted to.\n\n  // 2. If Type(V) is not Object, or V does not have a\n  //    [[TypedArrayName]] internal slot with a value\n  //    equal to Ts name, then throw a TypeError.\n  if (\n    webidl.util.Type(V) !== OBJECT ||\n    !types.isTypedArray(V) ||\n    V.constructor.name !== T.name\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${name} (\"${webidl.util.Stringify(V)}\")`,\n      types: [T.name]\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 4. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (V.buffer.resizable || V.buffer.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    })\n  }\n\n  // 5. Return the IDL value of type T that is a reference\n  //    to the same object as V.\n  return V\n}\n\nwebidl.converters.DataView = function (V, prefix, name, opts) {\n  // 1. If Type(V) is not Object, or V does not have a\n  //    [[DataView]] internal slot, then throw a TypeError.\n  if (webidl.util.Type(V) !== OBJECT || !types.isDataView(V)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${name} is not a DataView.`\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n  //    then throw a TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (V.buffer.resizable || V.buffer.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    })\n  }\n\n  // 4. Return the IDL DataView value that is a reference\n  //    to the same object as V.\n  return V\n}\n\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(\n  webidl.converters.ByteString\n)\n\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(\n  webidl.converters['sequence<ByteString>']\n)\n\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(\n  webidl.converters.ByteString,\n  webidl.converters.ByteString\n)\n\nwebidl.converters.Blob = webidl.interfaceConverter(webidl.is.Blob, 'Blob')\n\nwebidl.converters.AbortSignal = webidl.interfaceConverter(\n  webidl.is.AbortSignal,\n  'AbortSignal'\n)\n\nmodule.exports = {\n  webidl\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2ViaWRsL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyw0QkFBVztBQUM5QyxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsZ0RBQXFCOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFdBQVcsd0NBQXdDO0FBQ25EO0FBQ0EsZ0JBQWdCO0FBQ2hCLFVBQVU7QUFDVixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBLDBCQUEwQixlQUFlLElBQUksZ0JBQWdCO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGVBQWU7QUFDdEIsT0FBTyxPQUFPLElBQUksc0JBQXNCOztBQUV4QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjLGtCQUFrQixhQUFhO0FBQzlELEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0Esa0JBQWtCLEtBQUssVUFBVSxzQkFBc0I7QUFD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Q0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVLElBQUkseUJBQXlCO0FBQzFEO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU0sSUFBSSx5QkFBeUI7QUFDdEQ7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL3dlYmlkbC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB0eXBlcywgaW5zcGVjdCB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcbmNvbnN0IHsgbWFya0FzVW5jbG9uZWFibGUgfSA9IHJlcXVpcmUoJ25vZGU6d29ya2VyX3RocmVhZHMnKVxuXG5jb25zdCBVTkRFRklORUQgPSAxXG5jb25zdCBCT09MRUFOID0gMlxuY29uc3QgU1RSSU5HID0gM1xuY29uc3QgU1lNQk9MID0gNFxuY29uc3QgTlVNQkVSID0gNVxuY29uc3QgQklHSU5UID0gNlxuY29uc3QgTlVMTCA9IDdcbmNvbnN0IE9CSkVDVCA9IDggLy8gZnVuY3Rpb24gYW5kIG9iamVjdFxuXG5jb25zdCBGdW5jdGlvblByb3RvdHlwZVN5bWJvbEhhc0luc3RhbmNlID0gRnVuY3Rpb24uY2FsbC5iaW5kKEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdKVxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi4vLi4vLi4vdHlwZXMvd2ViaWRsJykuV2ViaWRsfSAqL1xuY29uc3Qgd2ViaWRsID0ge1xuICBjb252ZXJ0ZXJzOiB7fSxcbiAgdXRpbDoge30sXG4gIGVycm9yczoge30sXG4gIGlzOiB7fVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBJbnN0YW50aWF0ZSBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuaGVhZGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5tZXNzYWdlXG4gKiBAcmV0dXJucyB7VHlwZUVycm9yfVxuICovXG53ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKGAke21lc3NhZ2UuaGVhZGVyfTogJHttZXNzYWdlLm1lc3NhZ2V9YClcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gSW5zdGFudGlhdGUgYW4gZXJyb3Igd2hlbiBjb252ZXJzaW9uIGZyb20gb25lIHR5cGUgdG8gYW5vdGhlciBoYXMgZmFpbGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5wcmVmaXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmFyZ3VtZW50XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcHRzLnR5cGVzXG4gKiBAcmV0dXJucyB7VHlwZUVycm9yfVxuICovXG53ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQgPSBmdW5jdGlvbiAob3B0cykge1xuICBjb25zdCBwbHVyYWwgPSBvcHRzLnR5cGVzLmxlbmd0aCA9PT0gMSA/ICcnIDogJyBvbmUgb2YnXG4gIGNvbnN0IG1lc3NhZ2UgPVxuICAgIGAke29wdHMuYXJndW1lbnR9IGNvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG9gICtcbiAgICBgJHtwbHVyYWx9OiAke29wdHMudHlwZXMuam9pbignLCAnKX0uYFxuXG4gIHJldHVybiB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgaGVhZGVyOiBvcHRzLnByZWZpeCxcbiAgICBtZXNzYWdlXG4gIH0pXG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEluc3RhbnRpYXRlIGFuIGVycm9yIHdoZW4gYW4gaW52YWxpZCBhcmd1bWVudCBpcyBwcm92aWRlZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dC5wcmVmaXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0LnZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dC50eXBlXG4gKiBAcmV0dXJucyB7VHlwZUVycm9yfVxuICovXG53ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHJldHVybiB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgaGVhZGVyOiBjb250ZXh0LnByZWZpeCxcbiAgICBtZXNzYWdlOiBgXCIke2NvbnRleHQudmFsdWV9XCIgaXMgYW4gaW52YWxpZCAke2NvbnRleHQudHlwZX0uYFxuICB9KVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2ltcGxlbWVudHNcbndlYmlkbC5icmFuZENoZWNrID0gZnVuY3Rpb24gKFYsIEkpIHtcbiAgaWYgKCFGdW5jdGlvblByb3RvdHlwZVN5bWJvbEhhc0luc3RhbmNlKEksIFYpKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IFR5cGVFcnJvcignSWxsZWdhbCBpbnZvY2F0aW9uJylcbiAgICBlcnIuY29kZSA9ICdFUlJfSU5WQUxJRF9USElTJyAvLyBub2RlIGNvbXBhdC5cbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG53ZWJpZGwuYnJhbmRDaGVja011bHRpcGxlID0gZnVuY3Rpb24gKExpc3QpIHtcbiAgY29uc3QgcHJvdG90eXBlcyA9IExpc3QubWFwKChjKSA9PiB3ZWJpZGwudXRpbC5NYWtlVHlwZUFzc2VydGlvbihjKSlcblxuICByZXR1cm4gKFYpID0+IHtcbiAgICBpZiAocHJvdG90eXBlcy5ldmVyeSh0eXBlQ2hlY2sgPT4gIXR5cGVDaGVjayhWKSkpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgaW52b2NhdGlvbicpXG4gICAgICBlcnIuY29kZSA9ICdFUlJfSU5WQUxJRF9USElTJyAvLyBub2RlIGNvbXBhdC5cbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG53ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayA9IGZ1bmN0aW9uICh7IGxlbmd0aCB9LCBtaW4sIGN0eCkge1xuICBpZiAobGVuZ3RoIDwgbWluKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgbWVzc2FnZTogYCR7bWlufSBhcmd1bWVudCR7bWluICE9PSAxID8gJ3MnIDogJyd9IHJlcXVpcmVkLCBgICtcbiAgICAgICAgICAgICAgIGBidXQke2xlbmd0aCA/ICcgb25seScgOiAnJ30gJHtsZW5ndGh9IGZvdW5kLmAsXG4gICAgICBoZWFkZXI6IGN0eFxuICAgIH0pXG4gIH1cbn1cblxud2ViaWRsLmlsbGVnYWxDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgIGhlYWRlcjogJ1R5cGVFcnJvcicsXG4gICAgbWVzc2FnZTogJ0lsbGVnYWwgY29uc3RydWN0b3InXG4gIH0pXG59XG5cbndlYmlkbC51dGlsLk1ha2VUeXBlQXNzZXJ0aW9uID0gZnVuY3Rpb24gKEkpIHtcbiAgcmV0dXJuIChPKSA9PiBGdW5jdGlvblByb3RvdHlwZVN5bWJvbEhhc0luc3RhbmNlKEksIE8pXG59XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1kYXRhLXR5cGVzLWFuZC12YWx1ZXNcbndlYmlkbC51dGlsLlR5cGUgPSBmdW5jdGlvbiAoVikge1xuICBzd2l0Y2ggKHR5cGVvZiBWKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzogcmV0dXJuIFVOREVGSU5FRFxuICAgIGNhc2UgJ2Jvb2xlYW4nOiByZXR1cm4gQk9PTEVBTlxuICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiBTVFJJTkdcbiAgICBjYXNlICdzeW1ib2wnOiByZXR1cm4gU1lNQk9MXG4gICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuIE5VTUJFUlxuICAgIGNhc2UgJ2JpZ2ludCc6IHJldHVybiBCSUdJTlRcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgaWYgKFYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE5VTExcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9CSkVDVFxuICAgIH1cbiAgfVxufVxuXG53ZWJpZGwudXRpbC5UeXBlcyA9IHtcbiAgVU5ERUZJTkVELFxuICBCT09MRUFOLFxuICBTVFJJTkcsXG4gIFNZTUJPTCxcbiAgTlVNQkVSLFxuICBCSUdJTlQsXG4gIE5VTEwsXG4gIE9CSkVDVFxufVxuXG53ZWJpZGwudXRpbC5UeXBlVmFsdWVUb1N0cmluZyA9IGZ1bmN0aW9uIChvKSB7XG4gIHN3aXRjaCAod2ViaWRsLnV0aWwuVHlwZShvKSkge1xuICAgIGNhc2UgVU5ERUZJTkVEOiByZXR1cm4gJ1VuZGVmaW5lZCdcbiAgICBjYXNlIEJPT0xFQU46IHJldHVybiAnQm9vbGVhbidcbiAgICBjYXNlIFNUUklORzogcmV0dXJuICdTdHJpbmcnXG4gICAgY2FzZSBTWU1CT0w6IHJldHVybiAnU3ltYm9sJ1xuICAgIGNhc2UgTlVNQkVSOiByZXR1cm4gJ051bWJlcidcbiAgICBjYXNlIEJJR0lOVDogcmV0dXJuICdCaWdJbnQnXG4gICAgY2FzZSBOVUxMOiByZXR1cm4gJ051bGwnXG4gICAgY2FzZSBPQkpFQ1Q6IHJldHVybiAnT2JqZWN0J1xuICB9XG59XG5cbndlYmlkbC51dGlsLm1hcmtBc1VuY2xvbmVhYmxlID0gbWFya0FzVW5jbG9uZWFibGUgfHwgKCgpID0+IHt9KVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Fic3RyYWN0LW9wZGVmLWNvbnZlcnR0b2ludFxud2ViaWRsLnV0aWwuQ29udmVydFRvSW50ID0gZnVuY3Rpb24gKFYsIGJpdExlbmd0aCwgc2lnbmVkbmVzcywgb3B0cykge1xuICBsZXQgdXBwZXJCb3VuZFxuICBsZXQgbG93ZXJCb3VuZFxuXG4gIC8vIDEuIElmIGJpdExlbmd0aCBpcyA2NCwgdGhlbjpcbiAgaWYgKGJpdExlbmd0aCA9PT0gNjQpIHtcbiAgICAvLyAxLiBMZXQgdXBwZXJCb3VuZCBiZSAyXjUzIOKIkiAxLlxuICAgIHVwcGVyQm91bmQgPSBNYXRoLnBvdygyLCA1MykgLSAxXG5cbiAgICAvLyAyLiBJZiBzaWduZWRuZXNzIGlzIFwidW5zaWduZWRcIiwgdGhlbiBsZXQgbG93ZXJCb3VuZCBiZSAwLlxuICAgIGlmIChzaWduZWRuZXNzID09PSAndW5zaWduZWQnKSB7XG4gICAgICBsb3dlckJvdW5kID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAzLiBPdGhlcndpc2UgbGV0IGxvd2VyQm91bmQgYmUg4oiSMl41MyArIDEuXG4gICAgICBsb3dlckJvdW5kID0gTWF0aC5wb3coLTIsIDUzKSArIDFcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2lnbmVkbmVzcyA9PT0gJ3Vuc2lnbmVkJykge1xuICAgIC8vIDIuIE90aGVyd2lzZSwgaWYgc2lnbmVkbmVzcyBpcyBcInVuc2lnbmVkXCIsIHRoZW46XG5cbiAgICAvLyAxLiBMZXQgbG93ZXJCb3VuZCBiZSAwLlxuICAgIGxvd2VyQm91bmQgPSAwXG5cbiAgICAvLyAyLiBMZXQgdXBwZXJCb3VuZCBiZSAyXmJpdExlbmd0aCDiiJIgMS5cbiAgICB1cHBlckJvdW5kID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKSAtIDFcbiAgfSBlbHNlIHtcbiAgICAvLyAzLiBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBMZXQgbG93ZXJCb3VuZCBiZSAtMl5iaXRMZW5ndGgg4oiSIDEuXG4gICAgbG93ZXJCb3VuZCA9IE1hdGgucG93KC0yLCBiaXRMZW5ndGgpIC0gMVxuXG4gICAgLy8gMi4gTGV0IHVwcGVyQm91bmQgYmUgMl5iaXRMZW5ndGgg4oiSIDEg4oiSIDEuXG4gICAgdXBwZXJCb3VuZCA9IE1hdGgucG93KDIsIGJpdExlbmd0aCAtIDEpIC0gMVxuICB9XG5cbiAgLy8gNC4gTGV0IHggYmUgPyBUb051bWJlcihWKS5cbiAgbGV0IHggPSBOdW1iZXIoVilcblxuICAvLyA1LiBJZiB4IGlzIOKIkjAsIHRoZW4gc2V0IHggdG8gKzAuXG4gIGlmICh4ID09PSAwKSB7XG4gICAgeCA9IDBcbiAgfVxuXG4gIC8vIDYuIElmIHRoZSBjb252ZXJzaW9uIGlzIHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0VuZm9yY2VSYW5nZV0gZXh0ZW5kZWQgYXR0cmlidXRlLCB0aGVuOlxuICBpZiAob3B0cz8uZW5mb3JjZVJhbmdlID09PSB0cnVlKSB7XG4gICAgLy8gMS4gSWYgeCBpcyBOYU4sICviiJ4sIG9yIOKIkuKIniwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoXG4gICAgICBOdW1iZXIuaXNOYU4oeCkgfHxcbiAgICAgIHggPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fFxuICAgICAgeCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ0ludGVnZXIgY29udmVyc2lvbicsXG4gICAgICAgIG1lc3NhZ2U6IGBDb3VsZCBub3QgY29udmVydCAke3dlYmlkbC51dGlsLlN0cmluZ2lmeShWKX0gdG8gYW4gaW50ZWdlci5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIFNldCB4IHRvIEludGVnZXJQYXJ0KHgpLlxuICAgIHggPSB3ZWJpZGwudXRpbC5JbnRlZ2VyUGFydCh4KVxuXG4gICAgLy8gMy4gSWYgeCA8IGxvd2VyQm91bmQgb3IgeCA+IHVwcGVyQm91bmQsIHRoZW5cbiAgICAvLyAgICB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoeCA8IGxvd2VyQm91bmQgfHwgeCA+IHVwcGVyQm91bmQpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnSW50ZWdlciBjb252ZXJzaW9uJyxcbiAgICAgICAgbWVzc2FnZTogYFZhbHVlIG11c3QgYmUgYmV0d2VlbiAke2xvd2VyQm91bmR9LSR7dXBwZXJCb3VuZH0sIGdvdCAke3h9LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gNC4gUmV0dXJuIHguXG4gICAgcmV0dXJuIHhcbiAgfVxuXG4gIC8vIDcuIElmIHggaXMgbm90IE5hTiBhbmQgdGhlIGNvbnZlcnNpb24gaXMgdG8gYW4gSURMXG4gIC8vICAgIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBbQ2xhbXBdIGV4dGVuZGVkXG4gIC8vICAgIGF0dHJpYnV0ZSwgdGhlbjpcbiAgaWYgKCFOdW1iZXIuaXNOYU4oeCkgJiYgb3B0cz8uY2xhbXAgPT09IHRydWUpIHtcbiAgICAvLyAxLiBTZXQgeCB0byBtaW4obWF4KHgsIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKS5cbiAgICB4ID0gTWF0aC5taW4oTWF0aC5tYXgoeCwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpXG5cbiAgICAvLyAyLiBSb3VuZCB4IHRvIHRoZSBuZWFyZXN0IGludGVnZXIsIGNob29zaW5nIHRoZVxuICAgIC8vICAgIGV2ZW4gaW50ZWdlciBpZiBpdCBsaWVzIGhhbGZ3YXkgYmV0d2VlbiB0d28sXG4gICAgLy8gICAgYW5kIGNob29zaW5nICswIHJhdGhlciB0aGFuIOKIkjAuXG4gICAgaWYgKE1hdGguZmxvb3IoeCkgJSAyID09PSAwKSB7XG4gICAgICB4ID0gTWF0aC5mbG9vcih4KVxuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gTWF0aC5jZWlsKHgpXG4gICAgfVxuXG4gICAgLy8gMy4gUmV0dXJuIHguXG4gICAgcmV0dXJuIHhcbiAgfVxuXG4gIC8vIDguIElmIHggaXMgTmFOLCArMCwgK+KIniwgb3Ig4oiS4oieLCB0aGVuIHJldHVybiArMC5cbiAgaWYgKFxuICAgIE51bWJlci5pc05hTih4KSB8fFxuICAgICh4ID09PSAwICYmIE9iamVjdC5pcygwLCB4KSkgfHxcbiAgICB4ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHxcbiAgICB4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8vIDkuIFNldCB4IHRvIEludGVnZXJQYXJ0KHgpLlxuICB4ID0gd2ViaWRsLnV0aWwuSW50ZWdlclBhcnQoeClcblxuICAvLyAxMC4gU2V0IHggdG8geCBtb2R1bG8gMl5iaXRMZW5ndGguXG4gIHggPSB4ICUgTWF0aC5wb3coMiwgYml0TGVuZ3RoKVxuXG4gIC8vIDExLiBJZiBzaWduZWRuZXNzIGlzIFwic2lnbmVkXCIgYW5kIHgg4omlIDJeYml0TGVuZ3RoIOKIkiAxLFxuICAvLyAgICB0aGVuIHJldHVybiB4IOKIkiAyXmJpdExlbmd0aC5cbiAgaWYgKHNpZ25lZG5lc3MgPT09ICdzaWduZWQnICYmIHggPj0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKSAtIDEpIHtcbiAgICByZXR1cm4geCAtIE1hdGgucG93KDIsIGJpdExlbmd0aClcbiAgfVxuXG4gIC8vIDEyLiBPdGhlcndpc2UsIHJldHVybiB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Fic3RyYWN0LW9wZGVmLWludGVnZXJwYXJ0XG53ZWJpZGwudXRpbC5JbnRlZ2VyUGFydCA9IGZ1bmN0aW9uIChuKSB7XG4gIC8vIDEuIExldCByIGJlIGZsb29yKGFicyhuKSkuXG4gIGNvbnN0IHIgPSBNYXRoLmZsb29yKE1hdGguYWJzKG4pKVxuXG4gIC8vIDIuIElmIG4gPCAwLCB0aGVuIHJldHVybiAtMSDDlyByLlxuICBpZiAobiA8IDApIHtcbiAgICByZXR1cm4gLTEgKiByXG4gIH1cblxuICAvLyAzLiBPdGhlcndpc2UsIHJldHVybiByLlxuICByZXR1cm4gclxufVxuXG53ZWJpZGwudXRpbC5TdHJpbmdpZnkgPSBmdW5jdGlvbiAoVikge1xuICBjb25zdCB0eXBlID0gd2ViaWRsLnV0aWwuVHlwZShWKVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU1lNQk9MOlxuICAgICAgcmV0dXJuIGBTeW1ib2woJHtWLmRlc2NyaXB0aW9ufSlgXG4gICAgY2FzZSBPQkpFQ1Q6XG4gICAgICByZXR1cm4gaW5zcGVjdChWKVxuICAgIGNhc2UgU1RSSU5HOlxuICAgICAgcmV0dXJuIGBcIiR7Vn1cImBcbiAgICBjYXNlIEJJR0lOVDpcbiAgICAgIHJldHVybiBgJHtWfW5gXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBgJHtWfWBcbiAgfVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXNlcXVlbmNlXG53ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoY29udmVydGVyKSB7XG4gIHJldHVybiAoViwgcHJlZml4LCBhcmd1bWVudCwgSXRlcmFibGUpID0+IHtcbiAgICAvLyAxLiBJZiBUeXBlKFYpIGlzIG5vdCBPYmplY3QsIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSBPQkpFQ1QpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6IGAke2FyZ3VtZW50fSAoJHt3ZWJpZGwudXRpbC5TdHJpbmdpZnkoVil9KSBpcyBub3QgaXRlcmFibGUuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgbWV0aG9kIGJlID8gR2V0TWV0aG9kKFYsIEBAaXRlcmF0b3IpLlxuICAgIC8qKiBAdHlwZSB7R2VuZXJhdG9yfSAqL1xuICAgIGNvbnN0IG1ldGhvZCA9IHR5cGVvZiBJdGVyYWJsZSA9PT0gJ2Z1bmN0aW9uJyA/IEl0ZXJhYmxlKCkgOiBWPy5bU3ltYm9sLml0ZXJhdG9yXT8uKClcbiAgICBjb25zdCBzZXEgPSBbXVxuICAgIGxldCBpbmRleCA9IDBcblxuICAgIC8vIDMuIElmIG1ldGhvZCBpcyB1bmRlZmluZWQsIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChcbiAgICAgIG1ldGhvZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0eXBlb2YgbWV0aG9kLm5leHQgIT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6IGAke2FyZ3VtZW50fSBpcyBub3QgaXRlcmFibGUuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2NyZWF0ZS1zZXF1ZW5jZS1mcm9tLWl0ZXJhYmxlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IG1ldGhvZC5uZXh0KClcblxuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgc2VxLnB1c2goY29udmVydGVyKHZhbHVlLCBwcmVmaXgsIGAke2FyZ3VtZW50fVske2luZGV4Kyt9XWApKVxuICAgIH1cblxuICAgIHJldHVybiBzZXFcbiAgfVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXRvLXJlY29yZFxud2ViaWRsLnJlY29yZENvbnZlcnRlciA9IGZ1bmN0aW9uIChrZXlDb252ZXJ0ZXIsIHZhbHVlQ29udmVydGVyKSB7XG4gIHJldHVybiAoTywgcHJlZml4LCBhcmd1bWVudCkgPT4ge1xuICAgIC8vIDEuIElmIFR5cGUoTykgaXMgbm90IE9iamVjdCwgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHdlYmlkbC51dGlsLlR5cGUoTykgIT09IE9CSkVDVCkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogYCR7YXJndW1lbnR9IChcIiR7d2ViaWRsLnV0aWwuVHlwZVZhbHVlVG9TdHJpbmcoTyl9XCIpIGlzIG5vdCBhbiBPYmplY3QuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgcmVzdWx0IGJlIGEgbmV3IGVtcHR5IGluc3RhbmNlIG9mIHJlY29yZDxLLCBWPi5cbiAgICBjb25zdCByZXN1bHQgPSB7fVxuXG4gICAgaWYgKCF0eXBlcy5pc1Byb3h5KE8pKSB7XG4gICAgICAvLyAxLiBMZXQgZGVzYyBiZSA/IE8uW1tHZXRPd25Qcm9wZXJ0eV1dKGtleSkuXG4gICAgICBjb25zdCBrZXlzID0gWy4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pLCAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXVxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGNvbnN0IGtleU5hbWUgPSB3ZWJpZGwudXRpbC5TdHJpbmdpZnkoa2V5KVxuXG4gICAgICAgIC8vIDEuIExldCB0eXBlZEtleSBiZSBrZXkgY29udmVydGVkIHRvIGFuIElETCB2YWx1ZSBvZiB0eXBlIEsuXG4gICAgICAgIGNvbnN0IHR5cGVkS2V5ID0ga2V5Q29udmVydGVyKGtleSwgcHJlZml4LCBgS2V5ICR7a2V5TmFtZX0gaW4gJHthcmd1bWVudH1gKVxuXG4gICAgICAgIC8vIDIuIExldCB2YWx1ZSBiZSA/IEdldChPLCBrZXkpLlxuICAgICAgICAvLyAzLiBMZXQgdHlwZWRWYWx1ZSBiZSB2YWx1ZSBjb252ZXJ0ZWQgdG8gYW4gSURMIHZhbHVlIG9mIHR5cGUgVi5cbiAgICAgICAgY29uc3QgdHlwZWRWYWx1ZSA9IHZhbHVlQ29udmVydGVyKE9ba2V5XSwgcHJlZml4LCBgJHthcmd1bWVudH1bJHtrZXlOYW1lfV1gKVxuXG4gICAgICAgIC8vIDQuIFNldCByZXN1bHRbdHlwZWRLZXldIHRvIHR5cGVkVmFsdWUuXG4gICAgICAgIHJlc3VsdFt0eXBlZEtleV0gPSB0eXBlZFZhbHVlXG4gICAgICB9XG5cbiAgICAgIC8vIDUuIFJldHVybiByZXN1bHQuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IGtleXMgYmUgPyBPLltbT3duUHJvcGVydHlLZXlzXV0oKS5cbiAgICBjb25zdCBrZXlzID0gUmVmbGVjdC5vd25LZXlzKE8pXG5cbiAgICAvLyA0LiBGb3IgZWFjaCBrZXkgb2Yga2V5cy5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAvLyAxLiBMZXQgZGVzYyBiZSA/IE8uW1tHZXRPd25Qcm9wZXJ0eV1dKGtleSkuXG4gICAgICBjb25zdCBkZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywga2V5KVxuXG4gICAgICAvLyAyLiBJZiBkZXNjIGlzIG5vdCB1bmRlZmluZWQgYW5kIGRlc2MuW1tFbnVtZXJhYmxlXV0gaXMgdHJ1ZTpcbiAgICAgIGlmIChkZXNjPy5lbnVtZXJhYmxlKSB7XG4gICAgICAgIC8vIDEuIExldCB0eXBlZEtleSBiZSBrZXkgY29udmVydGVkIHRvIGFuIElETCB2YWx1ZSBvZiB0eXBlIEsuXG4gICAgICAgIGNvbnN0IHR5cGVkS2V5ID0ga2V5Q29udmVydGVyKGtleSwgcHJlZml4LCBhcmd1bWVudClcblxuICAgICAgICAvLyAyLiBMZXQgdmFsdWUgYmUgPyBHZXQoTywga2V5KS5cbiAgICAgICAgLy8gMy4gTGV0IHR5cGVkVmFsdWUgYmUgdmFsdWUgY29udmVydGVkIHRvIGFuIElETCB2YWx1ZSBvZiB0eXBlIFYuXG4gICAgICAgIGNvbnN0IHR5cGVkVmFsdWUgPSB2YWx1ZUNvbnZlcnRlcihPW2tleV0sIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgICAgICAgLy8gNC4gU2V0IHJlc3VsdFt0eXBlZEtleV0gdG8gdHlwZWRWYWx1ZS5cbiAgICAgICAgcmVzdWx0W3R5cGVkS2V5XSA9IHR5cGVkVmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LiBSZXR1cm4gcmVzdWx0LlxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG53ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyID0gZnVuY3Rpb24gKFR5cGVDaGVjaywgbmFtZSkge1xuICByZXR1cm4gKFYsIHByZWZpeCwgYXJndW1lbnQpID0+IHtcbiAgICBpZiAoIVR5cGVDaGVjayhWKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICR7YXJndW1lbnR9IChcIiR7d2ViaWRsLnV0aWwuU3RyaW5naWZ5KFYpfVwiKSB0byBiZSBhbiBpbnN0YW5jZSBvZiAke25hbWV9LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIFZcbiAgfVxufVxuXG53ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlciA9IGZ1bmN0aW9uIChjb252ZXJ0ZXJzKSB7XG4gIHJldHVybiAoZGljdGlvbmFyeSwgcHJlZml4LCBhcmd1bWVudCkgPT4ge1xuICAgIGNvbnN0IGRpY3QgPSB7fVxuXG4gICAgaWYgKGRpY3Rpb25hcnkgIT0gbnVsbCAmJiB3ZWJpZGwudXRpbC5UeXBlKGRpY3Rpb25hcnkpICE9PSBPQkpFQ1QpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCAke2RpY3Rpb25hcnl9IHRvIGJlIG9uZSBvZjogTnVsbCwgVW5kZWZpbmVkLCBPYmplY3QuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2YgY29udmVydGVycykge1xuICAgICAgY29uc3QgeyBrZXksIGRlZmF1bHRWYWx1ZSwgcmVxdWlyZWQsIGNvbnZlcnRlciB9ID0gb3B0aW9uc1xuXG4gICAgICBpZiAocmVxdWlyZWQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKGRpY3Rpb25hcnkgPT0gbnVsbCB8fCAhT2JqZWN0Lmhhc093bihkaWN0aW9uYXJ5LCBrZXkpKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgICAgICBtZXNzYWdlOiBgTWlzc2luZyByZXF1aXJlZCBrZXkgXCIke2tleX1cIi5gXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgdmFsdWUgPSBkaWN0aW9uYXJ5Py5ba2V5XVxuICAgICAgY29uc3QgaGFzRGVmYXVsdCA9IGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkXG5cbiAgICAgIC8vIE9ubHkgdXNlIGRlZmF1bHRWYWx1ZSBpZiB2YWx1ZSBpcyB1bmRlZmluZWQgYW5kXG4gICAgICAvLyBhIGRlZmF1bHRWYWx1ZSBvcHRpb25zIHdhcyBwcm92aWRlZC5cbiAgICAgIGlmIChoYXNEZWZhdWx0ICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWUoKVxuICAgICAgfVxuXG4gICAgICAvLyBBIGtleSBjYW4gYmUgb3B0aW9uYWwgYW5kIGhhdmUgbm8gZGVmYXVsdCB2YWx1ZS5cbiAgICAgIC8vIFdoZW4gdGhpcyBoYXBwZW5zLCBkbyBub3QgcGVyZm9ybSBhIGNvbnZlcnNpb24sXG4gICAgICAvLyBhbmQgZG8gbm90IGFzc2lnbiB0aGUga2V5IGEgdmFsdWUuXG4gICAgICBpZiAocmVxdWlyZWQgfHwgaGFzRGVmYXVsdCB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gY29udmVydGVyKHZhbHVlLCBwcmVmaXgsIGAke2FyZ3VtZW50fS4ke2tleX1gKVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBvcHRpb25zLmFsbG93ZWRWYWx1ZXMgJiZcbiAgICAgICAgICAhb3B0aW9ucy5hbGxvd2VkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGAke3ZhbHVlfSBpcyBub3QgYW4gYWNjZXB0ZWQgdHlwZS4gRXhwZWN0ZWQgb25lIG9mICR7b3B0aW9ucy5hbGxvd2VkVmFsdWVzLmpvaW4oJywgJyl9LmBcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgZGljdFtrZXldID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGljdFxuICB9XG59XG5cbndlYmlkbC5udWxsYWJsZUNvbnZlcnRlciA9IGZ1bmN0aW9uIChjb252ZXJ0ZXIpIHtcbiAgcmV0dXJuIChWLCBwcmVmaXgsIGFyZ3VtZW50KSA9PiB7XG4gICAgaWYgKFYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBWXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlcnRlcihWLCBwcmVmaXgsIGFyZ3VtZW50KVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbndlYmlkbC5pcy5VU1ZTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgdmFsdWUuaXNXZWxsRm9ybWVkKClcbiAgKVxufVxuXG53ZWJpZGwuaXMuUmVhZGFibGVTdHJlYW0gPSB3ZWJpZGwudXRpbC5NYWtlVHlwZUFzc2VydGlvbihSZWFkYWJsZVN0cmVhbSlcbndlYmlkbC5pcy5CbG9iID0gd2ViaWRsLnV0aWwuTWFrZVR5cGVBc3NlcnRpb24oQmxvYilcbndlYmlkbC5pcy5VUkxTZWFyY2hQYXJhbXMgPSB3ZWJpZGwudXRpbC5NYWtlVHlwZUFzc2VydGlvbihVUkxTZWFyY2hQYXJhbXMpXG53ZWJpZGwuaXMuRmlsZSA9IHdlYmlkbC51dGlsLk1ha2VUeXBlQXNzZXJ0aW9uKGdsb2JhbFRoaXMuRmlsZSA/PyByZXF1aXJlKCdub2RlOmJ1ZmZlcicpLkZpbGUpXG53ZWJpZGwuaXMuVVJMID0gd2ViaWRsLnV0aWwuTWFrZVR5cGVBc3NlcnRpb24oVVJMKVxud2ViaWRsLmlzLkFib3J0U2lnbmFsID0gd2ViaWRsLnV0aWwuTWFrZVR5cGVBc3NlcnRpb24oQWJvcnRTaWduYWwpXG53ZWJpZGwuaXMuTWVzc2FnZVBvcnQgPSB3ZWJpZGwudXRpbC5NYWtlVHlwZUFzc2VydGlvbihNZXNzYWdlUG9ydClcblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1ET01TdHJpbmdcbndlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50LCBvcHRzKSB7XG4gIC8vIDEuIElmIFYgaXMgbnVsbCBhbmQgdGhlIGNvbnZlcnNpb24gaXMgdG8gYW4gSURMIHR5cGVcbiAgLy8gICAgYXNzb2NpYXRlZCB3aXRoIHRoZSBbTGVnYWN5TnVsbFRvRW1wdHlTdHJpbmddXG4gIC8vICAgIGV4dGVuZGVkIGF0dHJpYnV0ZSwgdGhlbiByZXR1cm4gdGhlIERPTVN0cmluZyB2YWx1ZVxuICAvLyAgICB0aGF0IHJlcHJlc2VudHMgdGhlIGVtcHR5IHN0cmluZy5cbiAgaWYgKFYgPT09IG51bGwgJiYgb3B0cz8ubGVnYWN5TnVsbFRvRW1wdHlTdHJpbmcpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIDIuIExldCB4IGJlID8gVG9TdHJpbmcoVikuXG4gIGlmICh0eXBlb2YgViA9PT0gJ3N5bWJvbCcpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgIG1lc3NhZ2U6IGAke2FyZ3VtZW50fSBpcyBhIHN5bWJvbCwgd2hpY2ggY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIERPTVN0cmluZy5gXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIFJldHVybiB0aGUgSURMIERPTVN0cmluZyB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgdGhlXG4gIC8vICAgIHNhbWUgc2VxdWVuY2Ugb2YgY29kZSB1bml0cyBhcyB0aGUgb25lIHRoZVxuICAvLyAgICBFQ01BU2NyaXB0IFN0cmluZyB2YWx1ZSB4IHJlcHJlc2VudHMuXG4gIHJldHVybiBTdHJpbmcoVilcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1CeXRlU3RyaW5nXG53ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBUb1N0cmluZyhWKS5cbiAgaWYgKHR5cGVvZiBWID09PSAnc3ltYm9sJykge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgbWVzc2FnZTogYCR7YXJndW1lbnR9IGlzIGEgc3ltYm9sLCB3aGljaCBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgQnl0ZVN0cmluZy5gXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHggPSBTdHJpbmcoVilcblxuICAvLyAyLiBJZiB0aGUgdmFsdWUgb2YgYW55IGVsZW1lbnQgb2YgeCBpcyBncmVhdGVyIHRoYW5cbiAgLy8gICAgMjU1LCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgeC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBpZiAoeC5jaGFyQ29kZUF0KGluZGV4KSA+IDI1NSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IHRvIGEgQnl0ZVN0cmluZyBiZWNhdXNlIHRoZSBjaGFyYWN0ZXIgYXQgJyArXG4gICAgICAgIGBpbmRleCAke2luZGV4fSBoYXMgYSB2YWx1ZSBvZiAke3guY2hhckNvZGVBdChpbmRleCl9IHdoaWNoIGlzIGdyZWF0ZXIgdGhhbiAyNTUuYFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8vIDMuIFJldHVybiBhbiBJREwgQnl0ZVN0cmluZyB2YWx1ZSB3aG9zZSBsZW5ndGggaXMgdGhlXG4gIC8vICAgIGxlbmd0aCBvZiB4LCBhbmQgd2hlcmUgdGhlIHZhbHVlIG9mIGVhY2ggZWxlbWVudCBpc1xuICAvLyAgICB0aGUgdmFsdWUgb2YgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBvZiB4LlxuICByZXR1cm4geFxufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiBAc2VlIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtVVNWU3RyaW5nXG4gKi9cbndlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAvLyBUT0RPOiByZXdyaXRlIHRoaXMgc28gd2UgY2FuIGNvbnRyb2wgdGhlIGVycm9ycyB0aHJvd25cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUudG9XZWxsRm9ybWVkKClcbiAgfVxuICByZXR1cm4gYCR7dmFsdWV9YC50b1dlbGxGb3JtZWQoKVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLWJvb2xlYW5cbndlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4gPSBmdW5jdGlvbiAoVikge1xuICAvLyAxLiBMZXQgeCBiZSB0aGUgcmVzdWx0IG9mIGNvbXB1dGluZyBUb0Jvb2xlYW4oVikuXG4gIC8vIGh0dHBzOi8vMjYyLmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvMTAuMC9pbmRleC5odG1sI3RhYmxlLTEwXG4gIGNvbnN0IHggPSBCb29sZWFuKFYpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgYm9vbGVhbiB2YWx1ZSB0aGF0IGlzIHRoZSBvbmUgdGhhdCByZXByZXNlbnRzXG4gIC8vICAgIHRoZSBzYW1lIHRydXRoIHZhbHVlIGFzIHRoZSBFQ01BU2NyaXB0IEJvb2xlYW4gdmFsdWUgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1hbnlcbndlYmlkbC5jb252ZXJ0ZXJzLmFueSA9IGZ1bmN0aW9uIChWKSB7XG4gIHJldHVybiBWXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtbG9uZy1sb25nXG53ZWJpZGwuY29udmVydGVyc1snbG9uZyBsb25nJ10gPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICAvLyAxLiBMZXQgeCBiZSA/IENvbnZlcnRUb0ludChWLCA2NCwgXCJzaWduZWRcIikuXG4gIGNvbnN0IHggPSB3ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQoViwgNjQsICdzaWduZWQnLCB1bmRlZmluZWQsIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgbG9uZyBsb25nIHZhbHVlIHRoYXQgcmVwcmVzZW50c1xuICAvLyAgICB0aGUgc2FtZSBudW1lcmljIHZhbHVlIGFzIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtdW5zaWduZWQtbG9uZy1sb25nXG53ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyBsb25nJ10gPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICAvLyAxLiBMZXQgeCBiZSA/IENvbnZlcnRUb0ludChWLCA2NCwgXCJ1bnNpZ25lZFwiKS5cbiAgY29uc3QgeCA9IHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludChWLCA2NCwgJ3Vuc2lnbmVkJywgdW5kZWZpbmVkLCBwcmVmaXgsIGFyZ3VtZW50KVxuXG4gIC8vIDIuIFJldHVybiB0aGUgSURMIHVuc2lnbmVkIGxvbmcgbG9uZyB2YWx1ZSB0aGF0XG4gIC8vICAgIHJlcHJlc2VudHMgdGhlIHNhbWUgbnVtZXJpYyB2YWx1ZSBhcyB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXVuc2lnbmVkLWxvbmdcbndlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nJ10gPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICAvLyAxLiBMZXQgeCBiZSA/IENvbnZlcnRUb0ludChWLCAzMiwgXCJ1bnNpZ25lZFwiKS5cbiAgY29uc3QgeCA9IHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludChWLCAzMiwgJ3Vuc2lnbmVkJywgdW5kZWZpbmVkLCBwcmVmaXgsIGFyZ3VtZW50KVxuXG4gIC8vIDIuIFJldHVybiB0aGUgSURMIHVuc2lnbmVkIGxvbmcgdmFsdWUgdGhhdFxuICAvLyAgICByZXByZXNlbnRzIHRoZSBzYW1lIG51bWVyaWMgdmFsdWUgYXMgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy11bnNpZ25lZC1zaG9ydFxud2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIHNob3J0J10gPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCwgb3B0cykge1xuICAvLyAxLiBMZXQgeCBiZSA/IENvbnZlcnRUb0ludChWLCAxNiwgXCJ1bnNpZ25lZFwiKS5cbiAgY29uc3QgeCA9IHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludChWLCAxNiwgJ3Vuc2lnbmVkJywgb3B0cywgcHJlZml4LCBhcmd1bWVudClcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCB1bnNpZ25lZCBzaG9ydCB2YWx1ZSB0aGF0IHJlcHJlc2VudHNcbiAgLy8gICAgdGhlIHNhbWUgbnVtZXJpYyB2YWx1ZSBhcyB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2lkbC1BcnJheUJ1ZmZlclxud2ViaWRsLmNvbnZlcnRlcnMuQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCwgb3B0cykge1xuICAvLyAxLiBJZiBUeXBlKFYpIGlzIG5vdCBPYmplY3QsIG9yIFYgZG9lcyBub3QgaGF2ZSBhblxuICAvLyAgICBbW0FycmF5QnVmZmVyRGF0YV1dIGludGVybmFsIHNsb3QsIHRoZW4gdGhyb3cgYVxuICAvLyAgICBUeXBlRXJyb3IuXG4gIC8vIHNlZTogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1hcnJheWJ1ZmZlci1pbnN0YW5jZXNcbiAgLy8gc2VlOiBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLXNoYXJlZGFycmF5YnVmZmVyLWluc3RhbmNlc1xuICBpZiAoXG4gICAgd2ViaWRsLnV0aWwuVHlwZShWKSAhPT0gT0JKRUNUIHx8XG4gICAgIXR5cGVzLmlzQW55QXJyYXlCdWZmZXIoVilcbiAgKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICAgIHByZWZpeCxcbiAgICAgIGFyZ3VtZW50OiBgJHthcmd1bWVudH0gKFwiJHt3ZWJpZGwudXRpbC5TdHJpbmdpZnkoVil9XCIpYCxcbiAgICAgIHR5cGVzOiBbJ0FycmF5QnVmZmVyJ11cbiAgICB9KVxuICB9XG5cbiAgLy8gMi4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93U2hhcmVkXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1NoYXJlZEFycmF5QnVmZmVyKFYpIGlzIHRydWUsIHRoZW4gdGhyb3cgYVxuICAvLyAgICBUeXBlRXJyb3IuXG4gIGlmIChvcHRzPy5hbGxvd1NoYXJlZCA9PT0gZmFsc2UgJiYgdHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYWxsb3dlZC4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1Jlc2l6YWJsZV0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNSZXNpemFibGVBcnJheUJ1ZmZlcihWKSBpcyB0cnVlLCB0aGVuIHRocm93IGFcbiAgLy8gICAgVHlwZUVycm9yLlxuICBpZiAoVi5yZXNpemFibGUgfHwgVi5ncm93YWJsZSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdSZWNlaXZlZCBhIHJlc2l6YWJsZSBBcnJheUJ1ZmZlci4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDQuIFJldHVybiB0aGUgSURMIEFycmF5QnVmZmVyIHZhbHVlIHRoYXQgaXMgYVxuICAvLyAgICByZWZlcmVuY2UgdG8gdGhlIHNhbWUgb2JqZWN0IGFzIFYuXG4gIHJldHVybiBWXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlR5cGVkQXJyYXkgPSBmdW5jdGlvbiAoViwgVCwgcHJlZml4LCBuYW1lLCBvcHRzKSB7XG4gIC8vIDEuIExldCBUIGJlIHRoZSBJREwgdHlwZSBWIGlzIGJlaW5nIGNvbnZlcnRlZCB0by5cblxuICAvLyAyLiBJZiBUeXBlKFYpIGlzIG5vdCBPYmplY3QsIG9yIFYgZG9lcyBub3QgaGF2ZSBhXG4gIC8vICAgIFtbVHlwZWRBcnJheU5hbWVdXSBpbnRlcm5hbCBzbG90IHdpdGggYSB2YWx1ZVxuICAvLyAgICBlcXVhbCB0byBU4oCZcyBuYW1lLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAoXG4gICAgd2ViaWRsLnV0aWwuVHlwZShWKSAhPT0gT0JKRUNUIHx8XG4gICAgIXR5cGVzLmlzVHlwZWRBcnJheShWKSB8fFxuICAgIFYuY29uc3RydWN0b3IubmFtZSAhPT0gVC5uYW1lXG4gICkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICBwcmVmaXgsXG4gICAgICBhcmd1bWVudDogYCR7bmFtZX0gKFwiJHt3ZWJpZGwudXRpbC5TdHJpbmdpZnkoVil9XCIpYCxcbiAgICAgIHR5cGVzOiBbVC5uYW1lXVxuICAgIH0pXG4gIH1cblxuICAvLyAzLiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dTaGFyZWRdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzU2hhcmVkQXJyYXlCdWZmZXIoVi5bW1ZpZXdlZEFycmF5QnVmZmVyXV0pIGlzXG4gIC8vICAgIHRydWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChvcHRzPy5hbGxvd1NoYXJlZCA9PT0gZmFsc2UgJiYgdHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWLmJ1ZmZlcikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6ICdBcnJheUJ1ZmZlcicsXG4gICAgICBtZXNzYWdlOiAnU2hhcmVkQXJyYXlCdWZmZXIgaXMgbm90IGFsbG93ZWQuJ1xuICAgIH0pXG4gIH1cblxuICAvLyA0LiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dSZXNpemFibGVdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzUmVzaXphYmxlQXJyYXlCdWZmZXIoVi5bW1ZpZXdlZEFycmF5QnVmZmVyXV0pIGlzXG4gIC8vICAgIHRydWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChWLmJ1ZmZlci5yZXNpemFibGUgfHwgVi5idWZmZXIuZ3Jvd2FibGUpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6ICdBcnJheUJ1ZmZlcicsXG4gICAgICBtZXNzYWdlOiAnUmVjZWl2ZWQgYSByZXNpemFibGUgQXJyYXlCdWZmZXIuJ1xuICAgIH0pXG4gIH1cblxuICAvLyA1LiBSZXR1cm4gdGhlIElETCB2YWx1ZSBvZiB0eXBlIFQgdGhhdCBpcyBhIHJlZmVyZW5jZVxuICAvLyAgICB0byB0aGUgc2FtZSBvYmplY3QgYXMgVi5cbiAgcmV0dXJuIFZcbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuRGF0YVZpZXcgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBuYW1lLCBvcHRzKSB7XG4gIC8vIDEuIElmIFR5cGUoVikgaXMgbm90IE9iamVjdCwgb3IgViBkb2VzIG5vdCBoYXZlIGFcbiAgLy8gICAgW1tEYXRhVmlld11dIGludGVybmFsIHNsb3QsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSBPQkpFQ1QgfHwgIXR5cGVzLmlzRGF0YVZpZXcoVikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgIG1lc3NhZ2U6IGAke25hbWV9IGlzIG5vdCBhIERhdGFWaWV3LmBcbiAgICB9KVxuICB9XG5cbiAgLy8gMi4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93U2hhcmVkXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1NoYXJlZEFycmF5QnVmZmVyKFYuW1tWaWV3ZWRBcnJheUJ1ZmZlcl1dKSBpcyB0cnVlLFxuICAvLyAgICB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAob3B0cz8uYWxsb3dTaGFyZWQgPT09IGZhbHNlICYmIHR5cGVzLmlzU2hhcmVkQXJyYXlCdWZmZXIoVi5idWZmZXIpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiAnQXJyYXlCdWZmZXInLFxuICAgICAgbWVzc2FnZTogJ1NoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhbGxvd2VkLidcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93UmVzaXphYmxlXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1Jlc2l6YWJsZUFycmF5QnVmZmVyKFYuW1tWaWV3ZWRBcnJheUJ1ZmZlcl1dKSBpc1xuICAvLyAgICB0cnVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAoVi5idWZmZXIucmVzaXphYmxlIHx8IFYuYnVmZmVyLmdyb3dhYmxlKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiAnQXJyYXlCdWZmZXInLFxuICAgICAgbWVzc2FnZTogJ1JlY2VpdmVkIGEgcmVzaXphYmxlIEFycmF5QnVmZmVyLidcbiAgICB9KVxuICB9XG5cbiAgLy8gNC4gUmV0dXJuIHRoZSBJREwgRGF0YVZpZXcgdmFsdWUgdGhhdCBpcyBhIHJlZmVyZW5jZVxuICAvLyAgICB0byB0aGUgc2FtZSBvYmplY3QgYXMgVi5cbiAgcmV0dXJuIFZcbn1cblxud2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPEJ5dGVTdHJpbmc+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmdcbilcblxud2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8Qnl0ZVN0cmluZz4nXVxuKVxuXG53ZWJpZGwuY29udmVydGVyc1sncmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+J10gPSB3ZWJpZGwucmVjb3JkQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nLFxuICB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkJsb2IgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKHdlYmlkbC5pcy5CbG9iLCAnQmxvYicpXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkFib3J0U2lnbmFsID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgd2ViaWRsLmlzLkFib3J0U2lnbmFsLFxuICAnQWJvcnRTaWduYWwnXG4pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3ZWJpZGxcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/webidl/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/connection.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/connection.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst { parseExtensions, isClosed, isClosing, isEstablished, validateCloseCodeAndReason } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/websocket/util.js\")\nconst { channels } = __webpack_require__(/*! ../../core/diagnostics */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\nconst { makeRequest } = __webpack_require__(/*! ../fetch/request */ \"(rsc)/./node_modules/undici/lib/web/fetch/request.js\")\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(rsc)/./node_modules/undici/lib/web/fetch/index.js\")\nconst { Headers, getHeadersList } = __webpack_require__(/*! ../fetch/headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\")\nconst { getDecodeSplit } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(rsc)/./node_modules/undici/lib/web/websocket/frame.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\")\n/* c8 ignore next 3 */\n} catch {\n\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').Handler} handler\n * @param {Partial<import('../../../types/websocket').WebSocketInit>} options\n */\nfunction establishWebSocketConnection (url, protocols, client, handler, options) {\n  // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if urls\n  //    scheme is \"ws\", and to \"https\" otherwise.\n  const requestURL = url\n\n  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:'\n\n  // 2. Let request be a new request, whose URL is requestURL, client is client,\n  //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n  //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n  //    and redirect mode is \"error\".\n  const request = makeRequest({\n    urlList: [requestURL],\n    client,\n    serviceWorkers: 'none',\n    referrer: 'no-referrer',\n    mode: 'websocket',\n    credentials: 'include',\n    cache: 'no-store',\n    redirect: 'error'\n  })\n\n  // Note: undici extension, allow setting custom headers.\n  if (options.headers) {\n    const headersList = getHeadersList(new Headers(options.headers))\n\n    request.headersList = headersList\n  }\n\n  // 3. Append (`Upgrade`, `websocket`) to requests header list.\n  // 4. Append (`Connection`, `Upgrade`) to requests header list.\n  // Note: both of these are handled by undici currently.\n  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n\n  // 5. Let keyValue be a nonce consisting of a randomly selected\n  //    16-byte value that has been forgiving-base64-encoded and\n  //    isomorphic encoded.\n  const keyValue = crypto.randomBytes(16).toString('base64')\n\n  // 6. Append (`Sec-WebSocket-Key`, keyValue) to requests\n  //    header list.\n  request.headersList.append('sec-websocket-key', keyValue, true)\n\n  // 7. Append (`Sec-WebSocket-Version`, `13`) to requests\n  //    header list.\n  request.headersList.append('sec-websocket-version', '13', true)\n\n  // 8. For each protocol in protocols, combine\n  //    (`Sec-WebSocket-Protocol`, protocol) in requests header\n  //    list.\n  for (const protocol of protocols) {\n    request.headersList.append('sec-websocket-protocol', protocol, true)\n  }\n\n  // 9. Let permessageDeflate be a user-agent defined\n  //    \"permessage-deflate\" extension header value.\n  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n  const permessageDeflate = 'permessage-deflate; client_max_window_bits'\n\n  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n  //     requests header list.\n  request.headersList.append('sec-websocket-extensions', permessageDeflate, true)\n\n  // 11. Fetch request with useParallelQueue set to true, and\n  //     processResponse given response being these steps:\n  const controller = fetching({\n    request,\n    useParallelQueue: true,\n    dispatcher: options.dispatcher,\n    processResponse (response) {\n      if (response.type === 'error') {\n        // If the WebSocket connection could not be established, it is also said\n        // that _The WebSocket Connection is Closed_, but not _cleanly_.\n        handler.readyState = states.CLOSED\n      }\n\n      // 1. If response is a network error or its status is not 101,\n      //    fail the WebSocket connection.\n      if (response.type === 'error' || response.status !== 101) {\n        failWebsocketConnection(handler, 1002, 'Received network error or non-101 status code.', response.error)\n        return\n      }\n\n      // 2. If protocols is not the empty list and extracting header\n      //    list values given `Sec-WebSocket-Protocol` and responses\n      //    header list results in null, failure, or the empty byte\n      //    sequence, then fail the WebSocket connection.\n      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(handler, 1002, 'Server did not respond with sent protocols.')\n        return\n      }\n\n      // 3. Follow the requirements stated step 2 to step 6, inclusive,\n      //    of the last set of steps in section 4.1 of The WebSocket\n      //    Protocol to validate response. This either results in fail\n      //    the WebSocket connection or the WebSocket connection is\n      //    established.\n\n      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n      //    header field contains a value that is not an ASCII case-\n      //    insensitive match for the value \"websocket\", the client MUST\n      //    _Fail the WebSocket Connection_.\n      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {\n        failWebsocketConnection(handler, 1002, 'Server did not set Upgrade header to \"websocket\".')\n        return\n      }\n\n      // 3. If the response lacks a |Connection| header field or the\n      //    |Connection| header field doesn't contain a token that is an\n      //    ASCII case-insensitive match for the value \"Upgrade\", the client\n      //    MUST _Fail the WebSocket Connection_.\n      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {\n        failWebsocketConnection(handler, 1002, 'Server did not set Connection header to \"upgrade\".')\n        return\n      }\n\n      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n      //    the |Sec-WebSocket-Accept| contains a value other than the\n      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n      //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n      //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n      //    trailing whitespace, the client MUST _Fail the WebSocket\n      //    Connection_.\n      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept')\n      const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64')\n      if (secWSAccept !== digest) {\n        failWebsocketConnection(handler, 1002, 'Incorrect hash received in Sec-WebSocket-Accept header.')\n        return\n      }\n\n      // 5. If the response includes a |Sec-WebSocket-Extensions| header\n      //    field and this header field indicates the use of an extension\n      //    that was not present in the client's handshake (the server has\n      //    indicated an extension not requested by the client), the client\n      //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n      //    header field to determine which extensions are requested is\n      //    discussed in Section 9.1.)\n      const secExtension = response.headersList.get('Sec-WebSocket-Extensions')\n      let extensions\n\n      if (secExtension !== null) {\n        extensions = parseExtensions(secExtension)\n\n        if (!extensions.has('permessage-deflate')) {\n          failWebsocketConnection(handler, 1002, 'Sec-WebSocket-Extensions header does not match.')\n          return\n        }\n      }\n\n      // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n      //    and this header field indicates the use of a subprotocol that was\n      //    not present in the client's handshake (the server has indicated a\n      //    subprotocol not requested by the client), the client MUST _Fail\n      //    the WebSocket Connection_.\n      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol')\n\n      if (secProtocol !== null) {\n        const requestProtocols = getDecodeSplit('sec-websocket-protocol', request.headersList)\n\n        // The client can request that the server use a specific subprotocol by\n        // including the |Sec-WebSocket-Protocol| field in its handshake.  If it\n        // is specified, the server needs to include the same field and one of\n        // the selected subprotocol values in its response for the connection to\n        // be established.\n        if (!requestProtocols.includes(secProtocol)) {\n          failWebsocketConnection(handler, 1002, 'Protocol was not set in the opening handshake.')\n          return\n        }\n      }\n\n      response.socket.on('data', handler.onSocketData)\n      response.socket.on('close', handler.onSocketClose)\n      response.socket.on('error', handler.onSocketError)\n\n      if (channels.open.hasSubscribers) {\n        channels.open.publish({\n          address: response.socket.address(),\n          protocol: secProtocol,\n          extensions: secExtension\n        })\n      }\n\n      handler.wasEverConnected = true\n      handler.onConnectionEstablished(response, extensions)\n    }\n  })\n\n  return controller\n}\n\n/**\n * @see https://whatpr.org/websockets/48.html#close-the-websocket\n * @param {import('./websocket').Handler} object\n * @param {number} [code=null]\n * @param {string} [reason='']\n */\nfunction closeWebSocketConnection (object, code, reason, validate = false) {\n  // 1. If code was not supplied, let code be null.\n  code ??= null\n\n  // 2. If reason was not supplied, let reason be the empty string.\n  reason ??= ''\n\n  // 3. Validate close code and reason with code and reason.\n  if (validate) validateCloseCodeAndReason(code, reason)\n\n  // 4. Run the first matching steps from the following list:\n  //     - If objects ready state is CLOSING (2) or CLOSED (3)\n  //     - If the WebSocket connection is not yet established [WSP]\n  //     - If the WebSocket closing handshake has not yet been started [WSP]\n  //     - Otherwise\n  if (isClosed(object.readyState) || isClosing(object.readyState)) {\n    // Do nothing.\n  } else if (!isEstablished(object.readyState)) {\n    // Fail the WebSocket connection and set objects ready state to CLOSING (2). [WSP]\n    failWebsocketConnection(object)\n    object.readyState = states.CLOSING\n  } else if (!object.closeState.has(sentCloseFrameState.SENT) && !object.closeState.has(sentCloseFrameState.RECEIVED)) {\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n\n    const frame = new WebsocketFrameSend()\n\n    // If neither code nor reason is present, the WebSocket Close\n    // message must not have a body.\n\n    // If code is present, then the status code to use in the\n    // WebSocket Close message must be the integer given by code.\n    // If code is null and reason is the empty string, the WebSocket Close frame must not have a body.\n    // If reason is non-empty but code is null, then set code to 1000 (\"Normal Closure\").\n    if (reason.length !== 0 && code === null) {\n      code = 1000\n    }\n\n    // If code is set, then the status code to use in the WebSocket Close frame must be the integer given by code.\n    assert(code === null || Number.isInteger(code))\n\n    if (code === null && reason.length === 0) {\n      frame.frameData = emptyBuffer\n    } else if (code !== null && reason === null) {\n      frame.frameData = Buffer.allocUnsafe(2)\n      frame.frameData.writeUInt16BE(code, 0)\n    } else if (code !== null && reason !== null) {\n      // If reason is also present, then reasonBytes must be\n      // provided in the Close message after the status code.\n      frame.frameData = Buffer.allocUnsafe(2 + Buffer.byteLength(reason))\n      frame.frameData.writeUInt16BE(code, 0)\n      // the body MAY contain UTF-8-encoded data with value /reason/\n      frame.frameData.write(reason, 2, 'utf-8')\n    } else {\n      frame.frameData = emptyBuffer\n    }\n\n    object.socket.write(frame.createFrame(opcodes.CLOSE))\n\n    object.closeState.add(sentCloseFrameState.SENT)\n\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n    object.readyState = states.CLOSING\n  } else {\n    // Set objects ready state to CLOSING (2).\n    object.readyState = states.CLOSING\n  }\n}\n\n/**\n * @param {import('./websocket').Handler} handler\n * @param {number} code\n * @param {string|undefined} reason\n * @param {unknown} cause\n * @returns {void}\n */\nfunction failWebsocketConnection (handler, code, reason, cause) {\n  // If _The WebSocket Connection is Established_ prior to the point where\n  // the endpoint is required to _Fail the WebSocket Connection_, the\n  // endpoint SHOULD send a Close frame with an appropriate status code\n  // (Section 7.4) before proceeding to _Close the WebSocket Connection_.\n  if (isEstablished(handler.readyState)) {\n    closeWebSocketConnection(handler, code, reason, false)\n  }\n\n  handler.controller.abort()\n\n  if (handler.socket?.destroyed === false) {\n    handler.socket.destroy()\n  }\n\n  handler.onFail(code, reason, cause)\n}\n\nmodule.exports = {\n  establishWebSocketConnection,\n  failWebsocketConnection,\n  closeWebSocketConnection\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSx5REFBeUQsRUFBRSxtQkFBTyxDQUFDLCtFQUFhO0FBQ3hGLFFBQVEsa0ZBQWtGLEVBQUUsbUJBQU8sQ0FBQyxxRUFBUTtBQUM1RyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLG1GQUF3QjtBQUNyRCxRQUFRLGNBQWMsRUFBRSxtQkFBTyxDQUFDLDhFQUFrQjtBQUNsRCxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLDBFQUFnQjtBQUM3QyxRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsOEVBQWtCO0FBQzlELFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBZTtBQUNsRCxRQUFRLHFCQUFxQixFQUFFLG1CQUFPLENBQUMsdUVBQVM7QUFDaEQsZUFBZSxtQkFBTyxDQUFDLGdDQUFhOztBQUVwQyxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLGdDQUFhO0FBQ2hDO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsK0JBQStCO0FBQzFDLFdBQVcsMkRBQTJEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL3dlYnNvY2tldC9jb25uZWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHVpZCwgc3RhdGVzLCBzZW50Q2xvc2VGcmFtZVN0YXRlLCBlbXB0eUJ1ZmZlciwgb3Bjb2RlcyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBwYXJzZUV4dGVuc2lvbnMsIGlzQ2xvc2VkLCBpc0Nsb3NpbmcsIGlzRXN0YWJsaXNoZWQsIHZhbGlkYXRlQ2xvc2VDb2RlQW5kUmVhc29uIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBjaGFubmVscyB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kaWFnbm9zdGljcycpXG5jb25zdCB7IG1ha2VSZXF1ZXN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC9yZXF1ZXN0JylcbmNvbnN0IHsgZmV0Y2hpbmcgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2luZGV4JylcbmNvbnN0IHsgSGVhZGVycywgZ2V0SGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2hlYWRlcnMnKVxuY29uc3QgeyBnZXREZWNvZGVTcGxpdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvdXRpbCcpXG5jb25zdCB7IFdlYnNvY2tldEZyYW1lU2VuZCB9ID0gcmVxdWlyZSgnLi9mcmFtZScpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCdjcnlwdG8nKX0gKi9cbmxldCBjcnlwdG9cbnRyeSB7XG4gIGNyeXB0byA9IHJlcXVpcmUoJ25vZGU6Y3J5cHRvJylcbi8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbn0gY2F0Y2gge1xuXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXdlYnNvY2tldC1lc3RhYmxpc2hcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwcm90b2NvbHNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLkhhbmRsZXJ9IGhhbmRsZXJcbiAqIEBwYXJhbSB7UGFydGlhbDxpbXBvcnQoJy4uLy4uLy4uL3R5cGVzL3dlYnNvY2tldCcpLldlYlNvY2tldEluaXQ+fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24gKHVybCwgcHJvdG9jb2xzLCBjbGllbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgLy8gMS4gTGV0IHJlcXVlc3RVUkwgYmUgYSBjb3B5IG9mIHVybCwgd2l0aCBpdHMgc2NoZW1lIHNldCB0byBcImh0dHBcIiwgaWYgdXJs4oCZc1xuICAvLyAgICBzY2hlbWUgaXMgXCJ3c1wiLCBhbmQgdG8gXCJodHRwc1wiIG90aGVyd2lzZS5cbiAgY29uc3QgcmVxdWVzdFVSTCA9IHVybFxuXG4gIHJlcXVlc3RVUkwucHJvdG9jb2wgPSB1cmwucHJvdG9jb2wgPT09ICd3czonID8gJ2h0dHA6JyA6ICdodHRwczonXG5cbiAgLy8gMi4gTGV0IHJlcXVlc3QgYmUgYSBuZXcgcmVxdWVzdCwgd2hvc2UgVVJMIGlzIHJlcXVlc3RVUkwsIGNsaWVudCBpcyBjbGllbnQsXG4gIC8vICAgIHNlcnZpY2Utd29ya2VycyBtb2RlIGlzIFwibm9uZVwiLCByZWZlcnJlciBpcyBcIm5vLXJlZmVycmVyXCIsIG1vZGUgaXNcbiAgLy8gICAgXCJ3ZWJzb2NrZXRcIiwgY3JlZGVudGlhbHMgbW9kZSBpcyBcImluY2x1ZGVcIiwgY2FjaGUgbW9kZSBpcyBcIm5vLXN0b3JlXCIgLFxuICAvLyAgICBhbmQgcmVkaXJlY3QgbW9kZSBpcyBcImVycm9yXCIuXG4gIGNvbnN0IHJlcXVlc3QgPSBtYWtlUmVxdWVzdCh7XG4gICAgdXJsTGlzdDogW3JlcXVlc3RVUkxdLFxuICAgIGNsaWVudCxcbiAgICBzZXJ2aWNlV29ya2VyczogJ25vbmUnLFxuICAgIHJlZmVycmVyOiAnbm8tcmVmZXJyZXInLFxuICAgIG1vZGU6ICd3ZWJzb2NrZXQnLFxuICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgY2FjaGU6ICduby1zdG9yZScsXG4gICAgcmVkaXJlY3Q6ICdlcnJvcidcbiAgfSlcblxuICAvLyBOb3RlOiB1bmRpY2kgZXh0ZW5zaW9uLCBhbGxvdyBzZXR0aW5nIGN1c3RvbSBoZWFkZXJzLlxuICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgY29uc3QgaGVhZGVyc0xpc3QgPSBnZXRIZWFkZXJzTGlzdChuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpKVxuXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdCA9IGhlYWRlcnNMaXN0XG4gIH1cblxuICAvLyAzLiBBcHBlbmQgKGBVcGdyYWRlYCwgYHdlYnNvY2tldGApIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAvLyA0LiBBcHBlbmQgKGBDb25uZWN0aW9uYCwgYFVwZ3JhZGVgKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgLy8gTm90ZTogYm90aCBvZiB0aGVzZSBhcmUgaGFuZGxlZCBieSB1bmRpY2kgY3VycmVudGx5LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9ibG9iLzY4YzI2OWM0MTQ0YzQ0NmYzZjEyMjA5NTEzMzhkYWVmNGE2YjVlYzQvbGliL2NsaWVudC5qcyNMMTM5N1xuXG4gIC8vIDUuIExldCBrZXlWYWx1ZSBiZSBhIG5vbmNlIGNvbnNpc3Rpbmcgb2YgYSByYW5kb21seSBzZWxlY3RlZFxuICAvLyAgICAxNi1ieXRlIHZhbHVlIHRoYXQgaGFzIGJlZW4gZm9yZ2l2aW5nLWJhc2U2NC1lbmNvZGVkIGFuZFxuICAvLyAgICBpc29tb3JwaGljIGVuY29kZWQuXG4gIGNvbnN0IGtleVZhbHVlID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnYmFzZTY0JylcblxuICAvLyA2LiBBcHBlbmQgKGBTZWMtV2ViU29ja2V0LUtleWAsIGtleVZhbHVlKSB0byByZXF1ZXN04oCZc1xuICAvLyAgICBoZWFkZXIgbGlzdC5cbiAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3NlYy13ZWJzb2NrZXQta2V5Jywga2V5VmFsdWUsIHRydWUpXG5cbiAgLy8gNy4gQXBwZW5kIChgU2VjLVdlYlNvY2tldC1WZXJzaW9uYCwgYDEzYCkgdG8gcmVxdWVzdOKAmXNcbiAgLy8gICAgaGVhZGVyIGxpc3QuXG4gIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdzZWMtd2Vic29ja2V0LXZlcnNpb24nLCAnMTMnLCB0cnVlKVxuXG4gIC8vIDguIEZvciBlYWNoIHByb3RvY29sIGluIHByb3RvY29scywgY29tYmluZVxuICAvLyAgICAoYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgLCBwcm90b2NvbCkgaW4gcmVxdWVzdOKAmXMgaGVhZGVyXG4gIC8vICAgIGxpc3QuXG4gIGZvciAoY29uc3QgcHJvdG9jb2wgb2YgcHJvdG9jb2xzKSB7XG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnLCBwcm90b2NvbCwgdHJ1ZSlcbiAgfVxuXG4gIC8vIDkuIExldCBwZXJtZXNzYWdlRGVmbGF0ZSBiZSBhIHVzZXItYWdlbnQgZGVmaW5lZFxuICAvLyAgICBcInBlcm1lc3NhZ2UtZGVmbGF0ZVwiIGV4dGVuc2lvbiBoZWFkZXIgdmFsdWUuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2dlY2tvLWRldi9ibG9iL2NlNzgyMzRmNWU2NTNhNWQzOTE2ODEzZmY5OTBmMDUzNTEwMjI3YmMvbmV0d2Vyay9wcm90b2NvbC93ZWJzb2NrZXQvV2ViU29ja2V0Q2hhbm5lbC5jcHAjTDI2NzNcbiAgY29uc3QgcGVybWVzc2FnZURlZmxhdGUgPSAncGVybWVzc2FnZS1kZWZsYXRlOyBjbGllbnRfbWF4X3dpbmRvd19iaXRzJ1xuXG4gIC8vIDEwLiBBcHBlbmQgKGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgLCBwZXJtZXNzYWdlRGVmbGF0ZSkgdG9cbiAgLy8gICAgIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJywgcGVybWVzc2FnZURlZmxhdGUsIHRydWUpXG5cbiAgLy8gMTEuIEZldGNoIHJlcXVlc3Qgd2l0aCB1c2VQYXJhbGxlbFF1ZXVlIHNldCB0byB0cnVlLCBhbmRcbiAgLy8gICAgIHByb2Nlc3NSZXNwb25zZSBnaXZlbiByZXNwb25zZSBiZWluZyB0aGVzZSBzdGVwczpcbiAgY29uc3QgY29udHJvbGxlciA9IGZldGNoaW5nKHtcbiAgICByZXF1ZXN0LFxuICAgIHVzZVBhcmFsbGVsUXVldWU6IHRydWUsXG4gICAgZGlzcGF0Y2hlcjogb3B0aW9ucy5kaXNwYXRjaGVyLFxuICAgIHByb2Nlc3NSZXNwb25zZSAocmVzcG9uc2UpIHtcbiAgICAgIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQsIGl0IGlzIGFsc28gc2FpZFxuICAgICAgICAvLyB0aGF0IF9UaGUgV2ViU29ja2V0IENvbm5lY3Rpb24gaXMgQ2xvc2VkXywgYnV0IG5vdCBfY2xlYW5seV8uXG4gICAgICAgIGhhbmRsZXIucmVhZHlTdGF0ZSA9IHN0YXRlcy5DTE9TRURcbiAgICAgIH1cblxuICAgICAgLy8gMS4gSWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yIG9yIGl0cyBzdGF0dXMgaXMgbm90IDEwMSxcbiAgICAgIC8vICAgIGZhaWwgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicgfHwgcmVzcG9uc2Uuc3RhdHVzICE9PSAxMDEpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24oaGFuZGxlciwgMTAwMiwgJ1JlY2VpdmVkIG5ldHdvcmsgZXJyb3Igb3Igbm9uLTEwMSBzdGF0dXMgY29kZS4nLCByZXNwb25zZS5lcnJvcilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIHByb3RvY29scyBpcyBub3QgdGhlIGVtcHR5IGxpc3QgYW5kIGV4dHJhY3RpbmcgaGVhZGVyXG4gICAgICAvLyAgICBsaXN0IHZhbHVlcyBnaXZlbiBgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAgYW5kIHJlc3BvbnNl4oCZc1xuICAgICAgLy8gICAgaGVhZGVyIGxpc3QgcmVzdWx0cyBpbiBudWxsLCBmYWlsdXJlLCBvciB0aGUgZW1wdHkgYnl0ZVxuICAgICAgLy8gICAgc2VxdWVuY2UsIHRoZW4gZmFpbCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAgICBpZiAocHJvdG9jb2xzLmxlbmd0aCAhPT0gMCAmJiAhcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdTZWMtV2ViU29ja2V0LVByb3RvY29sJykpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24oaGFuZGxlciwgMTAwMiwgJ1NlcnZlciBkaWQgbm90IHJlc3BvbmQgd2l0aCBzZW50IHByb3RvY29scy4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMy4gRm9sbG93IHRoZSByZXF1aXJlbWVudHMgc3RhdGVkIHN0ZXAgMiB0byBzdGVwIDYsIGluY2x1c2l2ZSxcbiAgICAgIC8vICAgIG9mIHRoZSBsYXN0IHNldCBvZiBzdGVwcyBpbiBzZWN0aW9uIDQuMSBvZiBUaGUgV2ViU29ja2V0XG4gICAgICAvLyAgICBQcm90b2NvbCB0byB2YWxpZGF0ZSByZXNwb25zZS4gVGhpcyBlaXRoZXIgcmVzdWx0cyBpbiBmYWlsXG4gICAgICAvLyAgICB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gb3IgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzXG4gICAgICAvLyAgICBlc3RhYmxpc2hlZC5cblxuICAgICAgLy8gMi4gSWYgdGhlIHJlc3BvbnNlIGxhY2tzIGFuIHxVcGdyYWRlfCBoZWFkZXIgZmllbGQgb3IgdGhlIHxVcGdyYWRlfFxuICAgICAgLy8gICAgaGVhZGVyIGZpZWxkIGNvbnRhaW5zIGEgdmFsdWUgdGhhdCBpcyBub3QgYW4gQVNDSUkgY2FzZS1cbiAgICAgIC8vICAgIGluc2Vuc2l0aXZlIG1hdGNoIGZvciB0aGUgdmFsdWUgXCJ3ZWJzb2NrZXRcIiwgdGhlIGNsaWVudCBNVVNUXG4gICAgICAvLyAgICBfRmFpbCB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLlxuICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnVXBncmFkZScpPy50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbihoYW5kbGVyLCAxMDAyLCAnU2VydmVyIGRpZCBub3Qgc2V0IFVwZ3JhZGUgaGVhZGVyIHRvIFwid2Vic29ja2V0XCIuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIElmIHRoZSByZXNwb25zZSBsYWNrcyBhIHxDb25uZWN0aW9ufCBoZWFkZXIgZmllbGQgb3IgdGhlXG4gICAgICAvLyAgICB8Q29ubmVjdGlvbnwgaGVhZGVyIGZpZWxkIGRvZXNuJ3QgY29udGFpbiBhIHRva2VuIHRoYXQgaXMgYW5cbiAgICAgIC8vICAgIEFTQ0lJIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIHRoZSB2YWx1ZSBcIlVwZ3JhZGVcIiwgdGhlIGNsaWVudFxuICAgICAgLy8gICAgTVVTVCBfRmFpbCB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLlxuICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnQ29ubmVjdGlvbicpPy50b0xvd2VyQ2FzZSgpICE9PSAndXBncmFkZScpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24oaGFuZGxlciwgMTAwMiwgJ1NlcnZlciBkaWQgbm90IHNldCBDb25uZWN0aW9uIGhlYWRlciB0byBcInVwZ3JhZGVcIi4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNC4gSWYgdGhlIHJlc3BvbnNlIGxhY2tzIGEgfFNlYy1XZWJTb2NrZXQtQWNjZXB0fCBoZWFkZXIgZmllbGQgb3JcbiAgICAgIC8vICAgIHRoZSB8U2VjLVdlYlNvY2tldC1BY2NlcHR8IGNvbnRhaW5zIGEgdmFsdWUgb3RoZXIgdGhhbiB0aGVcbiAgICAgIC8vICAgIGJhc2U2NC1lbmNvZGVkIFNIQS0xIG9mIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSB8U2VjLVdlYlNvY2tldC1cbiAgICAgIC8vICAgIEtleXwgKGFzIGEgc3RyaW5nLCBub3QgYmFzZTY0LWRlY29kZWQpIHdpdGggdGhlIHN0cmluZyBcIjI1OEVBRkE1LVxuICAgICAgLy8gICAgRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExXCIgYnV0IGlnbm9yaW5nIGFueSBsZWFkaW5nIGFuZFxuICAgICAgLy8gICAgdHJhaWxpbmcgd2hpdGVzcGFjZSwgdGhlIGNsaWVudCBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vICAgIENvbm5lY3Rpb25fLlxuICAgICAgY29uc3Qgc2VjV1NBY2NlcHQgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtQWNjZXB0JylcbiAgICAgIGNvbnN0IGRpZ2VzdCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKGtleVZhbHVlICsgdWlkKS5kaWdlc3QoJ2Jhc2U2NCcpXG4gICAgICBpZiAoc2VjV1NBY2NlcHQgIT09IGRpZ2VzdCkge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbihoYW5kbGVyLCAxMDAyLCAnSW5jb3JyZWN0IGhhc2ggcmVjZWl2ZWQgaW4gU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyLicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA1LiBJZiB0aGUgcmVzcG9uc2UgaW5jbHVkZXMgYSB8U2VjLVdlYlNvY2tldC1FeHRlbnNpb25zfCBoZWFkZXJcbiAgICAgIC8vICAgIGZpZWxkIGFuZCB0aGlzIGhlYWRlciBmaWVsZCBpbmRpY2F0ZXMgdGhlIHVzZSBvZiBhbiBleHRlbnNpb25cbiAgICAgIC8vICAgIHRoYXQgd2FzIG5vdCBwcmVzZW50IGluIHRoZSBjbGllbnQncyBoYW5kc2hha2UgKHRoZSBzZXJ2ZXIgaGFzXG4gICAgICAvLyAgICBpbmRpY2F0ZWQgYW4gZXh0ZW5zaW9uIG5vdCByZXF1ZXN0ZWQgYnkgdGhlIGNsaWVudCksIHRoZSBjbGllbnRcbiAgICAgIC8vICAgIE1VU1QgX0ZhaWwgdGhlIFdlYlNvY2tldCBDb25uZWN0aW9uXy4gIChUaGUgcGFyc2luZyBvZiB0aGlzXG4gICAgICAvLyAgICBoZWFkZXIgZmllbGQgdG8gZGV0ZXJtaW5lIHdoaWNoIGV4dGVuc2lvbnMgYXJlIHJlcXVlc3RlZCBpc1xuICAgICAgLy8gICAgZGlzY3Vzc2VkIGluIFNlY3Rpb24gOS4xLilcbiAgICAgIGNvbnN0IHNlY0V4dGVuc2lvbiA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zJylcbiAgICAgIGxldCBleHRlbnNpb25zXG5cbiAgICAgIGlmIChzZWNFeHRlbnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHBhcnNlRXh0ZW5zaW9ucyhzZWNFeHRlbnNpb24pXG5cbiAgICAgICAgaWYgKCFleHRlbnNpb25zLmhhcygncGVybWVzc2FnZS1kZWZsYXRlJykpIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbihoYW5kbGVyLCAxMDAyLCAnU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlciBkb2VzIG5vdCBtYXRjaC4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDYuIElmIHRoZSByZXNwb25zZSBpbmNsdWRlcyBhIHxTZWMtV2ViU29ja2V0LVByb3RvY29sfCBoZWFkZXIgZmllbGRcbiAgICAgIC8vICAgIGFuZCB0aGlzIGhlYWRlciBmaWVsZCBpbmRpY2F0ZXMgdGhlIHVzZSBvZiBhIHN1YnByb3RvY29sIHRoYXQgd2FzXG4gICAgICAvLyAgICBub3QgcHJlc2VudCBpbiB0aGUgY2xpZW50J3MgaGFuZHNoYWtlICh0aGUgc2VydmVyIGhhcyBpbmRpY2F0ZWQgYVxuICAgICAgLy8gICAgc3VicHJvdG9jb2wgbm90IHJlcXVlc3RlZCBieSB0aGUgY2xpZW50KSwgdGhlIGNsaWVudCBNVVNUIF9GYWlsXG4gICAgICAvLyAgICB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLlxuICAgICAgY29uc3Qgc2VjUHJvdG9jb2wgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnKVxuXG4gICAgICBpZiAoc2VjUHJvdG9jb2wgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdFByb3RvY29scyA9IGdldERlY29kZVNwbGl0KCdzZWMtd2Vic29ja2V0LXByb3RvY29sJywgcmVxdWVzdC5oZWFkZXJzTGlzdClcblxuICAgICAgICAvLyBUaGUgY2xpZW50IGNhbiByZXF1ZXN0IHRoYXQgdGhlIHNlcnZlciB1c2UgYSBzcGVjaWZpYyBzdWJwcm90b2NvbCBieVxuICAgICAgICAvLyBpbmNsdWRpbmcgdGhlIHxTZWMtV2ViU29ja2V0LVByb3RvY29sfCBmaWVsZCBpbiBpdHMgaGFuZHNoYWtlLiAgSWYgaXRcbiAgICAgICAgLy8gaXMgc3BlY2lmaWVkLCB0aGUgc2VydmVyIG5lZWRzIHRvIGluY2x1ZGUgdGhlIHNhbWUgZmllbGQgYW5kIG9uZSBvZlxuICAgICAgICAvLyB0aGUgc2VsZWN0ZWQgc3VicHJvdG9jb2wgdmFsdWVzIGluIGl0cyByZXNwb25zZSBmb3IgdGhlIGNvbm5lY3Rpb24gdG9cbiAgICAgICAgLy8gYmUgZXN0YWJsaXNoZWQuXG4gICAgICAgIGlmICghcmVxdWVzdFByb3RvY29scy5pbmNsdWRlcyhzZWNQcm90b2NvbCkpIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbihoYW5kbGVyLCAxMDAyLCAnUHJvdG9jb2wgd2FzIG5vdCBzZXQgaW4gdGhlIG9wZW5pbmcgaGFuZHNoYWtlLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzcG9uc2Uuc29ja2V0Lm9uKCdkYXRhJywgaGFuZGxlci5vblNvY2tldERhdGEpXG4gICAgICByZXNwb25zZS5zb2NrZXQub24oJ2Nsb3NlJywgaGFuZGxlci5vblNvY2tldENsb3NlKVxuICAgICAgcmVzcG9uc2Uuc29ja2V0Lm9uKCdlcnJvcicsIGhhbmRsZXIub25Tb2NrZXRFcnJvcilcblxuICAgICAgaWYgKGNoYW5uZWxzLm9wZW4uaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgY2hhbm5lbHMub3Blbi5wdWJsaXNoKHtcbiAgICAgICAgICBhZGRyZXNzOiByZXNwb25zZS5zb2NrZXQuYWRkcmVzcygpLFxuICAgICAgICAgIHByb3RvY29sOiBzZWNQcm90b2NvbCxcbiAgICAgICAgICBleHRlbnNpb25zOiBzZWNFeHRlbnNpb25cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgaGFuZGxlci53YXNFdmVyQ29ubmVjdGVkID0gdHJ1ZVxuICAgICAgaGFuZGxlci5vbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZChyZXNwb25zZSwgZXh0ZW5zaW9ucylcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGNvbnRyb2xsZXJcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2hhdHByLm9yZy93ZWJzb2NrZXRzLzQ4Lmh0bWwjY2xvc2UtdGhlLXdlYnNvY2tldFxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuSGFuZGxlcn0gb2JqZWN0XG4gKiBAcGFyYW0ge251bWJlcn0gW2NvZGU9bnVsbF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uPScnXVxuICovXG5mdW5jdGlvbiBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24gKG9iamVjdCwgY29kZSwgcmVhc29uLCB2YWxpZGF0ZSA9IGZhbHNlKSB7XG4gIC8vIDEuIElmIGNvZGUgd2FzIG5vdCBzdXBwbGllZCwgbGV0IGNvZGUgYmUgbnVsbC5cbiAgY29kZSA/Pz0gbnVsbFxuXG4gIC8vIDIuIElmIHJlYXNvbiB3YXMgbm90IHN1cHBsaWVkLCBsZXQgcmVhc29uIGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIHJlYXNvbiA/Pz0gJydcblxuICAvLyAzLiBWYWxpZGF0ZSBjbG9zZSBjb2RlIGFuZCByZWFzb24gd2l0aCBjb2RlIGFuZCByZWFzb24uXG4gIGlmICh2YWxpZGF0ZSkgdmFsaWRhdGVDbG9zZUNvZGVBbmRSZWFzb24oY29kZSwgcmVhc29uKVxuXG4gIC8vIDQuIFJ1biB0aGUgZmlyc3QgbWF0Y2hpbmcgc3RlcHMgZnJvbSB0aGUgZm9sbG93aW5nIGxpc3Q6XG4gIC8vICAgICAtIElmIG9iamVjdOKAmXMgcmVhZHkgc3RhdGUgaXMgQ0xPU0lORyAoMikgb3IgQ0xPU0VEICgzKVxuICAvLyAgICAgLSBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgbm90IHlldCBlc3RhYmxpc2hlZCBbV1NQXVxuICAvLyAgICAgLSBJZiB0aGUgV2ViU29ja2V0IGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IGJlZW4gc3RhcnRlZCBbV1NQXVxuICAvLyAgICAgLSBPdGhlcndpc2VcbiAgaWYgKGlzQ2xvc2VkKG9iamVjdC5yZWFkeVN0YXRlKSB8fCBpc0Nsb3Npbmcob2JqZWN0LnJlYWR5U3RhdGUpKSB7XG4gICAgLy8gRG8gbm90aGluZy5cbiAgfSBlbHNlIGlmICghaXNFc3RhYmxpc2hlZChvYmplY3QucmVhZHlTdGF0ZSkpIHtcbiAgICAvLyBGYWlsIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBhbmQgc2V0IG9iamVjdOKAmXMgcmVhZHkgc3RhdGUgdG8gQ0xPU0lORyAoMikuIFtXU1BdXG4gICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24ob2JqZWN0KVxuICAgIG9iamVjdC5yZWFkeVN0YXRlID0gc3RhdGVzLkNMT1NJTkdcbiAgfSBlbHNlIGlmICghb2JqZWN0LmNsb3NlU3RhdGUuaGFzKHNlbnRDbG9zZUZyYW1lU3RhdGUuU0VOVCkgJiYgIW9iamVjdC5jbG9zZVN0YXRlLmhhcyhzZW50Q2xvc2VGcmFtZVN0YXRlLlJFQ0VJVkVEKSkge1xuICAgIC8vIFVwb24gZWl0aGVyIHNlbmRpbmcgb3IgcmVjZWl2aW5nIGEgQ2xvc2UgY29udHJvbCBmcmFtZSwgaXQgaXMgc2FpZFxuICAgIC8vIHRoYXQgX1RoZSBXZWJTb2NrZXQgQ2xvc2luZyBIYW5kc2hha2UgaXMgU3RhcnRlZF8gYW5kIHRoYXQgdGhlXG4gICAgLy8gV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgaW4gdGhlIENMT1NJTkcgc3RhdGUuXG5cbiAgICBjb25zdCBmcmFtZSA9IG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQoKVxuXG4gICAgLy8gSWYgbmVpdGhlciBjb2RlIG5vciByZWFzb24gaXMgcHJlc2VudCwgdGhlIFdlYlNvY2tldCBDbG9zZVxuICAgIC8vIG1lc3NhZ2UgbXVzdCBub3QgaGF2ZSBhIGJvZHkuXG5cbiAgICAvLyBJZiBjb2RlIGlzIHByZXNlbnQsIHRoZW4gdGhlIHN0YXR1cyBjb2RlIHRvIHVzZSBpbiB0aGVcbiAgICAvLyBXZWJTb2NrZXQgQ2xvc2UgbWVzc2FnZSBtdXN0IGJlIHRoZSBpbnRlZ2VyIGdpdmVuIGJ5IGNvZGUuXG4gICAgLy8gSWYgY29kZSBpcyBudWxsIGFuZCByZWFzb24gaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlIFdlYlNvY2tldCBDbG9zZSBmcmFtZSBtdXN0IG5vdCBoYXZlIGEgYm9keS5cbiAgICAvLyBJZiByZWFzb24gaXMgbm9uLWVtcHR5IGJ1dCBjb2RlIGlzIG51bGwsIHRoZW4gc2V0IGNvZGUgdG8gMTAwMCAoXCJOb3JtYWwgQ2xvc3VyZVwiKS5cbiAgICBpZiAocmVhc29uLmxlbmd0aCAhPT0gMCAmJiBjb2RlID09PSBudWxsKSB7XG4gICAgICBjb2RlID0gMTAwMFxuICAgIH1cblxuICAgIC8vIElmIGNvZGUgaXMgc2V0LCB0aGVuIHRoZSBzdGF0dXMgY29kZSB0byB1c2UgaW4gdGhlIFdlYlNvY2tldCBDbG9zZSBmcmFtZSBtdXN0IGJlIHRoZSBpbnRlZ2VyIGdpdmVuIGJ5IGNvZGUuXG4gICAgYXNzZXJ0KGNvZGUgPT09IG51bGwgfHwgTnVtYmVyLmlzSW50ZWdlcihjb2RlKSlcblxuICAgIGlmIChjb2RlID09PSBudWxsICYmIHJlYXNvbi5sZW5ndGggPT09IDApIHtcbiAgICAgIGZyYW1lLmZyYW1lRGF0YSA9IGVtcHR5QnVmZmVyXG4gICAgfSBlbHNlIGlmIChjb2RlICE9PSBudWxsICYmIHJlYXNvbiA9PT0gbnVsbCkge1xuICAgICAgZnJhbWUuZnJhbWVEYXRhID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG4gICAgICBmcmFtZS5mcmFtZURhdGEud3JpdGVVSW50MTZCRShjb2RlLCAwKVxuICAgIH0gZWxzZSBpZiAoY29kZSAhPT0gbnVsbCAmJiByZWFzb24gIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHJlYXNvbiBpcyBhbHNvIHByZXNlbnQsIHRoZW4gcmVhc29uQnl0ZXMgbXVzdCBiZVxuICAgICAgLy8gcHJvdmlkZWQgaW4gdGhlIENsb3NlIG1lc3NhZ2UgYWZ0ZXIgdGhlIHN0YXR1cyBjb2RlLlxuICAgICAgZnJhbWUuZnJhbWVEYXRhID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIgKyBCdWZmZXIuYnl0ZUxlbmd0aChyZWFzb24pKVxuICAgICAgZnJhbWUuZnJhbWVEYXRhLndyaXRlVUludDE2QkUoY29kZSwgMClcbiAgICAgIC8vIHRoZSBib2R5IE1BWSBjb250YWluIFVURi04LWVuY29kZWQgZGF0YSB3aXRoIHZhbHVlIC9yZWFzb24vXG4gICAgICBmcmFtZS5mcmFtZURhdGEud3JpdGUocmVhc29uLCAyLCAndXRmLTgnKVxuICAgIH0gZWxzZSB7XG4gICAgICBmcmFtZS5mcmFtZURhdGEgPSBlbXB0eUJ1ZmZlclxuICAgIH1cblxuICAgIG9iamVjdC5zb2NrZXQud3JpdGUoZnJhbWUuY3JlYXRlRnJhbWUob3Bjb2Rlcy5DTE9TRSkpXG5cbiAgICBvYmplY3QuY2xvc2VTdGF0ZS5hZGQoc2VudENsb3NlRnJhbWVTdGF0ZS5TRU5UKVxuXG4gICAgLy8gVXBvbiBlaXRoZXIgc2VuZGluZyBvciByZWNlaXZpbmcgYSBDbG9zZSBjb250cm9sIGZyYW1lLCBpdCBpcyBzYWlkXG4gICAgLy8gdGhhdCBfVGhlIFdlYlNvY2tldCBDbG9zaW5nIEhhbmRzaGFrZSBpcyBTdGFydGVkXyBhbmQgdGhhdCB0aGVcbiAgICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ0xPU0lORyBzdGF0ZS5cbiAgICBvYmplY3QucmVhZHlTdGF0ZSA9IHN0YXRlcy5DTE9TSU5HXG4gIH0gZWxzZSB7XG4gICAgLy8gU2V0IG9iamVjdOKAmXMgcmVhZHkgc3RhdGUgdG8gQ0xPU0lORyAoMikuXG4gICAgb2JqZWN0LnJlYWR5U3RhdGUgPSBzdGF0ZXMuQ0xPU0lOR1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuSGFuZGxlcn0gaGFuZGxlclxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gcmVhc29uXG4gKiBAcGFyYW0ge3Vua25vd259IGNhdXNlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZmFpbFdlYnNvY2tldENvbm5lY3Rpb24gKGhhbmRsZXIsIGNvZGUsIHJlYXNvbiwgY2F1c2UpIHtcbiAgLy8gSWYgX1RoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbiBpcyBFc3RhYmxpc2hlZF8gcHJpb3IgdG8gdGhlIHBvaW50IHdoZXJlXG4gIC8vIHRoZSBlbmRwb2ludCBpcyByZXF1aXJlZCB0byBfRmFpbCB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLCB0aGVcbiAgLy8gZW5kcG9pbnQgU0hPVUxEIHNlbmQgYSBDbG9zZSBmcmFtZSB3aXRoIGFuIGFwcHJvcHJpYXRlIHN0YXR1cyBjb2RlXG4gIC8vIChTZWN0aW9uIDcuNCkgYmVmb3JlIHByb2NlZWRpbmcgdG8gX0Nsb3NlIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uXG4gIGlmIChpc0VzdGFibGlzaGVkKGhhbmRsZXIucmVhZHlTdGF0ZSkpIHtcbiAgICBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24oaGFuZGxlciwgY29kZSwgcmVhc29uLCBmYWxzZSlcbiAgfVxuXG4gIGhhbmRsZXIuY29udHJvbGxlci5hYm9ydCgpXG5cbiAgaWYgKGhhbmRsZXIuc29ja2V0Py5kZXN0cm95ZWQgPT09IGZhbHNlKSB7XG4gICAgaGFuZGxlci5zb2NrZXQuZGVzdHJveSgpXG4gIH1cblxuICBoYW5kbGVyLm9uRmFpbChjb2RlLCByZWFzb24sIGNhdXNlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvbixcbiAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24sXG4gIGNsb3NlV2ViU29ja2V0Q29ubmVjdGlvblxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/constants.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * This is a Globally Unique Identifier unique used to validate that the\n * endpoint accepts websocket connections.\n * @see https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3\n * @type {'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'}\n */\nconst uid = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'\n\n/**\n * @type {PropertyDescriptor}\n */\nconst staticPropertyDescriptors = {\n  enumerable: true,\n  writable: false,\n  configurable: false\n}\n\n/**\n * The states of the WebSocket connection.\n *\n * @readonly\n * @enum\n * @property {0} CONNECTING\n * @property {1} OPEN\n * @property {2} CLOSING\n * @property {3} CLOSED\n */\nconst states = {\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSING: 2,\n  CLOSED: 3\n}\n\n/**\n * @readonly\n * @enum\n * @property {0} NOT_SENT\n * @property {1} PROCESSING\n * @property {2} SENT\n */\nconst sentCloseFrameState = {\n  SENT: 1,\n  RECEIVED: 2\n}\n\n/**\n * The WebSocket opcodes.\n *\n * @readonly\n * @enum\n * @property {0x0} CONTINUATION\n * @property {0x1} TEXT\n * @property {0x2} BINARY\n * @property {0x8} CLOSE\n * @property {0x9} PING\n * @property {0xA} PONG\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n */\nconst opcodes = {\n  CONTINUATION: 0x0,\n  TEXT: 0x1,\n  BINARY: 0x2,\n  CLOSE: 0x8,\n  PING: 0x9,\n  PONG: 0xA\n}\n\n/**\n * The maximum value for an unsigned 16-bit integer.\n *\n * @type {65535} 2 ** 16 - 1\n */\nconst maxUnsigned16Bit = 65535\n\n/**\n * The states of the parser.\n *\n * @readonly\n * @enum\n * @property {0} INFO\n * @property {2} PAYLOADLENGTH_16\n * @property {3} PAYLOADLENGTH_64\n * @property {4} READ_DATA\n */\nconst parserStates = {\n  INFO: 0,\n  PAYLOADLENGTH_16: 2,\n  PAYLOADLENGTH_64: 3,\n  READ_DATA: 4\n}\n\n/**\n * An empty buffer.\n *\n * @type {Buffer}\n */\nconst emptyBuffer = Buffer.allocUnsafe(0)\n\n/**\n * @readonly\n * @property {1} text\n * @property {2} typedArray\n * @property {3} arrayBuffer\n * @property {4} blob\n */\nconst sendHints = {\n  text: 1,\n  typedArray: 2,\n  arrayBuffer: 3,\n  blob: 4\n}\n\nmodule.exports = {\n  uid,\n  sentCloseFrameState,\n  staticPropertyDescriptors,\n  states,\n  opcodes,\n  maxUnsigned16Bit,\n  parserStates,\n  emptyBuffer,\n  sendHints\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxHQUFHO0FBQ2pCLGNBQWMsR0FBRztBQUNqQixjQUFjLEdBQUc7QUFDakIsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQixjQUFjLEdBQUc7QUFDakIsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQixjQUFjLEtBQUs7QUFDbkIsY0FBYyxLQUFLO0FBQ25CLGNBQWMsS0FBSztBQUNuQixjQUFjLEtBQUs7QUFDbkIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakIsY0FBYyxHQUFHO0FBQ2pCLGNBQWMsR0FBRztBQUNqQixjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQixjQUFjLEdBQUc7QUFDakIsY0FBYyxHQUFHO0FBQ2pCLGNBQWMsR0FBRztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi93ZWJzb2NrZXQvY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIFRoaXMgaXMgYSBHbG9iYWxseSBVbmlxdWUgSWRlbnRpZmllciB1bmlxdWUgdXNlZCB0byB2YWxpZGF0ZSB0aGF0IHRoZVxuICogZW5kcG9pbnQgYWNjZXB0cyB3ZWJzb2NrZXQgY29ubmVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2NDU1Lmh0bWwjc2VjdGlvbi0xLjNcbiAqIEB0eXBlIHsnMjU4RUFGQTUtRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExJ31cbiAqL1xuY29uc3QgdWlkID0gJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMSdcblxuLyoqXG4gKiBAdHlwZSB7UHJvcGVydHlEZXNjcmlwdG9yfVxuICovXG5jb25zdCBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn1cblxuLyoqXG4gKiBUaGUgc3RhdGVzIG9mIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAqXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtXG4gKiBAcHJvcGVydHkgezB9IENPTk5FQ1RJTkdcbiAqIEBwcm9wZXJ0eSB7MX0gT1BFTlxuICogQHByb3BlcnR5IHsyfSBDTE9TSU5HXG4gKiBAcHJvcGVydHkgezN9IENMT1NFRFxuICovXG5jb25zdCBzdGF0ZXMgPSB7XG4gIENPTk5FQ1RJTkc6IDAsXG4gIE9QRU46IDEsXG4gIENMT1NJTkc6IDIsXG4gIENMT1NFRDogM1xufVxuXG4vKipcbiAqIEByZWFkb25seVxuICogQGVudW1cbiAqIEBwcm9wZXJ0eSB7MH0gTk9UX1NFTlRcbiAqIEBwcm9wZXJ0eSB7MX0gUFJPQ0VTU0lOR1xuICogQHByb3BlcnR5IHsyfSBTRU5UXG4gKi9cbmNvbnN0IHNlbnRDbG9zZUZyYW1lU3RhdGUgPSB7XG4gIFNFTlQ6IDEsXG4gIFJFQ0VJVkVEOiAyXG59XG5cbi8qKlxuICogVGhlIFdlYlNvY2tldCBvcGNvZGVzLlxuICpcbiAqIEByZWFkb25seVxuICogQGVudW1cbiAqIEBwcm9wZXJ0eSB7MHgwfSBDT05USU5VQVRJT05cbiAqIEBwcm9wZXJ0eSB7MHgxfSBURVhUXG4gKiBAcHJvcGVydHkgezB4Mn0gQklOQVJZXG4gKiBAcHJvcGVydHkgezB4OH0gQ0xPU0VcbiAqIEBwcm9wZXJ0eSB7MHg5fSBQSU5HXG4gKiBAcHJvcGVydHkgezB4QX0gUE9OR1xuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi01LjJcbiAqL1xuY29uc3Qgb3Bjb2RlcyA9IHtcbiAgQ09OVElOVUFUSU9OOiAweDAsXG4gIFRFWFQ6IDB4MSxcbiAgQklOQVJZOiAweDIsXG4gIENMT1NFOiAweDgsXG4gIFBJTkc6IDB4OSxcbiAgUE9ORzogMHhBXG59XG5cbi8qKlxuICogVGhlIG1heGltdW0gdmFsdWUgZm9yIGFuIHVuc2lnbmVkIDE2LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEB0eXBlIHs2NTUzNX0gMiAqKiAxNiAtIDFcbiAqL1xuY29uc3QgbWF4VW5zaWduZWQxNkJpdCA9IDY1NTM1XG5cbi8qKlxuICogVGhlIHN0YXRlcyBvZiB0aGUgcGFyc2VyLlxuICpcbiAqIEByZWFkb25seVxuICogQGVudW1cbiAqIEBwcm9wZXJ0eSB7MH0gSU5GT1xuICogQHByb3BlcnR5IHsyfSBQQVlMT0FETEVOR1RIXzE2XG4gKiBAcHJvcGVydHkgezN9IFBBWUxPQURMRU5HVEhfNjRcbiAqIEBwcm9wZXJ0eSB7NH0gUkVBRF9EQVRBXG4gKi9cbmNvbnN0IHBhcnNlclN0YXRlcyA9IHtcbiAgSU5GTzogMCxcbiAgUEFZTE9BRExFTkdUSF8xNjogMixcbiAgUEFZTE9BRExFTkdUSF82NDogMyxcbiAgUkVBRF9EQVRBOiA0XG59XG5cbi8qKlxuICogQW4gZW1wdHkgYnVmZmVyLlxuICpcbiAqIEB0eXBlIHtCdWZmZXJ9XG4gKi9cbmNvbnN0IGVtcHR5QnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG5cbi8qKlxuICogQHJlYWRvbmx5XG4gKiBAcHJvcGVydHkgezF9IHRleHRcbiAqIEBwcm9wZXJ0eSB7Mn0gdHlwZWRBcnJheVxuICogQHByb3BlcnR5IHszfSBhcnJheUJ1ZmZlclxuICogQHByb3BlcnR5IHs0fSBibG9iXG4gKi9cbmNvbnN0IHNlbmRIaW50cyA9IHtcbiAgdGV4dDogMSxcbiAgdHlwZWRBcnJheTogMixcbiAgYXJyYXlCdWZmZXI6IDMsXG4gIGJsb2I6IDRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHVpZCxcbiAgc2VudENsb3NlRnJhbWVTdGF0ZSxcbiAgc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgc3RhdGVzLFxuICBvcGNvZGVzLFxuICBtYXhVbnNpZ25lZDE2Qml0LFxuICBwYXJzZXJTdGF0ZXMsXG4gIGVtcHR5QnVmZmVyLFxuICBzZW5kSGludHNcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/events.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/events.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\n/**\n * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent\n */\nclass MessageEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict = {}) {\n    if (type === kConstruct) {\n      super(arguments[1], arguments[2])\n      webidl.util.markAsUncloneable(this)\n      return\n    }\n\n    const prefix = 'MessageEvent constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    type = webidl.converters.DOMString(type, prefix, 'type')\n    eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, 'eventInitDict')\n\n    super(type, eventInitDict)\n\n    this.#eventInit = eventInitDict\n    webidl.util.markAsUncloneable(this)\n  }\n\n  get data () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.data\n  }\n\n  get origin () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.origin\n  }\n\n  get lastEventId () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.lastEventId\n  }\n\n  get source () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.source\n  }\n\n  get ports () {\n    webidl.brandCheck(this, MessageEvent)\n\n    if (!Object.isFrozen(this.#eventInit.ports)) {\n      Object.freeze(this.#eventInit.ports)\n    }\n\n    return this.#eventInit.ports\n  }\n\n  initMessageEvent (\n    type,\n    bubbles = false,\n    cancelable = false,\n    data = null,\n    origin = '',\n    lastEventId = '',\n    source = null,\n    ports = []\n  ) {\n    webidl.brandCheck(this, MessageEvent)\n\n    webidl.argumentLengthCheck(arguments, 1, 'MessageEvent.initMessageEvent')\n\n    return new MessageEvent(type, {\n      bubbles, cancelable, data, origin, lastEventId, source, ports\n    })\n  }\n\n  static createFastMessageEvent (type, init) {\n    const messageEvent = new MessageEvent(kConstruct, type, init)\n    messageEvent.#eventInit = init\n    messageEvent.#eventInit.data ??= null\n    messageEvent.#eventInit.origin ??= ''\n    messageEvent.#eventInit.lastEventId ??= ''\n    messageEvent.#eventInit.source ??= null\n    messageEvent.#eventInit.ports ??= []\n    return messageEvent\n  }\n}\n\nconst { createFastMessageEvent } = MessageEvent\ndelete MessageEvent.createFastMessageEvent\n\n/**\n * @see https://websockets.spec.whatwg.org/#the-closeevent-interface\n */\nclass CloseEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict = {}) {\n    const prefix = 'CloseEvent constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    type = webidl.converters.DOMString(type, prefix, 'type')\n    eventInitDict = webidl.converters.CloseEventInit(eventInitDict)\n\n    super(type, eventInitDict)\n\n    this.#eventInit = eventInitDict\n    webidl.util.markAsUncloneable(this)\n  }\n\n  get wasClean () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.wasClean\n  }\n\n  get code () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.code\n  }\n\n  get reason () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.reason\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface\nclass ErrorEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict) {\n    const prefix = 'ErrorEvent constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    super(type, eventInitDict)\n    webidl.util.markAsUncloneable(this)\n\n    type = webidl.converters.DOMString(type, prefix, 'type')\n    eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {})\n\n    this.#eventInit = eventInitDict\n  }\n\n  get message () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.message\n  }\n\n  get filename () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.filename\n  }\n\n  get lineno () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.lineno\n  }\n\n  get colno () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.colno\n  }\n\n  get error () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.error\n  }\n}\n\nObject.defineProperties(MessageEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'MessageEvent',\n    configurable: true\n  },\n  data: kEnumerableProperty,\n  origin: kEnumerableProperty,\n  lastEventId: kEnumerableProperty,\n  source: kEnumerableProperty,\n  ports: kEnumerableProperty,\n  initMessageEvent: kEnumerableProperty\n})\n\nObject.defineProperties(CloseEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'CloseEvent',\n    configurable: true\n  },\n  reason: kEnumerableProperty,\n  code: kEnumerableProperty,\n  wasClean: kEnumerableProperty\n})\n\nObject.defineProperties(ErrorEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'ErrorEvent',\n    configurable: true\n  },\n  message: kEnumerableProperty,\n  filename: kEnumerableProperty,\n  lineno: kEnumerableProperty,\n  colno: kEnumerableProperty,\n  error: kEnumerableProperty\n})\n\nwebidl.converters.MessagePort = webidl.interfaceConverter(\n  webidl.is.MessagePort,\n  'MessagePort'\n)\n\nwebidl.converters['sequence<MessagePort>'] = webidl.sequenceConverter(\n  webidl.converters.MessagePort\n)\n\nconst eventInit = [\n  {\n    key: 'bubbles',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'cancelable',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'composed',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  }\n]\n\nwebidl.converters.MessageEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'data',\n    converter: webidl.converters.any,\n    defaultValue: () => null\n  },\n  {\n    key: 'origin',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'lastEventId',\n    converter: webidl.converters.DOMString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'source',\n    // Node doesn't implement WindowProxy or ServiceWorker, so the only\n    // valid value for source is a MessagePort.\n    converter: webidl.nullableConverter(webidl.converters.MessagePort),\n    defaultValue: () => null\n  },\n  {\n    key: 'ports',\n    converter: webidl.converters['sequence<MessagePort>'],\n    defaultValue: () => new Array(0)\n  }\n])\n\nwebidl.converters.CloseEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'wasClean',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'code',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'reason',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  }\n])\n\nwebidl.converters.ErrorEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'message',\n    converter: webidl.converters.DOMString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'filename',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'lineno',\n    converter: webidl.converters['unsigned long'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'colno',\n    converter: webidl.converters['unsigned long'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'error',\n    converter: webidl.converters.any\n  }\n])\n\nmodule.exports = {\n  MessageEvent,\n  CloseEvent,\n  ErrorEvent,\n  createFastMessageEvent\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2V2ZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNFQUFXO0FBQ3RDLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDekQsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQywyRUFBb0I7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHlCQUF5QjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFOztBQUV4RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi93ZWJzb2NrZXQvZXZlbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vd2ViaWRsJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9zeW1ib2xzJylcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjbWVzc2FnZWV2ZW50XG4gKi9cbmNsYXNzIE1lc3NhZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgI2V2ZW50SW5pdFxuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBldmVudEluaXREaWN0ID0ge30pIHtcbiAgICBpZiAodHlwZSA9PT0ga0NvbnN0cnVjdCkge1xuICAgICAgc3VwZXIoYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pXG4gICAgICB3ZWJpZGwudXRpbC5tYXJrQXNVbmNsb25lYWJsZSh0aGlzKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ01lc3NhZ2VFdmVudCBjb25zdHJ1Y3RvcidcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIHR5cGUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcodHlwZSwgcHJlZml4LCAndHlwZScpXG4gICAgZXZlbnRJbml0RGljdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLk1lc3NhZ2VFdmVudEluaXQoZXZlbnRJbml0RGljdCwgcHJlZml4LCAnZXZlbnRJbml0RGljdCcpXG5cbiAgICBzdXBlcih0eXBlLCBldmVudEluaXREaWN0KVxuXG4gICAgdGhpcy4jZXZlbnRJbml0ID0gZXZlbnRJbml0RGljdFxuICAgIHdlYmlkbC51dGlsLm1hcmtBc1VuY2xvbmVhYmxlKHRoaXMpXG4gIH1cblxuICBnZXQgZGF0YSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5kYXRhXG4gIH1cblxuICBnZXQgb3JpZ2luICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0Lm9yaWdpblxuICB9XG5cbiAgZ2V0IGxhc3RFdmVudElkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0Lmxhc3RFdmVudElkXG4gIH1cblxuICBnZXQgc291cmNlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LnNvdXJjZVxuICB9XG5cbiAgZ2V0IHBvcnRzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICBpZiAoIU9iamVjdC5pc0Zyb3plbih0aGlzLiNldmVudEluaXQucG9ydHMpKSB7XG4gICAgICBPYmplY3QuZnJlZXplKHRoaXMuI2V2ZW50SW5pdC5wb3J0cylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LnBvcnRzXG4gIH1cblxuICBpbml0TWVzc2FnZUV2ZW50IChcbiAgICB0eXBlLFxuICAgIGJ1YmJsZXMgPSBmYWxzZSxcbiAgICBjYW5jZWxhYmxlID0gZmFsc2UsXG4gICAgZGF0YSA9IG51bGwsXG4gICAgb3JpZ2luID0gJycsXG4gICAgbGFzdEV2ZW50SWQgPSAnJyxcbiAgICBzb3VyY2UgPSBudWxsLFxuICAgIHBvcnRzID0gW11cbiAgKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnTWVzc2FnZUV2ZW50LmluaXRNZXNzYWdlRXZlbnQnKVxuXG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlRXZlbnQodHlwZSwge1xuICAgICAgYnViYmxlcywgY2FuY2VsYWJsZSwgZGF0YSwgb3JpZ2luLCBsYXN0RXZlbnRJZCwgc291cmNlLCBwb3J0c1xuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgY3JlYXRlRmFzdE1lc3NhZ2VFdmVudCAodHlwZSwgaW5pdCkge1xuICAgIGNvbnN0IG1lc3NhZ2VFdmVudCA9IG5ldyBNZXNzYWdlRXZlbnQoa0NvbnN0cnVjdCwgdHlwZSwgaW5pdClcbiAgICBtZXNzYWdlRXZlbnQuI2V2ZW50SW5pdCA9IGluaXRcbiAgICBtZXNzYWdlRXZlbnQuI2V2ZW50SW5pdC5kYXRhID8/PSBudWxsXG4gICAgbWVzc2FnZUV2ZW50LiNldmVudEluaXQub3JpZ2luID8/PSAnJ1xuICAgIG1lc3NhZ2VFdmVudC4jZXZlbnRJbml0Lmxhc3RFdmVudElkID8/PSAnJ1xuICAgIG1lc3NhZ2VFdmVudC4jZXZlbnRJbml0LnNvdXJjZSA/Pz0gbnVsbFxuICAgIG1lc3NhZ2VFdmVudC4jZXZlbnRJbml0LnBvcnRzID8/PSBbXVxuICAgIHJldHVybiBtZXNzYWdlRXZlbnRcbiAgfVxufVxuXG5jb25zdCB7IGNyZWF0ZUZhc3RNZXNzYWdlRXZlbnQgfSA9IE1lc3NhZ2VFdmVudFxuZGVsZXRlIE1lc3NhZ2VFdmVudC5jcmVhdGVGYXN0TWVzc2FnZUV2ZW50XG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyN0aGUtY2xvc2VldmVudC1pbnRlcmZhY2VcbiAqL1xuY2xhc3MgQ2xvc2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgI2V2ZW50SW5pdFxuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBldmVudEluaXREaWN0ID0ge30pIHtcbiAgICBjb25zdCBwcmVmaXggPSAnQ2xvc2VFdmVudCBjb25zdHJ1Y3RvcidcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIHR5cGUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcodHlwZSwgcHJlZml4LCAndHlwZScpXG4gICAgZXZlbnRJbml0RGljdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNsb3NlRXZlbnRJbml0KGV2ZW50SW5pdERpY3QpXG5cbiAgICBzdXBlcih0eXBlLCBldmVudEluaXREaWN0KVxuXG4gICAgdGhpcy4jZXZlbnRJbml0ID0gZXZlbnRJbml0RGljdFxuICAgIHdlYmlkbC51dGlsLm1hcmtBc1VuY2xvbmVhYmxlKHRoaXMpXG4gIH1cblxuICBnZXQgd2FzQ2xlYW4gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENsb3NlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0Lndhc0NsZWFuXG4gIH1cblxuICBnZXQgY29kZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2xvc2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuY29kZVxuICB9XG5cbiAgZ2V0IHJlYXNvbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2xvc2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQucmVhc29uXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI3RoZS1lcnJvcmV2ZW50LWludGVyZmFjZVxuY2xhc3MgRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgI2V2ZW50SW5pdFxuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBldmVudEluaXREaWN0KSB7XG4gICAgY29uc3QgcHJlZml4ID0gJ0Vycm9yRXZlbnQgY29uc3RydWN0b3InXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBzdXBlcih0eXBlLCBldmVudEluaXREaWN0KVxuICAgIHdlYmlkbC51dGlsLm1hcmtBc1VuY2xvbmVhYmxlKHRoaXMpXG5cbiAgICB0eXBlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHR5cGUsIHByZWZpeCwgJ3R5cGUnKVxuICAgIGV2ZW50SW5pdERpY3QgPSB3ZWJpZGwuY29udmVydGVycy5FcnJvckV2ZW50SW5pdChldmVudEluaXREaWN0ID8/IHt9KVxuXG4gICAgdGhpcy4jZXZlbnRJbml0ID0gZXZlbnRJbml0RGljdFxuICB9XG5cbiAgZ2V0IG1lc3NhZ2UgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0Lm1lc3NhZ2VcbiAgfVxuXG4gIGdldCBmaWxlbmFtZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuZmlsZW5hbWVcbiAgfVxuXG4gIGdldCBsaW5lbm8gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmxpbmVub1xuICB9XG5cbiAgZ2V0IGNvbG5vICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFcnJvckV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5jb2xub1xuICB9XG5cbiAgZ2V0IGVycm9yICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFcnJvckV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5lcnJvclxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1lc3NhZ2VFdmVudC5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ01lc3NhZ2VFdmVudCcsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIGRhdGE6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9yaWdpbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgbGFzdEV2ZW50SWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNvdXJjZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcG9ydHM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGluaXRNZXNzYWdlRXZlbnQ6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENsb3NlRXZlbnQucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdDbG9zZUV2ZW50JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgcmVhc29uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjb2RlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICB3YXNDbGVhbjoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRXJyb3JFdmVudC5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0Vycm9yRXZlbnQnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICBtZXNzYWdlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBmaWxlbmFtZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgbGluZW5vOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjb2xubzoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLk1lc3NhZ2VQb3J0ID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgd2ViaWRsLmlzLk1lc3NhZ2VQb3J0LFxuICAnTWVzc2FnZVBvcnQnXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxNZXNzYWdlUG9ydD4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZVBvcnRcbilcblxuY29uc3QgZXZlbnRJbml0ID0gW1xuICB7XG4gICAga2V5OiAnYnViYmxlcycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2NhbmNlbGFibGUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjb21wb3NlZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfVxuXVxuXG53ZWJpZGwuY29udmVydGVycy5NZXNzYWdlRXZlbnRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICAuLi5ldmVudEluaXQsXG4gIHtcbiAgICBrZXk6ICdkYXRhJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfSxcbiAge1xuICAgIGtleTogJ29yaWdpbicsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnbGFzdEV2ZW50SWQnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJydcbiAgfSxcbiAge1xuICAgIGtleTogJ3NvdXJjZScsXG4gICAgLy8gTm9kZSBkb2Vzbid0IGltcGxlbWVudCBXaW5kb3dQcm94eSBvciBTZXJ2aWNlV29ya2VyLCBzbyB0aGUgb25seVxuICAgIC8vIHZhbGlkIHZhbHVlIGZvciBzb3VyY2UgaXMgYSBNZXNzYWdlUG9ydC5cbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5NZXNzYWdlUG9ydCksXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdwb3J0cycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8TWVzc2FnZVBvcnQ+J10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBuZXcgQXJyYXkoMClcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnMuQ2xvc2VFdmVudEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIC4uLmV2ZW50SW5pdCxcbiAge1xuICAgIGtleTogJ3dhc0NsZWFuJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY29kZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ3JlYXNvbicsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAnJ1xuICB9XG5dKVxuXG53ZWJpZGwuY29udmVydGVycy5FcnJvckV2ZW50SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgLi4uZXZlbnRJbml0LFxuICB7XG4gICAga2V5OiAnbWVzc2FnZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnZmlsZW5hbWUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2xpbmVubycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyddLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gMFxuICB9LFxuICB7XG4gICAga2V5OiAnY29sbm8nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIGxvbmcnXSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ2Vycm9yJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueVxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTWVzc2FnZUV2ZW50LFxuICBDbG9zZUV2ZW50LFxuICBFcnJvckV2ZW50LFxuICBjcmVhdGVGYXN0TWVzc2FnZUV2ZW50XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/events.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/frame.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/frame.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { maxUnsigned16Bit, opcodes } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\n\nconst BUFFER_SIZE = 8 * 1024\n\n/** @type {import('crypto')} */\nlet crypto\nlet buffer = null\nlet bufIdx = BUFFER_SIZE\n\ntry {\n  crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\")\n/* c8 ignore next 3 */\n} catch {\n  crypto = {\n    // not full compatibility, but minimum.\n    randomFillSync: function randomFillSync (buffer, _offset, _size) {\n      for (let i = 0; i < buffer.length; ++i) {\n        buffer[i] = Math.random() * 255 | 0\n      }\n      return buffer\n    }\n  }\n}\n\nfunction generateMask () {\n  if (bufIdx === BUFFER_SIZE) {\n    bufIdx = 0\n    crypto.randomFillSync((buffer ??= Buffer.allocUnsafeSlow(BUFFER_SIZE)), 0, BUFFER_SIZE)\n  }\n  return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]]\n}\n\nclass WebsocketFrameSend {\n  /**\n   * @param {Buffer|undefined} data\n   */\n  constructor (data) {\n    this.frameData = data\n  }\n\n  createFrame (opcode) {\n    const frameData = this.frameData\n    const maskKey = generateMask()\n    const bodyLength = frameData?.byteLength ?? 0\n\n    /** @type {number} */\n    let payloadLength = bodyLength // 0-125\n    let offset = 6\n\n    if (bodyLength > maxUnsigned16Bit) {\n      offset += 8 // payload length is next 8 bytes\n      payloadLength = 127\n    } else if (bodyLength > 125) {\n      offset += 2 // payload length is next 2 bytes\n      payloadLength = 126\n    }\n\n    const buffer = Buffer.allocUnsafe(bodyLength + offset)\n\n    // Clear first 2 bytes, everything else is overwritten\n    buffer[0] = buffer[1] = 0\n    buffer[0] |= 0x80 // FIN\n    buffer[0] = (buffer[0] & 0xF0) + opcode // opcode\n\n    /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */\n    buffer[offset - 4] = maskKey[0]\n    buffer[offset - 3] = maskKey[1]\n    buffer[offset - 2] = maskKey[2]\n    buffer[offset - 1] = maskKey[3]\n\n    buffer[1] = payloadLength\n\n    if (payloadLength === 126) {\n      buffer.writeUInt16BE(bodyLength, 2)\n    } else if (payloadLength === 127) {\n      // Clear extended payload length\n      buffer[2] = buffer[3] = 0\n      buffer.writeUIntBE(bodyLength, 4, 6)\n    }\n\n    buffer[1] |= 0x80 // MASK\n\n    // mask body\n    for (let i = 0; i < bodyLength; ++i) {\n      buffer[offset + i] = frameData[i] ^ maskKey[i & 3]\n    }\n\n    return buffer\n  }\n\n  /**\n   * @param {Uint8Array} buffer\n   */\n  static createFastTextFrame (buffer) {\n    const maskKey = generateMask()\n\n    const bodyLength = buffer.length\n\n    // mask body\n    for (let i = 0; i < bodyLength; ++i) {\n      buffer[i] ^= maskKey[i & 3]\n    }\n\n    let payloadLength = bodyLength\n    let offset = 6\n\n    if (bodyLength > maxUnsigned16Bit) {\n      offset += 8 // payload length is next 8 bytes\n      payloadLength = 127\n    } else if (bodyLength > 125) {\n      offset += 2 // payload length is next 2 bytes\n      payloadLength = 126\n    }\n    const head = Buffer.allocUnsafeSlow(offset)\n\n    head[0] = 0x80 /* FIN */ | opcodes.TEXT /* opcode TEXT */\n    head[1] = payloadLength | 0x80 /* MASK */\n    head[offset - 4] = maskKey[0]\n    head[offset - 3] = maskKey[1]\n    head[offset - 2] = maskKey[2]\n    head[offset - 1] = maskKey[3]\n\n    if (payloadLength === 126) {\n      head.writeUInt16BE(bodyLength, 2)\n    } else if (payloadLength === 127) {\n      head[2] = head[3] = 0\n      head.writeUIntBE(bodyLength, 4, 6)\n    }\n\n    return [head, buffer]\n  }\n}\n\nmodule.exports = {\n  WebsocketFrameSend,\n  generateMask // for benchmark\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2ZyYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsNEJBQTRCLEVBQUUsbUJBQU8sQ0FBQywrRUFBYTs7QUFFM0Q7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLGdDQUFhO0FBQ2hDO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi93ZWJzb2NrZXQvZnJhbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgbWF4VW5zaWduZWQxNkJpdCwgb3Bjb2RlcyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuXG5jb25zdCBCVUZGRVJfU0laRSA9IDggKiAxMDI0XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCdjcnlwdG8nKX0gKi9cbmxldCBjcnlwdG9cbmxldCBidWZmZXIgPSBudWxsXG5sZXQgYnVmSWR4ID0gQlVGRkVSX1NJWkVcblxudHJ5IHtcbiAgY3J5cHRvID0gcmVxdWlyZSgnbm9kZTpjcnlwdG8nKVxuLyogYzggaWdub3JlIG5leHQgMyAqL1xufSBjYXRjaCB7XG4gIGNyeXB0byA9IHtcbiAgICAvLyBub3QgZnVsbCBjb21wYXRpYmlsaXR5LCBidXQgbWluaW11bS5cbiAgICByYW5kb21GaWxsU3luYzogZnVuY3Rpb24gcmFuZG9tRmlsbFN5bmMgKGJ1ZmZlciwgX29mZnNldCwgX3NpemUpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IE1hdGgucmFuZG9tKCkgKiAyNTUgfCAwXG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmZmVyXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTWFzayAoKSB7XG4gIGlmIChidWZJZHggPT09IEJVRkZFUl9TSVpFKSB7XG4gICAgYnVmSWR4ID0gMFxuICAgIGNyeXB0by5yYW5kb21GaWxsU3luYygoYnVmZmVyID8/PSBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KEJVRkZFUl9TSVpFKSksIDAsIEJVRkZFUl9TSVpFKVxuICB9XG4gIHJldHVybiBbYnVmZmVyW2J1ZklkeCsrXSwgYnVmZmVyW2J1ZklkeCsrXSwgYnVmZmVyW2J1ZklkeCsrXSwgYnVmZmVyW2J1ZklkeCsrXV1cbn1cblxuY2xhc3MgV2Vic29ja2V0RnJhbWVTZW5kIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfHVuZGVmaW5lZH0gZGF0YVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICB0aGlzLmZyYW1lRGF0YSA9IGRhdGFcbiAgfVxuXG4gIGNyZWF0ZUZyYW1lIChvcGNvZGUpIHtcbiAgICBjb25zdCBmcmFtZURhdGEgPSB0aGlzLmZyYW1lRGF0YVxuICAgIGNvbnN0IG1hc2tLZXkgPSBnZW5lcmF0ZU1hc2soKVxuICAgIGNvbnN0IGJvZHlMZW5ndGggPSBmcmFtZURhdGE/LmJ5dGVMZW5ndGggPz8gMFxuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgbGV0IHBheWxvYWRMZW5ndGggPSBib2R5TGVuZ3RoIC8vIDAtMTI1XG4gICAgbGV0IG9mZnNldCA9IDZcblxuICAgIGlmIChib2R5TGVuZ3RoID4gbWF4VW5zaWduZWQxNkJpdCkge1xuICAgICAgb2Zmc2V0ICs9IDggLy8gcGF5bG9hZCBsZW5ndGggaXMgbmV4dCA4IGJ5dGVzXG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI3XG4gICAgfSBlbHNlIGlmIChib2R5TGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMiAvLyBwYXlsb2FkIGxlbmd0aCBpcyBuZXh0IDIgYnl0ZXNcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjZcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYm9keUxlbmd0aCArIG9mZnNldClcblxuICAgIC8vIENsZWFyIGZpcnN0IDIgYnl0ZXMsIGV2ZXJ5dGhpbmcgZWxzZSBpcyBvdmVyd3JpdHRlblxuICAgIGJ1ZmZlclswXSA9IGJ1ZmZlclsxXSA9IDBcbiAgICBidWZmZXJbMF0gfD0gMHg4MCAvLyBGSU5cbiAgICBidWZmZXJbMF0gPSAoYnVmZmVyWzBdICYgMHhGMCkgKyBvcGNvZGUgLy8gb3Bjb2RlXG5cbiAgICAvKiEgd3MuIE1JVCBMaWNlbnNlLiBFaW5hciBPdHRvIFN0YW5ndmlrIDxlaW5hcm9zQGdtYWlsLmNvbT4gKi9cbiAgICBidWZmZXJbb2Zmc2V0IC0gNF0gPSBtYXNrS2V5WzBdXG4gICAgYnVmZmVyW29mZnNldCAtIDNdID0gbWFza0tleVsxXVxuICAgIGJ1ZmZlcltvZmZzZXQgLSAyXSA9IG1hc2tLZXlbMl1cbiAgICBidWZmZXJbb2Zmc2V0IC0gMV0gPSBtYXNrS2V5WzNdXG5cbiAgICBidWZmZXJbMV0gPSBwYXlsb2FkTGVuZ3RoXG5cbiAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICBidWZmZXIud3JpdGVVSW50MTZCRShib2R5TGVuZ3RoLCAyKVxuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICAvLyBDbGVhciBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aFxuICAgICAgYnVmZmVyWzJdID0gYnVmZmVyWzNdID0gMFxuICAgICAgYnVmZmVyLndyaXRlVUludEJFKGJvZHlMZW5ndGgsIDQsIDYpXG4gICAgfVxuXG4gICAgYnVmZmVyWzFdIHw9IDB4ODAgLy8gTUFTS1xuXG4gICAgLy8gbWFzayBib2R5XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2R5TGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGZyYW1lRGF0YVtpXSBeIG1hc2tLZXlbaSAmIDNdXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlRmFzdFRleHRGcmFtZSAoYnVmZmVyKSB7XG4gICAgY29uc3QgbWFza0tleSA9IGdlbmVyYXRlTWFzaygpXG5cbiAgICBjb25zdCBib2R5TGVuZ3RoID0gYnVmZmVyLmxlbmd0aFxuXG4gICAgLy8gbWFzayBib2R5XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2R5TGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ1ZmZlcltpXSBePSBtYXNrS2V5W2kgJiAzXVxuICAgIH1cblxuICAgIGxldCBwYXlsb2FkTGVuZ3RoID0gYm9keUxlbmd0aFxuICAgIGxldCBvZmZzZXQgPSA2XG5cbiAgICBpZiAoYm9keUxlbmd0aCA+IG1heFVuc2lnbmVkMTZCaXQpIHtcbiAgICAgIG9mZnNldCArPSA4IC8vIHBheWxvYWQgbGVuZ3RoIGlzIG5leHQgOCBieXRlc1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyN1xuICAgIH0gZWxzZSBpZiAoYm9keUxlbmd0aCA+IDEyNSkge1xuICAgICAgb2Zmc2V0ICs9IDIgLy8gcGF5bG9hZCBsZW5ndGggaXMgbmV4dCAyIGJ5dGVzXG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI2XG4gICAgfVxuICAgIGNvbnN0IGhlYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KG9mZnNldClcblxuICAgIGhlYWRbMF0gPSAweDgwIC8qIEZJTiAqLyB8IG9wY29kZXMuVEVYVCAvKiBvcGNvZGUgVEVYVCAqL1xuICAgIGhlYWRbMV0gPSBwYXlsb2FkTGVuZ3RoIHwgMHg4MCAvKiBNQVNLICovXG4gICAgaGVhZFtvZmZzZXQgLSA0XSA9IG1hc2tLZXlbMF1cbiAgICBoZWFkW29mZnNldCAtIDNdID0gbWFza0tleVsxXVxuICAgIGhlYWRbb2Zmc2V0IC0gMl0gPSBtYXNrS2V5WzJdXG4gICAgaGVhZFtvZmZzZXQgLSAxXSA9IG1hc2tLZXlbM11cblxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIGhlYWQud3JpdGVVSW50MTZCRShib2R5TGVuZ3RoLCAyKVxuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICBoZWFkWzJdID0gaGVhZFszXSA9IDBcbiAgICAgIGhlYWQud3JpdGVVSW50QkUoYm9keUxlbmd0aCwgNCwgNilcbiAgICB9XG5cbiAgICByZXR1cm4gW2hlYWQsIGJ1ZmZlcl1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2Vic29ja2V0RnJhbWVTZW5kLFxuICBnZW5lcmF0ZU1hc2sgLy8gZm9yIGJlbmNobWFya1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/frame.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/permessage-deflate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/permessage-deflate.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { createInflateRaw, Z_DEFAULT_WINDOWBITS } = __webpack_require__(/*! node:zlib */ \"node:zlib\")\nconst { isValidClientWindowBits } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/websocket/util.js\")\n\nconst tail = Buffer.from([0x00, 0x00, 0xff, 0xff])\nconst kBuffer = Symbol('kBuffer')\nconst kLength = Symbol('kLength')\n\nclass PerMessageDeflate {\n  /** @type {import('node:zlib').InflateRaw} */\n  #inflate\n\n  #options = {}\n\n  constructor (extensions) {\n    this.#options.serverNoContextTakeover = extensions.has('server_no_context_takeover')\n    this.#options.serverMaxWindowBits = extensions.get('server_max_window_bits')\n  }\n\n  decompress (chunk, fin, callback) {\n    // An endpoint uses the following algorithm to decompress a message.\n    // 1.  Append 4 octets of 0x00 0x00 0xff 0xff to the tail end of the\n    //     payload of the message.\n    // 2.  Decompress the resulting data using DEFLATE.\n\n    if (!this.#inflate) {\n      let windowBits = Z_DEFAULT_WINDOWBITS\n\n      if (this.#options.serverMaxWindowBits) { // empty values default to Z_DEFAULT_WINDOWBITS\n        if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) {\n          callback(new Error('Invalid server_max_window_bits'))\n          return\n        }\n\n        windowBits = Number.parseInt(this.#options.serverMaxWindowBits)\n      }\n\n      this.#inflate = createInflateRaw({ windowBits })\n      this.#inflate[kBuffer] = []\n      this.#inflate[kLength] = 0\n\n      this.#inflate.on('data', (data) => {\n        this.#inflate[kBuffer].push(data)\n        this.#inflate[kLength] += data.length\n      })\n\n      this.#inflate.on('error', (err) => {\n        this.#inflate = null\n        callback(err)\n      })\n    }\n\n    this.#inflate.write(chunk)\n    if (fin) {\n      this.#inflate.write(tail)\n    }\n\n    this.#inflate.flush(() => {\n      const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength])\n\n      this.#inflate[kBuffer].length = 0\n      this.#inflate[kLength] = 0\n\n      callback(null, full)\n    })\n  }\n}\n\nmodule.exports = { PerMessageDeflate }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLHlDQUF5QyxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDdEUsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLHFFQUFROztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGdDQUFnQztBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL3dlYnNvY2tldC9wZXJtZXNzYWdlLWRlZmxhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgY3JlYXRlSW5mbGF0ZVJhdywgWl9ERUZBVUxUX1dJTkRPV0JJVFMgfSA9IHJlcXVpcmUoJ25vZGU6emxpYicpXG5jb25zdCB7IGlzVmFsaWRDbGllbnRXaW5kb3dCaXRzIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG5jb25zdCB0YWlsID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4ZmYsIDB4ZmZdKVxuY29uc3Qga0J1ZmZlciA9IFN5bWJvbCgna0J1ZmZlcicpXG5jb25zdCBrTGVuZ3RoID0gU3ltYm9sKCdrTGVuZ3RoJylcblxuY2xhc3MgUGVyTWVzc2FnZURlZmxhdGUge1xuICAvKiogQHR5cGUge2ltcG9ydCgnbm9kZTp6bGliJykuSW5mbGF0ZVJhd30gKi9cbiAgI2luZmxhdGVcblxuICAjb3B0aW9ucyA9IHt9XG5cbiAgY29uc3RydWN0b3IgKGV4dGVuc2lvbnMpIHtcbiAgICB0aGlzLiNvcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyID0gZXh0ZW5zaW9ucy5oYXMoJ3NlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyJylcbiAgICB0aGlzLiNvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMgPSBleHRlbnNpb25zLmdldCgnc2VydmVyX21heF93aW5kb3dfYml0cycpXG4gIH1cblxuICBkZWNvbXByZXNzIChjaHVuaywgZmluLCBjYWxsYmFjaykge1xuICAgIC8vIEFuIGVuZHBvaW50IHVzZXMgdGhlIGZvbGxvd2luZyBhbGdvcml0aG0gdG8gZGVjb21wcmVzcyBhIG1lc3NhZ2UuXG4gICAgLy8gMS4gIEFwcGVuZCA0IG9jdGV0cyBvZiAweDAwIDB4MDAgMHhmZiAweGZmIHRvIHRoZSB0YWlsIGVuZCBvZiB0aGVcbiAgICAvLyAgICAgcGF5bG9hZCBvZiB0aGUgbWVzc2FnZS5cbiAgICAvLyAyLiAgRGVjb21wcmVzcyB0aGUgcmVzdWx0aW5nIGRhdGEgdXNpbmcgREVGTEFURS5cblxuICAgIGlmICghdGhpcy4jaW5mbGF0ZSkge1xuICAgICAgbGV0IHdpbmRvd0JpdHMgPSBaX0RFRkFVTFRfV0lORE9XQklUU1xuXG4gICAgICBpZiAodGhpcy4jb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzKSB7IC8vIGVtcHR5IHZhbHVlcyBkZWZhdWx0IHRvIFpfREVGQVVMVF9XSU5ET1dCSVRTXG4gICAgICAgIGlmICghaXNWYWxpZENsaWVudFdpbmRvd0JpdHModGhpcy4jb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzKSkge1xuICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignSW52YWxpZCBzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzJykpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3dCaXRzID0gTnVtYmVyLnBhcnNlSW50KHRoaXMuI29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cylcbiAgICAgIH1cblxuICAgICAgdGhpcy4jaW5mbGF0ZSA9IGNyZWF0ZUluZmxhdGVSYXcoeyB3aW5kb3dCaXRzIH0pXG4gICAgICB0aGlzLiNpbmZsYXRlW2tCdWZmZXJdID0gW11cbiAgICAgIHRoaXMuI2luZmxhdGVba0xlbmd0aF0gPSAwXG5cbiAgICAgIHRoaXMuI2luZmxhdGUub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICB0aGlzLiNpbmZsYXRlW2tCdWZmZXJdLnB1c2goZGF0YSlcbiAgICAgICAgdGhpcy4jaW5mbGF0ZVtrTGVuZ3RoXSArPSBkYXRhLmxlbmd0aFxuICAgICAgfSlcblxuICAgICAgdGhpcy4jaW5mbGF0ZS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuI2luZmxhdGUgPSBudWxsXG4gICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy4jaW5mbGF0ZS53cml0ZShjaHVuaylcbiAgICBpZiAoZmluKSB7XG4gICAgICB0aGlzLiNpbmZsYXRlLndyaXRlKHRhaWwpXG4gICAgfVxuXG4gICAgdGhpcy4jaW5mbGF0ZS5mbHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBmdWxsID0gQnVmZmVyLmNvbmNhdCh0aGlzLiNpbmZsYXRlW2tCdWZmZXJdLCB0aGlzLiNpbmZsYXRlW2tMZW5ndGhdKVxuXG4gICAgICB0aGlzLiNpbmZsYXRlW2tCdWZmZXJdLmxlbmd0aCA9IDBcbiAgICAgIHRoaXMuI2luZmxhdGVba0xlbmd0aF0gPSAwXG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGZ1bGwpXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgUGVyTWVzc2FnZURlZmxhdGUgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/permessage-deflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/receiver.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/receiver.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { Writable } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst { channels } = __webpack_require__(/*! ../../core/diagnostics */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\nconst {\n  isValidStatusCode,\n  isValidOpcode,\n  websocketMessageReceived,\n  utf8Decode,\n  isControlFrame,\n  isTextBinaryFrame,\n  isContinuationFrame\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/websocket/util.js\")\nconst { failWebsocketConnection } = __webpack_require__(/*! ./connection */ \"(rsc)/./node_modules/undici/lib/web/websocket/connection.js\")\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(rsc)/./node_modules/undici/lib/web/websocket/frame.js\")\nconst { PerMessageDeflate } = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/undici/lib/web/websocket/permessage-deflate.js\")\n\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\n\nclass ByteParser extends Writable {\n  #buffers = []\n  #fragmentsBytes = 0\n  #byteOffset = 0\n  #loop = false\n\n  #state = parserStates.INFO\n\n  #info = {}\n  #fragments = []\n\n  /** @type {Map<string, PerMessageDeflate>} */\n  #extensions\n\n  /** @type {import('./websocket').Handler} */\n  #handler\n\n  constructor (handler, extensions) {\n    super()\n\n    this.#handler = handler\n    this.#extensions = extensions == null ? new Map() : extensions\n\n    if (this.#extensions.has('permessage-deflate')) {\n      this.#extensions.set('permessage-deflate', new PerMessageDeflate(extensions))\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */\n  _write (chunk, _, callback) {\n    this.#buffers.push(chunk)\n    this.#byteOffset += chunk.length\n    this.#loop = true\n\n    this.run(callback)\n  }\n\n  /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */\n  run (callback) {\n    while (this.#loop) {\n      if (this.#state === parserStates.INFO) {\n        // If there aren't enough bytes to parse the payload length, etc.\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n        const fin = (buffer[0] & 0x80) !== 0\n        const opcode = buffer[0] & 0x0F\n        const masked = (buffer[1] & 0x80) === 0x80\n\n        const fragmented = !fin && opcode !== opcodes.CONTINUATION\n        const payloadLength = buffer[1] & 0x7F\n\n        const rsv1 = buffer[0] & 0x40\n        const rsv2 = buffer[0] & 0x20\n        const rsv3 = buffer[0] & 0x10\n\n        if (!isValidOpcode(opcode)) {\n          failWebsocketConnection(this.#handler, 1002, 'Invalid opcode received')\n          return callback()\n        }\n\n        if (masked) {\n          failWebsocketConnection(this.#handler, 1002, 'Frame cannot be masked')\n          return callback()\n        }\n\n        // MUST be 0 unless an extension is negotiated that defines meanings\n        // for non-zero values.  If a nonzero value is received and none of\n        // the negotiated extensions defines the meaning of such a nonzero\n        // value, the receiving endpoint MUST _Fail the WebSocket\n        // Connection_.\n        // This document allocates the RSV1 bit of the WebSocket header for\n        // PMCEs and calls the bit the \"Per-Message Compressed\" bit.  On a\n        // WebSocket connection where a PMCE is in use, this bit indicates\n        // whether a message is compressed or not.\n        if (rsv1 !== 0 && !this.#extensions.has('permessage-deflate')) {\n          failWebsocketConnection(this.#handler, 1002, 'Expected RSV1 to be clear.')\n          return\n        }\n\n        if (rsv2 !== 0 || rsv3 !== 0) {\n          failWebsocketConnection(this.#handler, 1002, 'RSV1, RSV2, RSV3 must be clear')\n          return\n        }\n\n        if (fragmented && !isTextBinaryFrame(opcode)) {\n          // Only text and binary frames can be fragmented\n          failWebsocketConnection(this.#handler, 1002, 'Invalid frame type was fragmented.')\n          return\n        }\n\n        // If we are already parsing a text/binary frame and do not receive either\n        // a continuation frame or close frame, fail the connection.\n        if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {\n          failWebsocketConnection(this.#handler, 1002, 'Expected continuation frame')\n          return\n        }\n\n        if (this.#info.fragmented && fragmented) {\n          // A fragmented frame can't be fragmented itself\n          failWebsocketConnection(this.#handler, 1002, 'Fragmented frame exceeded 125 bytes.')\n          return\n        }\n\n        // \"All control frames MUST have a payload length of 125 bytes or less\n        // and MUST NOT be fragmented.\"\n        if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {\n          failWebsocketConnection(this.#handler, 1002, 'Control frame either too large or fragmented')\n          return\n        }\n\n        if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {\n          failWebsocketConnection(this.#handler, 1002, 'Unexpected continuation frame')\n          return\n        }\n\n        if (payloadLength <= 125) {\n          this.#info.payloadLength = payloadLength\n          this.#state = parserStates.READ_DATA\n        } else if (payloadLength === 126) {\n          this.#state = parserStates.PAYLOADLENGTH_16\n        } else if (payloadLength === 127) {\n          this.#state = parserStates.PAYLOADLENGTH_64\n        }\n\n        if (isTextBinaryFrame(opcode)) {\n          this.#info.binaryType = opcode\n          this.#info.compressed = rsv1 !== 0\n        }\n\n        this.#info.opcode = opcode\n        this.#info.masked = masked\n        this.#info.fin = fin\n        this.#info.fragmented = fragmented\n      } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n\n        this.#info.payloadLength = buffer.readUInt16BE(0)\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n        if (this.#byteOffset < 8) {\n          return callback()\n        }\n\n        const buffer = this.consume(8)\n        const upper = buffer.readUInt32BE(0)\n\n        // 2^31 is the maximum bytes an arraybuffer can contain\n        // on 32-bit systems. Although, on 64-bit systems, this is\n        // 2^53-1 bytes.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n        if (upper > 2 ** 31 - 1) {\n          failWebsocketConnection(this.#handler, 1009, 'Received payload length > 2^31 bytes.')\n          return\n        }\n\n        const lower = buffer.readUInt32BE(4)\n\n        this.#info.payloadLength = (upper << 8) + lower\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.READ_DATA) {\n        if (this.#byteOffset < this.#info.payloadLength) {\n          return callback()\n        }\n\n        const body = this.consume(this.#info.payloadLength)\n\n        if (isControlFrame(this.#info.opcode)) {\n          this.#loop = this.parseControlFrame(body)\n          this.#state = parserStates.INFO\n        } else {\n          if (!this.#info.compressed) {\n            this.writeFragments(body)\n\n            // If the frame is not fragmented, a message has been received.\n            // If the frame is fragmented, it will terminate with a fin bit set\n            // and an opcode of 0 (continuation), therefore we handle that when\n            // parsing continuation frames, not here.\n            if (!this.#info.fragmented && this.#info.fin) {\n              websocketMessageReceived(this.#handler, this.#info.binaryType, this.consumeFragments())\n            }\n\n            this.#state = parserStates.INFO\n          } else {\n            this.#extensions.get('permessage-deflate').decompress(body, this.#info.fin, (error, data) => {\n              if (error) {\n                failWebsocketConnection(this.#handler, 1007, error.message)\n                return\n              }\n\n              this.writeFragments(data)\n\n              if (!this.#info.fin) {\n                this.#state = parserStates.INFO\n                this.#loop = true\n                this.run(callback)\n                return\n              }\n\n              websocketMessageReceived(this.#handler, this.#info.binaryType, this.consumeFragments())\n\n              this.#loop = true\n              this.#state = parserStates.INFO\n              this.run(callback)\n            })\n\n            this.#loop = false\n            break\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer}\n   */\n  consume (n) {\n    if (n > this.#byteOffset) {\n      throw new Error('Called consume() before buffers satiated.')\n    } else if (n === 0) {\n      return emptyBuffer\n    }\n\n    this.#byteOffset -= n\n\n    const first = this.#buffers[0]\n\n    if (first.length > n) {\n      // replace with remaining buffer\n      this.#buffers[0] = first.subarray(n, first.length)\n      return first.subarray(0, n)\n    } else if (first.length === n) {\n      // prefect match\n      return this.#buffers.shift()\n    } else {\n      let offset = 0\n      // If Buffer.allocUnsafe is used, extra copies will be made because the offset is non-zero.\n      const buffer = Buffer.allocUnsafeSlow(n)\n      while (offset !== n) {\n        const next = this.#buffers[0]\n        const length = next.length\n\n        if (length + offset === n) {\n          buffer.set(this.#buffers.shift(), offset)\n          break\n        } else if (length + offset > n) {\n          buffer.set(next.subarray(0, n - offset), offset)\n          this.#buffers[0] = next.subarray(n - offset)\n          break\n        } else {\n          buffer.set(this.#buffers.shift(), offset)\n          offset += length\n        }\n      }\n\n      return buffer\n    }\n  }\n\n  writeFragments (fragment) {\n    this.#fragmentsBytes += fragment.length\n    this.#fragments.push(fragment)\n  }\n\n  consumeFragments () {\n    const fragments = this.#fragments\n\n    if (fragments.length === 1) {\n      // single fragment\n      this.#fragmentsBytes = 0\n      return fragments.shift()\n    }\n\n    let offset = 0\n    // If Buffer.allocUnsafe is used, extra copies will be made because the offset is non-zero.\n    const output = Buffer.allocUnsafeSlow(this.#fragmentsBytes)\n\n    for (let i = 0; i < fragments.length; ++i) {\n      const buffer = fragments[i]\n      output.set(buffer, offset)\n      offset += buffer.length\n    }\n\n    this.#fragments = []\n    this.#fragmentsBytes = 0\n\n    return output\n  }\n\n  parseCloseBody (data) {\n    assert(data.length !== 1)\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n    /** @type {number|undefined} */\n    let code\n\n    if (data.length >= 2) {\n      // _The WebSocket Connection Close Code_ is\n      // defined as the status code (Section 7.4) contained in the first Close\n      // control frame received by the application\n      code = data.readUInt16BE(0)\n    }\n\n    if (code !== undefined && !isValidStatusCode(code)) {\n      return { code: 1002, reason: 'Invalid status code', error: true }\n    }\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n    /** @type {Buffer} */\n    let reason = data.subarray(2)\n\n    // Remove BOM\n    if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n      reason = reason.subarray(3)\n    }\n\n    try {\n      reason = utf8Decode(reason)\n    } catch {\n      return { code: 1007, reason: 'Invalid UTF-8', error: true }\n    }\n\n    return { code, reason, error: false }\n  }\n\n  /**\n   * Parses control frames.\n   * @param {Buffer} body\n   */\n  parseControlFrame (body) {\n    const { opcode, payloadLength } = this.#info\n\n    if (opcode === opcodes.CLOSE) {\n      if (payloadLength === 1) {\n        failWebsocketConnection(this.#handler, 1002, 'Received close frame with a 1-byte body.')\n        return false\n      }\n\n      this.#info.closeInfo = this.parseCloseBody(body)\n\n      if (this.#info.closeInfo.error) {\n        const { code, reason } = this.#info.closeInfo\n\n        failWebsocketConnection(this.#handler, code, reason)\n        return false\n      }\n\n      // Upon receiving such a frame, the other peer sends a\n      // Close frame in response, if it hasn't already sent one.\n      if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {\n        // If an endpoint receives a Close frame and did not previously send a\n        // Close frame, the endpoint MUST send a Close frame in response.  (When\n        // sending a Close frame in response, the endpoint typically echos the\n        // status code it received.)\n        let body = emptyBuffer\n        if (this.#info.closeInfo.code) {\n          body = Buffer.allocUnsafe(2)\n          body.writeUInt16BE(this.#info.closeInfo.code, 0)\n        }\n        const closeFrame = new WebsocketFrameSend(body)\n\n        this.#handler.socket.write(closeFrame.createFrame(opcodes.CLOSE))\n        this.#handler.closeState.add(sentCloseFrameState.SENT)\n      }\n\n      // Upon either sending or receiving a Close control frame, it is said\n      // that _The WebSocket Closing Handshake is Started_ and that the\n      // WebSocket connection is in the CLOSING state.\n      this.#handler.readyState = states.CLOSING\n      this.#handler.closeState.add(sentCloseFrameState.RECEIVED)\n\n      return false\n    } else if (opcode === opcodes.PING) {\n      // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n      // response, unless it already received a Close frame.\n      // A Pong frame sent in response to a Ping frame must have identical\n      // \"Application data\"\n\n      if (!this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {\n        const frame = new WebsocketFrameSend(body)\n\n        this.#handler.socket.write(frame.createFrame(opcodes.PONG))\n\n        if (channels.ping.hasSubscribers) {\n          channels.ping.publish({\n            payload: body\n          })\n        }\n      }\n    } else if (opcode === opcodes.PONG) {\n      // A Pong frame MAY be sent unsolicited.  This serves as a\n      // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n      // not expected.\n\n      if (channels.pong.hasSubscribers) {\n        channels.pong.publish({\n          payload: body\n        })\n      }\n    }\n\n    return true\n  }\n\n  get closingInfo () {\n    return this.#info.closeInfo\n  }\n}\n\nmodule.exports = {\n  ByteParser\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsa0VBQWtFLEVBQUUsbUJBQU8sQ0FBQywrRUFBYTtBQUNqRyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLG1GQUF3QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMscUVBQVE7QUFDcEIsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLGlGQUFjO0FBQzFELFFBQVEscUJBQXFCLEVBQUUsbUJBQU8sQ0FBQyx1RUFBUztBQUNoRCxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsaUdBQXNCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxnQ0FBZ0M7QUFDN0M7O0FBRUEsYUFBYSwrQkFBK0I7QUFDNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLDZDQUE2QyxNQUFNLE1BQU07QUFDckoscUdBQXFHLEtBQUs7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGVBQWU7QUFDZjs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsZUFBZTs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi93ZWJzb2NrZXQvcmVjZWl2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgV3JpdGFibGUgfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgcGFyc2VyU3RhdGVzLCBvcGNvZGVzLCBzdGF0ZXMsIGVtcHR5QnVmZmVyLCBzZW50Q2xvc2VGcmFtZVN0YXRlIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RpYWdub3N0aWNzJylcbmNvbnN0IHtcbiAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gIGlzVmFsaWRPcGNvZGUsXG4gIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCxcbiAgdXRmOERlY29kZSxcbiAgaXNDb250cm9sRnJhbWUsXG4gIGlzVGV4dEJpbmFyeUZyYW1lLFxuICBpc0NvbnRpbnVhdGlvbkZyYW1lXG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24gfSA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbicpXG5jb25zdCB7IFdlYnNvY2tldEZyYW1lU2VuZCB9ID0gcmVxdWlyZSgnLi9mcmFtZScpXG5jb25zdCB7IFBlck1lc3NhZ2VEZWZsYXRlIH0gPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpXG5cbi8vIFRoaXMgY29kZSB3YXMgaW5mbHVlbmNlZCBieSB3cyByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTEgRWluYXIgT3R0byBTdGFuZ3ZpayA8ZWluYXJvc0BnbWFpbC5jb20+XG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQXJub3V0IEthemVtaWVyIGFuZCBjb250cmlidXRvcnNcbi8vIENvcHlyaWdodCAoYykgMjAxNiBMdWlnaSBQaW5jYSBhbmQgY29udHJpYnV0b3JzXG5cbmNsYXNzIEJ5dGVQYXJzZXIgZXh0ZW5kcyBXcml0YWJsZSB7XG4gICNidWZmZXJzID0gW11cbiAgI2ZyYWdtZW50c0J5dGVzID0gMFxuICAjYnl0ZU9mZnNldCA9IDBcbiAgI2xvb3AgPSBmYWxzZVxuXG4gICNzdGF0ZSA9IHBhcnNlclN0YXRlcy5JTkZPXG5cbiAgI2luZm8gPSB7fVxuICAjZnJhZ21lbnRzID0gW11cblxuICAvKiogQHR5cGUge01hcDxzdHJpbmcsIFBlck1lc3NhZ2VEZWZsYXRlPn0gKi9cbiAgI2V4dGVuc2lvbnNcblxuICAvKiogQHR5cGUge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5IYW5kbGVyfSAqL1xuICAjaGFuZGxlclxuXG4gIGNvbnN0cnVjdG9yIChoYW5kbGVyLCBleHRlbnNpb25zKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy4jaGFuZGxlciA9IGhhbmRsZXJcbiAgICB0aGlzLiNleHRlbnNpb25zID0gZXh0ZW5zaW9ucyA9PSBudWxsID8gbmV3IE1hcCgpIDogZXh0ZW5zaW9uc1xuXG4gICAgaWYgKHRoaXMuI2V4dGVuc2lvbnMuaGFzKCdwZXJtZXNzYWdlLWRlZmxhdGUnKSkge1xuICAgICAgdGhpcy4jZXh0ZW5zaW9ucy5zZXQoJ3Blcm1lc3NhZ2UtZGVmbGF0ZScsIG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShleHRlbnNpb25zKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rXG4gICAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAgICovXG4gIF93cml0ZSAoY2h1bmssIF8sIGNhbGxiYWNrKSB7XG4gICAgdGhpcy4jYnVmZmVycy5wdXNoKGNodW5rKVxuICAgIHRoaXMuI2J5dGVPZmZzZXQgKz0gY2h1bmsubGVuZ3RoXG4gICAgdGhpcy4jbG9vcCA9IHRydWVcblxuICAgIHRoaXMucnVuKGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgd2hlbmV2ZXIgYSBuZXcgY2h1bmsgaXMgcmVjZWl2ZWQuXG4gICAqIENhbGxiYWNrIGlzIGNhbGxlZCB3aGVuZXZlciB0aGVyZSBhcmUgbm8gbW9yZSBjaHVua3MgYnVmZmVyaW5nLFxuICAgKiBvciBub3QgZW5vdWdoIGJ5dGVzIGFyZSBidWZmZXJlZCB0byBwYXJzZS5cbiAgICovXG4gIHJ1biAoY2FsbGJhY2spIHtcbiAgICB3aGlsZSAodGhpcy4jbG9vcCkge1xuICAgICAgaWYgKHRoaXMuI3N0YXRlID09PSBwYXJzZXJTdGF0ZXMuSU5GTykge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmVuJ3QgZW5vdWdoIGJ5dGVzIHRvIHBhcnNlIHRoZSBwYXlsb2FkIGxlbmd0aCwgZXRjLlxuICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA8IDIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5jb25zdW1lKDIpXG4gICAgICAgIGNvbnN0IGZpbiA9IChidWZmZXJbMF0gJiAweDgwKSAhPT0gMFxuICAgICAgICBjb25zdCBvcGNvZGUgPSBidWZmZXJbMF0gJiAweDBGXG4gICAgICAgIGNvbnN0IG1hc2tlZCA9IChidWZmZXJbMV0gJiAweDgwKSA9PT0gMHg4MFxuXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ZWQgPSAhZmluICYmIG9wY29kZSAhPT0gb3Bjb2Rlcy5DT05USU5VQVRJT05cbiAgICAgICAgY29uc3QgcGF5bG9hZExlbmd0aCA9IGJ1ZmZlclsxXSAmIDB4N0ZcblxuICAgICAgICBjb25zdCByc3YxID0gYnVmZmVyWzBdICYgMHg0MFxuICAgICAgICBjb25zdCByc3YyID0gYnVmZmVyWzBdICYgMHgyMFxuICAgICAgICBjb25zdCByc3YzID0gYnVmZmVyWzBdICYgMHgxMFxuXG4gICAgICAgIGlmICghaXNWYWxpZE9wY29kZShvcGNvZGUpKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgMTAwMiwgJ0ludmFsaWQgb3Bjb2RlIHJlY2VpdmVkJylcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hc2tlZCkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMuI2hhbmRsZXIsIDEwMDIsICdGcmFtZSBjYW5ub3QgYmUgbWFza2VkJylcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTVVTVCBiZSAwIHVubGVzcyBhbiBleHRlbnNpb24gaXMgbmVnb3RpYXRlZCB0aGF0IGRlZmluZXMgbWVhbmluZ3NcbiAgICAgICAgLy8gZm9yIG5vbi16ZXJvIHZhbHVlcy4gIElmIGEgbm9uemVybyB2YWx1ZSBpcyByZWNlaXZlZCBhbmQgbm9uZSBvZlxuICAgICAgICAvLyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zIGRlZmluZXMgdGhlIG1lYW5pbmcgb2Ygc3VjaCBhIG5vbnplcm9cbiAgICAgICAgLy8gdmFsdWUsIHRoZSByZWNlaXZpbmcgZW5kcG9pbnQgTVVTVCBfRmFpbCB0aGUgV2ViU29ja2V0XG4gICAgICAgIC8vIENvbm5lY3Rpb25fLlxuICAgICAgICAvLyBUaGlzIGRvY3VtZW50IGFsbG9jYXRlcyB0aGUgUlNWMSBiaXQgb2YgdGhlIFdlYlNvY2tldCBoZWFkZXIgZm9yXG4gICAgICAgIC8vIFBNQ0VzIGFuZCBjYWxscyB0aGUgYml0IHRoZSBcIlBlci1NZXNzYWdlIENvbXByZXNzZWRcIiBiaXQuICBPbiBhXG4gICAgICAgIC8vIFdlYlNvY2tldCBjb25uZWN0aW9uIHdoZXJlIGEgUE1DRSBpcyBpbiB1c2UsIHRoaXMgYml0IGluZGljYXRlc1xuICAgICAgICAvLyB3aGV0aGVyIGEgbWVzc2FnZSBpcyBjb21wcmVzc2VkIG9yIG5vdC5cbiAgICAgICAgaWYgKHJzdjEgIT09IDAgJiYgIXRoaXMuI2V4dGVuc2lvbnMuaGFzKCdwZXJtZXNzYWdlLWRlZmxhdGUnKSkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMuI2hhbmRsZXIsIDEwMDIsICdFeHBlY3RlZCBSU1YxIHRvIGJlIGNsZWFyLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocnN2MiAhPT0gMCB8fCByc3YzICE9PSAwKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgMTAwMiwgJ1JTVjEsIFJTVjIsIFJTVjMgbXVzdCBiZSBjbGVhcicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnJhZ21lbnRlZCAmJiAhaXNUZXh0QmluYXJ5RnJhbWUob3Bjb2RlKSkge1xuICAgICAgICAgIC8vIE9ubHkgdGV4dCBhbmQgYmluYXJ5IGZyYW1lcyBjYW4gYmUgZnJhZ21lbnRlZFxuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMuI2hhbmRsZXIsIDEwMDIsICdJbnZhbGlkIGZyYW1lIHR5cGUgd2FzIGZyYWdtZW50ZWQuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IHBhcnNpbmcgYSB0ZXh0L2JpbmFyeSBmcmFtZSBhbmQgZG8gbm90IHJlY2VpdmUgZWl0aGVyXG4gICAgICAgIC8vIGEgY29udGludWF0aW9uIGZyYW1lIG9yIGNsb3NlIGZyYW1lLCBmYWlsIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICBpZiAoaXNUZXh0QmluYXJ5RnJhbWUob3Bjb2RlKSAmJiB0aGlzLiNmcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMuI2hhbmRsZXIsIDEwMDIsICdFeHBlY3RlZCBjb250aW51YXRpb24gZnJhbWUnKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuI2luZm8uZnJhZ21lbnRlZCAmJiBmcmFnbWVudGVkKSB7XG4gICAgICAgICAgLy8gQSBmcmFnbWVudGVkIGZyYW1lIGNhbid0IGJlIGZyYWdtZW50ZWQgaXRzZWxmXG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgMTAwMiwgJ0ZyYWdtZW50ZWQgZnJhbWUgZXhjZWVkZWQgMTI1IGJ5dGVzLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBcIkFsbCBjb250cm9sIGZyYW1lcyBNVVNUIGhhdmUgYSBwYXlsb2FkIGxlbmd0aCBvZiAxMjUgYnl0ZXMgb3IgbGVzc1xuICAgICAgICAvLyBhbmQgTVVTVCBOT1QgYmUgZnJhZ21lbnRlZC5cIlxuICAgICAgICBpZiAoKHBheWxvYWRMZW5ndGggPiAxMjUgfHwgZnJhZ21lbnRlZCkgJiYgaXNDb250cm9sRnJhbWUob3Bjb2RlKSkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMuI2hhbmRsZXIsIDEwMDIsICdDb250cm9sIGZyYW1lIGVpdGhlciB0b28gbGFyZ2Ugb3IgZnJhZ21lbnRlZCcpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDb250aW51YXRpb25GcmFtZShvcGNvZGUpICYmIHRoaXMuI2ZyYWdtZW50cy5sZW5ndGggPT09IDAgJiYgIXRoaXMuI2luZm8uY29tcHJlc3NlZCkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMuI2hhbmRsZXIsIDEwMDIsICdVbmV4cGVjdGVkIGNvbnRpbnVhdGlvbiBmcmFtZScpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF5bG9hZExlbmd0aCA8PSAxMjUpIHtcbiAgICAgICAgICB0aGlzLiNpbmZvLnBheWxvYWRMZW5ndGggPSBwYXlsb2FkTGVuZ3RoXG4gICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUkVBRF9EQVRBXG4gICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUEFZTE9BRExFTkdUSF8xNlxuICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xuICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLlBBWUxPQURMRU5HVEhfNjRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1RleHRCaW5hcnlGcmFtZShvcGNvZGUpKSB7XG4gICAgICAgICAgdGhpcy4jaW5mby5iaW5hcnlUeXBlID0gb3Bjb2RlXG4gICAgICAgICAgdGhpcy4jaW5mby5jb21wcmVzc2VkID0gcnN2MSAhPT0gMFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4jaW5mby5vcGNvZGUgPSBvcGNvZGVcbiAgICAgICAgdGhpcy4jaW5mby5tYXNrZWQgPSBtYXNrZWRcbiAgICAgICAgdGhpcy4jaW5mby5maW4gPSBmaW5cbiAgICAgICAgdGhpcy4jaW5mby5mcmFnbWVudGVkID0gZnJhZ21lbnRlZFxuICAgICAgfSBlbHNlIGlmICh0aGlzLiNzdGF0ZSA9PT0gcGFyc2VyU3RhdGVzLlBBWUxPQURMRU5HVEhfMTYpIHtcbiAgICAgICAgaWYgKHRoaXMuI2J5dGVPZmZzZXQgPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuY29uc3VtZSgyKVxuXG4gICAgICAgIHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aCA9IGJ1ZmZlci5yZWFkVUludDE2QkUoMClcbiAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUkVBRF9EQVRBXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3N0YXRlID09PSBwYXJzZXJTdGF0ZXMuUEFZTE9BRExFTkdUSF82NCkge1xuICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA8IDgpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5jb25zdW1lKDgpXG4gICAgICAgIGNvbnN0IHVwcGVyID0gYnVmZmVyLnJlYWRVSW50MzJCRSgwKVxuXG4gICAgICAgIC8vIDJeMzEgaXMgdGhlIG1heGltdW0gYnl0ZXMgYW4gYXJyYXlidWZmZXIgY2FuIGNvbnRhaW5cbiAgICAgICAgLy8gb24gMzItYml0IHN5c3RlbXMuIEFsdGhvdWdoLCBvbiA2NC1iaXQgc3lzdGVtcywgdGhpcyBpc1xuICAgICAgICAvLyAyXjUzLTEgYnl0ZXMuXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Vycm9ycy9JbnZhbGlkX2FycmF5X2xlbmd0aFxuICAgICAgICAvLyBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjp2OC9zcmMvY29tbW9uL2dsb2JhbHMuaDtkcmM9MTk0NjIxMmFjMDEwMDY2OGYxNGViOWUyODQzYmRkODQ2ZTUxMGExZTticHY9MTticHQ9MTtsPTEyNzVcbiAgICAgICAgLy8gaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL21haW46djgvc3JjL29iamVjdHMvanMtYXJyYXktYnVmZmVyLmg7bD0zNDtkcmM9MTk0NjIxMmFjMDEwMDY2OGYxNGViOWUyODQzYmRkODQ2ZTUxMGExZVxuICAgICAgICBpZiAodXBwZXIgPiAyICoqIDMxIC0gMSkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMuI2hhbmRsZXIsIDEwMDksICdSZWNlaXZlZCBwYXlsb2FkIGxlbmd0aCA+IDJeMzEgYnl0ZXMuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvd2VyID0gYnVmZmVyLnJlYWRVSW50MzJCRSg0KVxuXG4gICAgICAgIHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aCA9ICh1cHBlciA8PCA4KSArIGxvd2VyXG4gICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLlJFQURfREFUQVxuICAgICAgfSBlbHNlIGlmICh0aGlzLiNzdGF0ZSA9PT0gcGFyc2VyU3RhdGVzLlJFQURfREFUQSkge1xuICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA8IHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5jb25zdW1lKHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aClcblxuICAgICAgICBpZiAoaXNDb250cm9sRnJhbWUodGhpcy4jaW5mby5vcGNvZGUpKSB7XG4gICAgICAgICAgdGhpcy4jbG9vcCA9IHRoaXMucGFyc2VDb250cm9sRnJhbWUoYm9keSlcbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5JTkZPXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNpbmZvLmNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVGcmFnbWVudHMoYm9keSlcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGZyYW1lIGlzIG5vdCBmcmFnbWVudGVkLCBhIG1lc3NhZ2UgaGFzIGJlZW4gcmVjZWl2ZWQuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZnJhbWUgaXMgZnJhZ21lbnRlZCwgaXQgd2lsbCB0ZXJtaW5hdGUgd2l0aCBhIGZpbiBiaXQgc2V0XG4gICAgICAgICAgICAvLyBhbmQgYW4gb3Bjb2RlIG9mIDAgKGNvbnRpbnVhdGlvbiksIHRoZXJlZm9yZSB3ZSBoYW5kbGUgdGhhdCB3aGVuXG4gICAgICAgICAgICAvLyBwYXJzaW5nIGNvbnRpbnVhdGlvbiBmcmFtZXMsIG5vdCBoZXJlLlxuICAgICAgICAgICAgaWYgKCF0aGlzLiNpbmZvLmZyYWdtZW50ZWQgJiYgdGhpcy4jaW5mby5maW4pIHtcbiAgICAgICAgICAgICAgd2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkKHRoaXMuI2hhbmRsZXIsIHRoaXMuI2luZm8uYmluYXJ5VHlwZSwgdGhpcy5jb25zdW1lRnJhZ21lbnRzKCkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jZXh0ZW5zaW9ucy5nZXQoJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpLmRlY29tcHJlc3MoYm9keSwgdGhpcy4jaW5mby5maW4sIChlcnJvciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLiNoYW5kbGVyLCAxMDA3LCBlcnJvci5tZXNzYWdlKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy53cml0ZUZyYWdtZW50cyhkYXRhKVxuXG4gICAgICAgICAgICAgIGlmICghdGhpcy4jaW5mby5maW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5JTkZPXG4gICAgICAgICAgICAgICAgdGhpcy4jbG9vcCA9IHRydWVcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCh0aGlzLiNoYW5kbGVyLCB0aGlzLiNpbmZvLmJpbmFyeVR5cGUsIHRoaXMuY29uc3VtZUZyYWdtZW50cygpKVxuXG4gICAgICAgICAgICAgIHRoaXMuI2xvb3AgPSB0cnVlXG4gICAgICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cbiAgICAgICAgICAgICAgdGhpcy5ydW4oY2FsbGJhY2spXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0aGlzLiNsb29wID0gZmFsc2VcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRha2UgbiBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBCdWZmZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gICAqL1xuICBjb25zdW1lIChuKSB7XG4gICAgaWYgKG4gPiB0aGlzLiNieXRlT2Zmc2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxlZCBjb25zdW1lKCkgYmVmb3JlIGJ1ZmZlcnMgc2F0aWF0ZWQuJylcbiAgICB9IGVsc2UgaWYgKG4gPT09IDApIHtcbiAgICAgIHJldHVybiBlbXB0eUJ1ZmZlclxuICAgIH1cblxuICAgIHRoaXMuI2J5dGVPZmZzZXQgLT0gblxuXG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLiNidWZmZXJzWzBdXG5cbiAgICBpZiAoZmlyc3QubGVuZ3RoID4gbikge1xuICAgICAgLy8gcmVwbGFjZSB3aXRoIHJlbWFpbmluZyBidWZmZXJcbiAgICAgIHRoaXMuI2J1ZmZlcnNbMF0gPSBmaXJzdC5zdWJhcnJheShuLCBmaXJzdC5sZW5ndGgpXG4gICAgICByZXR1cm4gZmlyc3Quc3ViYXJyYXkoMCwgbilcbiAgICB9IGVsc2UgaWYgKGZpcnN0Lmxlbmd0aCA9PT0gbikge1xuICAgICAgLy8gcHJlZmVjdCBtYXRjaFxuICAgICAgcmV0dXJuIHRoaXMuI2J1ZmZlcnMuc2hpZnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gMFxuICAgICAgLy8gSWYgQnVmZmVyLmFsbG9jVW5zYWZlIGlzIHVzZWQsIGV4dHJhIGNvcGllcyB3aWxsIGJlIG1hZGUgYmVjYXVzZSB0aGUgb2Zmc2V0IGlzIG5vbi16ZXJvLlxuICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyhuKVxuICAgICAgd2hpbGUgKG9mZnNldCAhPT0gbikge1xuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy4jYnVmZmVyc1swXVxuICAgICAgICBjb25zdCBsZW5ndGggPSBuZXh0Lmxlbmd0aFxuXG4gICAgICAgIGlmIChsZW5ndGggKyBvZmZzZXQgPT09IG4pIHtcbiAgICAgICAgICBidWZmZXIuc2V0KHRoaXMuI2J1ZmZlcnMuc2hpZnQoKSwgb2Zmc2V0KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoICsgb2Zmc2V0ID4gbikge1xuICAgICAgICAgIGJ1ZmZlci5zZXQobmV4dC5zdWJhcnJheSgwLCBuIC0gb2Zmc2V0KSwgb2Zmc2V0KVxuICAgICAgICAgIHRoaXMuI2J1ZmZlcnNbMF0gPSBuZXh0LnN1YmFycmF5KG4gLSBvZmZzZXQpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWZmZXIuc2V0KHRoaXMuI2J1ZmZlcnMuc2hpZnQoKSwgb2Zmc2V0KVxuICAgICAgICAgIG9mZnNldCArPSBsZW5ndGhcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgd3JpdGVGcmFnbWVudHMgKGZyYWdtZW50KSB7XG4gICAgdGhpcy4jZnJhZ21lbnRzQnl0ZXMgKz0gZnJhZ21lbnQubGVuZ3RoXG4gICAgdGhpcy4jZnJhZ21lbnRzLnB1c2goZnJhZ21lbnQpXG4gIH1cblxuICBjb25zdW1lRnJhZ21lbnRzICgpIHtcbiAgICBjb25zdCBmcmFnbWVudHMgPSB0aGlzLiNmcmFnbWVudHNcblxuICAgIGlmIChmcmFnbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBzaW5nbGUgZnJhZ21lbnRcbiAgICAgIHRoaXMuI2ZyYWdtZW50c0J5dGVzID0gMFxuICAgICAgcmV0dXJuIGZyYWdtZW50cy5zaGlmdCgpXG4gICAgfVxuXG4gICAgbGV0IG9mZnNldCA9IDBcbiAgICAvLyBJZiBCdWZmZXIuYWxsb2NVbnNhZmUgaXMgdXNlZCwgZXh0cmEgY29waWVzIHdpbGwgYmUgbWFkZSBiZWNhdXNlIHRoZSBvZmZzZXQgaXMgbm9uLXplcm8uXG4gICAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyh0aGlzLiNmcmFnbWVudHNCeXRlcylcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBmcmFnbWVudHNbaV1cbiAgICAgIG91dHB1dC5zZXQoYnVmZmVyLCBvZmZzZXQpXG4gICAgICBvZmZzZXQgKz0gYnVmZmVyLmxlbmd0aFxuICAgIH1cblxuICAgIHRoaXMuI2ZyYWdtZW50cyA9IFtdXG4gICAgdGhpcy4jZnJhZ21lbnRzQnl0ZXMgPSAwXG5cbiAgICByZXR1cm4gb3V0cHV0XG4gIH1cblxuICBwYXJzZUNsb3NlQm9keSAoZGF0YSkge1xuICAgIGFzc2VydChkYXRhLmxlbmd0aCAhPT0gMSlcblxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTcuMS41XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgIGxldCBjb2RlXG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPj0gMikge1xuICAgICAgLy8gX1RoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbiBDbG9zZSBDb2RlXyBpc1xuICAgICAgLy8gZGVmaW5lZCBhcyB0aGUgc3RhdHVzIGNvZGUgKFNlY3Rpb24gNy40KSBjb250YWluZWQgaW4gdGhlIGZpcnN0IENsb3NlXG4gICAgICAvLyBjb250cm9sIGZyYW1lIHJlY2VpdmVkIGJ5IHRoZSBhcHBsaWNhdGlvblxuICAgICAgY29kZSA9IGRhdGEucmVhZFVJbnQxNkJFKDApXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCAmJiAhaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgIHJldHVybiB7IGNvZGU6IDEwMDIsIHJlYXNvbjogJ0ludmFsaWQgc3RhdHVzIGNvZGUnLCBlcnJvcjogdHJ1ZSB9XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNy4xLjZcbiAgICAvKiogQHR5cGUge0J1ZmZlcn0gKi9cbiAgICBsZXQgcmVhc29uID0gZGF0YS5zdWJhcnJheSgyKVxuXG4gICAgLy8gUmVtb3ZlIEJPTVxuICAgIGlmIChyZWFzb25bMF0gPT09IDB4RUYgJiYgcmVhc29uWzFdID09PSAweEJCICYmIHJlYXNvblsyXSA9PT0gMHhCRikge1xuICAgICAgcmVhc29uID0gcmVhc29uLnN1YmFycmF5KDMpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJlYXNvbiA9IHV0ZjhEZWNvZGUocmVhc29uKVxuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHsgY29kZTogMTAwNywgcmVhc29uOiAnSW52YWxpZCBVVEYtOCcsIGVycm9yOiB0cnVlIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBjb2RlLCByZWFzb24sIGVycm9yOiBmYWxzZSB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGNvbnRyb2wgZnJhbWVzLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYm9keVxuICAgKi9cbiAgcGFyc2VDb250cm9sRnJhbWUgKGJvZHkpIHtcbiAgICBjb25zdCB7IG9wY29kZSwgcGF5bG9hZExlbmd0aCB9ID0gdGhpcy4jaW5mb1xuXG4gICAgaWYgKG9wY29kZSA9PT0gb3Bjb2Rlcy5DTE9TRSkge1xuICAgICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgMTAwMiwgJ1JlY2VpdmVkIGNsb3NlIGZyYW1lIHdpdGggYSAxLWJ5dGUgYm9keS4nKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgdGhpcy4jaW5mby5jbG9zZUluZm8gPSB0aGlzLnBhcnNlQ2xvc2VCb2R5KGJvZHkpXG5cbiAgICAgIGlmICh0aGlzLiNpbmZvLmNsb3NlSW5mby5lcnJvcikge1xuICAgICAgICBjb25zdCB7IGNvZGUsIHJlYXNvbiB9ID0gdGhpcy4jaW5mby5jbG9zZUluZm9cblxuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLiNoYW5kbGVyLCBjb2RlLCByZWFzb24pXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICAvLyBVcG9uIHJlY2VpdmluZyBzdWNoIGEgZnJhbWUsIHRoZSBvdGhlciBwZWVyIHNlbmRzIGFcbiAgICAgIC8vIENsb3NlIGZyYW1lIGluIHJlc3BvbnNlLCBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBzZW50IG9uZS5cbiAgICAgIGlmICghdGhpcy4jaGFuZGxlci5jbG9zZVN0YXRlLmhhcyhzZW50Q2xvc2VGcmFtZVN0YXRlLlNFTlQpICYmICF0aGlzLiNoYW5kbGVyLmNsb3NlU3RhdGUuaGFzKHNlbnRDbG9zZUZyYW1lU3RhdGUuUkVDRUlWRUQpKSB7XG4gICAgICAgIC8vIElmIGFuIGVuZHBvaW50IHJlY2VpdmVzIGEgQ2xvc2UgZnJhbWUgYW5kIGRpZCBub3QgcHJldmlvdXNseSBzZW5kIGFcbiAgICAgICAgLy8gQ2xvc2UgZnJhbWUsIHRoZSBlbmRwb2ludCBNVVNUIHNlbmQgYSBDbG9zZSBmcmFtZSBpbiByZXNwb25zZS4gIChXaGVuXG4gICAgICAgIC8vIHNlbmRpbmcgYSBDbG9zZSBmcmFtZSBpbiByZXNwb25zZSwgdGhlIGVuZHBvaW50IHR5cGljYWxseSBlY2hvcyB0aGVcbiAgICAgICAgLy8gc3RhdHVzIGNvZGUgaXQgcmVjZWl2ZWQuKVxuICAgICAgICBsZXQgYm9keSA9IGVtcHR5QnVmZmVyXG4gICAgICAgIGlmICh0aGlzLiNpbmZvLmNsb3NlSW5mby5jb2RlKSB7XG4gICAgICAgICAgYm9keSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKVxuICAgICAgICAgIGJvZHkud3JpdGVVSW50MTZCRSh0aGlzLiNpbmZvLmNsb3NlSW5mby5jb2RlLCAwKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsb3NlRnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKGJvZHkpXG5cbiAgICAgICAgdGhpcy4jaGFuZGxlci5zb2NrZXQud3JpdGUoY2xvc2VGcmFtZS5jcmVhdGVGcmFtZShvcGNvZGVzLkNMT1NFKSlcbiAgICAgICAgdGhpcy4jaGFuZGxlci5jbG9zZVN0YXRlLmFkZChzZW50Q2xvc2VGcmFtZVN0YXRlLlNFTlQpXG4gICAgICB9XG5cbiAgICAgIC8vIFVwb24gZWl0aGVyIHNlbmRpbmcgb3IgcmVjZWl2aW5nIGEgQ2xvc2UgY29udHJvbCBmcmFtZSwgaXQgaXMgc2FpZFxuICAgICAgLy8gdGhhdCBfVGhlIFdlYlNvY2tldCBDbG9zaW5nIEhhbmRzaGFrZSBpcyBTdGFydGVkXyBhbmQgdGhhdCB0aGVcbiAgICAgIC8vIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGluIHRoZSBDTE9TSU5HIHN0YXRlLlxuICAgICAgdGhpcy4jaGFuZGxlci5yZWFkeVN0YXRlID0gc3RhdGVzLkNMT1NJTkdcbiAgICAgIHRoaXMuI2hhbmRsZXIuY2xvc2VTdGF0ZS5hZGQoc2VudENsb3NlRnJhbWVTdGF0ZS5SRUNFSVZFRClcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChvcGNvZGUgPT09IG9wY29kZXMuUElORykge1xuICAgICAgLy8gVXBvbiByZWNlaXB0IG9mIGEgUGluZyBmcmFtZSwgYW4gZW5kcG9pbnQgTVVTVCBzZW5kIGEgUG9uZyBmcmFtZSBpblxuICAgICAgLy8gcmVzcG9uc2UsIHVubGVzcyBpdCBhbHJlYWR5IHJlY2VpdmVkIGEgQ2xvc2UgZnJhbWUuXG4gICAgICAvLyBBIFBvbmcgZnJhbWUgc2VudCBpbiByZXNwb25zZSB0byBhIFBpbmcgZnJhbWUgbXVzdCBoYXZlIGlkZW50aWNhbFxuICAgICAgLy8gXCJBcHBsaWNhdGlvbiBkYXRhXCJcblxuICAgICAgaWYgKCF0aGlzLiNoYW5kbGVyLmNsb3NlU3RhdGUuaGFzKHNlbnRDbG9zZUZyYW1lU3RhdGUuUkVDRUlWRUQpKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gbmV3IFdlYnNvY2tldEZyYW1lU2VuZChib2R5KVxuXG4gICAgICAgIHRoaXMuI2hhbmRsZXIuc29ja2V0LndyaXRlKGZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuUE9ORykpXG5cbiAgICAgICAgaWYgKGNoYW5uZWxzLnBpbmcuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICBjaGFubmVscy5waW5nLnB1Ymxpc2goe1xuICAgICAgICAgICAgcGF5bG9hZDogYm9keVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wY29kZSA9PT0gb3Bjb2Rlcy5QT05HKSB7XG4gICAgICAvLyBBIFBvbmcgZnJhbWUgTUFZIGJlIHNlbnQgdW5zb2xpY2l0ZWQuICBUaGlzIHNlcnZlcyBhcyBhXG4gICAgICAvLyB1bmlkaXJlY3Rpb25hbCBoZWFydGJlYXQuICBBIHJlc3BvbnNlIHRvIGFuIHVuc29saWNpdGVkIFBvbmcgZnJhbWUgaXNcbiAgICAgIC8vIG5vdCBleHBlY3RlZC5cblxuICAgICAgaWYgKGNoYW5uZWxzLnBvbmcuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgY2hhbm5lbHMucG9uZy5wdWJsaXNoKHtcbiAgICAgICAgICBwYXlsb2FkOiBib2R5XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGdldCBjbG9zaW5nSW5mbyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2luZm8uY2xvc2VJbmZvXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEJ5dGVQYXJzZXJcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/receiver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/sender.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/sender.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(rsc)/./node_modules/undici/lib/web/websocket/frame.js\")\nconst { opcodes, sendHints } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst FixedQueue = __webpack_require__(/*! ../../dispatcher/fixed-queue */ \"(rsc)/./node_modules/undici/lib/dispatcher/fixed-queue.js\")\n\n/**\n * @typedef {object} SendQueueNode\n * @property {Promise<void> | null} promise\n * @property {((...args: any[]) => any)} callback\n * @property {Buffer | null} frame\n */\n\nclass SendQueue {\n  /**\n   * @type {FixedQueue}\n   */\n  #queue = new FixedQueue()\n\n  /**\n   * @type {boolean}\n   */\n  #running = false\n\n  /** @type {import('node:net').Socket} */\n  #socket\n\n  constructor (socket) {\n    this.#socket = socket\n  }\n\n  add (item, cb, hint) {\n    if (hint !== sendHints.blob) {\n      if (!this.#running) {\n        // TODO(@tsctx): support fast-path for string on running\n        if (hint === sendHints.text) {\n          // special fast-path for string\n          const { 0: head, 1: body } = WebsocketFrameSend.createFastTextFrame(item)\n          this.#socket.cork()\n          this.#socket.write(head)\n          this.#socket.write(body, cb)\n          this.#socket.uncork()\n        } else {\n          // direct writing\n          this.#socket.write(createFrame(item, hint), cb)\n        }\n      } else {\n        /** @type {SendQueueNode} */\n        const node = {\n          promise: null,\n          callback: cb,\n          frame: createFrame(item, hint)\n        }\n        this.#queue.push(node)\n      }\n      return\n    }\n\n    /** @type {SendQueueNode} */\n    const node = {\n      promise: item.arrayBuffer().then((ab) => {\n        node.promise = null\n        node.frame = createFrame(ab, hint)\n      }),\n      callback: cb,\n      frame: null\n    }\n\n    this.#queue.push(node)\n\n    if (!this.#running) {\n      this.#run()\n    }\n  }\n\n  async #run () {\n    this.#running = true\n    const queue = this.#queue\n    while (!queue.isEmpty()) {\n      const node = queue.shift()\n      // wait pending promise\n      if (node.promise !== null) {\n        await node.promise\n      }\n      // write\n      this.#socket.write(node.frame, node.callback)\n      // cleanup\n      node.callback = node.frame = null\n    }\n    this.#running = false\n  }\n}\n\nfunction createFrame (data, hint) {\n  return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.text ? opcodes.TEXT : opcodes.BINARY)\n}\n\nfunction toBuffer (data, hint) {\n  switch (hint) {\n    case sendHints.text:\n    case sendHints.typedArray:\n      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength)\n    case sendHints.arrayBuffer:\n    case sendHints.blob:\n      return new Uint8Array(data)\n  }\n}\n\nmodule.exports = { SendQueue }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3NlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLHFCQUFxQixFQUFFLG1CQUFPLENBQUMsdUVBQVM7QUFDaEQsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLCtFQUFhO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLCtGQUE4Qjs7QUFFekQ7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxzQkFBc0I7QUFDcEMsY0FBYywyQkFBMkI7QUFDekMsY0FBYyxlQUFlO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBLGFBQWEsMkJBQTJCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2ZsaXhodWIvbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL3dlYnNvY2tldC9zZW5kZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgV2Vic29ja2V0RnJhbWVTZW5kIH0gPSByZXF1aXJlKCcuL2ZyYW1lJylcbmNvbnN0IHsgb3Bjb2Rlcywgc2VuZEhpbnRzIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBGaXhlZFF1ZXVlID0gcmVxdWlyZSgnLi4vLi4vZGlzcGF0Y2hlci9maXhlZC1xdWV1ZScpXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gU2VuZFF1ZXVlTm9kZVxuICogQHByb3BlcnR5IHtQcm9taXNlPHZvaWQ+IHwgbnVsbH0gcHJvbWlzZVxuICogQHByb3BlcnR5IHsoKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpfSBjYWxsYmFja1xuICogQHByb3BlcnR5IHtCdWZmZXIgfCBudWxsfSBmcmFtZVxuICovXG5cbmNsYXNzIFNlbmRRdWV1ZSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Rml4ZWRRdWV1ZX1cbiAgICovXG4gICNxdWV1ZSA9IG5ldyBGaXhlZFF1ZXVlKClcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICAjcnVubmluZyA9IGZhbHNlXG5cbiAgLyoqIEB0eXBlIHtpbXBvcnQoJ25vZGU6bmV0JykuU29ja2V0fSAqL1xuICAjc29ja2V0XG5cbiAgY29uc3RydWN0b3IgKHNvY2tldCkge1xuICAgIHRoaXMuI3NvY2tldCA9IHNvY2tldFxuICB9XG5cbiAgYWRkIChpdGVtLCBjYiwgaGludCkge1xuICAgIGlmIChoaW50ICE9PSBzZW5kSGludHMuYmxvYikge1xuICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgIC8vIFRPRE8oQHRzY3R4KTogc3VwcG9ydCBmYXN0LXBhdGggZm9yIHN0cmluZyBvbiBydW5uaW5nXG4gICAgICAgIGlmIChoaW50ID09PSBzZW5kSGludHMudGV4dCkge1xuICAgICAgICAgIC8vIHNwZWNpYWwgZmFzdC1wYXRoIGZvciBzdHJpbmdcbiAgICAgICAgICBjb25zdCB7IDA6IGhlYWQsIDE6IGJvZHkgfSA9IFdlYnNvY2tldEZyYW1lU2VuZC5jcmVhdGVGYXN0VGV4dEZyYW1lKGl0ZW0pXG4gICAgICAgICAgdGhpcy4jc29ja2V0LmNvcmsoKVxuICAgICAgICAgIHRoaXMuI3NvY2tldC53cml0ZShoZWFkKVxuICAgICAgICAgIHRoaXMuI3NvY2tldC53cml0ZShib2R5LCBjYilcbiAgICAgICAgICB0aGlzLiNzb2NrZXQudW5jb3JrKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkaXJlY3Qgd3JpdGluZ1xuICAgICAgICAgIHRoaXMuI3NvY2tldC53cml0ZShjcmVhdGVGcmFtZShpdGVtLCBoaW50KSwgY2IpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qKiBAdHlwZSB7U2VuZFF1ZXVlTm9kZX0gKi9cbiAgICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgICBwcm9taXNlOiBudWxsLFxuICAgICAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgICAgICBmcmFtZTogY3JlYXRlRnJhbWUoaXRlbSwgaGludClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNxdWV1ZS5wdXNoKG5vZGUpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvKiogQHR5cGUge1NlbmRRdWV1ZU5vZGV9ICovXG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHByb21pc2U6IGl0ZW0uYXJyYXlCdWZmZXIoKS50aGVuKChhYikgPT4ge1xuICAgICAgICBub2RlLnByb21pc2UgPSBudWxsXG4gICAgICAgIG5vZGUuZnJhbWUgPSBjcmVhdGVGcmFtZShhYiwgaGludClcbiAgICAgIH0pLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgZnJhbWU6IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLiNxdWV1ZS5wdXNoKG5vZGUpXG5cbiAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgIHRoaXMuI3J1bigpXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgI3J1biAoKSB7XG4gICAgdGhpcy4jcnVubmluZyA9IHRydWVcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMuI3F1ZXVlXG4gICAgd2hpbGUgKCFxdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBxdWV1ZS5zaGlmdCgpXG4gICAgICAvLyB3YWl0IHBlbmRpbmcgcHJvbWlzZVxuICAgICAgaWYgKG5vZGUucHJvbWlzZSAhPT0gbnVsbCkge1xuICAgICAgICBhd2FpdCBub2RlLnByb21pc2VcbiAgICAgIH1cbiAgICAgIC8vIHdyaXRlXG4gICAgICB0aGlzLiNzb2NrZXQud3JpdGUobm9kZS5mcmFtZSwgbm9kZS5jYWxsYmFjaylcbiAgICAgIC8vIGNsZWFudXBcbiAgICAgIG5vZGUuY2FsbGJhY2sgPSBub2RlLmZyYW1lID0gbnVsbFxuICAgIH1cbiAgICB0aGlzLiNydW5uaW5nID0gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFtZSAoZGF0YSwgaGludCkge1xuICByZXR1cm4gbmV3IFdlYnNvY2tldEZyYW1lU2VuZCh0b0J1ZmZlcihkYXRhLCBoaW50KSkuY3JlYXRlRnJhbWUoaGludCA9PT0gc2VuZEhpbnRzLnRleHQgPyBvcGNvZGVzLlRFWFQgOiBvcGNvZGVzLkJJTkFSWSlcbn1cblxuZnVuY3Rpb24gdG9CdWZmZXIgKGRhdGEsIGhpbnQpIHtcbiAgc3dpdGNoIChoaW50KSB7XG4gICAgY2FzZSBzZW5kSGludHMudGV4dDpcbiAgICBjYXNlIHNlbmRIaW50cy50eXBlZEFycmF5OlxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aClcbiAgICBjYXNlIHNlbmRIaW50cy5hcnJheUJ1ZmZlcjpcbiAgICBjYXNlIHNlbmRIaW50cy5ibG9iOlxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IFNlbmRRdWV1ZSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/sender.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/stream/websocketerror.js":
/*!************************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/stream/websocketerror.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { webidl } = __webpack_require__(/*! ../../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { validateCloseCodeAndReason } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/undici/lib/web/websocket/util.js\")\nconst { kConstruct } = __webpack_require__(/*! ../../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nclass WebSocketError extends DOMException {\n  #closeCode\n  #reason\n\n  constructor (message = '', init = undefined) {\n    message = webidl.converters.DOMString(message, 'WebSocketError', 'message')\n\n    // 1. Set this 's name to \" WebSocketError \".\n    // 2. Set this 's message to message .\n    super(message, 'WebSocketError')\n\n    if (init === kConstruct) {\n      return\n    } else if (init !== null) {\n      init = webidl.converters.WebSocketCloseInfo(init)\n    }\n\n    // 3. Let code be init [\" closeCode \"] if it exists , or null otherwise.\n    let code = init.closeCode ?? null\n\n    // 4. Let reason be init [\" reason \"] if it exists , or the empty string otherwise.\n    const reason = init.reason ?? ''\n\n    // 5. Validate close code and reason with code and reason .\n    validateCloseCodeAndReason(code, reason)\n\n    // 6. If reason is non-empty, but code is not set, then set code to 1000 (\"Normal Closure\").\n    if (reason.length !== 0 && code === null) {\n      code = 1000\n    }\n\n    // 7. Set this 's closeCode to code .\n    this.#closeCode = code\n\n    // 8. Set this 's reason to reason .\n    this.#reason = reason\n  }\n\n  get closeCode () {\n    return this.#closeCode\n  }\n\n  get reason () {\n    return this.#reason\n  }\n\n  /**\n   * @param {string} message\n   * @param {number|null} code\n   * @param {string} reason\n   */\n  static createUnvalidatedWebSocketError (message, code, reason) {\n    const error = new WebSocketError(message, kConstruct)\n    error.#closeCode = code\n    error.#reason = reason\n    return error\n  }\n}\n\nconst { createUnvalidatedWebSocketError } = WebSocketError\ndelete WebSocketError.createUnvalidatedWebSocketError\n\nObject.defineProperties(WebSocketError.prototype, {\n  closeCode: kEnumerableProperty,\n  reason: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocketError',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nwebidl.is.WebSocketError = webidl.util.MakeTypeAssertion(WebSocketError)\n\nmodule.exports = { WebSocketError, createUnvalidatedWebSocketError }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3N0cmVhbS93ZWJzb2NrZXRlcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHlFQUFjO0FBQ3pDLFFBQVEsNkJBQTZCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBUztBQUN4RCxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLDhFQUF1QjtBQUN0RCxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsd0VBQW9COztBQUU1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsa0NBQWtDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsbUJBQW1CIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi93ZWJzb2NrZXQvc3RyZWFtL3dlYnNvY2tldGVycm9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViaWRsJylcbmNvbnN0IHsgdmFsaWRhdGVDbG9zZUNvZGVBbmRSZWFzb24gfSA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuY29uc3QgeyBrQ29uc3RydWN0IH0gPSByZXF1aXJlKCcuLi8uLi8uLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi8uLi8uLi9jb3JlL3V0aWwnKVxuXG5jbGFzcyBXZWJTb2NrZXRFcnJvciBleHRlbmRzIERPTUV4Y2VwdGlvbiB7XG4gICNjbG9zZUNvZGVcbiAgI3JlYXNvblxuXG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlID0gJycsIGluaXQgPSB1bmRlZmluZWQpIHtcbiAgICBtZXNzYWdlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKG1lc3NhZ2UsICdXZWJTb2NrZXRFcnJvcicsICdtZXNzYWdlJylcblxuICAgIC8vIDEuIFNldCB0aGlzICdzIG5hbWUgdG8gXCIgV2ViU29ja2V0RXJyb3IgXCIuXG4gICAgLy8gMi4gU2V0IHRoaXMgJ3MgbWVzc2FnZSB0byBtZXNzYWdlIC5cbiAgICBzdXBlcihtZXNzYWdlLCAnV2ViU29ja2V0RXJyb3InKVxuXG4gICAgaWYgKGluaXQgPT09IGtDb25zdHJ1Y3QpIHtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSBpZiAoaW5pdCAhPT0gbnVsbCkge1xuICAgICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLldlYlNvY2tldENsb3NlSW5mbyhpbml0KVxuICAgIH1cblxuICAgIC8vIDMuIExldCBjb2RlIGJlIGluaXQgW1wiIGNsb3NlQ29kZSBcIl0gaWYgaXQgZXhpc3RzICwgb3IgbnVsbCBvdGhlcndpc2UuXG4gICAgbGV0IGNvZGUgPSBpbml0LmNsb3NlQ29kZSA/PyBudWxsXG5cbiAgICAvLyA0LiBMZXQgcmVhc29uIGJlIGluaXQgW1wiIHJlYXNvbiBcIl0gaWYgaXQgZXhpc3RzICwgb3IgdGhlIGVtcHR5IHN0cmluZyBvdGhlcndpc2UuXG4gICAgY29uc3QgcmVhc29uID0gaW5pdC5yZWFzb24gPz8gJydcblxuICAgIC8vIDUuIFZhbGlkYXRlIGNsb3NlIGNvZGUgYW5kIHJlYXNvbiB3aXRoIGNvZGUgYW5kIHJlYXNvbiAuXG4gICAgdmFsaWRhdGVDbG9zZUNvZGVBbmRSZWFzb24oY29kZSwgcmVhc29uKVxuXG4gICAgLy8gNi4gSWYgcmVhc29uIGlzIG5vbi1lbXB0eSwgYnV0IGNvZGUgaXMgbm90IHNldCwgdGhlbiBzZXQgY29kZSB0byAxMDAwIChcIk5vcm1hbCBDbG9zdXJlXCIpLlxuICAgIGlmIChyZWFzb24ubGVuZ3RoICE9PSAwICYmIGNvZGUgPT09IG51bGwpIHtcbiAgICAgIGNvZGUgPSAxMDAwXG4gICAgfVxuXG4gICAgLy8gNy4gU2V0IHRoaXMgJ3MgY2xvc2VDb2RlIHRvIGNvZGUgLlxuICAgIHRoaXMuI2Nsb3NlQ29kZSA9IGNvZGVcblxuICAgIC8vIDguIFNldCB0aGlzICdzIHJlYXNvbiB0byByZWFzb24gLlxuICAgIHRoaXMuI3JlYXNvbiA9IHJlYXNvblxuICB9XG5cbiAgZ2V0IGNsb3NlQ29kZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Nsb3NlQ29kZVxuICB9XG5cbiAgZ2V0IHJlYXNvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYXNvblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7bnVtYmVyfG51bGx9IGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVVudmFsaWRhdGVkV2ViU29ja2V0RXJyb3IgKG1lc3NhZ2UsIGNvZGUsIHJlYXNvbikge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFdlYlNvY2tldEVycm9yKG1lc3NhZ2UsIGtDb25zdHJ1Y3QpXG4gICAgZXJyb3IuI2Nsb3NlQ29kZSA9IGNvZGVcbiAgICBlcnJvci4jcmVhc29uID0gcmVhc29uXG4gICAgcmV0dXJuIGVycm9yXG4gIH1cbn1cblxuY29uc3QgeyBjcmVhdGVVbnZhbGlkYXRlZFdlYlNvY2tldEVycm9yIH0gPSBXZWJTb2NrZXRFcnJvclxuZGVsZXRlIFdlYlNvY2tldEVycm9yLmNyZWF0ZVVudmFsaWRhdGVkV2ViU29ja2V0RXJyb3JcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV2ViU29ja2V0RXJyb3IucHJvdG90eXBlLCB7XG4gIGNsb3NlQ29kZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVhc29uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnV2ViU29ja2V0RXJyb3InLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxud2ViaWRsLmlzLldlYlNvY2tldEVycm9yID0gd2ViaWRsLnV0aWwuTWFrZVR5cGVBc3NlcnRpb24oV2ViU29ja2V0RXJyb3IpXG5cbm1vZHVsZS5leHBvcnRzID0geyBXZWJTb2NrZXRFcnJvciwgY3JlYXRlVW52YWxpZGF0ZWRXZWJTb2NrZXRFcnJvciB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/stream/websocketerror.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/stream/websocketstream.js":
/*!*************************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/stream/websocketstream.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { createDeferredPromise, environmentSettingsObject } = __webpack_require__(/*! ../../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { states, opcodes, sentCloseFrameState } = __webpack_require__(/*! ../constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst { webidl } = __webpack_require__(/*! ../../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { getURLRecord, isValidSubprotocol, isEstablished, utf8Decode } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/undici/lib/web/websocket/util.js\")\nconst { establishWebSocketConnection, failWebsocketConnection, closeWebSocketConnection } = __webpack_require__(/*! ../connection */ \"(rsc)/./node_modules/undici/lib/web/websocket/connection.js\")\nconst { types } = __webpack_require__(/*! node:util */ \"node:util\")\nconst { channels } = __webpack_require__(/*! ../../../core/diagnostics */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\nconst { WebsocketFrameSend } = __webpack_require__(/*! ../frame */ \"(rsc)/./node_modules/undici/lib/web/websocket/frame.js\")\nconst { ByteParser } = __webpack_require__(/*! ../receiver */ \"(rsc)/./node_modules/undici/lib/web/websocket/receiver.js\")\nconst { WebSocketError, createUnvalidatedWebSocketError } = __webpack_require__(/*! ./websocketerror */ \"(rsc)/./node_modules/undici/lib/web/websocket/stream/websocketerror.js\")\nconst { utf8DecodeBytes } = __webpack_require__(/*! ../../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nlet emittedExperimentalWarning = false\n\nclass WebSocketStream {\n  // Each WebSocketStream object has an associated url , which is a URL record .\n  /** @type {URL} */\n  #url\n\n  // Each WebSocketStream object has an associated opened promise , which is a promise.\n  /** @type {ReturnType<typeof createDeferredPromise>} */\n  #openedPromise\n\n  // Each WebSocketStream object has an associated closed promise , which is a promise.\n  /** @type {ReturnType<typeof createDeferredPromise>} */\n  #closedPromise\n\n  // Each WebSocketStream object has an associated readable stream , which is a ReadableStream .\n  /** @type {ReadableStream} */\n  #readableStream\n  /** @type {ReadableStreamDefaultController} */\n  #readableStreamController\n\n  // Each WebSocketStream object has an associated writable stream , which is a WritableStream .\n  /** @type {WritableStream} */\n  #writableStream\n\n  // Each WebSocketStream object has an associated boolean handshake aborted , which is initially false.\n  #handshakeAborted = false\n\n  /** @type {import('../websocket').Handler} */\n  #handler = {\n    // https://whatpr.org/websockets/48/7b748d3...d5570f3.html#feedback-to-websocket-stream-from-the-protocol\n    onConnectionEstablished: (response, extensions) => this.#onConnectionEstablished(response, extensions),\n    onFail: (_code, _reason) => {},\n    onMessage: (opcode, data) => this.#onMessage(opcode, data),\n    onParserError: (err) => failWebsocketConnection(this.#handler, null, err.message),\n    onParserDrain: () => this.#handler.socket.resume(),\n    onSocketData: (chunk) => {\n      if (!this.#parser.write(chunk)) {\n        this.#handler.socket.pause()\n      }\n    },\n    onSocketError: (err) => {\n      this.#handler.readyState = states.CLOSING\n\n      if (channels.socketError.hasSubscribers) {\n        channels.socketError.publish(err)\n      }\n\n      this.#handler.socket.destroy()\n    },\n    onSocketClose: () => this.#onSocketClose(),\n\n    readyState: states.CONNECTING,\n    socket: null,\n    closeState: new Set(),\n    controller: null,\n    wasEverConnected: false\n  }\n\n  /** @type {import('../receiver').ByteParser} */\n  #parser\n\n  constructor (url, options = undefined) {\n    if (!emittedExperimentalWarning) {\n      process.emitWarning('WebSocketStream is experimental! Expect it to change at any time.', {\n        code: 'UNDICI-WSS'\n      })\n      emittedExperimentalWarning = true\n    }\n\n    webidl.argumentLengthCheck(arguments, 1, 'WebSocket')\n\n    url = webidl.converters.USVString(url)\n    if (options !== null) {\n      options = webidl.converters.WebSocketStreamOptions(options)\n    }\n\n    // 1. Let baseURL be this 's relevant settings object 's API base URL .\n    const baseURL = environmentSettingsObject.settingsObject.baseUrl\n\n    // 2. Let urlRecord be the result of getting a URL record given url and baseURL .\n    const urlRecord = getURLRecord(url, baseURL)\n\n    // 3. Let protocols be options [\" protocols \"] if it exists , otherwise an empty sequence.\n    const protocols = options.protocols\n\n    // 4. If any of the values in protocols occur more than once or otherwise fail to match the requirements for elements that comprise the value of ` Sec-WebSocket-Protocol ` fields as defined by The WebSocket Protocol , then throw a \" SyntaxError \" DOMException . [WSP]\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    // 5. Set this 's url to urlRecord .\n    this.#url = urlRecord.toString()\n\n    // 6. Set this 's opened promise and closed promise to new promises.\n    this.#openedPromise = createDeferredPromise()\n    this.#closedPromise = createDeferredPromise()\n\n    // 7. Apply backpressure to the WebSocket.\n    // TODO\n\n    // 8.  If options [\" signal \"] exists ,\n    if (options.signal != null) {\n      // 8.1. Let signal be options [\" signal \"].\n      const signal = options.signal\n\n      // 8.2. If signal is aborted , then reject this 's opened promise and closed promise with signal s abort reason\n      //      and return.\n      if (signal.aborted) {\n        this.#openedPromise.reject(signal.reason)\n        this.#closedPromise.reject(signal.reason)\n        return\n      }\n\n      // 8.3. Add the following abort steps to signal :\n      signal.addEventListener('abort', () => {\n        // 8.3.1. If the WebSocket connection is not yet established : [WSP]\n        if (!isEstablished(this.#handler.readyState)) {\n          // 8.3.1.1. Fail the WebSocket connection .\n          failWebsocketConnection(this.#handler)\n\n          // Set this 's ready state to CLOSING .\n          this.#handler.readyState = states.CLOSING\n\n          // Reject this 's opened promise and closed promise with signal s abort reason .\n          this.#openedPromise.reject(signal.reason)\n          this.#closedPromise.reject(signal.reason)\n\n          // Set this 's handshake aborted to true.\n          this.#handshakeAborted = true\n        }\n      }, { once: true })\n    }\n\n    // 9.  Let client be this 's relevant settings object .\n    const client = environmentSettingsObject.settingsObject\n\n    // 10. Run this step in parallel :\n    // 10.1. Establish a WebSocket connection given urlRecord , protocols , and client . [FETCH]\n    this.#handler.controller = establishWebSocketConnection(\n      urlRecord,\n      protocols,\n      client,\n      this.#handler,\n      options\n    )\n  }\n\n  // The url getter steps are to return this 's url , serialized .\n  get url () {\n    return this.#url.toString()\n  }\n\n  // The opened getter steps are to return this 's opened promise .\n  get opened () {\n    return this.#openedPromise.promise\n  }\n\n  // The closed getter steps are to return this 's closed promise .\n  get closed () {\n    return this.#closedPromise.promise\n  }\n\n  // The close( closeInfo ) method steps are:\n  close (closeInfo = undefined) {\n    if (closeInfo !== null) {\n      closeInfo = webidl.converters.WebSocketCloseInfo(closeInfo)\n    }\n\n    // 1. Let code be closeInfo [\" closeCode \"] if present, or null otherwise.\n    const code = closeInfo.closeCode ?? null\n\n    // 2. Let reason be closeInfo [\" reason \"].\n    const reason = closeInfo.reason\n\n    // 3. Close the WebSocket with this , code , and reason .\n    closeWebSocketConnection(this.#handler, code, reason, true)\n  }\n\n  #write (chunk) {\n    // 1. Let promise be a new promise created in stream s relevant realm .\n    const promise = createDeferredPromise()\n\n    // 2. Let data be null.\n    let data = null\n\n    // 3. Let opcode be null.\n    let opcode = null\n\n    // 4. If chunk is a BufferSource ,\n    if (ArrayBuffer.isView(chunk) || types.isArrayBuffer(chunk)) {\n      // 4.1. Set data to a copy of the bytes given chunk .\n      data = new Uint8Array(ArrayBuffer.isView(chunk) ? new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength) : chunk)\n\n      // 4.2. Set opcode to a binary frame opcode.\n      opcode = opcodes.BINARY\n    } else {\n      // 5. Otherwise,\n\n      // 5.1. Let string be the result of converting chunk to an IDL USVString .\n      //    If this throws an exception, return a promise rejected with the exception.\n      let string\n\n      try {\n        string = webidl.converters.DOMString(chunk)\n      } catch (e) {\n        promise.reject(e)\n        return\n      }\n\n      // 5.2. Set data to the result of UTF-8 encoding string .\n      data = new TextEncoder().encode(string)\n\n      // 5.3. Set opcode to a text frame opcode.\n      opcode = opcodes.TEXT\n    }\n\n    // 6. In parallel,\n    // 6.1. Wait until there is sufficient buffer space in stream to send the message.\n\n    // 6.2. If the closing handshake has not yet started , Send a WebSocket Message to stream comprised of data using opcode .\n    if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {\n      const frame = new WebsocketFrameSend(data)\n\n      this.#handler.socket.write(frame.createFrame(opcode), () => {\n        promise.resolve(undefined)\n      })\n    }\n\n    // 6.3. Queue a global task on the WebSocket task source given stream s relevant global object to resolve promise with undefined.\n    return promise\n  }\n\n  /** @type {import('../websocket').Handler['onConnectionEstablished']} */\n  #onConnectionEstablished (response, parsedExtensions) {\n    this.#handler.socket = response.socket\n\n    const parser = new ByteParser(this.#handler, parsedExtensions)\n    parser.on('drain', () => this.#handler.onParserDrain())\n    parser.on('error', (err) => this.#handler.onParserError(err))\n\n    this.#parser = parser\n\n    // 1. Change stream s ready state to OPEN (1).\n    this.#handler.readyState = states.OPEN\n\n    // 2. Set stream s was ever connected to true.\n    // This is done in the opening handshake.\n\n    // 3. Let extensions be the extensions in use .\n    const extensions = parsedExtensions ?? ''\n\n    // 4. Let protocol be the subprotocol in use .\n    const protocol = response.headersList.get('sec-websocket-protocol') ?? ''\n\n    // 5. Let pullAlgorithm be an action that pulls bytes from stream .\n    // 6. Let cancelAlgorithm be an action that cancels stream with reason , given reason .\n    // 7. Let readable be a new ReadableStream .\n    // 8. Set up readable with pullAlgorithm and cancelAlgorithm .\n    const readable = new ReadableStream({\n      start: (controller) => {\n        this.#readableStreamController = controller\n      },\n      pull (controller) {\n        let chunk\n        while (controller.desiredSize > 0 && (chunk = response.socket.read()) !== null) {\n          controller.enqueue(chunk)\n        }\n      },\n      cancel: (reason) => this.#cancel(reason)\n    })\n\n    // 9. Let writeAlgorithm be an action that writes chunk to stream , given chunk .\n    // 10. Let closeAlgorithm be an action that closes stream .\n    // 11. Let abortAlgorithm be an action that aborts stream with reason , given reason .\n    // 12. Let writable be a new WritableStream .\n    // 13. Set up writable with writeAlgorithm , closeAlgorithm , and abortAlgorithm .\n    const writable = new WritableStream({\n      write: (chunk) => this.#write(chunk),\n      close: () => closeWebSocketConnection(this.#handler, null, null),\n      abort: (reason) => this.#closeUsingReason(reason)\n    })\n\n    // Set stream s readable stream to readable .\n    this.#readableStream = readable\n\n    // Set stream s writable stream to writable .\n    this.#writableStream = writable\n\n    // Resolve stream s opened promise with WebSocketOpenInfo [ \" extensions \"  extensions , \" protocol \"  protocol , \" readable \"  readable , \" writable \"  writable ].\n    this.#openedPromise.resolve({\n      extensions,\n      protocol,\n      readable,\n      writable\n    })\n  }\n\n  /** @type {import('../websocket').Handler['onMessage']} */\n  #onMessage (type, data) {\n    // 1. If streams ready state is not OPEN (1), then return.\n    if (this.#handler.readyState !== states.OPEN) {\n      return\n    }\n\n    // 2. Let chunk be determined by switching on type:\n    //      - type indicates that the data is Text\n    //          a new DOMString containing data\n    //      - type indicates that the data is Binary\n    //          a new Uint8Array object, created in the relevant Realm of the\n    //          WebSocketStream object, whose contents are data\n    let chunk\n\n    if (type === opcodes.TEXT) {\n      try {\n        chunk = utf8Decode(data)\n      } catch {\n        failWebsocketConnection(this.#handler, 'Received invalid UTF-8 in text frame.')\n        return\n      }\n    } else if (type === opcodes.BINARY) {\n      chunk = new Uint8Array(data.buffer, data.byteOffset, data.byteLength)\n    }\n\n    // 3. Enqueue chunk into streams readable stream.\n    this.#readableStreamController.enqueue(chunk)\n\n    // 4. Apply backpressure to the WebSocket.\n  }\n\n  /** @type {import('../websocket').Handler['onSocketClose']} */\n  #onSocketClose () {\n    const wasClean =\n      this.#handler.closeState.has(sentCloseFrameState.SENT) &&\n      this.#handler.closeState.has(sentCloseFrameState.RECEIVED)\n\n    // 1. Change the ready state to CLOSED (3).\n    this.#handler.readyState = states.CLOSED\n\n    // 2. If stream s handshake aborted is true, then return.\n    if (this.#handshakeAborted) {\n      return\n    }\n\n    // 3. If stream s was ever connected is false, then reject stream s opened promise with a new WebSocketError.\n    if (!this.#handler.wasEverConnected) {\n      this.#openedPromise.reject(new WebSocketError('Socket never opened'))\n    }\n\n    const result = this.#parser.closingInfo\n\n    // 4. Let code be the WebSocket connection close code .\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n    // If this Close control frame contains no status code, _The WebSocket\n    // Connection Close Code_ is considered to be 1005. If _The WebSocket\n    // Connection is Closed_ and no Close control frame was received by the\n    // endpoint (such as could occur if the underlying transport connection\n    // is lost), _The WebSocket Connection Close Code_ is considered to be\n    // 1006.\n    let code = result?.code ?? 1005\n\n    if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {\n      code = 1006\n    }\n\n    // 5. Let reason be the result of applying UTF-8 decode without BOM to the WebSocket connection close reason .\n    const reason = result?.reason == null ? '' : utf8DecodeBytes(Buffer.from(result.reason))\n\n    // 6. If the connection was closed cleanly ,\n    if (wasClean) {\n      // 6.1. Close stream s readable stream .\n      this.#readableStream.cancel().catch(() => {})\n\n      // 6.2. Error stream s writable stream with an \" InvalidStateError \" DOMException indicating that a closed WebSocketStream cannot be written to.\n      if (!this.#writableStream.locked) {\n        this.#writableStream.abort(new DOMException('A closed WebSocketStream cannot be written to', 'InvalidStateError'))\n      }\n\n      // 6.3. Resolve stream s closed promise with WebSocketCloseInfo [ \" closeCode \"  code , \" reason \"  reason ].\n      this.#closedPromise.resolve({\n        closeCode: code,\n        reason\n      })\n    } else {\n      // 7. Otherwise,\n\n      // 7.1. Let error be a new WebSocketError whose closeCode is code and reason is reason .\n      const error = createUnvalidatedWebSocketError('unclean close', code, reason)\n\n      // 7.2. Error stream s readable stream with error .\n      this.#readableStreamController.error(error)\n\n      // 7.3. Error stream s writable stream with error .\n      this.#writableStream.abort(error)\n\n      // 7.4. Reject stream s closed promise with error .\n      this.#closedPromise.reject(error)\n    }\n  }\n\n  #closeUsingReason (reason) {\n    // 1. Let code be null.\n    let code = null\n\n    // 2. Let reasonString be the empty string.\n    let reasonString = ''\n\n    // 3. If reason implements WebSocketError ,\n    if (webidl.is.WebSocketError(reason)) {\n      // 3.1. Set code to reason s closeCode .\n      code = reason.closeCode\n\n      // 3.2. Set reasonString to reason s reason .\n      reasonString = reason.reason\n    }\n\n    // 4. Close the WebSocket with stream , code , and reasonString . If this throws an exception,\n    //    discard code and reasonString and close the WebSocket with stream .\n    closeWebSocketConnection(this.#handler, code, reasonString)\n  }\n\n  //  To cancel a WebSocketStream stream given reason , close using reason giving stream and reason .\n  #cancel (reason) {\n    this.#closeUsingReason(reason)\n  }\n}\n\nObject.defineProperties(WebSocketStream.prototype, {\n  url: kEnumerableProperty,\n  opened: kEnumerableProperty,\n  closed: kEnumerableProperty,\n  close: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocketStream',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nwebidl.converters.WebSocketStreamOptions = webidl.dictionaryConverter([\n  {\n    key: 'protocols',\n    converter: webidl.sequenceConverter(webidl.converters.USVString),\n    defaultValue: () => []\n  },\n  {\n    key: 'signal',\n    converter: webidl.nullableConverter(webidl.converters.AbortSignal),\n    defaultValue: () => null\n  }\n])\n\nwebidl.converters.WebSocketCloseInfo = webidl.dictionaryConverter([\n  {\n    key: 'closeCode',\n    converter: (V) => webidl.converters['unsigned short'](V, { enforceRange: true })\n  },\n  {\n    key: 'reason',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  }\n])\n\nmodule.exports = { WebSocketStream }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3N0cmVhbS93ZWJzb2NrZXRzdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxtREFBbUQsRUFBRSxtQkFBTyxDQUFDLDJFQUFrQjtBQUN2RixRQUFRLHVDQUF1QyxFQUFFLG1CQUFPLENBQUMsZ0ZBQWM7QUFDdkUsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyx5RUFBYztBQUN6QyxRQUFRLDhEQUE4RCxFQUFFLG1CQUFPLENBQUMsc0VBQVM7QUFDekYsUUFBUSxrRkFBa0YsRUFBRSxtQkFBTyxDQUFDLGtGQUFlO0FBQ25ILFFBQVEsUUFBUSxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDckMsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxzRkFBMkI7QUFDeEQsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLHdFQUFVO0FBQ2pELFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsOEVBQWE7QUFDNUMsUUFBUSxrREFBa0QsRUFBRSxtQkFBTyxDQUFDLGdHQUFrQjtBQUN0RixRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsMkVBQWtCO0FBQ3RELFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBb0I7O0FBRTVEOztBQUVBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7O0FBRUE7QUFDQSxhQUFhLDBDQUEwQztBQUN2RDs7QUFFQTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZEOztBQUVBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxhQUFhLGlDQUFpQztBQUM5Qzs7QUFFQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxnQ0FBZ0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGtDQUFrQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUksWUFBWTtBQUN2Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWEsMkRBQTJEO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLGFBQWEsNkNBQTZDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLGlEQUFpRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsb0JBQW9CO0FBQ25GLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi93ZWJzb2NrZXQvc3RyZWFtL3dlYnNvY2tldHN0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBjcmVhdGVEZWZlcnJlZFByb21pc2UsIGVudmlyb25tZW50U2V0dGluZ3NPYmplY3QgfSA9IHJlcXVpcmUoJy4uLy4uL2ZldGNoL3V0aWwnKVxuY29uc3QgeyBzdGF0ZXMsIG9wY29kZXMsIHNlbnRDbG9zZUZyYW1lU3RhdGUgfSA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViaWRsJylcbmNvbnN0IHsgZ2V0VVJMUmVjb3JkLCBpc1ZhbGlkU3VicHJvdG9jb2wsIGlzRXN0YWJsaXNoZWQsIHV0ZjhEZWNvZGUgfSA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuY29uc3QgeyBlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uLCBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiwgY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uIH0gPSByZXF1aXJlKCcuLi9jb25uZWN0aW9uJylcbmNvbnN0IHsgdHlwZXMgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9jb3JlL2RpYWdub3N0aWNzJylcbmNvbnN0IHsgV2Vic29ja2V0RnJhbWVTZW5kIH0gPSByZXF1aXJlKCcuLi9mcmFtZScpXG5jb25zdCB7IEJ5dGVQYXJzZXIgfSA9IHJlcXVpcmUoJy4uL3JlY2VpdmVyJylcbmNvbnN0IHsgV2ViU29ja2V0RXJyb3IsIGNyZWF0ZVVudmFsaWRhdGVkV2ViU29ja2V0RXJyb3IgfSA9IHJlcXVpcmUoJy4vd2Vic29ja2V0ZXJyb3InKVxuY29uc3QgeyB1dGY4RGVjb2RlQnl0ZXMgfSA9IHJlcXVpcmUoJy4uLy4uL2ZldGNoL3V0aWwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi8uLi8uLi9jb3JlL3V0aWwnKVxuXG5sZXQgZW1pdHRlZEV4cGVyaW1lbnRhbFdhcm5pbmcgPSBmYWxzZVxuXG5jbGFzcyBXZWJTb2NrZXRTdHJlYW0ge1xuICAvLyBFYWNoIFdlYlNvY2tldFN0cmVhbSBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgdXJsICwgd2hpY2ggaXMgYSBVUkwgcmVjb3JkIC5cbiAgLyoqIEB0eXBlIHtVUkx9ICovXG4gICN1cmxcblxuICAvLyBFYWNoIFdlYlNvY2tldFN0cmVhbSBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgb3BlbmVkIHByb21pc2UgLCB3aGljaCBpcyBhIHByb21pc2UuXG4gIC8qKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlRGVmZXJyZWRQcm9taXNlPn0gKi9cbiAgI29wZW5lZFByb21pc2VcblxuICAvLyBFYWNoIFdlYlNvY2tldFN0cmVhbSBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgY2xvc2VkIHByb21pc2UgLCB3aGljaCBpcyBhIHByb21pc2UuXG4gIC8qKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlRGVmZXJyZWRQcm9taXNlPn0gKi9cbiAgI2Nsb3NlZFByb21pc2VcblxuICAvLyBFYWNoIFdlYlNvY2tldFN0cmVhbSBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgcmVhZGFibGUgc3RyZWFtICwgd2hpY2ggaXMgYSBSZWFkYWJsZVN0cmVhbSAuXG4gIC8qKiBAdHlwZSB7UmVhZGFibGVTdHJlYW19ICovXG4gICNyZWFkYWJsZVN0cmVhbVxuICAvKiogQHR5cGUge1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJ9ICovXG4gICNyZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJcblxuICAvLyBFYWNoIFdlYlNvY2tldFN0cmVhbSBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgd3JpdGFibGUgc3RyZWFtICwgd2hpY2ggaXMgYSBXcml0YWJsZVN0cmVhbSAuXG4gIC8qKiBAdHlwZSB7V3JpdGFibGVTdHJlYW19ICovXG4gICN3cml0YWJsZVN0cmVhbVxuXG4gIC8vIEVhY2ggV2ViU29ja2V0U3RyZWFtIG9iamVjdCBoYXMgYW4gYXNzb2NpYXRlZCBib29sZWFuIGhhbmRzaGFrZSBhYm9ydGVkICwgd2hpY2ggaXMgaW5pdGlhbGx5IGZhbHNlLlxuICAjaGFuZHNoYWtlQWJvcnRlZCA9IGZhbHNlXG5cbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uL3dlYnNvY2tldCcpLkhhbmRsZXJ9ICovXG4gICNoYW5kbGVyID0ge1xuICAgIC8vIGh0dHBzOi8vd2hhdHByLm9yZy93ZWJzb2NrZXRzLzQ4LzdiNzQ4ZDMuLi5kNTU3MGYzLmh0bWwjZmVlZGJhY2stdG8td2Vic29ja2V0LXN0cmVhbS1mcm9tLXRoZS1wcm90b2NvbFxuICAgIG9uQ29ubmVjdGlvbkVzdGFibGlzaGVkOiAocmVzcG9uc2UsIGV4dGVuc2lvbnMpID0+IHRoaXMuI29uQ29ubmVjdGlvbkVzdGFibGlzaGVkKHJlc3BvbnNlLCBleHRlbnNpb25zKSxcbiAgICBvbkZhaWw6IChfY29kZSwgX3JlYXNvbikgPT4ge30sXG4gICAgb25NZXNzYWdlOiAob3Bjb2RlLCBkYXRhKSA9PiB0aGlzLiNvbk1lc3NhZ2Uob3Bjb2RlLCBkYXRhKSxcbiAgICBvblBhcnNlckVycm9yOiAoZXJyKSA9PiBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLiNoYW5kbGVyLCBudWxsLCBlcnIubWVzc2FnZSksXG4gICAgb25QYXJzZXJEcmFpbjogKCkgPT4gdGhpcy4jaGFuZGxlci5zb2NrZXQucmVzdW1lKCksXG4gICAgb25Tb2NrZXREYXRhOiAoY2h1bmspID0+IHtcbiAgICAgIGlmICghdGhpcy4jcGFyc2VyLndyaXRlKGNodW5rKSkge1xuICAgICAgICB0aGlzLiNoYW5kbGVyLnNvY2tldC5wYXVzZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICBvblNvY2tldEVycm9yOiAoZXJyKSA9PiB7XG4gICAgICB0aGlzLiNoYW5kbGVyLnJlYWR5U3RhdGUgPSBzdGF0ZXMuQ0xPU0lOR1xuXG4gICAgICBpZiAoY2hhbm5lbHMuc29ja2V0RXJyb3IuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgY2hhbm5lbHMuc29ja2V0RXJyb3IucHVibGlzaChlcnIpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuI2hhbmRsZXIuc29ja2V0LmRlc3Ryb3koKVxuICAgIH0sXG4gICAgb25Tb2NrZXRDbG9zZTogKCkgPT4gdGhpcy4jb25Tb2NrZXRDbG9zZSgpLFxuXG4gICAgcmVhZHlTdGF0ZTogc3RhdGVzLkNPTk5FQ1RJTkcsXG4gICAgc29ja2V0OiBudWxsLFxuICAgIGNsb3NlU3RhdGU6IG5ldyBTZXQoKSxcbiAgICBjb250cm9sbGVyOiBudWxsLFxuICAgIHdhc0V2ZXJDb25uZWN0ZWQ6IGZhbHNlXG4gIH1cblxuICAvKiogQHR5cGUge2ltcG9ydCgnLi4vcmVjZWl2ZXInKS5CeXRlUGFyc2VyfSAqL1xuICAjcGFyc2VyXG5cbiAgY29uc3RydWN0b3IgKHVybCwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgIGlmICghZW1pdHRlZEV4cGVyaW1lbnRhbFdhcm5pbmcpIHtcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoJ1dlYlNvY2tldFN0cmVhbSBpcyBleHBlcmltZW50YWwhIEV4cGVjdCBpdCB0byBjaGFuZ2UgYXQgYW55IHRpbWUuJywge1xuICAgICAgICBjb2RlOiAnVU5ESUNJLVdTUydcbiAgICAgIH0pXG4gICAgICBlbWl0dGVkRXhwZXJpbWVudGFsV2FybmluZyA9IHRydWVcbiAgICB9XG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdXZWJTb2NrZXQnKVxuXG4gICAgdXJsID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKHVybClcbiAgICBpZiAob3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLldlYlNvY2tldFN0cmVhbU9wdGlvbnMob3B0aW9ucylcbiAgICB9XG5cbiAgICAvLyAxLiBMZXQgYmFzZVVSTCBiZSB0aGlzICdzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdCAncyBBUEkgYmFzZSBVUkwgLlxuICAgIGNvbnN0IGJhc2VVUkwgPSBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0LnNldHRpbmdzT2JqZWN0LmJhc2VVcmxcblxuICAgIC8vIDIuIExldCB1cmxSZWNvcmQgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIGEgVVJMIHJlY29yZCBnaXZlbiB1cmwgYW5kIGJhc2VVUkwgLlxuICAgIGNvbnN0IHVybFJlY29yZCA9IGdldFVSTFJlY29yZCh1cmwsIGJhc2VVUkwpXG5cbiAgICAvLyAzLiBMZXQgcHJvdG9jb2xzIGJlIG9wdGlvbnMgW1wiIHByb3RvY29scyBcIl0gaWYgaXQgZXhpc3RzICwgb3RoZXJ3aXNlIGFuIGVtcHR5IHNlcXVlbmNlLlxuICAgIGNvbnN0IHByb3RvY29scyA9IG9wdGlvbnMucHJvdG9jb2xzXG5cbiAgICAvLyA0LiBJZiBhbnkgb2YgdGhlIHZhbHVlcyBpbiBwcm90b2NvbHMgb2NjdXIgbW9yZSB0aGFuIG9uY2Ugb3Igb3RoZXJ3aXNlIGZhaWwgdG8gbWF0Y2ggdGhlIHJlcXVpcmVtZW50cyBmb3IgZWxlbWVudHMgdGhhdCBjb21wcmlzZSB0aGUgdmFsdWUgb2YgYCBTZWMtV2ViU29ja2V0LVByb3RvY29sIGAgZmllbGRzIGFzIGRlZmluZWQgYnkgVGhlIFdlYlNvY2tldCBQcm90b2NvbCAsIHRoZW4gdGhyb3cgYSBcIiBTeW50YXhFcnJvciBcIiBET01FeGNlcHRpb24gLiBbV1NQXVxuICAgIGlmIChwcm90b2NvbHMubGVuZ3RoICE9PSBuZXcgU2V0KHByb3RvY29scy5tYXAocCA9PiBwLnRvTG93ZXJDYXNlKCkpKS5zaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtUHJvdG9jb2wgdmFsdWUnLCAnU3ludGF4RXJyb3InKVxuICAgIH1cblxuICAgIGlmIChwcm90b2NvbHMubGVuZ3RoID4gMCAmJiAhcHJvdG9jb2xzLmV2ZXJ5KHAgPT4gaXNWYWxpZFN1YnByb3RvY29sKHApKSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIHZhbHVlJywgJ1N5bnRheEVycm9yJylcbiAgICB9XG5cbiAgICAvLyA1LiBTZXQgdGhpcyAncyB1cmwgdG8gdXJsUmVjb3JkIC5cbiAgICB0aGlzLiN1cmwgPSB1cmxSZWNvcmQudG9TdHJpbmcoKVxuXG4gICAgLy8gNi4gU2V0IHRoaXMgJ3Mgb3BlbmVkIHByb21pc2UgYW5kIGNsb3NlZCBwcm9taXNlIHRvIG5ldyBwcm9taXNlcy5cbiAgICB0aGlzLiNvcGVuZWRQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcbiAgICB0aGlzLiNjbG9zZWRQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgIC8vIDcuIEFwcGx5IGJhY2twcmVzc3VyZSB0byB0aGUgV2ViU29ja2V0LlxuICAgIC8vIFRPRE9cblxuICAgIC8vIDguICBJZiBvcHRpb25zIFtcIiBzaWduYWwgXCJdIGV4aXN0cyAsXG4gICAgaWYgKG9wdGlvbnMuc2lnbmFsICE9IG51bGwpIHtcbiAgICAgIC8vIDguMS4gTGV0IHNpZ25hbCBiZSBvcHRpb25zIFtcIiBzaWduYWwgXCJdLlxuICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucy5zaWduYWxcblxuICAgICAgLy8gOC4yLiBJZiBzaWduYWwgaXMgYWJvcnRlZCAsIHRoZW4gcmVqZWN0IHRoaXMgJ3Mgb3BlbmVkIHByb21pc2UgYW5kIGNsb3NlZCBwcm9taXNlIHdpdGggc2lnbmFsIOKAmXMgYWJvcnQgcmVhc29uXG4gICAgICAvLyAgICAgIGFuZCByZXR1cm4uXG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgdGhpcy4jb3BlbmVkUHJvbWlzZS5yZWplY3Qoc2lnbmFsLnJlYXNvbilcbiAgICAgICAgdGhpcy4jY2xvc2VkUHJvbWlzZS5yZWplY3Qoc2lnbmFsLnJlYXNvbilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDguMy4gQWRkIHRoZSBmb2xsb3dpbmcgYWJvcnQgc3RlcHMgdG8gc2lnbmFsIDpcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgLy8gOC4zLjEuIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBub3QgeWV0IGVzdGFibGlzaGVkIDogW1dTUF1cbiAgICAgICAgaWYgKCFpc0VzdGFibGlzaGVkKHRoaXMuI2hhbmRsZXIucmVhZHlTdGF0ZSkpIHtcbiAgICAgICAgICAvLyA4LjMuMS4xLiBGYWlsIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiAuXG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlcilcblxuICAgICAgICAgIC8vIFNldCB0aGlzICdzIHJlYWR5IHN0YXRlIHRvIENMT1NJTkcgLlxuICAgICAgICAgIHRoaXMuI2hhbmRsZXIucmVhZHlTdGF0ZSA9IHN0YXRlcy5DTE9TSU5HXG5cbiAgICAgICAgICAvLyBSZWplY3QgdGhpcyAncyBvcGVuZWQgcHJvbWlzZSBhbmQgY2xvc2VkIHByb21pc2Ugd2l0aCBzaWduYWwg4oCZcyBhYm9ydCByZWFzb24gLlxuICAgICAgICAgIHRoaXMuI29wZW5lZFByb21pc2UucmVqZWN0KHNpZ25hbC5yZWFzb24pXG4gICAgICAgICAgdGhpcy4jY2xvc2VkUHJvbWlzZS5yZWplY3Qoc2lnbmFsLnJlYXNvbilcblxuICAgICAgICAgIC8vIFNldCB0aGlzICdzIGhhbmRzaGFrZSBhYm9ydGVkIHRvIHRydWUuXG4gICAgICAgICAgdGhpcy4jaGFuZHNoYWtlQWJvcnRlZCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pXG4gICAgfVxuXG4gICAgLy8gOS4gIExldCBjbGllbnQgYmUgdGhpcyAncyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QgLlxuICAgIGNvbnN0IGNsaWVudCA9IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3RcblxuICAgIC8vIDEwLiBSdW4gdGhpcyBzdGVwIGluIHBhcmFsbGVsIDpcbiAgICAvLyAxMC4xLiBFc3RhYmxpc2ggYSBXZWJTb2NrZXQgY29ubmVjdGlvbiBnaXZlbiB1cmxSZWNvcmQgLCBwcm90b2NvbHMgLCBhbmQgY2xpZW50IC4gW0ZFVENIXVxuICAgIHRoaXMuI2hhbmRsZXIuY29udHJvbGxlciA9IGVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24oXG4gICAgICB1cmxSZWNvcmQsXG4gICAgICBwcm90b2NvbHMsXG4gICAgICBjbGllbnQsXG4gICAgICB0aGlzLiNoYW5kbGVyLFxuICAgICAgb3B0aW9uc1xuICAgIClcbiAgfVxuXG4gIC8vIFRoZSB1cmwgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpcyAncyB1cmwgLCBzZXJpYWxpemVkIC5cbiAgZ2V0IHVybCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VybC50b1N0cmluZygpXG4gIH1cblxuICAvLyBUaGUgb3BlbmVkIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXMgJ3Mgb3BlbmVkIHByb21pc2UgLlxuICBnZXQgb3BlbmVkICgpIHtcbiAgICByZXR1cm4gdGhpcy4jb3BlbmVkUHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICAvLyBUaGUgY2xvc2VkIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXMgJ3MgY2xvc2VkIHByb21pc2UgLlxuICBnZXQgY2xvc2VkICgpIHtcbiAgICByZXR1cm4gdGhpcy4jY2xvc2VkUHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICAvLyBUaGUgY2xvc2UoIGNsb3NlSW5mbyApIG1ldGhvZCBzdGVwcyBhcmU6XG4gIGNsb3NlIChjbG9zZUluZm8gPSB1bmRlZmluZWQpIHtcbiAgICBpZiAoY2xvc2VJbmZvICE9PSBudWxsKSB7XG4gICAgICBjbG9zZUluZm8gPSB3ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRDbG9zZUluZm8oY2xvc2VJbmZvKVxuICAgIH1cblxuICAgIC8vIDEuIExldCBjb2RlIGJlIGNsb3NlSW5mbyBbXCIgY2xvc2VDb2RlIFwiXSBpZiBwcmVzZW50LCBvciBudWxsIG90aGVyd2lzZS5cbiAgICBjb25zdCBjb2RlID0gY2xvc2VJbmZvLmNsb3NlQ29kZSA/PyBudWxsXG5cbiAgICAvLyAyLiBMZXQgcmVhc29uIGJlIGNsb3NlSW5mbyBbXCIgcmVhc29uIFwiXS5cbiAgICBjb25zdCByZWFzb24gPSBjbG9zZUluZm8ucmVhc29uXG5cbiAgICAvLyAzLiBDbG9zZSB0aGUgV2ViU29ja2V0IHdpdGggdGhpcyAsIGNvZGUgLCBhbmQgcmVhc29uIC5cbiAgICBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgY29kZSwgcmVhc29uLCB0cnVlKVxuICB9XG5cbiAgI3dyaXRlIChjaHVuaykge1xuICAgIC8vIDEuIExldCBwcm9taXNlIGJlIGEgbmV3IHByb21pc2UgY3JlYXRlZCBpbiBzdHJlYW0g4oCZcyByZWxldmFudCByZWFsbSAuXG4gICAgY29uc3QgcHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyAyLiBMZXQgZGF0YSBiZSBudWxsLlxuICAgIGxldCBkYXRhID0gbnVsbFxuXG4gICAgLy8gMy4gTGV0IG9wY29kZSBiZSBudWxsLlxuICAgIGxldCBvcGNvZGUgPSBudWxsXG5cbiAgICAvLyA0LiBJZiBjaHVuayBpcyBhIEJ1ZmZlclNvdXJjZSAsXG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhjaHVuaykgfHwgdHlwZXMuaXNBcnJheUJ1ZmZlcihjaHVuaykpIHtcbiAgICAgIC8vIDQuMS4gU2V0IGRhdGEgdG8gYSBjb3B5IG9mIHRoZSBieXRlcyBnaXZlbiBjaHVuayAuXG4gICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoQXJyYXlCdWZmZXIuaXNWaWV3KGNodW5rKSA/IG5ldyBVaW50OEFycmF5KGNodW5rLmJ1ZmZlciwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aCkgOiBjaHVuaylcblxuICAgICAgLy8gNC4yLiBTZXQgb3Bjb2RlIHRvIGEgYmluYXJ5IGZyYW1lIG9wY29kZS5cbiAgICAgIG9wY29kZSA9IG9wY29kZXMuQklOQVJZXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDUuIE90aGVyd2lzZSxcblxuICAgICAgLy8gNS4xLiBMZXQgc3RyaW5nIGJlIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBjaHVuayB0byBhbiBJREwgVVNWU3RyaW5nIC5cbiAgICAgIC8vICAgIElmIHRoaXMgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgcmV0dXJuIGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBleGNlcHRpb24uXG4gICAgICBsZXQgc3RyaW5nXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0cmluZyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhjaHVuaylcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJvbWlzZS5yZWplY3QoZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDUuMi4gU2V0IGRhdGEgdG8gdGhlIHJlc3VsdCBvZiBVVEYtOCBlbmNvZGluZyBzdHJpbmcgLlxuICAgICAgZGF0YSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHJpbmcpXG5cbiAgICAgIC8vIDUuMy4gU2V0IG9wY29kZSB0byBhIHRleHQgZnJhbWUgb3Bjb2RlLlxuICAgICAgb3Bjb2RlID0gb3Bjb2Rlcy5URVhUXG4gICAgfVxuXG4gICAgLy8gNi4gSW4gcGFyYWxsZWwsXG4gICAgLy8gNi4xLiBXYWl0IHVudGlsIHRoZXJlIGlzIHN1ZmZpY2llbnQgYnVmZmVyIHNwYWNlIGluIHN0cmVhbSB0byBzZW5kIHRoZSBtZXNzYWdlLlxuXG4gICAgLy8gNi4yLiBJZiB0aGUgY2xvc2luZyBoYW5kc2hha2UgaGFzIG5vdCB5ZXQgc3RhcnRlZCAsIFNlbmQgYSBXZWJTb2NrZXQgTWVzc2FnZSB0byBzdHJlYW0gY29tcHJpc2VkIG9mIGRhdGEgdXNpbmcgb3Bjb2RlIC5cbiAgICBpZiAoIXRoaXMuI2hhbmRsZXIuY2xvc2VTdGF0ZS5oYXMoc2VudENsb3NlRnJhbWVTdGF0ZS5TRU5UKSAmJiAhdGhpcy4jaGFuZGxlci5jbG9zZVN0YXRlLmhhcyhzZW50Q2xvc2VGcmFtZVN0YXRlLlJFQ0VJVkVEKSkge1xuICAgICAgY29uc3QgZnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKGRhdGEpXG5cbiAgICAgIHRoaXMuI2hhbmRsZXIuc29ja2V0LndyaXRlKGZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZSksICgpID0+IHtcbiAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gNi4zLiBRdWV1ZSBhIGdsb2JhbCB0YXNrIG9uIHRoZSBXZWJTb2NrZXQgdGFzayBzb3VyY2UgZ2l2ZW4gc3RyZWFtIOKAmXMgcmVsZXZhbnQgZ2xvYmFsIG9iamVjdCB0byByZXNvbHZlIHByb21pc2Ugd2l0aCB1bmRlZmluZWQuXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCcuLi93ZWJzb2NrZXQnKS5IYW5kbGVyWydvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZCddfSAqL1xuICAjb25Db25uZWN0aW9uRXN0YWJsaXNoZWQgKHJlc3BvbnNlLCBwYXJzZWRFeHRlbnNpb25zKSB7XG4gICAgdGhpcy4jaGFuZGxlci5zb2NrZXQgPSByZXNwb25zZS5zb2NrZXRcblxuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBCeXRlUGFyc2VyKHRoaXMuI2hhbmRsZXIsIHBhcnNlZEV4dGVuc2lvbnMpXG4gICAgcGFyc2VyLm9uKCdkcmFpbicsICgpID0+IHRoaXMuI2hhbmRsZXIub25QYXJzZXJEcmFpbigpKVxuICAgIHBhcnNlci5vbignZXJyb3InLCAoZXJyKSA9PiB0aGlzLiNoYW5kbGVyLm9uUGFyc2VyRXJyb3IoZXJyKSlcblxuICAgIHRoaXMuI3BhcnNlciA9IHBhcnNlclxuXG4gICAgLy8gMS4gQ2hhbmdlIHN0cmVhbSDigJlzIHJlYWR5IHN0YXRlIHRvIE9QRU4gKDEpLlxuICAgIHRoaXMuI2hhbmRsZXIucmVhZHlTdGF0ZSA9IHN0YXRlcy5PUEVOXG5cbiAgICAvLyAyLiBTZXQgc3RyZWFtIOKAmXMgd2FzIGV2ZXIgY29ubmVjdGVkIHRvIHRydWUuXG4gICAgLy8gVGhpcyBpcyBkb25lIGluIHRoZSBvcGVuaW5nIGhhbmRzaGFrZS5cblxuICAgIC8vIDMuIExldCBleHRlbnNpb25zIGJlIHRoZSBleHRlbnNpb25zIGluIHVzZSAuXG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHBhcnNlZEV4dGVuc2lvbnMgPz8gJydcblxuICAgIC8vIDQuIExldCBwcm90b2NvbCBiZSB0aGUgc3VicHJvdG9jb2wgaW4gdXNlIC5cbiAgICBjb25zdCBwcm90b2NvbCA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnc2VjLXdlYnNvY2tldC1wcm90b2NvbCcpID8/ICcnXG5cbiAgICAvLyA1LiBMZXQgcHVsbEFsZ29yaXRobSBiZSBhbiBhY3Rpb24gdGhhdCBwdWxscyBieXRlcyBmcm9tIHN0cmVhbSAuXG4gICAgLy8gNi4gTGV0IGNhbmNlbEFsZ29yaXRobSBiZSBhbiBhY3Rpb24gdGhhdCBjYW5jZWxzIHN0cmVhbSB3aXRoIHJlYXNvbiAsIGdpdmVuIHJlYXNvbiAuXG4gICAgLy8gNy4gTGV0IHJlYWRhYmxlIGJlIGEgbmV3IFJlYWRhYmxlU3RyZWFtIC5cbiAgICAvLyA4LiBTZXQgdXAgcmVhZGFibGUgd2l0aCBwdWxsQWxnb3JpdGhtIGFuZCBjYW5jZWxBbGdvcml0aG0gLlxuICAgIGNvbnN0IHJlYWRhYmxlID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICB0aGlzLiNyZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyXG4gICAgICB9LFxuICAgICAgcHVsbCAoY29udHJvbGxlcikge1xuICAgICAgICBsZXQgY2h1bmtcbiAgICAgICAgd2hpbGUgKGNvbnRyb2xsZXIuZGVzaXJlZFNpemUgPiAwICYmIChjaHVuayA9IHJlc3BvbnNlLnNvY2tldC5yZWFkKCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FuY2VsOiAocmVhc29uKSA9PiB0aGlzLiNjYW5jZWwocmVhc29uKVxuICAgIH0pXG5cbiAgICAvLyA5LiBMZXQgd3JpdGVBbGdvcml0aG0gYmUgYW4gYWN0aW9uIHRoYXQgd3JpdGVzIGNodW5rIHRvIHN0cmVhbSAsIGdpdmVuIGNodW5rIC5cbiAgICAvLyAxMC4gTGV0IGNsb3NlQWxnb3JpdGhtIGJlIGFuIGFjdGlvbiB0aGF0IGNsb3NlcyBzdHJlYW0gLlxuICAgIC8vIDExLiBMZXQgYWJvcnRBbGdvcml0aG0gYmUgYW4gYWN0aW9uIHRoYXQgYWJvcnRzIHN0cmVhbSB3aXRoIHJlYXNvbiAsIGdpdmVuIHJlYXNvbiAuXG4gICAgLy8gMTIuIExldCB3cml0YWJsZSBiZSBhIG5ldyBXcml0YWJsZVN0cmVhbSAuXG4gICAgLy8gMTMuIFNldCB1cCB3cml0YWJsZSB3aXRoIHdyaXRlQWxnb3JpdGhtICwgY2xvc2VBbGdvcml0aG0gLCBhbmQgYWJvcnRBbGdvcml0aG0gLlxuICAgIGNvbnN0IHdyaXRhYmxlID0gbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgIHdyaXRlOiAoY2h1bmspID0+IHRoaXMuI3dyaXRlKGNodW5rKSxcbiAgICAgIGNsb3NlOiAoKSA9PiBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgbnVsbCwgbnVsbCksXG4gICAgICBhYm9ydDogKHJlYXNvbikgPT4gdGhpcy4jY2xvc2VVc2luZ1JlYXNvbihyZWFzb24pXG4gICAgfSlcblxuICAgIC8vIFNldCBzdHJlYW0g4oCZcyByZWFkYWJsZSBzdHJlYW0gdG8gcmVhZGFibGUgLlxuICAgIHRoaXMuI3JlYWRhYmxlU3RyZWFtID0gcmVhZGFibGVcblxuICAgIC8vIFNldCBzdHJlYW0g4oCZcyB3cml0YWJsZSBzdHJlYW0gdG8gd3JpdGFibGUgLlxuICAgIHRoaXMuI3dyaXRhYmxlU3RyZWFtID0gd3JpdGFibGVcblxuICAgIC8vIFJlc29sdmUgc3RyZWFtIOKAmXMgb3BlbmVkIHByb21pc2Ugd2l0aCBXZWJTb2NrZXRPcGVuSW5mbyDCq1sgXCIgZXh0ZW5zaW9ucyBcIiDihpIgZXh0ZW5zaW9ucyAsIFwiIHByb3RvY29sIFwiIOKGkiBwcm90b2NvbCAsIFwiIHJlYWRhYmxlIFwiIOKGkiByZWFkYWJsZSAsIFwiIHdyaXRhYmxlIFwiIOKGkiB3cml0YWJsZSBdwrsuXG4gICAgdGhpcy4jb3BlbmVkUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIGV4dGVuc2lvbnMsXG4gICAgICBwcm90b2NvbCxcbiAgICAgIHJlYWRhYmxlLFxuICAgICAgd3JpdGFibGVcbiAgICB9KVxuICB9XG5cbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uL3dlYnNvY2tldCcpLkhhbmRsZXJbJ29uTWVzc2FnZSddfSAqL1xuICAjb25NZXNzYWdlICh0eXBlLCBkYXRhKSB7XG4gICAgLy8gMS4gSWYgc3RyZWFt4oCZcyByZWFkeSBzdGF0ZSBpcyBub3QgT1BFTiAoMSksIHRoZW4gcmV0dXJuLlxuICAgIGlmICh0aGlzLiNoYW5kbGVyLnJlYWR5U3RhdGUgIT09IHN0YXRlcy5PUEVOKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgY2h1bmsgYmUgZGV0ZXJtaW5lZCBieSBzd2l0Y2hpbmcgb24gdHlwZTpcbiAgICAvLyAgICAgIC0gdHlwZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZGF0YSBpcyBUZXh0XG4gICAgLy8gICAgICAgICAgYSBuZXcgRE9NU3RyaW5nIGNvbnRhaW5pbmcgZGF0YVxuICAgIC8vICAgICAgLSB0eXBlIGluZGljYXRlcyB0aGF0IHRoZSBkYXRhIGlzIEJpbmFyeVxuICAgIC8vICAgICAgICAgIGEgbmV3IFVpbnQ4QXJyYXkgb2JqZWN0LCBjcmVhdGVkIGluIHRoZSByZWxldmFudCBSZWFsbSBvZiB0aGVcbiAgICAvLyAgICAgICAgICBXZWJTb2NrZXRTdHJlYW0gb2JqZWN0LCB3aG9zZSBjb250ZW50cyBhcmUgZGF0YVxuICAgIGxldCBjaHVua1xuXG4gICAgaWYgKHR5cGUgPT09IG9wY29kZXMuVEVYVCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2h1bmsgPSB1dGY4RGVjb2RlKGRhdGEpXG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgJ1JlY2VpdmVkIGludmFsaWQgVVRGLTggaW4gdGV4dCBmcmFtZS4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IG9wY29kZXMuQklOQVJZKSB7XG4gICAgICBjaHVuayA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aClcbiAgICB9XG5cbiAgICAvLyAzLiBFbnF1ZXVlIGNodW5rIGludG8gc3RyZWFt4oCZcyByZWFkYWJsZSBzdHJlYW0uXG4gICAgdGhpcy4jcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLmVucXVldWUoY2h1bmspXG5cbiAgICAvLyA0LiBBcHBseSBiYWNrcHJlc3N1cmUgdG8gdGhlIFdlYlNvY2tldC5cbiAgfVxuXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCcuLi93ZWJzb2NrZXQnKS5IYW5kbGVyWydvblNvY2tldENsb3NlJ119ICovXG4gICNvblNvY2tldENsb3NlICgpIHtcbiAgICBjb25zdCB3YXNDbGVhbiA9XG4gICAgICB0aGlzLiNoYW5kbGVyLmNsb3NlU3RhdGUuaGFzKHNlbnRDbG9zZUZyYW1lU3RhdGUuU0VOVCkgJiZcbiAgICAgIHRoaXMuI2hhbmRsZXIuY2xvc2VTdGF0ZS5oYXMoc2VudENsb3NlRnJhbWVTdGF0ZS5SRUNFSVZFRClcblxuICAgIC8vIDEuIENoYW5nZSB0aGUgcmVhZHkgc3RhdGUgdG8gQ0xPU0VEICgzKS5cbiAgICB0aGlzLiNoYW5kbGVyLnJlYWR5U3RhdGUgPSBzdGF0ZXMuQ0xPU0VEXG5cbiAgICAvLyAyLiBJZiBzdHJlYW0g4oCZcyBoYW5kc2hha2UgYWJvcnRlZCBpcyB0cnVlLCB0aGVuIHJldHVybi5cbiAgICBpZiAodGhpcy4jaGFuZHNoYWtlQWJvcnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgc3RyZWFtIOKAmXMgd2FzIGV2ZXIgY29ubmVjdGVkIGlzIGZhbHNlLCB0aGVuIHJlamVjdCBzdHJlYW0g4oCZcyBvcGVuZWQgcHJvbWlzZSB3aXRoIGEgbmV3IFdlYlNvY2tldEVycm9yLlxuICAgIGlmICghdGhpcy4jaGFuZGxlci53YXNFdmVyQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLiNvcGVuZWRQcm9taXNlLnJlamVjdChuZXcgV2ViU29ja2V0RXJyb3IoJ1NvY2tldCBuZXZlciBvcGVuZWQnKSlcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNwYXJzZXIuY2xvc2luZ0luZm9cblxuICAgIC8vIDQuIExldCBjb2RlIGJlIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZSBjb2RlIC5cbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi03LjEuNVxuICAgIC8vIElmIHRoaXMgQ2xvc2UgY29udHJvbCBmcmFtZSBjb250YWlucyBubyBzdGF0dXMgY29kZSwgX1RoZSBXZWJTb2NrZXRcbiAgICAvLyBDb25uZWN0aW9uIENsb3NlIENvZGVfIGlzIGNvbnNpZGVyZWQgdG8gYmUgMTAwNS4gSWYgX1RoZSBXZWJTb2NrZXRcbiAgICAvLyBDb25uZWN0aW9uIGlzIENsb3NlZF8gYW5kIG5vIENsb3NlIGNvbnRyb2wgZnJhbWUgd2FzIHJlY2VpdmVkIGJ5IHRoZVxuICAgIC8vIGVuZHBvaW50IChzdWNoIGFzIGNvdWxkIG9jY3VyIGlmIHRoZSB1bmRlcmx5aW5nIHRyYW5zcG9ydCBjb25uZWN0aW9uXG4gICAgLy8gaXMgbG9zdCksIF9UaGUgV2ViU29ja2V0IENvbm5lY3Rpb24gQ2xvc2UgQ29kZV8gaXMgY29uc2lkZXJlZCB0byBiZVxuICAgIC8vIDEwMDYuXG4gICAgbGV0IGNvZGUgPSByZXN1bHQ/LmNvZGUgPz8gMTAwNVxuXG4gICAgaWYgKCF0aGlzLiNoYW5kbGVyLmNsb3NlU3RhdGUuaGFzKHNlbnRDbG9zZUZyYW1lU3RhdGUuU0VOVCkgJiYgIXRoaXMuI2hhbmRsZXIuY2xvc2VTdGF0ZS5oYXMoc2VudENsb3NlRnJhbWVTdGF0ZS5SRUNFSVZFRCkpIHtcbiAgICAgIGNvZGUgPSAxMDA2XG4gICAgfVxuXG4gICAgLy8gNS4gTGV0IHJlYXNvbiBiZSB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIFVURi04IGRlY29kZSB3aXRob3V0IEJPTSB0byB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2UgcmVhc29uIC5cbiAgICBjb25zdCByZWFzb24gPSByZXN1bHQ/LnJlYXNvbiA9PSBudWxsID8gJycgOiB1dGY4RGVjb2RlQnl0ZXMoQnVmZmVyLmZyb20ocmVzdWx0LnJlYXNvbikpXG5cbiAgICAvLyA2LiBJZiB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGNsZWFubHkgLFxuICAgIGlmICh3YXNDbGVhbikge1xuICAgICAgLy8gNi4xLiBDbG9zZSBzdHJlYW0g4oCZcyByZWFkYWJsZSBzdHJlYW0gLlxuICAgICAgdGhpcy4jcmVhZGFibGVTdHJlYW0uY2FuY2VsKCkuY2F0Y2goKCkgPT4ge30pXG5cbiAgICAgIC8vIDYuMi4gRXJyb3Igc3RyZWFtIOKAmXMgd3JpdGFibGUgc3RyZWFtIHdpdGggYW4gXCIgSW52YWxpZFN0YXRlRXJyb3IgXCIgRE9NRXhjZXB0aW9uIGluZGljYXRpbmcgdGhhdCBhIGNsb3NlZCBXZWJTb2NrZXRTdHJlYW0gY2Fubm90IGJlIHdyaXR0ZW4gdG8uXG4gICAgICBpZiAoIXRoaXMuI3dyaXRhYmxlU3RyZWFtLmxvY2tlZCkge1xuICAgICAgICB0aGlzLiN3cml0YWJsZVN0cmVhbS5hYm9ydChuZXcgRE9NRXhjZXB0aW9uKCdBIGNsb3NlZCBXZWJTb2NrZXRTdHJlYW0gY2Fubm90IGJlIHdyaXR0ZW4gdG8nLCAnSW52YWxpZFN0YXRlRXJyb3InKSlcbiAgICAgIH1cblxuICAgICAgLy8gNi4zLiBSZXNvbHZlIHN0cmVhbSDigJlzIGNsb3NlZCBwcm9taXNlIHdpdGggV2ViU29ja2V0Q2xvc2VJbmZvIMKrWyBcIiBjbG9zZUNvZGUgXCIg4oaSIGNvZGUgLCBcIiByZWFzb24gXCIg4oaSIHJlYXNvbiBdwrsuXG4gICAgICB0aGlzLiNjbG9zZWRQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBjbG9zZUNvZGU6IGNvZGUsXG4gICAgICAgIHJlYXNvblxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gNy4gT3RoZXJ3aXNlLFxuXG4gICAgICAvLyA3LjEuIExldCBlcnJvciBiZSBhIG5ldyBXZWJTb2NrZXRFcnJvciB3aG9zZSBjbG9zZUNvZGUgaXMgY29kZSBhbmQgcmVhc29uIGlzIHJlYXNvbiAuXG4gICAgICBjb25zdCBlcnJvciA9IGNyZWF0ZVVudmFsaWRhdGVkV2ViU29ja2V0RXJyb3IoJ3VuY2xlYW4gY2xvc2UnLCBjb2RlLCByZWFzb24pXG5cbiAgICAgIC8vIDcuMi4gRXJyb3Igc3RyZWFtIOKAmXMgcmVhZGFibGUgc3RyZWFtIHdpdGggZXJyb3IgLlxuICAgICAgdGhpcy4jcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLmVycm9yKGVycm9yKVxuXG4gICAgICAvLyA3LjMuIEVycm9yIHN0cmVhbSDigJlzIHdyaXRhYmxlIHN0cmVhbSB3aXRoIGVycm9yIC5cbiAgICAgIHRoaXMuI3dyaXRhYmxlU3RyZWFtLmFib3J0KGVycm9yKVxuXG4gICAgICAvLyA3LjQuIFJlamVjdCBzdHJlYW0g4oCZcyBjbG9zZWQgcHJvbWlzZSB3aXRoIGVycm9yIC5cbiAgICAgIHRoaXMuI2Nsb3NlZFByb21pc2UucmVqZWN0KGVycm9yKVxuICAgIH1cbiAgfVxuXG4gICNjbG9zZVVzaW5nUmVhc29uIChyZWFzb24pIHtcbiAgICAvLyAxLiBMZXQgY29kZSBiZSBudWxsLlxuICAgIGxldCBjb2RlID0gbnVsbFxuXG4gICAgLy8gMi4gTGV0IHJlYXNvblN0cmluZyBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIGxldCByZWFzb25TdHJpbmcgPSAnJ1xuXG4gICAgLy8gMy4gSWYgcmVhc29uIGltcGxlbWVudHMgV2ViU29ja2V0RXJyb3IgLFxuICAgIGlmICh3ZWJpZGwuaXMuV2ViU29ja2V0RXJyb3IocmVhc29uKSkge1xuICAgICAgLy8gMy4xLiBTZXQgY29kZSB0byByZWFzb24g4oCZcyBjbG9zZUNvZGUgLlxuICAgICAgY29kZSA9IHJlYXNvbi5jbG9zZUNvZGVcblxuICAgICAgLy8gMy4yLiBTZXQgcmVhc29uU3RyaW5nIHRvIHJlYXNvbiDigJlzIHJlYXNvbiAuXG4gICAgICByZWFzb25TdHJpbmcgPSByZWFzb24ucmVhc29uXG4gICAgfVxuXG4gICAgLy8gNC4gQ2xvc2UgdGhlIFdlYlNvY2tldCB3aXRoIHN0cmVhbSAsIGNvZGUgLCBhbmQgcmVhc29uU3RyaW5nIC4gSWYgdGhpcyB0aHJvd3MgYW4gZXhjZXB0aW9uLFxuICAgIC8vICAgIGRpc2NhcmQgY29kZSBhbmQgcmVhc29uU3RyaW5nIGFuZCBjbG9zZSB0aGUgV2ViU29ja2V0IHdpdGggc3RyZWFtIC5cbiAgICBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgY29kZSwgcmVhc29uU3RyaW5nKVxuICB9XG5cbiAgLy8gIFRvIGNhbmNlbCBhIFdlYlNvY2tldFN0cmVhbSBzdHJlYW0gZ2l2ZW4gcmVhc29uICwgY2xvc2UgdXNpbmcgcmVhc29uIGdpdmluZyBzdHJlYW0gYW5kIHJlYXNvbiAuXG4gICNjYW5jZWwgKHJlYXNvbikge1xuICAgIHRoaXMuI2Nsb3NlVXNpbmdSZWFzb24ocmVhc29uKVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdlYlNvY2tldFN0cmVhbS5wcm90b3R5cGUsIHtcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvcGVuZWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNsb3NlZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2xvc2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdXZWJTb2NrZXRTdHJlYW0nLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0U3RyZWFtT3B0aW9ucyA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ3Byb3RvY29scycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IFtdXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdzaWduYWwnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkFib3J0U2lnbmFsKSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0Q2xvc2VJbmZvID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAnY2xvc2VDb2RlJyxcbiAgICBjb252ZXJ0ZXI6IChWKSA9PiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXShWLCB7IGVuZm9yY2VSYW5nZTogdHJ1ZSB9KVxuICB9LFxuICB7XG4gICAga2V5OiAncmVhc29uJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+ICcnXG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0geyBXZWJTb2NrZXRTdHJlYW0gfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/stream/websocketstream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/util.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/util.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { states, opcodes } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst { isUtf8 } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\nconst { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = __webpack_require__(/*! ../fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\n\n/**\n * @param {number} readyState\n * @returns {boolean}\n */\nfunction isConnecting (readyState) {\n  // If the WebSocket connection is not yet established, and the connection\n  // is not yet closed, then the WebSocket connection is in the CONNECTING state.\n  return readyState === states.CONNECTING\n}\n\n/**\n * @param {number} readyState\n * @returns {boolean}\n */\nfunction isEstablished (readyState) {\n  // If the server's response is validated as provided for above, it is\n  // said that _The WebSocket Connection is Established_ and that the\n  // WebSocket Connection is in the OPEN state.\n  return readyState === states.OPEN\n}\n\n/**\n * @param {number} readyState\n * @returns {boolean}\n */\nfunction isClosing (readyState) {\n  // Upon either sending or receiving a Close control frame, it is said\n  // that _The WebSocket Closing Handshake is Started_ and that the\n  // WebSocket connection is in the CLOSING state.\n  return readyState === states.CLOSING\n}\n\n/**\n * @param {number} readyState\n * @returns {boolean}\n */\nfunction isClosed (readyState) {\n  return readyState === states.CLOSED\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {(...args: ConstructorParameters<typeof Event>) => Event} eventFactory\n * @param {EventInit | undefined} eventInitDict\n * @returns {void}\n */\nfunction fireEvent (e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {\n  // 1. If eventConstructor is not given, then let eventConstructor be Event.\n\n  // 2. Let event be the result of creating an event given eventConstructor,\n  //    in the relevant realm of target.\n  // 3. Initialize events type attribute to e.\n  const event = eventFactory(e, eventInitDict)\n\n  // 4. Initialize any other IDL attributes of event as described in the\n  //    invocation of this algorithm.\n\n  // 5. Return the result of dispatching event at target, with legacy target\n  //    override flag set if set.\n  target.dispatchEvent(event)\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').Handler} handler\n * @param {number} type Opcode\n * @param {Buffer} data application data\n * @returns {void}\n */\nfunction websocketMessageReceived (handler, type, data) {\n  handler.onMessage(type, data)\n}\n\n/**\n * @param {Buffer} buffer\n * @returns {ArrayBuffer}\n */\nfunction toArrayBuffer (buffer) {\n  if (buffer.byteLength === buffer.buffer.byteLength) {\n    return buffer.buffer\n  }\n  return new Uint8Array(buffer).buffer\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n * @returns {boolean}\n */\nfunction isValidSubprotocol (protocol) {\n  // If present, this value indicates one\n  // or more comma-separated subprotocol the client wishes to speak,\n  // ordered by preference.  The elements that comprise this value\n  // MUST be non-empty strings with characters in the range U+0021 to\n  // U+007E not including separator characters as defined in\n  // [RFC2616] and MUST all be unique strings.\n  if (protocol.length === 0) {\n    return false\n  }\n\n  for (let i = 0; i < protocol.length; ++i) {\n    const code = protocol.charCodeAt(i)\n\n    if (\n      code < 0x21 || // CTL, contains SP (0x20) and HT (0x09)\n      code > 0x7E ||\n      code === 0x22 || // \"\n      code === 0x28 || // (\n      code === 0x29 || // )\n      code === 0x2C || // ,\n      code === 0x2F || // /\n      code === 0x3A || // :\n      code === 0x3B || // ;\n      code === 0x3C || // <\n      code === 0x3D || // =\n      code === 0x3E || // >\n      code === 0x3F || // ?\n      code === 0x40 || // @\n      code === 0x5B || // [\n      code === 0x5C || // \\\n      code === 0x5D || // ]\n      code === 0x7B || // {\n      code === 0x7D // }\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n * @returns {boolean}\n */\nfunction isValidStatusCode (code) {\n  if (code >= 1000 && code < 1015) {\n    return (\n      code !== 1004 && // reserved\n      code !== 1005 && // \"MUST NOT be set as a status code\"\n      code !== 1006 // \"MUST NOT be set as a status code\"\n    )\n  }\n\n  return code >= 3000 && code <= 4999\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-5.5\n * @param {number} opcode\n * @returns {boolean}\n */\nfunction isControlFrame (opcode) {\n  return (\n    opcode === opcodes.CLOSE ||\n    opcode === opcodes.PING ||\n    opcode === opcodes.PONG\n  )\n}\n\n/**\n * @param {number} opcode\n * @returns {boolean}\n */\nfunction isContinuationFrame (opcode) {\n  return opcode === opcodes.CONTINUATION\n}\n\n/**\n * @param {number} opcode\n * @returns {boolean}\n */\nfunction isTextBinaryFrame (opcode) {\n  return opcode === opcodes.TEXT || opcode === opcodes.BINARY\n}\n\n/**\n *\n * @param {number} opcode\n * @returns {boolean}\n */\nfunction isValidOpcode (opcode) {\n  return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode)\n}\n\n/**\n * Parses a Sec-WebSocket-Extensions header value.\n * @param {string} extensions\n * @returns {Map<string, string>}\n */\n// TODO(@Uzlopak, @KhafraDev): make compliant https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\nfunction parseExtensions (extensions) {\n  const position = { position: 0 }\n  const extensionList = new Map()\n\n  while (position.position < extensions.length) {\n    const pair = collectASequenceOfCodePointsFast(';', extensions, position)\n    const [name, value = ''] = pair.split('=', 2)\n\n    extensionList.set(\n      removeHTTPWhitespace(name, true, false),\n      removeHTTPWhitespace(value, false, true)\n    )\n\n    position.position++\n  }\n\n  return extensionList\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7692#section-7.1.2.2\n * @description \"client-max-window-bits = 1*DIGIT\"\n * @param {string} value\n * @returns {boolean}\n */\nfunction isValidClientWindowBits (value) {\n  for (let i = 0; i < value.length; i++) {\n    const byte = value.charCodeAt(i)\n\n    if (byte < 0x30 || byte > 0x39) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://whatpr.org/websockets/48/7b748d3...d5570f3.html#get-a-url-record\n * @param {string} url\n * @param {string} [baseURL]\n */\nfunction getURLRecord (url, baseURL) {\n  // 1. Let urlRecord be the result of applying the URL parser to url with baseURL .\n  // 2. If urlRecord is failure, then throw a \" SyntaxError \" DOMException .\n  let urlRecord\n\n  try {\n    urlRecord = new URL(url, baseURL)\n  } catch (e) {\n    throw new DOMException(e, 'SyntaxError')\n  }\n\n  // 3. If urlRecord s scheme is \" http \", then set urlRecord s scheme to \" ws \".\n  // 4. Otherwise, if urlRecord s scheme is \" https \", set urlRecord s scheme to \" wss \".\n  if (urlRecord.protocol === 'http:') {\n    urlRecord.protocol = 'ws:'\n  } else if (urlRecord.protocol === 'https:') {\n    urlRecord.protocol = 'wss:'\n  }\n\n  // 5. If urlRecord s scheme is not \" ws \" or \" wss \", then throw a \" SyntaxError \" DOMException .\n  if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n    throw new DOMException('expected a ws: or wss: url', 'SyntaxError')\n  }\n\n  // If urlRecord s fragment is non-null, then throw a \" SyntaxError \" DOMException .\n  if (urlRecord.hash.length || urlRecord.href.endsWith('#')) {\n    throw new DOMException('hash', 'SyntaxError')\n  }\n\n  // Return urlRecord .\n  return urlRecord\n}\n\n// https://whatpr.org/websockets/48.html#validate-close-code-and-reason\nfunction validateCloseCodeAndReason (code, reason) {\n  // 1. If code is not null, but is neither an integer equal to\n  //    1000 nor an integer in the range 3000 to 4999, inclusive,\n  //    throw an \"InvalidAccessError\" DOMException.\n  if (code !== null) {\n    if (code !== 1000 && (code < 3000 || code > 4999)) {\n      throw new DOMException('invalid code', 'InvalidAccessError')\n    }\n  }\n\n  // 2. If reason is not null, then:\n  if (reason !== null) {\n    // 2.1. Let reasonBytes be the result of UTF-8 encoding reason.\n    // 2.2. If reasonBytes is longer than 123 bytes, then throw a\n    //      \"SyntaxError\" DOMException.\n    const reasonBytesLength = Buffer.byteLength(reason)\n\n    if (reasonBytesLength > 123) {\n      throw new DOMException(`Reason must be less than 123 bytes; received ${reasonBytesLength}`, 'SyntaxError')\n    }\n  }\n}\n\n/**\n * Converts a Buffer to utf-8, even on platforms without icu.\n * @type {(buffer: Buffer) => string}\n */\nconst utf8Decode = (() => {\n  if (typeof process.versions.icu === 'string') {\n    const fatalDecoder = new TextDecoder('utf-8', { fatal: true })\n    return fatalDecoder.decode.bind(fatalDecoder)\n  }\n  return function (buffer) {\n    if (isUtf8(buffer)) {\n      return buffer.toString('utf-8')\n    }\n    throw new TypeError('Invalid utf-8 received.')\n  }\n})()\n\nmodule.exports = {\n  isConnecting,\n  isEstablished,\n  isClosing,\n  isClosed,\n  fireEvent,\n  isValidSubprotocol,\n  isValidStatusCode,\n  websocketMessageReceived,\n  utf8Decode,\n  isControlFrame,\n  isContinuationFrame,\n  isTextBinaryFrame,\n  isValidOpcode,\n  parseExtensions,\n  isValidClientWindowBits,\n  toArrayBuffer,\n  getURLRecord,\n  validateCloseCodeAndReason\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLCtFQUFhO0FBQ2pELFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDeEMsUUFBUSx5REFBeUQsRUFBRSxtQkFBTyxDQUFDLGdGQUFtQjs7QUFFOUY7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixXQUFXLHlEQUF5RDtBQUNwRSxXQUFXLHVCQUF1QjtBQUNsQyxhQUFhO0FBQ2I7QUFDQSx1R0FBdUc7QUFDdkc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRSxXQUFXLGtCQUFrQjtBQUMvRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsYUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi93ZWJzb2NrZXQvdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBzdGF0ZXMsIG9wY29kZXMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgaXNVdGY4IH0gPSByZXF1aXJlKCdub2RlOmJ1ZmZlcicpXG5jb25zdCB7IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0LCByZW1vdmVIVFRQV2hpdGVzcGFjZSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZGF0YS11cmwnKVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWFkeVN0YXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDb25uZWN0aW5nIChyZWFkeVN0YXRlKSB7XG4gIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBub3QgeWV0IGVzdGFibGlzaGVkLCBhbmQgdGhlIGNvbm5lY3Rpb25cbiAgLy8gaXMgbm90IHlldCBjbG9zZWQsIHRoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGluIHRoZSBDT05ORUNUSU5HIHN0YXRlLlxuICByZXR1cm4gcmVhZHlTdGF0ZSA9PT0gc3RhdGVzLkNPTk5FQ1RJTkdcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcmVhZHlTdGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRXN0YWJsaXNoZWQgKHJlYWR5U3RhdGUpIHtcbiAgLy8gSWYgdGhlIHNlcnZlcidzIHJlc3BvbnNlIGlzIHZhbGlkYXRlZCBhcyBwcm92aWRlZCBmb3IgYWJvdmUsIGl0IGlzXG4gIC8vIHNhaWQgdGhhdCBfVGhlIFdlYlNvY2tldCBDb25uZWN0aW9uIGlzIEVzdGFibGlzaGVkXyBhbmQgdGhhdCB0aGVcbiAgLy8gV2ViU29ja2V0IENvbm5lY3Rpb24gaXMgaW4gdGhlIE9QRU4gc3RhdGUuXG4gIHJldHVybiByZWFkeVN0YXRlID09PSBzdGF0ZXMuT1BFTlxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWFkeVN0YXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDbG9zaW5nIChyZWFkeVN0YXRlKSB7XG4gIC8vIFVwb24gZWl0aGVyIHNlbmRpbmcgb3IgcmVjZWl2aW5nIGEgQ2xvc2UgY29udHJvbCBmcmFtZSwgaXQgaXMgc2FpZFxuICAvLyB0aGF0IF9UaGUgV2ViU29ja2V0IENsb3NpbmcgSGFuZHNoYWtlIGlzIFN0YXJ0ZWRfIGFuZCB0aGF0IHRoZVxuICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ0xPU0lORyBzdGF0ZS5cbiAgcmV0dXJuIHJlYWR5U3RhdGUgPT09IHN0YXRlcy5DTE9TSU5HXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHJlYWR5U3RhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Nsb3NlZCAocmVhZHlTdGF0ZSkge1xuICByZXR1cm4gcmVhZHlTdGF0ZSA9PT0gc3RhdGVzLkNMT1NFRFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWV2ZW50LWZpcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7KC4uLmFyZ3M6IENvbnN0cnVjdG9yUGFyYW1ldGVyczx0eXBlb2YgRXZlbnQ+KSA9PiBFdmVudH0gZXZlbnRGYWN0b3J5XG4gKiBAcGFyYW0ge0V2ZW50SW5pdCB8IHVuZGVmaW5lZH0gZXZlbnRJbml0RGljdFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGZpcmVFdmVudCAoZSwgdGFyZ2V0LCBldmVudEZhY3RvcnkgPSAodHlwZSwgaW5pdCkgPT4gbmV3IEV2ZW50KHR5cGUsIGluaXQpLCBldmVudEluaXREaWN0ID0ge30pIHtcbiAgLy8gMS4gSWYgZXZlbnRDb25zdHJ1Y3RvciBpcyBub3QgZ2l2ZW4sIHRoZW4gbGV0IGV2ZW50Q29uc3RydWN0b3IgYmUgRXZlbnQuXG5cbiAgLy8gMi4gTGV0IGV2ZW50IGJlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW4gZXZlbnQgZ2l2ZW4gZXZlbnRDb25zdHJ1Y3RvcixcbiAgLy8gICAgaW4gdGhlIHJlbGV2YW50IHJlYWxtIG9mIHRhcmdldC5cbiAgLy8gMy4gSW5pdGlhbGl6ZSBldmVudOKAmXMgdHlwZSBhdHRyaWJ1dGUgdG8gZS5cbiAgY29uc3QgZXZlbnQgPSBldmVudEZhY3RvcnkoZSwgZXZlbnRJbml0RGljdClcblxuICAvLyA0LiBJbml0aWFsaXplIGFueSBvdGhlciBJREwgYXR0cmlidXRlcyBvZiBldmVudCBhcyBkZXNjcmliZWQgaW4gdGhlXG4gIC8vICAgIGludm9jYXRpb24gb2YgdGhpcyBhbGdvcml0aG0uXG5cbiAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgZGlzcGF0Y2hpbmcgZXZlbnQgYXQgdGFyZ2V0LCB3aXRoIGxlZ2FjeSB0YXJnZXRcbiAgLy8gICAgb3ZlcnJpZGUgZmxhZyBzZXQgaWYgc2V0LlxuICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2ZlZWRiYWNrLWZyb20tdGhlLXByb3RvY29sXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5IYW5kbGVyfSBoYW5kbGVyXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBPcGNvZGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIGFwcGxpY2F0aW9uIGRhdGFcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQgKGhhbmRsZXIsIHR5cGUsIGRhdGEpIHtcbiAgaGFuZGxlci5vbk1lc3NhZ2UodHlwZSwgZGF0YSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPT09IGJ1ZmZlci5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWZmZXIuYnVmZmVyXG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcikuYnVmZmVyXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTVcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMyNjE2XG4gKiBAc2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM5ODQwN1xuICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFN1YnByb3RvY29sIChwcm90b2NvbCkge1xuICAvLyBJZiBwcmVzZW50LCB0aGlzIHZhbHVlIGluZGljYXRlcyBvbmVcbiAgLy8gb3IgbW9yZSBjb21tYS1zZXBhcmF0ZWQgc3VicHJvdG9jb2wgdGhlIGNsaWVudCB3aXNoZXMgdG8gc3BlYWssXG4gIC8vIG9yZGVyZWQgYnkgcHJlZmVyZW5jZS4gIFRoZSBlbGVtZW50cyB0aGF0IGNvbXByaXNlIHRoaXMgdmFsdWVcbiAgLy8gTVVTVCBiZSBub24tZW1wdHkgc3RyaW5ncyB3aXRoIGNoYXJhY3RlcnMgaW4gdGhlIHJhbmdlIFUrMDAyMSB0b1xuICAvLyBVKzAwN0Ugbm90IGluY2x1ZGluZyBzZXBhcmF0b3IgY2hhcmFjdGVycyBhcyBkZWZpbmVkIGluXG4gIC8vIFtSRkMyNjE2XSBhbmQgTVVTVCBhbGwgYmUgdW5pcXVlIHN0cmluZ3MuXG4gIGlmIChwcm90b2NvbC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvdG9jb2wubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb2RlID0gcHJvdG9jb2wuY2hhckNvZGVBdChpKVxuXG4gICAgaWYgKFxuICAgICAgY29kZSA8IDB4MjEgfHwgLy8gQ1RMLCBjb250YWlucyBTUCAoMHgyMCkgYW5kIEhUICgweDA5KVxuICAgICAgY29kZSA+IDB4N0UgfHxcbiAgICAgIGNvZGUgPT09IDB4MjIgfHwgLy8gXCJcbiAgICAgIGNvZGUgPT09IDB4MjggfHwgLy8gKFxuICAgICAgY29kZSA9PT0gMHgyOSB8fCAvLyApXG4gICAgICBjb2RlID09PSAweDJDIHx8IC8vICxcbiAgICAgIGNvZGUgPT09IDB4MkYgfHwgLy8gL1xuICAgICAgY29kZSA9PT0gMHgzQSB8fCAvLyA6XG4gICAgICBjb2RlID09PSAweDNCIHx8IC8vIDtcbiAgICAgIGNvZGUgPT09IDB4M0MgfHwgLy8gPFxuICAgICAgY29kZSA9PT0gMHgzRCB8fCAvLyA9XG4gICAgICBjb2RlID09PSAweDNFIHx8IC8vID5cbiAgICAgIGNvZGUgPT09IDB4M0YgfHwgLy8gP1xuICAgICAgY29kZSA9PT0gMHg0MCB8fCAvLyBAXG4gICAgICBjb2RlID09PSAweDVCIHx8IC8vIFtcbiAgICAgIGNvZGUgPT09IDB4NUMgfHwgLy8gXFxcbiAgICAgIGNvZGUgPT09IDB4NUQgfHwgLy8gXVxuICAgICAgY29kZSA9PT0gMHg3QiB8fCAvLyB7XG4gICAgICBjb2RlID09PSAweDdEIC8vIH1cbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi03LTRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFN0YXR1c0NvZGUgKGNvZGUpIHtcbiAgaWYgKGNvZGUgPj0gMTAwMCAmJiBjb2RlIDwgMTAxNSkge1xuICAgIHJldHVybiAoXG4gICAgICBjb2RlICE9PSAxMDA0ICYmIC8vIHJlc2VydmVkXG4gICAgICBjb2RlICE9PSAxMDA1ICYmIC8vIFwiTVVTVCBOT1QgYmUgc2V0IGFzIGEgc3RhdHVzIGNvZGVcIlxuICAgICAgY29kZSAhPT0gMTAwNiAvLyBcIk1VU1QgTk9UIGJlIHNldCBhcyBhIHN0YXR1cyBjb2RlXCJcbiAgICApXG4gIH1cblxuICByZXR1cm4gY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNS41XG4gKiBAcGFyYW0ge251bWJlcn0gb3Bjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDb250cm9sRnJhbWUgKG9wY29kZSkge1xuICByZXR1cm4gKFxuICAgIG9wY29kZSA9PT0gb3Bjb2Rlcy5DTE9TRSB8fFxuICAgIG9wY29kZSA9PT0gb3Bjb2Rlcy5QSU5HIHx8XG4gICAgb3Bjb2RlID09PSBvcGNvZGVzLlBPTkdcbiAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcGNvZGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0NvbnRpbnVhdGlvbkZyYW1lIChvcGNvZGUpIHtcbiAgcmV0dXJuIG9wY29kZSA9PT0gb3Bjb2Rlcy5DT05USU5VQVRJT05cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb3Bjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNUZXh0QmluYXJ5RnJhbWUgKG9wY29kZSkge1xuICByZXR1cm4gb3Bjb2RlID09PSBvcGNvZGVzLlRFWFQgfHwgb3Bjb2RlID09PSBvcGNvZGVzLkJJTkFSWVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb3Bjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZE9wY29kZSAob3Bjb2RlKSB7XG4gIHJldHVybiBpc1RleHRCaW5hcnlGcmFtZShvcGNvZGUpIHx8IGlzQ29udGludWF0aW9uRnJhbWUob3Bjb2RlKSB8fCBpc0NvbnRyb2xGcmFtZShvcGNvZGUpXG59XG5cbi8qKlxuICogUGFyc2VzIGEgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlciB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBleHRlbnNpb25zXG4gKiBAcmV0dXJucyB7TWFwPHN0cmluZywgc3RyaW5nPn1cbiAqL1xuLy8gVE9ETyhAVXpsb3BhaywgQEtoYWZyYURldik6IG1ha2UgY29tcGxpYW50IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuZnVuY3Rpb24gcGFyc2VFeHRlbnNpb25zIChleHRlbnNpb25zKSB7XG4gIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG4gIGNvbnN0IGV4dGVuc2lvbkxpc3QgPSBuZXcgTWFwKClcblxuICB3aGlsZSAocG9zaXRpb24ucG9zaXRpb24gPCBleHRlbnNpb25zLmxlbmd0aCkge1xuICAgIGNvbnN0IHBhaXIgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCgnOycsIGV4dGVuc2lvbnMsIHBvc2l0aW9uKVxuICAgIGNvbnN0IFtuYW1lLCB2YWx1ZSA9ICcnXSA9IHBhaXIuc3BsaXQoJz0nLCAyKVxuXG4gICAgZXh0ZW5zaW9uTGlzdC5zZXQoXG4gICAgICByZW1vdmVIVFRQV2hpdGVzcGFjZShuYW1lLCB0cnVlLCBmYWxzZSksXG4gICAgICByZW1vdmVIVFRQV2hpdGVzcGFjZSh2YWx1ZSwgZmFsc2UsIHRydWUpXG4gICAgKVxuXG4gICAgcG9zaXRpb24ucG9zaXRpb24rK1xuICB9XG5cbiAgcmV0dXJuIGV4dGVuc2lvbkxpc3Rcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3NjkyI3NlY3Rpb24tNy4xLjIuMlxuICogQGRlc2NyaXB0aW9uIFwiY2xpZW50LW1heC13aW5kb3ctYml0cyA9IDEqRElHSVRcIlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENsaWVudFdpbmRvd0JpdHMgKHZhbHVlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBieXRlID0gdmFsdWUuY2hhckNvZGVBdChpKVxuXG4gICAgaWYgKGJ5dGUgPCAweDMwIHx8IGJ5dGUgPiAweDM5KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93aGF0cHIub3JnL3dlYnNvY2tldHMvNDgvN2I3NDhkMy4uLmQ1NTcwZjMuaHRtbCNnZXQtYS11cmwtcmVjb3JkXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gW2Jhc2VVUkxdXG4gKi9cbmZ1bmN0aW9uIGdldFVSTFJlY29yZCAodXJsLCBiYXNlVVJMKSB7XG4gIC8vIDEuIExldCB1cmxSZWNvcmQgYmUgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgVVJMIHBhcnNlciB0byB1cmwgd2l0aCBiYXNlVVJMIC5cbiAgLy8gMi4gSWYgdXJsUmVjb3JkIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBcIiBTeW50YXhFcnJvciBcIiBET01FeGNlcHRpb24gLlxuICBsZXQgdXJsUmVjb3JkXG5cbiAgdHJ5IHtcbiAgICB1cmxSZWNvcmQgPSBuZXcgVVJMKHVybCwgYmFzZVVSTClcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oZSwgJ1N5bnRheEVycm9yJylcbiAgfVxuXG4gIC8vIDMuIElmIHVybFJlY29yZCDigJlzIHNjaGVtZSBpcyBcIiBodHRwIFwiLCB0aGVuIHNldCB1cmxSZWNvcmQg4oCZcyBzY2hlbWUgdG8gXCIgd3MgXCIuXG4gIC8vIDQuIE90aGVyd2lzZSwgaWYgdXJsUmVjb3JkIOKAmXMgc2NoZW1lIGlzIFwiIGh0dHBzIFwiLCBzZXQgdXJsUmVjb3JkIOKAmXMgc2NoZW1lIHRvIFwiIHdzcyBcIi5cbiAgaWYgKHVybFJlY29yZC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgIHVybFJlY29yZC5wcm90b2NvbCA9ICd3czonXG4gIH0gZWxzZSBpZiAodXJsUmVjb3JkLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgIHVybFJlY29yZC5wcm90b2NvbCA9ICd3c3M6J1xuICB9XG5cbiAgLy8gNS4gSWYgdXJsUmVjb3JkIOKAmXMgc2NoZW1lIGlzIG5vdCBcIiB3cyBcIiBvciBcIiB3c3MgXCIsIHRoZW4gdGhyb3cgYSBcIiBTeW50YXhFcnJvciBcIiBET01FeGNlcHRpb24gLlxuICBpZiAodXJsUmVjb3JkLnByb3RvY29sICE9PSAnd3M6JyAmJiB1cmxSZWNvcmQucHJvdG9jb2wgIT09ICd3c3M6Jykge1xuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ2V4cGVjdGVkIGEgd3M6IG9yIHdzczogdXJsJywgJ1N5bnRheEVycm9yJylcbiAgfVxuXG4gIC8vIElmIHVybFJlY29yZCDigJlzIGZyYWdtZW50IGlzIG5vbi1udWxsLCB0aGVuIHRocm93IGEgXCIgU3ludGF4RXJyb3IgXCIgRE9NRXhjZXB0aW9uIC5cbiAgaWYgKHVybFJlY29yZC5oYXNoLmxlbmd0aCB8fCB1cmxSZWNvcmQuaHJlZi5lbmRzV2l0aCgnIycpKSB7XG4gICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignaGFzaCcsICdTeW50YXhFcnJvcicpXG4gIH1cblxuICAvLyBSZXR1cm4gdXJsUmVjb3JkIC5cbiAgcmV0dXJuIHVybFJlY29yZFxufVxuXG4vLyBodHRwczovL3doYXRwci5vcmcvd2Vic29ja2V0cy80OC5odG1sI3ZhbGlkYXRlLWNsb3NlLWNvZGUtYW5kLXJlYXNvblxuZnVuY3Rpb24gdmFsaWRhdGVDbG9zZUNvZGVBbmRSZWFzb24gKGNvZGUsIHJlYXNvbikge1xuICAvLyAxLiBJZiBjb2RlIGlzIG5vdCBudWxsLCBidXQgaXMgbmVpdGhlciBhbiBpbnRlZ2VyIGVxdWFsIHRvXG4gIC8vICAgIDEwMDAgbm9yIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIDMwMDAgdG8gNDk5OSwgaW5jbHVzaXZlLFxuICAvLyAgICB0aHJvdyBhbiBcIkludmFsaWRBY2Nlc3NFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgaWYgKGNvZGUgIT09IG51bGwpIHtcbiAgICBpZiAoY29kZSAhPT0gMTAwMCAmJiAoY29kZSA8IDMwMDAgfHwgY29kZSA+IDQ5OTkpKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdpbnZhbGlkIGNvZGUnLCAnSW52YWxpZEFjY2Vzc0Vycm9yJylcbiAgICB9XG4gIH1cblxuICAvLyAyLiBJZiByZWFzb24gaXMgbm90IG51bGwsIHRoZW46XG4gIGlmIChyZWFzb24gIT09IG51bGwpIHtcbiAgICAvLyAyLjEuIExldCByZWFzb25CeXRlcyBiZSB0aGUgcmVzdWx0IG9mIFVURi04IGVuY29kaW5nIHJlYXNvbi5cbiAgICAvLyAyLjIuIElmIHJlYXNvbkJ5dGVzIGlzIGxvbmdlciB0aGFuIDEyMyBieXRlcywgdGhlbiB0aHJvdyBhXG4gICAgLy8gICAgICBcIlN5bnRheEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgIGNvbnN0IHJlYXNvbkJ5dGVzTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgocmVhc29uKVxuXG4gICAgaWYgKHJlYXNvbkJ5dGVzTGVuZ3RoID4gMTIzKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGBSZWFzb24gbXVzdCBiZSBsZXNzIHRoYW4gMTIzIGJ5dGVzOyByZWNlaXZlZCAke3JlYXNvbkJ5dGVzTGVuZ3RofWAsICdTeW50YXhFcnJvcicpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBCdWZmZXIgdG8gdXRmLTgsIGV2ZW4gb24gcGxhdGZvcm1zIHdpdGhvdXQgaWN1LlxuICogQHR5cGUgeyhidWZmZXI6IEJ1ZmZlcikgPT4gc3RyaW5nfVxuICovXG5jb25zdCB1dGY4RGVjb2RlID0gKCgpID0+IHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLmljdSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBmYXRhbERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBmYXRhbDogdHJ1ZSB9KVxuICAgIHJldHVybiBmYXRhbERlY29kZXIuZGVjb2RlLmJpbmQoZmF0YWxEZWNvZGVyKVxuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgaWYgKGlzVXRmOChidWZmZXIpKSB7XG4gICAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCd1dGYtOCcpXG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdXRmLTggcmVjZWl2ZWQuJylcbiAgfVxufSkoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNDb25uZWN0aW5nLFxuICBpc0VzdGFibGlzaGVkLFxuICBpc0Nsb3NpbmcsXG4gIGlzQ2xvc2VkLFxuICBmaXJlRXZlbnQsXG4gIGlzVmFsaWRTdWJwcm90b2NvbCxcbiAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCxcbiAgdXRmOERlY29kZSxcbiAgaXNDb250cm9sRnJhbWUsXG4gIGlzQ29udGludWF0aW9uRnJhbWUsXG4gIGlzVGV4dEJpbmFyeUZyYW1lLFxuICBpc1ZhbGlkT3Bjb2RlLFxuICBwYXJzZUV4dGVuc2lvbnMsXG4gIGlzVmFsaWRDbGllbnRXaW5kb3dCaXRzLFxuICB0b0FycmF5QnVmZmVyLFxuICBnZXRVUkxSZWNvcmQsXG4gIHZhbGlkYXRlQ2xvc2VDb2RlQW5kUmVhc29uXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/websocket.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/websocket.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { webidl } = __webpack_require__(/*! ../webidl */ \"(rsc)/./node_modules/undici/lib/web/webidl/index.js\")\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { environmentSettingsObject } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { staticPropertyDescriptors, states, sentCloseFrameState, sendHints, opcodes } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst {\n  isConnecting,\n  isEstablished,\n  isClosing,\n  isValidSubprotocol,\n  fireEvent,\n  utf8Decode,\n  toArrayBuffer,\n  getURLRecord\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/websocket/util.js\")\nconst { establishWebSocketConnection, closeWebSocketConnection, failWebsocketConnection } = __webpack_require__(/*! ./connection */ \"(rsc)/./node_modules/undici/lib/web/websocket/connection.js\")\nconst { ByteParser } = __webpack_require__(/*! ./receiver */ \"(rsc)/./node_modules/undici/lib/web/websocket/receiver.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../../global */ \"(rsc)/./node_modules/undici/lib/global.js\")\nconst { types } = __webpack_require__(/*! node:util */ \"node:util\")\nconst { ErrorEvent, CloseEvent, createFastMessageEvent } = __webpack_require__(/*! ./events */ \"(rsc)/./node_modules/undici/lib/web/websocket/events.js\")\nconst { SendQueue } = __webpack_require__(/*! ./sender */ \"(rsc)/./node_modules/undici/lib/web/websocket/sender.js\")\nconst { channels } = __webpack_require__(/*! ../../core/diagnostics */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\n\n/**\n * @typedef {object} Handler\n * @property {(response: any, extensions?: string[]) => void} onConnectionEstablished\n * @property {(code: number, reason: any) => void} onFail\n * @property {(opcode: number, data: Buffer) => void} onMessage\n * @property {(error: Error) => void} onParserError\n * @property {() => void} onParserDrain\n * @property {(chunk: Buffer) => void} onSocketData\n * @property {(err: Error) => void} onSocketError\n * @property {() => void} onSocketClose\n *\n * @property {number} readyState\n * @property {import('stream').Duplex} socket\n * @property {Set<number>} closeState\n * @property {import('../fetch/index').Fetch} controller\n * @property {boolean} [wasEverConnected=false]\n */\n\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    close: null,\n    message: null\n  }\n\n  #bufferedAmount = 0\n  #protocol = ''\n  #extensions = ''\n\n  /** @type {SendQueue} */\n  #sendQueue\n\n  /** @type {Handler} */\n  #handler = {\n    onConnectionEstablished: (response, extensions) => this.#onConnectionEstablished(response, extensions),\n    onFail: (code, reason, cause) => this.#onFail(code, reason, cause),\n    onMessage: (opcode, data) => this.#onMessage(opcode, data),\n    onParserError: (err) => failWebsocketConnection(this.#handler, null, err.message),\n    onParserDrain: () => this.#onParserDrain(),\n    onSocketData: (chunk) => {\n      if (!this.#parser.write(chunk)) {\n        this.#handler.socket.pause()\n      }\n    },\n    onSocketError: (err) => {\n      this.#handler.readyState = states.CLOSING\n\n      if (channels.socketError.hasSubscribers) {\n        channels.socketError.publish(err)\n      }\n\n      this.#handler.socket.destroy()\n    },\n    onSocketClose: () => this.#onSocketClose(),\n\n    readyState: states.CONNECTING,\n    socket: null,\n    closeState: new Set(),\n    controller: null,\n    wasEverConnected: false\n  }\n\n  #url\n  #binaryType\n  /** @type {import('./receiver').ByteParser} */\n  #parser\n\n  /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */\n  constructor (url, protocols = []) {\n    super()\n\n    webidl.util.markAsUncloneable(this)\n\n    const prefix = 'WebSocket constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols, prefix, 'options')\n\n    url = webidl.converters.USVString(url)\n    protocols = options.protocols\n\n    // 1. Let baseURL be this's relevant settings object's API base URL.\n    const baseURL = environmentSettingsObject.settingsObject.baseUrl\n\n    // 2. Let urlRecord be the result of getting a URL record given url and baseURL.\n    const urlRecord = getURLRecord(url, baseURL)\n\n    // 3. If protocols is a string, set protocols to a sequence consisting\n    //    of just that string.\n    if (typeof protocols === 'string') {\n      protocols = [protocols]\n    }\n\n    // 4. If any of the values in protocols occur more than once or otherwise\n    //    fail to match the requirements for elements that comprise the value\n    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n    //    protocol, then throw a \"SyntaxError\" DOMException.\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    // 5. Set this's url to urlRecord.\n    this.#url = new URL(urlRecord.href)\n\n    // 6. Let client be this's relevant settings object.\n    const client = environmentSettingsObject.settingsObject\n\n    // 7. Run this step in parallel:\n    // 7.1. Establish a WebSocket connection given urlRecord, protocols,\n    //      and client.\n    this.#handler.controller = establishWebSocketConnection(\n      urlRecord,\n      protocols,\n      client,\n      this.#handler,\n      options\n    )\n\n    // Each WebSocket object has an associated ready state, which is a\n    // number representing the state of the connection. Initially it must\n    // be CONNECTING (0).\n    this.#handler.readyState = WebSocket.CONNECTING\n\n    // The extensions attribute must initially return the empty string.\n\n    // The protocol attribute must initially return the empty string.\n\n    // Each WebSocket object has an associated binary type, which is a\n    // BinaryType. Initially it must be \"blob\".\n    this.#binaryType = 'blob'\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */\n  close (code = undefined, reason = undefined) {\n    webidl.brandCheck(this, WebSocket)\n\n    const prefix = 'WebSocket.close'\n\n    if (code !== undefined) {\n      code = webidl.converters['unsigned short'](code, prefix, 'code', { clamp: true })\n    }\n\n    if (reason !== undefined) {\n      reason = webidl.converters.USVString(reason)\n    }\n\n    // 1. If code is the special value \"missing\", then set code to null.\n    code ??= null\n\n    // 2. If reason is the special value \"missing\", then set reason to the empty string.\n    reason ??= ''\n\n    // 3. Close the WebSocket with this, code, and reason.\n    closeWebSocketConnection(this.#handler, code, reason, true)\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */\n  send (data) {\n    webidl.brandCheck(this, WebSocket)\n\n    const prefix = 'WebSocket.send'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    data = webidl.converters.WebSocketSendData(data, prefix, 'data')\n\n    // 1. If this's ready state is CONNECTING, then throw an\n    //    \"InvalidStateError\" DOMException.\n    if (isConnecting(this.#handler.readyState)) {\n      throw new DOMException('Sent before connected.', 'InvalidStateError')\n    }\n\n    // 2. Run the appropriate set of steps from the following list:\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n\n    if (!isEstablished(this.#handler.readyState) || isClosing(this.#handler.readyState)) {\n      return\n    }\n\n    // If data is a string\n    if (typeof data === 'string') {\n      // If the WebSocket connection is established and the WebSocket\n      // closing handshake has not yet started, then the user agent\n      // must send a WebSocket Message comprised of the data argument\n      // using a text frame opcode; if the data cannot be sent, e.g.\n      // because it would need to be buffered but the buffer is full,\n      // the user agent must flag the WebSocket as full and then close\n      // the WebSocket connection. Any invocation of this method with a\n      // string argument that does not throw an exception must increase\n      // the bufferedAmount attribute by the number of bytes needed to\n      // express the argument as UTF-8.\n\n      const buffer = Buffer.from(data)\n\n      this.#bufferedAmount += buffer.byteLength\n      this.#sendQueue.add(buffer, () => {\n        this.#bufferedAmount -= buffer.byteLength\n      }, sendHints.text)\n    } else if (types.isArrayBuffer(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need\n      // to be buffered but the buffer is full, the user agent must flag\n      // the WebSocket as full and then close the WebSocket connection.\n      // The data to be sent is the data stored in the buffer described\n      // by the ArrayBuffer object. Any invocation of this method with an\n      // ArrayBuffer argument that does not throw an exception must\n      // increase the bufferedAmount attribute by the length of the\n      // ArrayBuffer in bytes.\n\n      this.#bufferedAmount += data.byteLength\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.byteLength\n      }, sendHints.arrayBuffer)\n    } else if (ArrayBuffer.isView(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The\n      // data to be sent is the data stored in the section of the buffer\n      // described by the ArrayBuffer object that data references. Any\n      // invocation of this method with this kind of argument that does\n      // not throw an exception must increase the bufferedAmount attribute\n      // by the length of datas buffer in bytes.\n\n      this.#bufferedAmount += data.byteLength\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.byteLength\n      }, sendHints.typedArray)\n    } else if (webidl.is.Blob(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The data\n      // to be sent is the raw data represented by the Blob object. Any\n      // invocation of this method with a Blob argument that does not throw\n      // an exception must increase the bufferedAmount attribute by the size\n      // of the Blob objects raw data, in bytes.\n\n      this.#bufferedAmount += data.size\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.size\n      }, sendHints.blob)\n    }\n  }\n\n  get readyState () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The readyState getter steps are to return this's ready state.\n    return this.#handler.readyState\n  }\n\n  get bufferedAmount () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#bufferedAmount\n  }\n\n  get url () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The url getter steps are to return this's url, serialized.\n    return URLSerializer(this.#url)\n  }\n\n  get extensions () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#extensions\n  }\n\n  get protocol () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#protocol\n  }\n\n  get onopen () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.open = fn\n      this.addEventListener('open', fn)\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onerror () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this.#events.error = null\n    }\n  }\n\n  get onclose () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.close\n  }\n\n  set onclose (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.close) {\n      this.removeEventListener('close', this.#events.close)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.close = fn\n      this.addEventListener('close', fn)\n    } else {\n      this.#events.close = null\n    }\n  }\n\n  get onmessage () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.message = fn\n      this.addEventListener('message', fn)\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get binaryType () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#binaryType\n  }\n\n  set binaryType (type) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (type !== 'blob' && type !== 'arraybuffer') {\n      this.#binaryType = 'blob'\n    } else {\n      this.#binaryType = type\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */\n  #onConnectionEstablished (response, parsedExtensions) {\n    // processResponse is called when the \"responses header list has been received and initialized.\"\n    // once this happens, the connection is open\n    this.#handler.socket = response.socket\n\n    const parser = new ByteParser(this.#handler, parsedExtensions)\n    parser.on('drain', () => this.#handler.onParserDrain())\n    parser.on('error', (err) => this.#handler.onParserError(err))\n\n    this.#parser = parser\n    this.#sendQueue = new SendQueue(response.socket)\n\n    // 1. Change the ready state to OPEN (1).\n    this.#handler.readyState = states.OPEN\n\n    // 2. Change the extensions attributes value to the extensions in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n    const extensions = response.headersList.get('sec-websocket-extensions')\n\n    if (extensions !== null) {\n      this.#extensions = extensions\n    }\n\n    // 3. Change the protocol attributes value to the subprotocol in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n    const protocol = response.headersList.get('sec-websocket-protocol')\n\n    if (protocol !== null) {\n      this.#protocol = protocol\n    }\n\n    // 4. Fire an event named open at the WebSocket object.\n    fireEvent('open', this)\n  }\n\n  #onFail (code, reason, cause) {\n    if (reason) {\n      // TODO: process.nextTick\n      fireEvent('error', this, (type, init) => new ErrorEvent(type, init), {\n        error: new Error(reason, cause ? { cause } : undefined),\n        message: reason\n      })\n    }\n\n    if (!this.#handler.wasEverConnected) {\n      this.#handler.readyState = states.CLOSED\n\n      // If the WebSocket connection could not be established, it is also said\n      // that _The WebSocket Connection is Closed_, but not _cleanly_.\n      fireEvent('close', this, (type, init) => new CloseEvent(type, init), {\n        wasClean: false, code, reason\n      })\n    }\n  }\n\n  #onMessage (type, data) {\n    // 1. If ready state is not OPEN (1), then return.\n    if (this.#handler.readyState !== states.OPEN) {\n      return\n    }\n\n    // 2. Let dataForEvent be determined by switching on type and binary type:\n    let dataForEvent\n\n    if (type === opcodes.TEXT) {\n      // -> type indicates that the data is Text\n      //      a new DOMString containing data\n      try {\n        dataForEvent = utf8Decode(data)\n      } catch {\n        failWebsocketConnection(this.#handler, 1007, 'Received invalid UTF-8 in text frame.')\n        return\n      }\n    } else if (type === opcodes.BINARY) {\n      if (this.#binaryType === 'blob') {\n        // -> type indicates that the data is Binary and binary type is \"blob\"\n        //      a new Blob object, created in the relevant Realm of the WebSocket\n        //      object, that represents data as its raw data\n        dataForEvent = new Blob([data])\n      } else {\n        // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n        //      a new ArrayBuffer object, created in the relevant Realm of the\n        //      WebSocket object, whose contents are data\n        dataForEvent = toArrayBuffer(data)\n      }\n    }\n\n    // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n    //    with the origin attribute initialized to the serialization of the WebSocket\n    //    objects url's origin, and the data attribute initialized to dataForEvent.\n    fireEvent('message', this, createFastMessageEvent, {\n      origin: this.#url.origin,\n      data: dataForEvent\n    })\n  }\n\n  #onParserDrain () {\n    this.#handler.socket.resume()\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n   */\n  #onSocketClose () {\n    // If the TCP connection was closed after the\n    // WebSocket closing handshake was completed, the WebSocket connection\n    // is said to have been closed _cleanly_.\n    const wasClean =\n      this.#handler.closeState.has(sentCloseFrameState.SENT) &&\n      this.#handler.closeState.has(sentCloseFrameState.RECEIVED)\n\n    let code = 1005\n    let reason = ''\n\n    const result = this.#parser.closingInfo\n\n    if (result && !result.error) {\n      code = result.code ?? 1005\n      reason = result.reason\n    } else if (!this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {\n      // If _The WebSocket\n      // Connection is Closed_ and no Close control frame was received by the\n      // endpoint (such as could occur if the underlying transport connection\n      // is lost), _The WebSocket Connection Close Code_ is considered to be\n      // 1006.\n      code = 1006\n    }\n\n    // 1. Change the ready state to CLOSED (3).\n    this.#handler.readyState = states.CLOSED\n\n    // 2. If the user agent was required to fail the WebSocket\n    //    connection, or if the WebSocket connection was closed\n    //    after being flagged as full, fire an event named error\n    //    at the WebSocket object.\n    // TODO\n\n    // 3. Fire an event named close at the WebSocket object,\n    //    using CloseEvent, with the wasClean attribute\n    //    initialized to true if the connection closed cleanly\n    //    and false otherwise, the code attribute initialized to\n    //    the WebSocket connection close code, and the reason\n    //    attribute initialized to the result of applying UTF-8\n    //    decode without BOM to the WebSocket connection close\n    //    reason.\n    // TODO: process.nextTick\n    fireEvent('close', this, (type, init) => new CloseEvent(type, init), {\n      wasClean, code, reason\n    })\n\n    if (channels.close.hasSubscribers) {\n      channels.close.publish({\n        websocket: this,\n        code,\n        reason\n      })\n    }\n  }\n}\n\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED\n\nObject.defineProperties(WebSocket.prototype, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors,\n  url: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  bufferedAmount: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onclose: kEnumerableProperty,\n  close: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  binaryType: kEnumerableProperty,\n  send: kEnumerableProperty,\n  extensions: kEnumerableProperty,\n  protocol: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocket',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nObject.defineProperties(WebSocket, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors\n})\n\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(\n  webidl.converters.DOMString\n)\n\nwebidl.converters['DOMString or sequence<DOMString>'] = function (V, prefix, argument) {\n  if (webidl.util.Type(V) === webidl.util.Types.OBJECT && Symbol.iterator in V) {\n    return webidl.converters['sequence<DOMString>'](V)\n  }\n\n  return webidl.converters.DOMString(V, prefix, argument)\n}\n\n// This implements the proposal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([\n  {\n    key: 'protocols',\n    converter: webidl.converters['DOMString or sequence<DOMString>'],\n    defaultValue: () => new Array(0)\n  },\n  {\n    key: 'dispatcher',\n    converter: webidl.converters.any,\n    defaultValue: () => getGlobalDispatcher()\n  },\n  {\n    key: 'headers',\n    converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n  }\n])\n\nwebidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {\n  if (webidl.util.Type(V) === webidl.util.Types.OBJECT && !(Symbol.iterator in V)) {\n    return webidl.converters.WebSocketInit(V)\n  }\n\n  return { protocols: webidl.converters['DOMString or sequence<DOMString>'](V) }\n}\n\nwebidl.converters.WebSocketSendData = function (V) {\n  if (webidl.util.Type(V) === webidl.util.Types.OBJECT) {\n    if (webidl.is.Blob(V)) {\n      return V\n    }\n\n    if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {\n      return V\n    }\n  }\n\n  return webidl.converters.USVString(V)\n}\n\nmodule.exports = {\n  WebSocket\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNFQUFXO0FBQ3RDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDckQsUUFBUSw0QkFBNEIsRUFBRSxtQkFBTyxDQUFDLHdFQUFlO0FBQzdELFFBQVEsNkVBQTZFLEVBQUUsbUJBQU8sQ0FBQywrRUFBYTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxxRUFBUTtBQUNwQixRQUFRLGtGQUFrRixFQUFFLG1CQUFPLENBQUMsaUZBQWM7QUFDbEgsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyw2RUFBWTtBQUMzQyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQ3pELFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQywrREFBYztBQUN0RCxRQUFRLFFBQVEsRUFBRSxtQkFBTyxDQUFDLDRCQUFXO0FBQ3JDLFFBQVEsaURBQWlELEVBQUUsbUJBQU8sQ0FBQyx5RUFBVTtBQUM3RSxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLHlFQUFVO0FBQ3hDLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsbUZBQXdCOztBQUVyRDtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGdEQUFnRDtBQUM5RCxjQUFjLHFDQUFxQztBQUNuRCxjQUFjLHdDQUF3QztBQUN0RCxjQUFjLHdCQUF3QjtBQUN0QyxjQUFjLFlBQVk7QUFDMUIsY0FBYyx5QkFBeUI7QUFDdkMsY0FBYyxzQkFBc0I7QUFDcEMsY0FBYyxZQUFZO0FBQzFCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMseUJBQXlCO0FBQ3ZDLGNBQWMsYUFBYTtBQUMzQixjQUFjLGdDQUFnQztBQUM5QyxjQUFjLFNBQVM7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxXQUFXO0FBQ3hCOztBQUVBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUNBQWlDO0FBQzlDOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUVBQXlFLGFBQWE7QUFDdEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsMkNBQTJDO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9mbGl4aHViL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi93ZWJzb2NrZXQvd2Vic29ja2V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vd2ViaWRsJylcbmNvbnN0IHsgVVJMU2VyaWFsaXplciB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZGF0YS11cmwnKVxuY29uc3QgeyBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC91dGlsJylcbmNvbnN0IHsgc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycywgc3RhdGVzLCBzZW50Q2xvc2VGcmFtZVN0YXRlLCBzZW5kSGludHMsIG9wY29kZXMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHtcbiAgaXNDb25uZWN0aW5nLFxuICBpc0VzdGFibGlzaGVkLFxuICBpc0Nsb3NpbmcsXG4gIGlzVmFsaWRTdWJwcm90b2NvbCxcbiAgZmlyZUV2ZW50LFxuICB1dGY4RGVjb2RlLFxuICB0b0FycmF5QnVmZmVyLFxuICBnZXRVUkxSZWNvcmRcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uLCBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24sIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uIH0gPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKVxuY29uc3QgeyBCeXRlUGFyc2VyIH0gPSByZXF1aXJlKCcuL3JlY2VpdmVyJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgZ2V0R2xvYmFsRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi4vLi4vZ2xvYmFsJylcbmNvbnN0IHsgdHlwZXMgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCB7IEVycm9yRXZlbnQsIENsb3NlRXZlbnQsIGNyZWF0ZUZhc3RNZXNzYWdlRXZlbnQgfSA9IHJlcXVpcmUoJy4vZXZlbnRzJylcbmNvbnN0IHsgU2VuZFF1ZXVlIH0gPSByZXF1aXJlKCcuL3NlbmRlcicpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RpYWdub3N0aWNzJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBIYW5kbGVyXG4gKiBAcHJvcGVydHkgeyhyZXNwb25zZTogYW55LCBleHRlbnNpb25zPzogc3RyaW5nW10pID0+IHZvaWR9IG9uQ29ubmVjdGlvbkVzdGFibGlzaGVkXG4gKiBAcHJvcGVydHkgeyhjb2RlOiBudW1iZXIsIHJlYXNvbjogYW55KSA9PiB2b2lkfSBvbkZhaWxcbiAqIEBwcm9wZXJ0eSB7KG9wY29kZTogbnVtYmVyLCBkYXRhOiBCdWZmZXIpID0+IHZvaWR9IG9uTWVzc2FnZVxuICogQHByb3BlcnR5IHsoZXJyb3I6IEVycm9yKSA9PiB2b2lkfSBvblBhcnNlckVycm9yXG4gKiBAcHJvcGVydHkgeygpID0+IHZvaWR9IG9uUGFyc2VyRHJhaW5cbiAqIEBwcm9wZXJ0eSB7KGNodW5rOiBCdWZmZXIpID0+IHZvaWR9IG9uU29ja2V0RGF0YVxuICogQHByb3BlcnR5IHsoZXJyOiBFcnJvcikgPT4gdm9pZH0gb25Tb2NrZXRFcnJvclxuICogQHByb3BlcnR5IHsoKSA9PiB2b2lkfSBvblNvY2tldENsb3NlXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlYWR5U3RhdGVcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdHJlYW0nKS5EdXBsZXh9IHNvY2tldFxuICogQHByb3BlcnR5IHtTZXQ8bnVtYmVyPn0gY2xvc2VTdGF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoJy4uL2ZldGNoL2luZGV4JykuRmV0Y2h9IGNvbnRyb2xsZXJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dhc0V2ZXJDb25uZWN0ZWQ9ZmFsc2VdXG4gKi9cblxuLy8gaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jaW50ZXJmYWNlLWRlZmluaXRpb25cbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgI2V2ZW50cyA9IHtcbiAgICBvcGVuOiBudWxsLFxuICAgIGVycm9yOiBudWxsLFxuICAgIGNsb3NlOiBudWxsLFxuICAgIG1lc3NhZ2U6IG51bGxcbiAgfVxuXG4gICNidWZmZXJlZEFtb3VudCA9IDBcbiAgI3Byb3RvY29sID0gJydcbiAgI2V4dGVuc2lvbnMgPSAnJ1xuXG4gIC8qKiBAdHlwZSB7U2VuZFF1ZXVlfSAqL1xuICAjc2VuZFF1ZXVlXG5cbiAgLyoqIEB0eXBlIHtIYW5kbGVyfSAqL1xuICAjaGFuZGxlciA9IHtcbiAgICBvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZDogKHJlc3BvbnNlLCBleHRlbnNpb25zKSA9PiB0aGlzLiNvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZChyZXNwb25zZSwgZXh0ZW5zaW9ucyksXG4gICAgb25GYWlsOiAoY29kZSwgcmVhc29uLCBjYXVzZSkgPT4gdGhpcy4jb25GYWlsKGNvZGUsIHJlYXNvbiwgY2F1c2UpLFxuICAgIG9uTWVzc2FnZTogKG9wY29kZSwgZGF0YSkgPT4gdGhpcy4jb25NZXNzYWdlKG9wY29kZSwgZGF0YSksXG4gICAgb25QYXJzZXJFcnJvcjogKGVycikgPT4gZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy4jaGFuZGxlciwgbnVsbCwgZXJyLm1lc3NhZ2UpLFxuICAgIG9uUGFyc2VyRHJhaW46ICgpID0+IHRoaXMuI29uUGFyc2VyRHJhaW4oKSxcbiAgICBvblNvY2tldERhdGE6IChjaHVuaykgPT4ge1xuICAgICAgaWYgKCF0aGlzLiNwYXJzZXIud3JpdGUoY2h1bmspKSB7XG4gICAgICAgIHRoaXMuI2hhbmRsZXIuc29ja2V0LnBhdXNlKClcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uU29ja2V0RXJyb3I6IChlcnIpID0+IHtcbiAgICAgIHRoaXMuI2hhbmRsZXIucmVhZHlTdGF0ZSA9IHN0YXRlcy5DTE9TSU5HXG5cbiAgICAgIGlmIChjaGFubmVscy5zb2NrZXRFcnJvci5oYXNTdWJzY3JpYmVycykge1xuICAgICAgICBjaGFubmVscy5zb2NrZXRFcnJvci5wdWJsaXNoKGVycilcbiAgICAgIH1cblxuICAgICAgdGhpcy4jaGFuZGxlci5zb2NrZXQuZGVzdHJveSgpXG4gICAgfSxcbiAgICBvblNvY2tldENsb3NlOiAoKSA9PiB0aGlzLiNvblNvY2tldENsb3NlKCksXG5cbiAgICByZWFkeVN0YXRlOiBzdGF0ZXMuQ09OTkVDVElORyxcbiAgICBzb2NrZXQ6IG51bGwsXG4gICAgY2xvc2VTdGF0ZTogbmV3IFNldCgpLFxuICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgd2FzRXZlckNvbm5lY3RlZDogZmFsc2VcbiAgfVxuXG4gICN1cmxcbiAgI2JpbmFyeVR5cGVcbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vcmVjZWl2ZXInKS5CeXRlUGFyc2VyfSAqL1xuICAjcGFyc2VyXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHByb3RvY29sc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHVybCwgcHJvdG9jb2xzID0gW10pIHtcbiAgICBzdXBlcigpXG5cbiAgICB3ZWJpZGwudXRpbC5tYXJrQXNVbmNsb25lYWJsZSh0aGlzKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ1dlYlNvY2tldCBjb25zdHJ1Y3RvcidcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4gb3IgV2ViU29ja2V0SW5pdCddKHByb3RvY29scywgcHJlZml4LCAnb3B0aW9ucycpXG5cbiAgICB1cmwgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodXJsKVxuICAgIHByb3RvY29scyA9IG9wdGlvbnMucHJvdG9jb2xzXG5cbiAgICAvLyAxLiBMZXQgYmFzZVVSTCBiZSB0aGlzJ3MgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN0J3MgQVBJIGJhc2UgVVJMLlxuICAgIGNvbnN0IGJhc2VVUkwgPSBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0LnNldHRpbmdzT2JqZWN0LmJhc2VVcmxcblxuICAgIC8vIDIuIExldCB1cmxSZWNvcmQgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIGEgVVJMIHJlY29yZCBnaXZlbiB1cmwgYW5kIGJhc2VVUkwuXG4gICAgY29uc3QgdXJsUmVjb3JkID0gZ2V0VVJMUmVjb3JkKHVybCwgYmFzZVVSTClcblxuICAgIC8vIDMuIElmIHByb3RvY29scyBpcyBhIHN0cmluZywgc2V0IHByb3RvY29scyB0byBhIHNlcXVlbmNlIGNvbnNpc3RpbmdcbiAgICAvLyAgICBvZiBqdXN0IHRoYXQgc3RyaW5nLlxuICAgIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnc3RyaW5nJykge1xuICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc11cbiAgICB9XG5cbiAgICAvLyA0LiBJZiBhbnkgb2YgdGhlIHZhbHVlcyBpbiBwcm90b2NvbHMgb2NjdXIgbW9yZSB0aGFuIG9uY2Ugb3Igb3RoZXJ3aXNlXG4gICAgLy8gICAgZmFpbCB0byBtYXRjaCB0aGUgcmVxdWlyZW1lbnRzIGZvciBlbGVtZW50cyB0aGF0IGNvbXByaXNlIHRoZSB2YWx1ZVxuICAgIC8vICAgIG9mIGBTZWMtV2ViU29ja2V0LVByb3RvY29sYCBmaWVsZHMgYXMgZGVmaW5lZCBieSBUaGUgV2ViU29ja2V0XG4gICAgLy8gICAgcHJvdG9jb2wsIHRoZW4gdGhyb3cgYSBcIlN5bnRheEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgIGlmIChwcm90b2NvbHMubGVuZ3RoICE9PSBuZXcgU2V0KHByb3RvY29scy5tYXAocCA9PiBwLnRvTG93ZXJDYXNlKCkpKS5zaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtUHJvdG9jb2wgdmFsdWUnLCAnU3ludGF4RXJyb3InKVxuICAgIH1cblxuICAgIGlmIChwcm90b2NvbHMubGVuZ3RoID4gMCAmJiAhcHJvdG9jb2xzLmV2ZXJ5KHAgPT4gaXNWYWxpZFN1YnByb3RvY29sKHApKSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIHZhbHVlJywgJ1N5bnRheEVycm9yJylcbiAgICB9XG5cbiAgICAvLyA1LiBTZXQgdGhpcydzIHVybCB0byB1cmxSZWNvcmQuXG4gICAgdGhpcy4jdXJsID0gbmV3IFVSTCh1cmxSZWNvcmQuaHJlZilcblxuICAgIC8vIDYuIExldCBjbGllbnQgYmUgdGhpcydzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdC5cbiAgICBjb25zdCBjbGllbnQgPSBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0LnNldHRpbmdzT2JqZWN0XG5cbiAgICAvLyA3LiBSdW4gdGhpcyBzdGVwIGluIHBhcmFsbGVsOlxuICAgIC8vIDcuMS4gRXN0YWJsaXNoIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24gZ2l2ZW4gdXJsUmVjb3JkLCBwcm90b2NvbHMsXG4gICAgLy8gICAgICBhbmQgY2xpZW50LlxuICAgIHRoaXMuI2hhbmRsZXIuY29udHJvbGxlciA9IGVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24oXG4gICAgICB1cmxSZWNvcmQsXG4gICAgICBwcm90b2NvbHMsXG4gICAgICBjbGllbnQsXG4gICAgICB0aGlzLiNoYW5kbGVyLFxuICAgICAgb3B0aW9uc1xuICAgIClcblxuICAgIC8vIEVhY2ggV2ViU29ja2V0IG9iamVjdCBoYXMgYW4gYXNzb2NpYXRlZCByZWFkeSBzdGF0ZSwgd2hpY2ggaXMgYVxuICAgIC8vIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoZSBjb25uZWN0aW9uLiBJbml0aWFsbHkgaXQgbXVzdFxuICAgIC8vIGJlIENPTk5FQ1RJTkcgKDApLlxuICAgIHRoaXMuI2hhbmRsZXIucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DT05ORUNUSU5HXG5cbiAgICAvLyBUaGUgZXh0ZW5zaW9ucyBhdHRyaWJ1dGUgbXVzdCBpbml0aWFsbHkgcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG5cbiAgICAvLyBUaGUgcHJvdG9jb2wgYXR0cmlidXRlIG11c3QgaW5pdGlhbGx5IHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuXG4gICAgLy8gRWFjaCBXZWJTb2NrZXQgb2JqZWN0IGhhcyBhbiBhc3NvY2lhdGVkIGJpbmFyeSB0eXBlLCB3aGljaCBpcyBhXG4gICAgLy8gQmluYXJ5VHlwZS4gSW5pdGlhbGx5IGl0IG11c3QgYmUgXCJibG9iXCIuXG4gICAgdGhpcy4jYmluYXJ5VHlwZSA9ICdibG9iJ1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1jbG9zZVxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSByZWFzb25cbiAgICovXG4gIGNsb3NlIChjb2RlID0gdW5kZWZpbmVkLCByZWFzb24gPSB1bmRlZmluZWQpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnV2ViU29ja2V0LmNsb3NlJ1xuXG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29kZSA9IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddKGNvZGUsIHByZWZpeCwgJ2NvZGUnLCB7IGNsYW1wOiB0cnVlIH0pXG4gICAgfVxuXG4gICAgaWYgKHJlYXNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZWFzb24gPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcocmVhc29uKVxuICAgIH1cblxuICAgIC8vIDEuIElmIGNvZGUgaXMgdGhlIHNwZWNpYWwgdmFsdWUgXCJtaXNzaW5nXCIsIHRoZW4gc2V0IGNvZGUgdG8gbnVsbC5cbiAgICBjb2RlID8/PSBudWxsXG5cbiAgICAvLyAyLiBJZiByZWFzb24gaXMgdGhlIHNwZWNpYWwgdmFsdWUgXCJtaXNzaW5nXCIsIHRoZW4gc2V0IHJlYXNvbiB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIHJlYXNvbiA/Pz0gJydcblxuICAgIC8vIDMuIENsb3NlIHRoZSBXZWJTb2NrZXQgd2l0aCB0aGlzLCBjb2RlLCBhbmQgcmVhc29uLlxuICAgIGNsb3NlV2ViU29ja2V0Q29ubmVjdGlvbih0aGlzLiNoYW5kbGVyLCBjb2RlLCByZWFzb24sIHRydWUpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LXNlbmRcbiAgICogQHBhcmFtIHtOb2RlSlMuVHlwZWRBcnJheXxBcnJheUJ1ZmZlcnxCbG9ifHN0cmluZ30gZGF0YVxuICAgKi9cbiAgc2VuZCAoZGF0YSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGNvbnN0IHByZWZpeCA9ICdXZWJTb2NrZXQuc2VuZCdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIGRhdGEgPSB3ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRTZW5kRGF0YShkYXRhLCBwcmVmaXgsICdkYXRhJylcblxuICAgIC8vIDEuIElmIHRoaXMncyByZWFkeSBzdGF0ZSBpcyBDT05ORUNUSU5HLCB0aGVuIHRocm93IGFuXG4gICAgLy8gICAgXCJJbnZhbGlkU3RhdGVFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICBpZiAoaXNDb25uZWN0aW5nKHRoaXMuI2hhbmRsZXIucmVhZHlTdGF0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1NlbnQgYmVmb3JlIGNvbm5lY3RlZC4nLCAnSW52YWxpZFN0YXRlRXJyb3InKVxuICAgIH1cblxuICAgIC8vIDIuIFJ1biB0aGUgYXBwcm9wcmlhdGUgc2V0IG9mIHN0ZXBzIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0OlxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTYuMVxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTUuMlxuXG4gICAgaWYgKCFpc0VzdGFibGlzaGVkKHRoaXMuI2hhbmRsZXIucmVhZHlTdGF0ZSkgfHwgaXNDbG9zaW5nKHRoaXMuI2hhbmRsZXIucmVhZHlTdGF0ZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIGRhdGEgaXMgYSBzdHJpbmdcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnRcbiAgICAgIC8vIG11c3Qgc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiB0aGUgZGF0YSBhcmd1bWVudFxuICAgICAgLy8gdXNpbmcgYSB0ZXh0IGZyYW1lIG9wY29kZTsgaWYgdGhlIGRhdGEgY2Fubm90IGJlIHNlbnQsIGUuZy5cbiAgICAgIC8vIGJlY2F1c2UgaXQgd291bGQgbmVlZCB0byBiZSBidWZmZXJlZCBidXQgdGhlIGJ1ZmZlciBpcyBmdWxsLFxuICAgICAgLy8gdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnIHRoZSBXZWJTb2NrZXQgYXMgZnVsbCBhbmQgdGhlbiBjbG9zZVxuICAgICAgLy8gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLiBBbnkgaW52b2NhdGlvbiBvZiB0aGlzIG1ldGhvZCB3aXRoIGFcbiAgICAgIC8vIHN0cmluZyBhcmd1bWVudCB0aGF0IGRvZXMgbm90IHRocm93IGFuIGV4Y2VwdGlvbiBtdXN0IGluY3JlYXNlXG4gICAgICAvLyB0aGUgYnVmZmVyZWRBbW91bnQgYXR0cmlidXRlIGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXMgbmVlZGVkIHRvXG4gICAgICAvLyBleHByZXNzIHRoZSBhcmd1bWVudCBhcyBVVEYtOC5cblxuICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSlcblxuICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgKz0gYnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgIHRoaXMuI3NlbmRRdWV1ZS5hZGQoYnVmZmVyLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50IC09IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICB9LCBzZW5kSGludHMudGV4dClcbiAgICB9IGVsc2UgaWYgKHR5cGVzLmlzQXJyYXlCdWZmZXIoZGF0YSkpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnQgbXVzdFxuICAgICAgLy8gc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiBkYXRhIHVzaW5nIGEgYmluYXJ5IGZyYW1lXG4gICAgICAvLyBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuIGJlY2F1c2UgaXQgd291bGQgbmVlZFxuICAgICAgLy8gdG8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCwgdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnXG4gICAgICAvLyB0aGUgV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgLy8gVGhlIGRhdGEgdG8gYmUgc2VudCBpcyB0aGUgZGF0YSBzdG9yZWQgaW4gdGhlIGJ1ZmZlciBkZXNjcmliZWRcbiAgICAgIC8vIGJ5IHRoZSBBcnJheUJ1ZmZlciBvYmplY3QuIEFueSBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kIHdpdGggYW5cbiAgICAgIC8vIEFycmF5QnVmZmVyIGFyZ3VtZW50IHRoYXQgZG9lcyBub3QgdGhyb3cgYW4gZXhjZXB0aW9uIG11c3RcbiAgICAgIC8vIGluY3JlYXNlIHRoZSBidWZmZXJlZEFtb3VudCBhdHRyaWJ1dGUgYnkgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICAgIC8vIEFycmF5QnVmZmVyIGluIGJ5dGVzLlxuXG4gICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCArPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICAgIHRoaXMuI3NlbmRRdWV1ZS5hZGQoZGF0YSwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCAtPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICAgIH0sIHNlbmRIaW50cy5hcnJheUJ1ZmZlcilcbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCBhbmQgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gY2xvc2luZyBoYW5kc2hha2UgaGFzIG5vdCB5ZXQgc3RhcnRlZCwgdGhlbiB0aGUgdXNlciBhZ2VudCBtdXN0XG4gICAgICAvLyBzZW5kIGEgV2ViU29ja2V0IE1lc3NhZ2UgY29tcHJpc2VkIG9mIGRhdGEgdXNpbmcgYSBiaW5hcnkgZnJhbWVcbiAgICAgIC8vIG9wY29kZTsgaWYgdGhlIGRhdGEgY2Fubm90IGJlIHNlbnQsIGUuZy4gYmVjYXVzZSBpdCB3b3VsZCBuZWVkIHRvXG4gICAgICAvLyBiZSBidWZmZXJlZCBidXQgdGhlIGJ1ZmZlciBpcyBmdWxsLCB0aGUgdXNlciBhZ2VudCBtdXN0IGZsYWcgdGhlXG4gICAgICAvLyBXZWJTb2NrZXQgYXMgZnVsbCBhbmQgdGhlbiBjbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uIFRoZVxuICAgICAgLy8gZGF0YSB0byBiZSBzZW50IGlzIHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgc2VjdGlvbiBvZiB0aGUgYnVmZmVyXG4gICAgICAvLyBkZXNjcmliZWQgYnkgdGhlIEFycmF5QnVmZmVyIG9iamVjdCB0aGF0IGRhdGEgcmVmZXJlbmNlcy4gQW55XG4gICAgICAvLyBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kIHdpdGggdGhpcyBraW5kIG9mIGFyZ3VtZW50IHRoYXQgZG9lc1xuICAgICAgLy8gbm90IHRocm93IGFuIGV4Y2VwdGlvbiBtdXN0IGluY3JlYXNlIHRoZSBidWZmZXJlZEFtb3VudCBhdHRyaWJ1dGVcbiAgICAgIC8vIGJ5IHRoZSBsZW5ndGggb2YgZGF0YeKAmXMgYnVmZmVyIGluIGJ5dGVzLlxuXG4gICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCArPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICAgIHRoaXMuI3NlbmRRdWV1ZS5hZGQoZGF0YSwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCAtPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICAgIH0sIHNlbmRIaW50cy50eXBlZEFycmF5KVxuICAgIH0gZWxzZSBpZiAod2ViaWRsLmlzLkJsb2IoZGF0YSkpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnQgbXVzdFxuICAgICAgLy8gc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiBkYXRhIHVzaW5nIGEgYmluYXJ5IGZyYW1lXG4gICAgICAvLyBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuIGJlY2F1c2UgaXQgd291bGQgbmVlZCB0b1xuICAgICAgLy8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCwgdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnIHRoZVxuICAgICAgLy8gV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLiBUaGUgZGF0YVxuICAgICAgLy8gdG8gYmUgc2VudCBpcyB0aGUgcmF3IGRhdGEgcmVwcmVzZW50ZWQgYnkgdGhlIEJsb2Igb2JqZWN0LiBBbnlcbiAgICAgIC8vIGludm9jYXRpb24gb2YgdGhpcyBtZXRob2Qgd2l0aCBhIEJsb2IgYXJndW1lbnQgdGhhdCBkb2VzIG5vdCB0aHJvd1xuICAgICAgLy8gYW4gZXhjZXB0aW9uIG11c3QgaW5jcmVhc2UgdGhlIGJ1ZmZlcmVkQW1vdW50IGF0dHJpYnV0ZSBieSB0aGUgc2l6ZVxuICAgICAgLy8gb2YgdGhlIEJsb2Igb2JqZWN04oCZcyByYXcgZGF0YSwgaW4gYnl0ZXMuXG5cbiAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50ICs9IGRhdGEuc2l6ZVxuICAgICAgdGhpcy4jc2VuZFF1ZXVlLmFkZChkYXRhLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50IC09IGRhdGEuc2l6ZVxuICAgICAgfSwgc2VuZEhpbnRzLmJsb2IpXG4gICAgfVxuICB9XG5cbiAgZ2V0IHJlYWR5U3RhdGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIC8vIFRoZSByZWFkeVN0YXRlIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXMncyByZWFkeSBzdGF0ZS5cbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5yZWFkeVN0YXRlXG4gIH1cblxuICBnZXQgYnVmZmVyZWRBbW91bnQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNidWZmZXJlZEFtb3VudFxuICB9XG5cbiAgZ2V0IHVybCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgLy8gVGhlIHVybCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlzJ3MgdXJsLCBzZXJpYWxpemVkLlxuICAgIHJldHVybiBVUkxTZXJpYWxpemVyKHRoaXMuI3VybClcbiAgfVxuXG4gIGdldCBleHRlbnNpb25zICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXh0ZW5zaW9uc1xuICB9XG5cbiAgZ2V0IHByb3RvY29sICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jcHJvdG9jb2xcbiAgfVxuXG4gIGdldCBvbm9wZW4gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNldmVudHMub3BlblxuICB9XG5cbiAgc2V0IG9ub3BlbiAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodGhpcy4jZXZlbnRzLm9wZW4pIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIHRoaXMuI2V2ZW50cy5vcGVuKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5vcGVuID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMub3BlbiA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25lcnJvciAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5lcnJvclxuICB9XG5cbiAgc2V0IG9uZXJyb3IgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKHRoaXMuI2V2ZW50cy5lcnJvcikge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuI2V2ZW50cy5lcnJvcilcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMuZXJyb3IgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMuZXJyb3IgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9uY2xvc2UgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNldmVudHMuY2xvc2VcbiAgfVxuXG4gIHNldCBvbmNsb3NlIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGlmICh0aGlzLiNldmVudHMuY2xvc2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xvc2UnLCB0aGlzLiNldmVudHMuY2xvc2UpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLmNsb3NlID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLmNsb3NlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbm1lc3NhZ2UgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNldmVudHMubWVzc2FnZVxuICB9XG5cbiAgc2V0IG9ubWVzc2FnZSAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodGhpcy4jZXZlbnRzLm1lc3NhZ2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuI2V2ZW50cy5tZXNzYWdlKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5tZXNzYWdlID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMubWVzc2FnZSA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgYmluYXJ5VHlwZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2JpbmFyeVR5cGVcbiAgfVxuXG4gIHNldCBiaW5hcnlUeXBlICh0eXBlKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKHR5cGUgIT09ICdibG9iJyAmJiB0eXBlICE9PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICB0aGlzLiNiaW5hcnlUeXBlID0gJ2Jsb2InXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2JpbmFyeVR5cGUgPSB0eXBlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZmVlZGJhY2stZnJvbS10aGUtcHJvdG9jb2xcbiAgICovXG4gICNvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZCAocmVzcG9uc2UsIHBhcnNlZEV4dGVuc2lvbnMpIHtcbiAgICAvLyBwcm9jZXNzUmVzcG9uc2UgaXMgY2FsbGVkIHdoZW4gdGhlIFwicmVzcG9uc2XigJlzIGhlYWRlciBsaXN0IGhhcyBiZWVuIHJlY2VpdmVkIGFuZCBpbml0aWFsaXplZC5cIlxuICAgIC8vIG9uY2UgdGhpcyBoYXBwZW5zLCB0aGUgY29ubmVjdGlvbiBpcyBvcGVuXG4gICAgdGhpcy4jaGFuZGxlci5zb2NrZXQgPSByZXNwb25zZS5zb2NrZXRcblxuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBCeXRlUGFyc2VyKHRoaXMuI2hhbmRsZXIsIHBhcnNlZEV4dGVuc2lvbnMpXG4gICAgcGFyc2VyLm9uKCdkcmFpbicsICgpID0+IHRoaXMuI2hhbmRsZXIub25QYXJzZXJEcmFpbigpKVxuICAgIHBhcnNlci5vbignZXJyb3InLCAoZXJyKSA9PiB0aGlzLiNoYW5kbGVyLm9uUGFyc2VyRXJyb3IoZXJyKSlcblxuICAgIHRoaXMuI3BhcnNlciA9IHBhcnNlclxuICAgIHRoaXMuI3NlbmRRdWV1ZSA9IG5ldyBTZW5kUXVldWUocmVzcG9uc2Uuc29ja2V0KVxuXG4gICAgLy8gMS4gQ2hhbmdlIHRoZSByZWFkeSBzdGF0ZSB0byBPUEVOICgxKS5cbiAgICB0aGlzLiNoYW5kbGVyLnJlYWR5U3RhdGUgPSBzdGF0ZXMuT1BFTlxuXG4gICAgLy8gMi4gQ2hhbmdlIHRoZSBleHRlbnNpb25zIGF0dHJpYnV0ZeKAmXMgdmFsdWUgdG8gdGhlIGV4dGVuc2lvbnMgaW4gdXNlLCBpZlxuICAgIC8vICAgIGl0IGlzIG5vdCB0aGUgbnVsbCB2YWx1ZS5cbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbiAgICBjb25zdCBleHRlbnNpb25zID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnKVxuXG4gICAgaWYgKGV4dGVuc2lvbnMgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuI2V4dGVuc2lvbnMgPSBleHRlbnNpb25zXG4gICAgfVxuXG4gICAgLy8gMy4gQ2hhbmdlIHRoZSBwcm90b2NvbCBhdHRyaWJ1dGXigJlzIHZhbHVlIHRvIHRoZSBzdWJwcm90b2NvbCBpbiB1c2UsIGlmXG4gICAgLy8gICAgaXQgaXMgbm90IHRoZSBudWxsIHZhbHVlLlxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTEuOVxuICAgIGNvbnN0IHByb3RvY29sID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdzZWMtd2Vic29ja2V0LXByb3RvY29sJylcblxuICAgIGlmIChwcm90b2NvbCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy4jcHJvdG9jb2wgPSBwcm90b2NvbFxuICAgIH1cblxuICAgIC8vIDQuIEZpcmUgYW4gZXZlbnQgbmFtZWQgb3BlbiBhdCB0aGUgV2ViU29ja2V0IG9iamVjdC5cbiAgICBmaXJlRXZlbnQoJ29wZW4nLCB0aGlzKVxuICB9XG5cbiAgI29uRmFpbCAoY29kZSwgcmVhc29uLCBjYXVzZSkge1xuICAgIGlmIChyZWFzb24pIHtcbiAgICAgIC8vIFRPRE86IHByb2Nlc3MubmV4dFRpY2tcbiAgICAgIGZpcmVFdmVudCgnZXJyb3InLCB0aGlzLCAodHlwZSwgaW5pdCkgPT4gbmV3IEVycm9yRXZlbnQodHlwZSwgaW5pdCksIHtcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihyZWFzb24sIGNhdXNlID8geyBjYXVzZSB9IDogdW5kZWZpbmVkKSxcbiAgICAgICAgbWVzc2FnZTogcmVhc29uXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICghdGhpcy4jaGFuZGxlci53YXNFdmVyQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLiNoYW5kbGVyLnJlYWR5U3RhdGUgPSBzdGF0ZXMuQ0xPU0VEXG5cbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQsIGl0IGlzIGFsc28gc2FpZFxuICAgICAgLy8gdGhhdCBfVGhlIFdlYlNvY2tldCBDb25uZWN0aW9uIGlzIENsb3NlZF8sIGJ1dCBub3QgX2NsZWFubHlfLlxuICAgICAgZmlyZUV2ZW50KCdjbG9zZScsIHRoaXMsICh0eXBlLCBpbml0KSA9PiBuZXcgQ2xvc2VFdmVudCh0eXBlLCBpbml0KSwge1xuICAgICAgICB3YXNDbGVhbjogZmFsc2UsIGNvZGUsIHJlYXNvblxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAjb25NZXNzYWdlICh0eXBlLCBkYXRhKSB7XG4gICAgLy8gMS4gSWYgcmVhZHkgc3RhdGUgaXMgbm90IE9QRU4gKDEpLCB0aGVuIHJldHVybi5cbiAgICBpZiAodGhpcy4jaGFuZGxlci5yZWFkeVN0YXRlICE9PSBzdGF0ZXMuT1BFTikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IGRhdGFGb3JFdmVudCBiZSBkZXRlcm1pbmVkIGJ5IHN3aXRjaGluZyBvbiB0eXBlIGFuZCBiaW5hcnkgdHlwZTpcbiAgICBsZXQgZGF0YUZvckV2ZW50XG5cbiAgICBpZiAodHlwZSA9PT0gb3Bjb2Rlcy5URVhUKSB7XG4gICAgICAvLyAtPiB0eXBlIGluZGljYXRlcyB0aGF0IHRoZSBkYXRhIGlzIFRleHRcbiAgICAgIC8vICAgICAgYSBuZXcgRE9NU3RyaW5nIGNvbnRhaW5pbmcgZGF0YVxuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YUZvckV2ZW50ID0gdXRmOERlY29kZShkYXRhKVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMuI2hhbmRsZXIsIDEwMDcsICdSZWNlaXZlZCBpbnZhbGlkIFVURi04IGluIHRleHQgZnJhbWUuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBvcGNvZGVzLkJJTkFSWSkge1xuICAgICAgaWYgKHRoaXMuI2JpbmFyeVR5cGUgPT09ICdibG9iJykge1xuICAgICAgICAvLyAtPiB0eXBlIGluZGljYXRlcyB0aGF0IHRoZSBkYXRhIGlzIEJpbmFyeSBhbmQgYmluYXJ5IHR5cGUgaXMgXCJibG9iXCJcbiAgICAgICAgLy8gICAgICBhIG5ldyBCbG9iIG9iamVjdCwgY3JlYXRlZCBpbiB0aGUgcmVsZXZhbnQgUmVhbG0gb2YgdGhlIFdlYlNvY2tldFxuICAgICAgICAvLyAgICAgIG9iamVjdCwgdGhhdCByZXByZXNlbnRzIGRhdGEgYXMgaXRzIHJhdyBkYXRhXG4gICAgICAgIGRhdGFGb3JFdmVudCA9IG5ldyBCbG9iKFtkYXRhXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIC0+IHR5cGUgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGEgaXMgQmluYXJ5IGFuZCBiaW5hcnkgdHlwZSBpcyBcImFycmF5YnVmZmVyXCJcbiAgICAgICAgLy8gICAgICBhIG5ldyBBcnJheUJ1ZmZlciBvYmplY3QsIGNyZWF0ZWQgaW4gdGhlIHJlbGV2YW50IFJlYWxtIG9mIHRoZVxuICAgICAgICAvLyAgICAgIFdlYlNvY2tldCBvYmplY3QsIHdob3NlIGNvbnRlbnRzIGFyZSBkYXRhXG4gICAgICAgIGRhdGFGb3JFdmVudCA9IHRvQXJyYXlCdWZmZXIoZGF0YSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzLiBGaXJlIGFuIGV2ZW50IG5hbWVkIG1lc3NhZ2UgYXQgdGhlIFdlYlNvY2tldCBvYmplY3QsIHVzaW5nIE1lc3NhZ2VFdmVudCxcbiAgICAvLyAgICB3aXRoIHRoZSBvcmlnaW4gYXR0cmlidXRlIGluaXRpYWxpemVkIHRvIHRoZSBzZXJpYWxpemF0aW9uIG9mIHRoZSBXZWJTb2NrZXRcbiAgICAvLyAgICBvYmplY3TigJlzIHVybCdzIG9yaWdpbiwgYW5kIHRoZSBkYXRhIGF0dHJpYnV0ZSBpbml0aWFsaXplZCB0byBkYXRhRm9yRXZlbnQuXG4gICAgZmlyZUV2ZW50KCdtZXNzYWdlJywgdGhpcywgY3JlYXRlRmFzdE1lc3NhZ2VFdmVudCwge1xuICAgICAgb3JpZ2luOiB0aGlzLiN1cmwub3JpZ2luLFxuICAgICAgZGF0YTogZGF0YUZvckV2ZW50XG4gICAgfSlcbiAgfVxuXG4gICNvblBhcnNlckRyYWluICgpIHtcbiAgICB0aGlzLiNoYW5kbGVyLnNvY2tldC5yZXN1bWUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZmVlZGJhY2stZnJvbS10aGUtcHJvdG9jb2xcbiAgICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi03LjEuNFxuICAgKi9cbiAgI29uU29ja2V0Q2xvc2UgKCkge1xuICAgIC8vIElmIHRoZSBUQ1AgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGFmdGVyIHRoZVxuICAgIC8vIFdlYlNvY2tldCBjbG9zaW5nIGhhbmRzaGFrZSB3YXMgY29tcGxldGVkLCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICAvLyBpcyBzYWlkIHRvIGhhdmUgYmVlbiBjbG9zZWQgX2NsZWFubHlfLlxuICAgIGNvbnN0IHdhc0NsZWFuID1cbiAgICAgIHRoaXMuI2hhbmRsZXIuY2xvc2VTdGF0ZS5oYXMoc2VudENsb3NlRnJhbWVTdGF0ZS5TRU5UKSAmJlxuICAgICAgdGhpcy4jaGFuZGxlci5jbG9zZVN0YXRlLmhhcyhzZW50Q2xvc2VGcmFtZVN0YXRlLlJFQ0VJVkVEKVxuXG4gICAgbGV0IGNvZGUgPSAxMDA1XG4gICAgbGV0IHJlYXNvbiA9ICcnXG5cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNwYXJzZXIuY2xvc2luZ0luZm9cblxuICAgIGlmIChyZXN1bHQgJiYgIXJlc3VsdC5lcnJvcikge1xuICAgICAgY29kZSA9IHJlc3VsdC5jb2RlID8/IDEwMDVcbiAgICAgIHJlYXNvbiA9IHJlc3VsdC5yZWFzb25cbiAgICB9IGVsc2UgaWYgKCF0aGlzLiNoYW5kbGVyLmNsb3NlU3RhdGUuaGFzKHNlbnRDbG9zZUZyYW1lU3RhdGUuUkVDRUlWRUQpKSB7XG4gICAgICAvLyBJZiBfVGhlIFdlYlNvY2tldFxuICAgICAgLy8gQ29ubmVjdGlvbiBpcyBDbG9zZWRfIGFuZCBubyBDbG9zZSBjb250cm9sIGZyYW1lIHdhcyByZWNlaXZlZCBieSB0aGVcbiAgICAgIC8vIGVuZHBvaW50IChzdWNoIGFzIGNvdWxkIG9jY3VyIGlmIHRoZSB1bmRlcmx5aW5nIHRyYW5zcG9ydCBjb25uZWN0aW9uXG4gICAgICAvLyBpcyBsb3N0KSwgX1RoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbiBDbG9zZSBDb2RlXyBpcyBjb25zaWRlcmVkIHRvIGJlXG4gICAgICAvLyAxMDA2LlxuICAgICAgY29kZSA9IDEwMDZcbiAgICB9XG5cbiAgICAvLyAxLiBDaGFuZ2UgdGhlIHJlYWR5IHN0YXRlIHRvIENMT1NFRCAoMykuXG4gICAgdGhpcy4jaGFuZGxlci5yZWFkeVN0YXRlID0gc3RhdGVzLkNMT1NFRFxuXG4gICAgLy8gMi4gSWYgdGhlIHVzZXIgYWdlbnQgd2FzIHJlcXVpcmVkIHRvIGZhaWwgdGhlIFdlYlNvY2tldFxuICAgIC8vICAgIGNvbm5lY3Rpb24sIG9yIGlmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAgLy8gICAgYWZ0ZXIgYmVpbmcgZmxhZ2dlZCBhcyBmdWxsLCBmaXJlIGFuIGV2ZW50IG5hbWVkIGVycm9yXG4gICAgLy8gICAgYXQgdGhlIFdlYlNvY2tldCBvYmplY3QuXG4gICAgLy8gVE9ET1xuXG4gICAgLy8gMy4gRmlyZSBhbiBldmVudCBuYW1lZCBjbG9zZSBhdCB0aGUgV2ViU29ja2V0IG9iamVjdCxcbiAgICAvLyAgICB1c2luZyBDbG9zZUV2ZW50LCB3aXRoIHRoZSB3YXNDbGVhbiBhdHRyaWJ1dGVcbiAgICAvLyAgICBpbml0aWFsaXplZCB0byB0cnVlIGlmIHRoZSBjb25uZWN0aW9uIGNsb3NlZCBjbGVhbmx5XG4gICAgLy8gICAgYW5kIGZhbHNlIG90aGVyd2lzZSwgdGhlIGNvZGUgYXR0cmlidXRlIGluaXRpYWxpemVkIHRvXG4gICAgLy8gICAgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNsb3NlIGNvZGUsIGFuZCB0aGUgcmVhc29uXG4gICAgLy8gICAgYXR0cmlidXRlIGluaXRpYWxpemVkIHRvIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgVVRGLThcbiAgICAvLyAgICBkZWNvZGUgd2l0aG91dCBCT00gdG8gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNsb3NlXG4gICAgLy8gICAgcmVhc29uLlxuICAgIC8vIFRPRE86IHByb2Nlc3MubmV4dFRpY2tcbiAgICBmaXJlRXZlbnQoJ2Nsb3NlJywgdGhpcywgKHR5cGUsIGluaXQpID0+IG5ldyBDbG9zZUV2ZW50KHR5cGUsIGluaXQpLCB7XG4gICAgICB3YXNDbGVhbiwgY29kZSwgcmVhc29uXG4gICAgfSlcblxuICAgIGlmIChjaGFubmVscy5jbG9zZS5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuY2xvc2UucHVibGlzaCh7XG4gICAgICAgIHdlYnNvY2tldDogdGhpcyxcbiAgICAgICAgY29kZSxcbiAgICAgICAgcmVhc29uXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LWNvbm5lY3RpbmdcbldlYlNvY2tldC5DT05ORUNUSU5HID0gV2ViU29ja2V0LnByb3RvdHlwZS5DT05ORUNUSU5HID0gc3RhdGVzLkNPTk5FQ1RJTkdcbi8vIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtb3BlblxuV2ViU29ja2V0Lk9QRU4gPSBXZWJTb2NrZXQucHJvdG90eXBlLk9QRU4gPSBzdGF0ZXMuT1BFTlxuLy8gaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1jbG9zaW5nXG5XZWJTb2NrZXQuQ0xPU0lORyA9IFdlYlNvY2tldC5wcm90b3R5cGUuQ0xPU0lORyA9IHN0YXRlcy5DTE9TSU5HXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LWNsb3NlZFxuV2ViU29ja2V0LkNMT1NFRCA9IFdlYlNvY2tldC5wcm90b3R5cGUuQ0xPU0VEID0gc3RhdGVzLkNMT1NFRFxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXZWJTb2NrZXQucHJvdG90eXBlLCB7XG4gIENPTk5FQ1RJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIE9QRU46IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIENMT1NJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIENMT1NFRDogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkeVN0YXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBidWZmZXJlZEFtb3VudDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25vcGVuOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmNsb3NlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjbG9zZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25tZXNzYWdlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBiaW5hcnlUeXBlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzZW5kOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBleHRlbnNpb25zOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBwcm90b2NvbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ1dlYlNvY2tldCcsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXZWJTb2NrZXQsIHtcbiAgQ09OTkVDVElORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgT1BFTjogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgQ0xPU0lORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgQ0xPU0VEOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzXG59KVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8RE9NU3RyaW5nPiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmdcbilcblxud2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+J10gPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gd2ViaWRsLnV0aWwuVHlwZXMuT0JKRUNUICYmIFN5bWJvbC5pdGVyYXRvciBpbiBWKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxET01TdHJpbmc+J10oVilcbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoViwgcHJlZml4LCBhcmd1bWVudClcbn1cblxuLy8gVGhpcyBpbXBsZW1lbnRzIHRoZSBwcm9wb3NhbCBtYWRlIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvd2Vic29ja2V0cy9pc3N1ZXMvNDJcbndlYmlkbC5jb252ZXJ0ZXJzLldlYlNvY2tldEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICdwcm90b2NvbHMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+J10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBuZXcgQXJyYXkoMClcbiAgfSxcbiAge1xuICAgIGtleTogJ2Rpc3BhdGNoZXInLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55LFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdoZWFkZXJzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdClcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+IG9yIFdlYlNvY2tldEluaXQnXSA9IGZ1bmN0aW9uIChWKSB7XG4gIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpID09PSB3ZWJpZGwudXRpbC5UeXBlcy5PQkpFQ1QgJiYgIShTeW1ib2wuaXRlcmF0b3IgaW4gVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0SW5pdChWKVxuICB9XG5cbiAgcmV0dXJuIHsgcHJvdG9jb2xzOiB3ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4nXShWKSB9XG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLldlYlNvY2tldFNlbmREYXRhID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09IHdlYmlkbC51dGlsLlR5cGVzLk9CSkVDVCkge1xuICAgIGlmICh3ZWJpZGwuaXMuQmxvYihWKSkge1xuICAgICAgcmV0dXJuIFZcbiAgICB9XG5cbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KFYpIHx8IHR5cGVzLmlzQXJyYXlCdWZmZXIoVikpIHtcbiAgICAgIHJldHVybiBWXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhWKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViU29ja2V0XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/websocket.js\n");

/***/ })

};
;